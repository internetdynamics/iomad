{"version":3,"file":"templates.min.js","sources":["../src/templates.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Template renderer for Moodle. Load and render Moodle templates with Mustache.\r\n *\r\n * @module     core/templates\r\n * @copyright  2015 Damyon Wiese <damyon@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n * @since      2.9\r\n */\r\ndefine([\r\n    'core/mustache',\r\n    'jquery',\r\n    'core/ajax',\r\n    'core/str',\r\n    'core/notification',\r\n    'core/url',\r\n    'core/config',\r\n    'core/localstorage',\r\n    'core/icon_system',\r\n    'core_filters/events',\r\n    'core/yui',\r\n    'core/log',\r\n    'core/truncate',\r\n    'core/user_date',\r\n    'core/pending',\r\n],\r\nfunction(\r\n    mustache,\r\n    $,\r\n    ajax,\r\n    str,\r\n    notification,\r\n    coreurl,\r\n    config,\r\n    storage,\r\n    IconSystem,\r\n    filterEvents,\r\n    Y,\r\n    Log,\r\n    Truncate,\r\n    UserDate,\r\n    Pending\r\n) {\r\n\r\n    // Module variables.\r\n    /** @var {Number} uniqInstances Count of times this constructor has been called. */\r\n    var uniqInstances = 0;\r\n\r\n    /** @var {String[]} templateCache - Cache of already loaded template strings */\r\n    var templateCache = {};\r\n\r\n    /** @var {Promise[]} templatePromises - Cache of already loaded template promises */\r\n    var templatePromises = {};\r\n\r\n    /** @var {Promise[]} cachePartialPromises - Cache of already loaded template partial promises */\r\n    var cachePartialPromises = {};\r\n\r\n    /** @var {Object} iconSystem - Object extending core/iconsystem */\r\n    var iconSystem = {};\r\n\r\n    /** @var {Object[]} loadTemplateBuffer - List of templates to be loaded */\r\n    var loadTemplateBuffer = [];\r\n\r\n    /** @var {Bool} isLoadingTemplates - Whether templates are currently being loaded */\r\n    var isLoadingTemplates = false;\r\n\r\n    /** @var {Array} disallowedNestedHelpers - List of helpers that can't be called within other helpers */\r\n    var disallowedNestedHelpers = ['js'];\r\n\r\n    /**\r\n     * Normalise the provided component such that '', 'moodle', and 'core' are treated consistently.\r\n     *\r\n     * @param   {String} component\r\n     * @returns {String}\r\n     */\r\n    var getNormalisedComponent = function(component) {\r\n        if (component) {\r\n            if (component !== 'moodle' && component !== 'core') {\r\n                return component;\r\n            }\r\n        }\r\n\r\n        return 'core';\r\n    };\r\n\r\n    /**\r\n     * Search the various caches for a template promise for the given search key.\r\n     * The search key should be in the format <theme>/<component>/<template> e.g. boost/core/modal.\r\n     *\r\n     * If the template is found in any of the caches it will populate the other caches with\r\n     * the same data as well.\r\n     *\r\n     * @param {String} searchKey The template search key in the format <theme>/<component>/<template> e.g. boost/core/modal\r\n     * @return {Object} jQuery promise resolved with the template source\r\n     */\r\n    var getTemplatePromiseFromCache = function(searchKey) {\r\n        // First try the cache of promises.\r\n        if (searchKey in templatePromises) {\r\n            return templatePromises[searchKey];\r\n        }\r\n\r\n        // Check the module cache.\r\n        if (searchKey in templateCache) {\r\n            // Add this to the promises cache for future.\r\n            templatePromises[searchKey] = $.Deferred().resolve(templateCache[searchKey]).promise();\r\n            return templatePromises[searchKey];\r\n        }\r\n\r\n        if (M.cfg.templaterev <= 0) {\r\n            // Template caching is disabled. Do not store in persistent storage.\r\n            return null;\r\n        }\r\n\r\n        // Now try local storage.\r\n        var cached = storage.get('core_template/' + M.cfg.templaterev + ':' + searchKey);\r\n        if (cached) {\r\n            // Add this to the module cache for future.\r\n            templateCache[searchKey] = cached;\r\n            // Add this to the promises cache for future.\r\n            templatePromises[searchKey] = $.Deferred().resolve(cached).promise();\r\n            return templatePromises[searchKey];\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Take all of the templates waiting in the buffer and load them from the server\r\n     * or from the cache.\r\n     *\r\n     * All of the templates that need to be loaded from the server will be batched up\r\n     * and sent in a single network request.\r\n     */\r\n    var processLoadTemplateBuffer = function() {\r\n        if (!loadTemplateBuffer.length) {\r\n            return;\r\n        }\r\n\r\n        if (isLoadingTemplates) {\r\n            return;\r\n        }\r\n\r\n        isLoadingTemplates = true;\r\n        // Grab any templates waiting in the buffer.\r\n        var templatesToLoad = loadTemplateBuffer.slice();\r\n        // This will be resolved with the list of promises for the server request.\r\n        var serverRequestsDeferred = $.Deferred();\r\n        var requests = [];\r\n        // Get a list of promises for each of the templates we need to load.\r\n        var templatePromises = templatesToLoad.map(function(templateData) {\r\n            var component = getNormalisedComponent(templateData.component);\r\n            var name = templateData.name;\r\n            var searchKey = templateData.searchKey;\r\n            var theme = templateData.theme;\r\n            var templateDeferred = templateData.deferred;\r\n            var promise = null;\r\n\r\n            // Double check to see if this template happened to have landed in the\r\n            // cache as a dependency of an earlier template.\r\n            var cachedPromise = getTemplatePromiseFromCache(searchKey);\r\n            if (cachedPromise) {\r\n                // We've seen this template so immediately resolve the existing promise.\r\n                promise = cachedPromise;\r\n            } else {\r\n                // We haven't seen this template yet so we need to request it from\r\n                // the server.\r\n                requests.push({\r\n                    methodname: 'core_output_load_template_with_dependencies',\r\n                    args: {\r\n                        component: component,\r\n                        template: name,\r\n                        themename: theme,\r\n                        lang: $('html').attr('lang').replace(/-/g, '_')\r\n                    }\r\n                });\r\n                // Remember the index in the requests list for this template so that\r\n                // we can get the appropriate promise back.\r\n                var index = requests.length - 1;\r\n\r\n                // The server deferred will be resolved with a list of all of the promises\r\n                // that were sent in the order that they were added to the requests array.\r\n                promise = serverRequestsDeferred.promise()\r\n                    .then(function(promises) {\r\n                        // The promise for this template will be the one that matches the index\r\n                        // for it's entry in the requests array.\r\n                        //\r\n                        // Make sure the promise is added to the promises cache for this template\r\n                        // search key so that we don't request it again.\r\n                        templatePromises[searchKey] = promises[index].then(function(response) {\r\n                            var templateSource = null;\r\n\r\n                            // Process all of the template dependencies for this template and add\r\n                            // them to the caches so that we don't request them again later.\r\n                            response.templates.forEach(function(data) {\r\n                                data.component = getNormalisedComponent(data.component);\r\n                                // Generate the search key for this template in the response so that we\r\n                                // can add it to the caches.\r\n                                var tempSearchKey = [theme, data.component, data.name].join('/');\r\n                                // Cache all of the dependent templates because we'll need them to render\r\n                                // the requested template.\r\n                                templateCache[tempSearchKey] = data.value;\r\n\r\n                                if (M.cfg.templaterev > 0) {\r\n                                    // The template cache is enabled - set the value there.\r\n                                    storage.set('core_template/' + M.cfg.templaterev + ':' + tempSearchKey, data.value);\r\n                                }\r\n\r\n                                if (data.component == component && data.name == name) {\r\n                                    // This is the original template that was requested so remember it to return.\r\n                                    templateSource = data.value;\r\n                                }\r\n                            });\r\n\r\n                            if (response.strings.length) {\r\n                                // If we have strings that the template needs then warm the string cache\r\n                                // with them now so that we don't need to re-fetch them.\r\n                                str.cache_strings(response.strings.map(function(data) {\r\n                                    return {\r\n                                        component: getNormalisedComponent(data.component),\r\n                                        key: data.name,\r\n                                        value: data.value\r\n                                    };\r\n                                }));\r\n                            }\r\n\r\n                            // Return the original template source that the user requested.\r\n                            return templateSource;\r\n                        });\r\n\r\n                        return templatePromises[searchKey];\r\n                    });\r\n            }\r\n\r\n            return promise\r\n                .then(function(source) {\r\n                    // When we've successfully loaded the template then resolve the deferred\r\n                    // in the buffer so that all of the calling code can proceed.\r\n                    return templateDeferred.resolve(source);\r\n                })\r\n                .catch(function(error) {\r\n                    // If there was an error loading the template then reject the deferred\r\n                    // in the buffer so that all of the calling code can proceed.\r\n                    templateDeferred.reject(error);\r\n                    // Rethrow for anyone else listening.\r\n                    throw error;\r\n                });\r\n        });\r\n\r\n        if (requests.length) {\r\n            // We have requests to send so resolve the deferred with the promises.\r\n            serverRequestsDeferred.resolve(ajax.call(requests, true, false, false, 0, M.cfg.templaterev));\r\n        } else {\r\n            // Nothing to load so we can resolve our deferred.\r\n            serverRequestsDeferred.resolve();\r\n        }\r\n\r\n        // Once we've finished loading all of the templates then recurse to process\r\n        // any templates that may have been added to the buffer in the time that we\r\n        // were fetching.\r\n        $.when.apply(null, templatePromises)\r\n            .then(function() {\r\n                // Remove the templates we've loaded from the buffer.\r\n                loadTemplateBuffer.splice(0, templatesToLoad.length);\r\n                isLoadingTemplates = false;\r\n                processLoadTemplateBuffer();\r\n                return;\r\n            })\r\n            .catch(function() {\r\n                // Remove the templates we've loaded from the buffer.\r\n                loadTemplateBuffer.splice(0, templatesToLoad.length);\r\n                isLoadingTemplates = false;\r\n                processLoadTemplateBuffer();\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Constructor\r\n     *\r\n     * Each call to templates.render gets it's own instance of this class.\r\n     */\r\n    var Renderer = function() {\r\n        this.requiredStrings = [];\r\n        this.requiredJS = [];\r\n        this.requiredDates = [];\r\n        this.currentThemeName = '';\r\n    };\r\n    // Class variables and functions.\r\n\r\n    /** @var {string[]} requiredStrings - Collection of strings found during the rendering of one template */\r\n    Renderer.prototype.requiredStrings = null;\r\n\r\n    /** @var {object[]} requiredDates - Collection of dates found during the rendering of one template */\r\n    Renderer.prototype.requiredDates = [];\r\n\r\n    /** @var {string[]} requiredJS - Collection of js blocks found during the rendering of one template */\r\n    Renderer.prototype.requiredJS = null;\r\n\r\n    /** @var {String} themeName for the current render */\r\n    Renderer.prototype.currentThemeName = '';\r\n\r\n    /**\r\n     * Load a template.\r\n     *\r\n     * @method getTemplate\r\n     * @private\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @return {Promise} JQuery promise object resolved when the template has been fetched.\r\n     */\r\n    Renderer.prototype.getTemplate = function(templateName) {\r\n        var currentTheme = this.currentThemeName;\r\n        var searchKey = currentTheme + '/' + templateName;\r\n\r\n        // If we haven't already seen this template then buffer it.\r\n        var cachedPromise = getTemplatePromiseFromCache(searchKey);\r\n        if (cachedPromise) {\r\n            return cachedPromise;\r\n        }\r\n\r\n        // Check the buffer to see if this template has already been added.\r\n        var existingBufferRecords = loadTemplateBuffer.filter(function(record) {\r\n            return record.searchKey == searchKey;\r\n        });\r\n        if (existingBufferRecords.length) {\r\n            // This template is already in the buffer so just return the existing\r\n            // promise. No need to add it to the buffer again.\r\n            return existingBufferRecords[0].deferred.promise();\r\n        }\r\n\r\n        // This is the first time this has been requested so let's add it to the buffer\r\n        // to be loaded.\r\n        var parts = templateName.split('/');\r\n        var component = getNormalisedComponent(parts.shift());\r\n        var name = parts.join('/');\r\n        var deferred = $.Deferred();\r\n\r\n        // Add this template to the buffer to be loaded.\r\n        loadTemplateBuffer.push({\r\n            component: component,\r\n            name: name,\r\n            theme: currentTheme,\r\n            searchKey: searchKey,\r\n            deferred: deferred\r\n        });\r\n\r\n        // We know there is at least one thing in the buffer so kick off a processing run.\r\n        processLoadTemplateBuffer();\r\n        return deferred.promise();\r\n    };\r\n\r\n    /**\r\n     * Prefetch a set of templates without rendering them.\r\n     *\r\n     * @param {Array} templateNames The list of templates to fetch\r\n     * @param {String} currentTheme\r\n     */\r\n    Renderer.prototype.prefetchTemplates = function(templateNames, currentTheme) {\r\n        templateNames.forEach(function(templateName) {\r\n            var searchKey = currentTheme + '/' + templateName;\r\n\r\n            // If we haven't already seen this template then buffer it.\r\n            if (getTemplatePromiseFromCache(searchKey)) {\r\n                return;\r\n            }\r\n\r\n            // Check the buffer to see if this template has already been added.\r\n            var existingBufferRecords = loadTemplateBuffer.filter(function(record) {\r\n                return record.searchKey == searchKey;\r\n            });\r\n\r\n            if (existingBufferRecords.length) {\r\n                // This template is already in the buffer so just return the existing promise.\r\n                // No need to add it to the buffer again.\r\n                return;\r\n            }\r\n\r\n            // This is the first time this has been requested so let's add it to the buffer to be loaded.\r\n            var parts = templateName.split('/');\r\n            var component = getNormalisedComponent(parts.shift());\r\n            var name = parts.join('/');\r\n\r\n            // Add this template to the buffer to be loaded.\r\n            loadTemplateBuffer.push({\r\n                component: component,\r\n                name: name,\r\n                theme: currentTheme,\r\n                searchKey: searchKey,\r\n                deferred: $.Deferred(),\r\n            });\r\n        });\r\n\r\n        processLoadTemplateBuffer();\r\n    };\r\n\r\n    /**\r\n     * Load a partial from the cache or ajax.\r\n     *\r\n     * @method partialHelper\r\n     * @private\r\n     * @param {string} name The partial name to load.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.partialHelper = function(name) {\r\n\r\n        var searchKey = this.currentThemeName + '/' + name;\r\n\r\n        if (!(searchKey in templateCache)) {\r\n            notification.exception(new Error('Failed to pre-fetch the template: ' + name));\r\n        }\r\n\r\n        return templateCache[searchKey];\r\n    };\r\n\r\n    /**\r\n     * Render a single image icon.\r\n     *\r\n     * @method renderIcon\r\n     * @private\r\n     * @param {string} key The icon key.\r\n     * @param {string} component The component name.\r\n     * @param {string} title The icon title\r\n     * @return {Promise}\r\n     */\r\n    Renderer.prototype.renderIcon = function(key, component, title) {\r\n        // Preload the module to do the icon rendering based on the theme iconsystem.\r\n        var modulename = config.iconsystemmodule;\r\n        component = getNormalisedComponent(component);\r\n\r\n        // RequireJS does not return a promise.\r\n        var ready = $.Deferred();\r\n        require([modulename], function(System) {\r\n            var system = new System();\r\n            if (!(system instanceof IconSystem)) {\r\n                ready.reject('Invalid icon system specified' + config.iconsystemmodule);\r\n            } else {\r\n                iconSystem = system;\r\n                system.init().then(ready.resolve).catch(notification.exception);\r\n            }\r\n        });\r\n\r\n        return ready.then(function(iconSystem) {\r\n            return this.getTemplate(iconSystem.getTemplateName());\r\n        }.bind(this)).then(function(template) {\r\n            return iconSystem.renderIcon(\r\n                key,\r\n                component,\r\n                title,\r\n                template\r\n            );\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Render image icons.\r\n     *\r\n     * @method pixHelper\r\n     * @private\r\n     * @param {object} context The mustache context\r\n     * @param {string} sectionText The text to parse arguments from.\r\n     * @param {function} helper Used to render the alt attribute of the text.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.pixHelper = function(context, sectionText, helper) {\r\n        var parts = sectionText.split(',');\r\n        var key = '';\r\n        var component = '';\r\n        var text = '';\r\n\r\n        if (parts.length > 0) {\r\n            key = helper(parts.shift().trim(), context);\r\n        }\r\n        if (parts.length > 0) {\r\n            component = helper(parts.shift().trim(), context);\r\n        }\r\n        if (parts.length > 0) {\r\n            text = helper(parts.join(',').trim(), context);\r\n        }\r\n\r\n        var templateName = iconSystem.getTemplateName();\r\n        var searchKey = this.currentThemeName + '/' + templateName;\r\n        var template = templateCache[searchKey];\r\n\r\n        component = getNormalisedComponent(component);\r\n\r\n        // The key might have been escaped by the JS Mustache engine which\r\n        // converts forward slashes to HTML entities. Let us undo that here.\r\n        key = key.replace(/&#x2F;/gi, '/');\r\n\r\n        return iconSystem.renderIcon(\r\n            key,\r\n            component,\r\n            text,\r\n            template\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Render blocks of javascript and save them in an array.\r\n     *\r\n     * @method jsHelper\r\n     * @private\r\n     * @param {object} context The current mustache context.\r\n     * @param {string} sectionText The text to save as a js block.\r\n     * @param {function} helper Used to render the block.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.jsHelper = function(context, sectionText, helper) {\r\n        this.requiredJS.push(helper(sectionText, context));\r\n        return '';\r\n    };\r\n\r\n    /**\r\n     * String helper used to render {{#str}}abd component { a : 'fish'}{{/str}}\r\n     * into a get_string call.\r\n     *\r\n     * @method stringHelper\r\n     * @private\r\n     * @param {object} context The current mustache context.\r\n     * @param {string} sectionText The text to parse the arguments from.\r\n     * @param {function} helper Used to render subsections of the text.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.stringHelper = function(context, sectionText, helper) {\r\n        var parts = sectionText.split(',');\r\n        var key = '';\r\n        var component = '';\r\n        var param = '';\r\n        if (parts.length > 0) {\r\n            key = parts.shift().trim();\r\n        }\r\n        if (parts.length > 0) {\r\n            component = parts.shift().trim();\r\n        }\r\n        if (parts.length > 0) {\r\n            param = parts.join(',').trim();\r\n        }\r\n\r\n        component = getNormalisedComponent(component);\r\n\r\n        if (param !== '') {\r\n            // Allow variable expansion in the param part only.\r\n            param = helper(param, context);\r\n        }\r\n\r\n        // Allow json formatted $a arguments.\r\n        if (param.match(/^{\\s*\"/gm)) {\r\n            // If it can't be parsed then the string is not a JSON format.\r\n            try {\r\n                const parsedParam = JSON.parse(param);\r\n                // Handle non-exception-throwing cases, e.g. null, integer, boolean.\r\n                if (parsedParam && typeof parsedParam === \"object\") {\r\n                    param = parsedParam;\r\n                }\r\n            } catch (err) {\r\n                // This was probably not JSON.\r\n                // Keep the error message visible.\r\n                window.console.warn(err.message);\r\n            }\r\n        }\r\n\r\n        var index = this.requiredStrings.length;\r\n        this.requiredStrings.push({\r\n            key: key,\r\n            component: component,\r\n            param: param\r\n        });\r\n\r\n        // The placeholder must not use {{}} as those can be misinterpreted by the engine.\r\n        return '[[_s' + index + ']]';\r\n    };\r\n\r\n    /**\r\n     * String helper to render {{#cleanstr}}abd component { a : 'fish'}{{/cleanstr}}\r\n     * into a get_string following by an HTML escape.\r\n     *\r\n     * @method cleanStringHelper\r\n     * @private\r\n     * @param {object} context The current mustache context.\r\n     * @param {string} sectionText The text to parse the arguments from.\r\n     * @param {function} helper Used to render subsections of the text.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.cleanStringHelper = function(context, sectionText, helper) {\r\n        var str = this.stringHelper(context, sectionText, helper);\r\n\r\n        // We're going to use [[_cx]] format for clean strings, where x is a number.\r\n        // Hence, replacing 's' with 'c' in the placeholder that stringHelper returns.\r\n        return str.replace('s', 'c');\r\n    };\r\n\r\n    /**\r\n     * Quote helper used to wrap content in quotes, and escape all special JSON characters present in the content.\r\n     *\r\n     * @method quoteHelper\r\n     * @private\r\n     * @param {object} context The current mustache context.\r\n     * @param {string} sectionText The text to parse the arguments from.\r\n     * @param {function} helper Used to render subsections of the text.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.quoteHelper = function(context, sectionText, helper) {\r\n        var content = helper(sectionText.trim(), context);\r\n\r\n        // Escape the {{ and JSON encode.\r\n        // This involves wrapping {{, and }} in change delimeter tags.\r\n        content = JSON.stringify(content);\r\n        content = content.replace(/([{}]{2,3})/g, '{{=<% %>=}}$1<%={{ }}=%>');\r\n        return content;\r\n    };\r\n\r\n    /**\r\n     * Shorten text helper to truncate text and append a trailing ellipsis.\r\n     *\r\n     * @method shortenTextHelper\r\n     * @private\r\n     * @param {object} context The current mustache context.\r\n     * @param {string} sectionText The text to parse the arguments from.\r\n     * @param {function} helper Used to render subsections of the text.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.shortenTextHelper = function(context, sectionText, helper) {\r\n        // Non-greedy split on comma to grab section text into the length and\r\n        // text parts.\r\n        var regex = /(.*?),(.*)/;\r\n        var parts = sectionText.match(regex);\r\n        // The length is the part matched in the first set of parethesis.\r\n        var length = parts[1].trim();\r\n        // The length is the part matched in the second set of parethesis.\r\n        var text = parts[2].trim();\r\n        var content = helper(text, context);\r\n        return Truncate.truncate(content, {\r\n            length: length,\r\n            words: true,\r\n            ellipsis: '...'\r\n        });\r\n    };\r\n\r\n    /**\r\n     * User date helper to render user dates from timestamps.\r\n     *\r\n     * @method userDateHelper\r\n     * @private\r\n     * @param {object} context The current mustache context.\r\n     * @param {string} sectionText The text to parse the arguments from.\r\n     * @param {function} helper Used to render subsections of the text.\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.userDateHelper = function(context, sectionText, helper) {\r\n        // Non-greedy split on comma to grab the timestamp and format.\r\n        var regex = /(.*?),(.*)/;\r\n        var parts = sectionText.match(regex);\r\n        var timestamp = helper(parts[1].trim(), context);\r\n        var format = helper(parts[2].trim(), context);\r\n        var index = this.requiredDates.length;\r\n\r\n        this.requiredDates.push({\r\n            timestamp: timestamp,\r\n            format: format\r\n        });\r\n\r\n        return '[[_t_' + index + ']]';\r\n    };\r\n\r\n    /**\r\n     * Return a helper function to be added to the context for rendering the a\r\n     * template.\r\n     *\r\n     * This will parse the provided text before giving it to the helper function\r\n     * in order to remove any disallowed nested helpers to prevent one helper\r\n     * from calling another.\r\n     *\r\n     * In particular to prevent the JS helper from being called from within another\r\n     * helper because it can lead to security issues when the JS portion is user\r\n     * provided.\r\n     *\r\n     * @param  {function} helperFunction The helper function to add\r\n     * @param  {object} context The template context for the helper function\r\n     * @return {Function} To be set in the context\r\n     */\r\n    Renderer.prototype.addHelperFunction = function(helperFunction, context) {\r\n        return function() {\r\n            return function(sectionText, helper) {\r\n                // Override the disallowed helpers in the template context with\r\n                // a function that returns an empty string for use when executing\r\n                // other helpers. This is to prevent these helpers from being\r\n                // executed as part of the rendering of another helper in order to\r\n                // prevent any potential security issues.\r\n                var originalHelpers = disallowedNestedHelpers.reduce(function(carry, name) {\r\n                    if (context.hasOwnProperty(name)) {\r\n                        carry[name] = context[name];\r\n                    }\r\n\r\n                    return carry;\r\n                }, {});\r\n\r\n                disallowedNestedHelpers.forEach(function(helperName) {\r\n                    context[helperName] = function() {\r\n                        return '';\r\n                    };\r\n                });\r\n\r\n                // Execute the helper with the modified context that doesn't include\r\n                // the disallowed nested helpers. This prevents the disallowed\r\n                // helpers from being called from within other helpers.\r\n                var result = helperFunction.apply(this, [context, sectionText, helper]);\r\n\r\n                // Restore the original helper implementation in the context so that\r\n                // any further rendering has access to them again.\r\n                for (var name in originalHelpers) {\r\n                    context[name] = originalHelpers[name];\r\n                }\r\n\r\n                return result;\r\n            }.bind(this);\r\n        }.bind(this);\r\n    };\r\n\r\n    /**\r\n     * Add some common helper functions to all context objects passed to templates.\r\n     * These helpers match exactly the helpers available in php.\r\n     *\r\n     * @method addHelpers\r\n     * @private\r\n     * @param {Object} context Simple types used as the context for the template.\r\n     * @param {String} themeName We set this multiple times, because there are async calls.\r\n     */\r\n    Renderer.prototype.addHelpers = function(context, themeName) {\r\n        this.currentThemeName = themeName;\r\n        this.requiredStrings = [];\r\n        this.requiredJS = [];\r\n        context.uniqid = (uniqInstances++);\r\n        context.str = this.addHelperFunction(this.stringHelper, context);\r\n        context.cleanstr = this.addHelperFunction(this.cleanStringHelper, context);\r\n        context.pix = this.addHelperFunction(this.pixHelper, context);\r\n        context.js = this.addHelperFunction(this.jsHelper, context);\r\n        context.quote = this.addHelperFunction(this.quoteHelper, context);\r\n        context.shortentext = this.addHelperFunction(this.shortenTextHelper, context);\r\n        context.userdate = this.addHelperFunction(this.userDateHelper, context);\r\n        context.globals = {config: config};\r\n        context.currentTheme = themeName;\r\n    };\r\n\r\n    /**\r\n     * Get all the JS blocks from the last rendered template.\r\n     *\r\n     * @method getJS\r\n     * @private\r\n     * @return {string}\r\n     */\r\n    Renderer.prototype.getJS = function() {\r\n        var js = '';\r\n        if (this.requiredJS.length > 0) {\r\n            js = this.requiredJS.join(\";\\n\");\r\n        }\r\n\r\n        return js;\r\n    };\r\n\r\n    /**\r\n     * Treat strings in content.\r\n     *\r\n     * The purpose of this method is to replace the placeholders found in a string\r\n     * with the their respective translated strings.\r\n     *\r\n     * Previously we were relying on String.replace() but the complexity increased with\r\n     * the numbers of strings to replace. Now we manually walk the string and stop at each\r\n     * placeholder we find, only then we replace it. Most of the time we will\r\n     * replace all the placeholders in a single run, at times we will need a few\r\n     * more runs when placeholders are replaced with strings that contain placeholders\r\n     * themselves.\r\n     *\r\n     * @param {String} content The content in which string placeholders are to be found.\r\n     * @param {Array} strings The strings to replace with.\r\n     * @return {String} The treated content.\r\n     */\r\n    Renderer.prototype.treatStringsInContent = function(content, strings) {\r\n        var pattern = /\\[\\[_(s|c)\\d+\\]\\]/,\r\n            treated,\r\n            index,\r\n            strIndex,\r\n            walker,\r\n            char,\r\n            strFinal,\r\n            isClean;\r\n\r\n        do {\r\n            treated = '';\r\n            index = content.search(pattern);\r\n            while (index > -1) {\r\n\r\n                // Copy the part prior to the placeholder to the treated string.\r\n                treated += content.substring(0, index);\r\n                content = content.substr(index);\r\n                isClean = content[3] == 'c';\r\n                strIndex = '';\r\n                walker = 4; // 4 is the length of either '[[_s' or '[[_c'.\r\n\r\n                // Walk the characters to manually extract the index of the string from the placeholder.\r\n                char = content.substr(walker, 1);\r\n                do {\r\n                    strIndex += char;\r\n                    walker++;\r\n                    char = content.substr(walker, 1);\r\n                } while (char != ']');\r\n\r\n                // Get the string, add it to the treated result, and remove the placeholder from the content to treat.\r\n                strFinal = strings[parseInt(strIndex, 10)];\r\n                if (typeof strFinal === 'undefined') {\r\n                    Log.debug('Could not find string for pattern [[_' + (isClean ? 'c' : 's') + strIndex + ']].');\r\n                    strFinal = '';\r\n                }\r\n                if (isClean) {\r\n                    strFinal = mustache.escape(strFinal);\r\n                }\r\n                treated += strFinal;\r\n                content = content.substr(6 + strIndex.length); // 6 is the length of the placeholder without the index.\r\n                                                               // That's either '[[_s]]' or '[[_c]]'.\r\n\r\n                // Find the next placeholder.\r\n                index = content.search(pattern);\r\n            }\r\n\r\n            // The content becomes the treated part with the rest of the content.\r\n            content = treated + content;\r\n\r\n            // Check if we need to walk the content again, in case strings contained placeholders.\r\n            index = content.search(pattern);\r\n\r\n        } while (index > -1);\r\n\r\n        return content;\r\n    };\r\n\r\n    /**\r\n     * Treat strings in content.\r\n     *\r\n     * The purpose of this method is to replace the date placeholders found in the\r\n     * content with the their respective translated dates.\r\n     *\r\n     * @param {String} content The content in which string placeholders are to be found.\r\n     * @param {Array} dates The dates to replace with.\r\n     * @return {String} The treated content.\r\n     */\r\n    Renderer.prototype.treatDatesInContent = function(content, dates) {\r\n        dates.forEach(function(date, index) {\r\n            var key = '\\\\[\\\\[_t_' + index + '\\\\]\\\\]';\r\n            var re = new RegExp(key, 'g');\r\n            content = content.replace(re, date);\r\n        });\r\n\r\n        return content;\r\n    };\r\n\r\n    /**\r\n     * Render a template and then call the callback with the result.\r\n     *\r\n     * @method doRender\r\n     * @private\r\n     * @param {string} templateSource The mustache template to render.\r\n     * @param {Object} context Simple types used as the context for the template.\r\n     * @param {String} themeName Name of the current theme.\r\n     * @return {Promise} object\r\n     */\r\n    Renderer.prototype.doRender = function(templateSource, context, themeName) {\r\n        this.currentThemeName = themeName;\r\n        var iconTemplate = iconSystem.getTemplateName();\r\n\r\n        var pendingPromise = new Pending('core/templates:doRender');\r\n        return this.getTemplate(iconTemplate).then(function() {\r\n            this.addHelpers(context, themeName);\r\n            var result = mustache.render(templateSource, context, this.partialHelper.bind(this));\r\n            return $.Deferred().resolve(result.trim(), this.getJS()).promise();\r\n        }.bind(this))\r\n        .then(function(html, js) {\r\n            if (this.requiredStrings.length > 0) {\r\n                return str.get_strings(this.requiredStrings).then(function(strings) {\r\n\r\n                    // Make sure string substitutions are done for the userdate\r\n                    // values as well.\r\n                    this.requiredDates = this.requiredDates.map(function(date) {\r\n                        return {\r\n                            timestamp: this.treatStringsInContent(date.timestamp, strings),\r\n                            format: this.treatStringsInContent(date.format, strings)\r\n                        };\r\n                    }.bind(this));\r\n\r\n                    // Why do we not do another call the render here?\r\n                    //\r\n                    // Because that would expose DOS holes. E.g.\r\n                    // I create an assignment called \"{{fish\" which\r\n                    // would get inserted in the template in the first pass\r\n                    // and cause the template to die on the second pass (unbalanced).\r\n                    html = this.treatStringsInContent(html, strings);\r\n                    js = this.treatStringsInContent(js, strings);\r\n                    return $.Deferred().resolve(html, js).promise();\r\n                }.bind(this));\r\n            }\r\n\r\n            return $.Deferred().resolve(html, js).promise();\r\n        }.bind(this))\r\n        .then(function(html, js) {\r\n            // This has to happen after the strings replacement because you can\r\n            // use the string helper in content for the user date helper.\r\n            if (this.requiredDates.length > 0) {\r\n                return UserDate.get(this.requiredDates).then(function(dates) {\r\n                    html = this.treatDatesInContent(html, dates);\r\n                    js = this.treatDatesInContent(js, dates);\r\n                    return $.Deferred().resolve(html, js).promise();\r\n                }.bind(this));\r\n            }\r\n\r\n            return $.Deferred().resolve(html, js).promise();\r\n        }.bind(this))\r\n        .then(function(html, js) {\r\n            pendingPromise.resolve();\r\n            return $.Deferred().resolve(html, js).promise();\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Execute a block of JS returned from a template.\r\n     * Call this AFTER adding the template HTML into the DOM so the nodes can be found.\r\n     *\r\n     * @method runTemplateJS\r\n     * @param {string} source - A block of javascript.\r\n     */\r\n    var runTemplateJS = function(source) {\r\n        if (source.trim() !== '') {\r\n            var newscript = $('<script>').attr('type', 'text/javascript').html(source);\r\n            $('head').append(newscript);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Do some DOM replacement and trigger correct events and fire javascript.\r\n     *\r\n     * @method domReplace\r\n     * @private\r\n     * @param {JQuery} element - Element or selector to replace.\r\n     * @param {String} newHTML - HTML to insert / replace.\r\n     * @param {String} newJS - Javascript to run after the insertion.\r\n     * @param {Boolean} replaceChildNodes - Replace only the childnodes, alternative is to replace the entire node.\r\n     * @return {Array} The list of new DOM Nodes\r\n     * @fires event:filterContentUpdated\r\n     */\r\n    var domReplace = function(element, newHTML, newJS, replaceChildNodes) {\r\n        var replaceNode = $(element);\r\n        if (replaceNode.length) {\r\n            // First create the dom nodes so we have a reference to them.\r\n            var newNodes = $(newHTML);\r\n            var yuiNodes = null;\r\n            // Do the replacement in the page.\r\n            if (replaceChildNodes) {\r\n                // Cleanup any YUI event listeners attached to any of these nodes.\r\n                yuiNodes = new Y.NodeList(replaceNode.children().get());\r\n                yuiNodes.destroy(true);\r\n\r\n                // JQuery will cleanup after itself.\r\n                replaceNode.empty();\r\n                replaceNode.append(newNodes);\r\n            } else {\r\n                // Cleanup any YUI event listeners attached to any of these nodes.\r\n                yuiNodes = new Y.NodeList(replaceNode.get());\r\n                yuiNodes.destroy(true);\r\n\r\n                // JQuery will cleanup after itself.\r\n                replaceNode.replaceWith(newNodes);\r\n            }\r\n            // Run any javascript associated with the new HTML.\r\n            runTemplateJS(newJS);\r\n            // Notify all filters about the new content.\r\n            filterEvents.notifyFilterContentUpdated(newNodes);\r\n\r\n            return newNodes.get();\r\n        }\r\n\r\n        return [];\r\n    };\r\n\r\n    /**\r\n     * Scan a template source for partial tags and return a list of the found partials.\r\n     *\r\n     * @method scanForPartials\r\n     * @private\r\n     * @param {string} templateSource - source template to scan.\r\n     * @return {Array} List of partials.\r\n     */\r\n    Renderer.prototype.scanForPartials = function(templateSource) {\r\n        var tokens = mustache.parse(templateSource),\r\n            partials = [];\r\n\r\n        var findPartial = function(tokens, partials) {\r\n            var i, token;\r\n            for (i = 0; i < tokens.length; i++) {\r\n                token = tokens[i];\r\n                if (token[0] == '>' || token[0] == '<') {\r\n                    partials.push(token[1]);\r\n                }\r\n                if (token.length > 4) {\r\n                    findPartial(token[4], partials);\r\n                }\r\n            }\r\n        };\r\n\r\n        findPartial(tokens, partials);\r\n\r\n        return partials;\r\n    };\r\n\r\n    /**\r\n     * Load a template and scan it for partials. Recursively fetch the partials.\r\n     *\r\n     * @method cachePartials\r\n     * @private\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @param {Array} parentage - A list of requested partials in this render chain.\r\n     * @return {Promise} JQuery promise object resolved when all partials are in the cache.\r\n     */\r\n    Renderer.prototype.cachePartials = function(templateName, parentage) {\r\n        var searchKey = this.currentThemeName + '/' + templateName;\r\n\r\n        if (searchKey in cachePartialPromises) {\r\n            return cachePartialPromises[searchKey];\r\n        }\r\n\r\n        // This promise will not be resolved until all child partials are also resolved and ready.\r\n        // We create it here to allow us to check for recursive inclusion of templates.\r\n        // Keep track of the requested partials in this chain.\r\n        parentage = parentage || [searchKey];\r\n\r\n        cachePartialPromises[searchKey] = $.Deferred();\r\n\r\n        this.getTemplate(templateName)\r\n        .then(function(templateSource) {\r\n            var partials = this.scanForPartials(templateSource);\r\n            var uniquePartials = partials.filter(function(partialName) {\r\n                // Check for recursion.\r\n\r\n                if (parentage.indexOf(this.currentThemeName + '/' + partialName) >= 0) {\r\n                    // Ignore templates which include a parent template already requested in the current chain.\r\n                    return false;\r\n                }\r\n\r\n                // Ignore templates that include themselves.\r\n                return partialName != templateName;\r\n            }.bind(this));\r\n\r\n            // Fetch any partial which has not already been fetched.\r\n            var fetchThemAll = uniquePartials.map(function(partialName) {\r\n                parentage.push(this.currentThemeName + '/' + partialName);\r\n                return this.cachePartials(partialName, parentage);\r\n            }.bind(this));\r\n\r\n            // Resolve the templateName promise when all of the children are resolved.\r\n            return $.when.apply($, fetchThemAll)\r\n            .then(function() {\r\n                return cachePartialPromises[searchKey].resolve(templateSource);\r\n            });\r\n        }.bind(this))\r\n        .catch(cachePartialPromises[searchKey].reject);\r\n\r\n        return cachePartialPromises[searchKey];\r\n    };\r\n\r\n    /**\r\n     * Load a template and call doRender on it.\r\n     *\r\n     * @method render\r\n     * @private\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @param {Object} context - Could be array, string or simple value for the context of the template.\r\n     * @param {string} themeName - Name of the current theme.\r\n     * @return {Promise} JQuery promise object resolved when the template has been rendered.\r\n     */\r\n    Renderer.prototype.render = function(templateName, context, themeName) {\r\n        if (typeof (themeName) === \"undefined\") {\r\n            // System context by default.\r\n            themeName = config.theme;\r\n        }\r\n\r\n        this.currentThemeName = themeName;\r\n\r\n        // Preload the module to do the icon rendering based on the theme iconsystem.\r\n        var modulename = config.iconsystemmodule;\r\n\r\n        var ready = $.Deferred();\r\n        require([modulename], function(System) {\r\n            var system = new System();\r\n            if (!(system instanceof IconSystem)) {\r\n                ready.reject('Invalid icon system specified' + config.iconsystem);\r\n            } else {\r\n                iconSystem = system;\r\n                system.init().then(ready.resolve).catch(notification.exception);\r\n            }\r\n        });\r\n\r\n        return ready.then(function() {\r\n                return this.cachePartials(templateName);\r\n            }.bind(this)).then(function(templateSource) {\r\n                return this.doRender(templateSource, context, themeName);\r\n            }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Prepend some HTML to a node and trigger events and fire javascript.\r\n     *\r\n     * @method domPrepend\r\n     * @private\r\n     * @param {jQuery|String} element - Element or selector to prepend HTML to\r\n     * @param {String} html - HTML to prepend\r\n     * @param {String} js - Javascript to run after we prepend the html\r\n     * @return {Array} The list of new DOM Nodes\r\n     * @fires event:filterContentUpdated\r\n     */\r\n    var domPrepend = function(element, html, js) {\r\n        var node = $(element);\r\n        if (node.length) {\r\n            // Prepend the html.\r\n            var newContent = $(html);\r\n            node.prepend(newContent);\r\n            // Run any javascript associated with the new HTML.\r\n            runTemplateJS(js);\r\n            // Notify all filters about the new content.\r\n            filterEvents.notifyFilterContentUpdated(node);\r\n\r\n            return newContent.get();\r\n        }\r\n\r\n        return [];\r\n    };\r\n\r\n    /**\r\n     * Append some HTML to a node and trigger events and fire javascript.\r\n     *\r\n     * @method domAppend\r\n     * @private\r\n     * @param {jQuery|String} element - Element or selector to append HTML to\r\n     * @param {String} html - HTML to append\r\n     * @param {String} js - Javascript to run after we append the html\r\n     * @return {Array} The list of new DOM Nodes\r\n     * @fires event:filterContentUpdated\r\n     */\r\n    var domAppend = function(element, html, js) {\r\n        var node = $(element);\r\n        if (node.length) {\r\n            // Append the html.\r\n            var newContent = $(html);\r\n            node.append(newContent);\r\n            // Run any javascript associated with the new HTML.\r\n            runTemplateJS(js);\r\n            // Notify all filters about the new content.\r\n            filterEvents.notifyFilterContentUpdated(node);\r\n\r\n            return newContent.get();\r\n        }\r\n\r\n        return [];\r\n    };\r\n\r\n    return /** @alias module:core/templates */ {\r\n        // Public variables and functions.\r\n        /**\r\n         * Every call to render creates a new instance of the class and calls render on it. This\r\n         * means each render call has it's own class variables.\r\n         *\r\n         * @method render\r\n         * @private\r\n         * @param {string} templateName - should consist of the component and the name of the template like this:\r\n         *                              core/menu (lib/templates/menu.mustache) or\r\n         *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n         * @param {Object} context - Could be array, string or simple value for the context of the template.\r\n         * @param {string} themeName - Name of the current theme.\r\n         * @return {Promise} JQuery promise object resolved when the template has been rendered.\r\n         */\r\n        render: function(templateName, context, themeName) {\r\n            var renderer = new Renderer();\r\n            return renderer.render(templateName, context, themeName);\r\n        },\r\n\r\n        /**\r\n         * Prefetch a set of templates without rendering them.\r\n         *\r\n         * @method getTemplate\r\n         * @param {Array} templateNames The list of templates to fetch\r\n         * @param {String} themeName\r\n         * @returns {Promise}\r\n         */\r\n        prefetchTemplates: function(templateNames, themeName) {\r\n            var renderer = new Renderer();\r\n\r\n            if (typeof themeName === \"undefined\") {\r\n                // System context by default.\r\n                themeName = config.theme;\r\n            }\r\n\r\n            return renderer.prefetchTemplates(templateNames, themeName);\r\n        },\r\n\r\n        /**\r\n         * Every call to render creates a new instance of the class and calls render on it. This\r\n         * means each render call has it's own class variables.\r\n         *\r\n         * This alernate to the standard .render() function returns the html and js in a single object suitable for a\r\n         * native Promise.\r\n         *\r\n         * @method renderForPromise\r\n         * @private\r\n         * @param {string} templateName - should consist of the component and the name of the template like this:\r\n         *                              core/menu (lib/templates/menu.mustache) or\r\n         *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n         * @param {Object} context - Could be array, string or simple value for the context of the template.\r\n         * @param {string} themeName - Name of the current theme.\r\n         * @return {Promise} JQuery promise object resolved when the template has been rendered.\r\n         */\r\n        renderForPromise: function(templateName, context, themeName) {\r\n            var renderer = new Renderer();\r\n            return renderer.render(templateName, context, themeName)\r\n            .then(function(html, js) {\r\n                return {\r\n                    html: html,\r\n                    js: js,\r\n                };\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Every call to renderIcon creates a new instance of the class and calls renderIcon on it. This\r\n         * means each render call has it's own class variables.\r\n         *\r\n         * @method renderIcon\r\n         * @public\r\n         * @param {string} key - Icon key.\r\n         * @param {string} component - Icon component\r\n         * @param {string} title - Icon title\r\n         * @return {Promise} JQuery promise object resolved when the pix has been rendered.\r\n         */\r\n        renderPix: function(key, component, title) {\r\n            var renderer = new Renderer();\r\n            return renderer.renderIcon(\r\n                key,\r\n                getNormalisedComponent(component),\r\n                title\r\n            );\r\n        },\r\n\r\n        /**\r\n         * Execute a block of JS returned from a template.\r\n         * Call this AFTER adding the template HTML into the DOM so the nodes can be found.\r\n         *\r\n         * @method runTemplateJS\r\n         * @param {string} source - A block of javascript.\r\n         */\r\n        runTemplateJS: runTemplateJS,\r\n\r\n        /**\r\n         * Replace a node in the page with some new HTML and run the JS.\r\n         *\r\n         * @method replaceNodeContents\r\n         * @param {JQuery} element - Element or selector to replace.\r\n         * @param {String} newHTML - HTML to insert / replace.\r\n         * @param {String} newJS - Javascript to run after the insertion.\r\n         * @return {Array} The list of new DOM Nodes\r\n         */\r\n        replaceNodeContents: function(element, newHTML, newJS) {\r\n            return domReplace(element, newHTML, newJS, true);\r\n        },\r\n\r\n        /**\r\n         * Insert a node in the page with some new HTML and run the JS.\r\n         *\r\n         * @method replaceNode\r\n         * @param {JQuery} element - Element or selector to replace.\r\n         * @param {String} newHTML - HTML to insert / replace.\r\n         * @param {String} newJS - Javascript to run after the insertion.\r\n         * @return {Array} The list of new DOM Nodes\r\n         */\r\n        replaceNode: function(element, newHTML, newJS) {\r\n            return domReplace(element, newHTML, newJS, false);\r\n        },\r\n\r\n        /**\r\n         * Prepend some HTML to a node and trigger events and fire javascript.\r\n         *\r\n         * @method prependNodeContents\r\n         * @param {jQuery|String} element - Element or selector to prepend HTML to\r\n         * @param {String} html - HTML to prepend\r\n         * @param {String} js - Javascript to run after we prepend the html\r\n         * @return {Array} The list of new DOM Nodes\r\n         */\r\n        prependNodeContents: function(element, html, js) {\r\n            return domPrepend(element, html, js);\r\n        },\r\n\r\n        /**\r\n         * Append some HTML to a node and trigger events and fire javascript.\r\n         *\r\n         * @method appendNodeContents\r\n         * @param {jQuery|String} element - Element or selector to append HTML to\r\n         * @param {String} html - HTML to append\r\n         * @param {String} js - Javascript to run after we append the html\r\n         * @return {Array} The list of new DOM Nodes\r\n         */\r\n        appendNodeContents: function(element, html, js) {\r\n            return domAppend(element, html, js);\r\n        },\r\n    };\r\n});\r\n"],"names":["define","mustache","$","ajax","str","notification","coreurl","config","storage","IconSystem","filterEvents","Y","Log","Truncate","UserDate","Pending","uniqInstances","templateCache","templatePromises","cachePartialPromises","iconSystem","loadTemplateBuffer","isLoadingTemplates","disallowedNestedHelpers","getNormalisedComponent","component","getTemplatePromiseFromCache","searchKey","Deferred","resolve","promise","M","cfg","templaterev","cached","get","processLoadTemplateBuffer","length","templatesToLoad","slice","serverRequestsDeferred","requests","map","templateData","name","theme","templateDeferred","deferred","cachedPromise","push","methodname","args","template","themename","lang","attr","replace","index","then","promises","response","templateSource","templates","forEach","data","tempSearchKey","join","value","set","strings","cache_strings","key","source","catch","error","reject","call","when","apply","splice","Renderer","requiredStrings","requiredJS","requiredDates","currentThemeName","prototype","getTemplate","templateName","currentTheme","this","existingBufferRecords","filter","record","parts","split","shift","prefetchTemplates","templateNames","partialHelper","exception","Error","renderIcon","title","modulename","iconsystemmodule","ready","require","System","system","init","getTemplateName","bind","pixHelper","context","sectionText","helper","text","trim","jsHelper","stringHelper","param","match","parsedParam","JSON","parse","err","window","console","warn","message","cleanStringHelper","quoteHelper","content","stringify","shortenTextHelper","truncate","words","ellipsis","userDateHelper","timestamp","format","addHelperFunction","helperFunction","originalHelpers","reduce","carry","hasOwnProperty","helperName","result","addHelpers","themeName","uniqid","cleanstr","pix","js","quote","shortentext","userdate","globals","getJS","treatStringsInContent","treated","strIndex","walker","char","strFinal","isClean","pattern","search","substring","substr","parseInt","debug","escape","treatDatesInContent","dates","date","re","RegExp","doRender","iconTemplate","pendingPromise","render","html","get_strings","runTemplateJS","newscript","append","domReplace","element","newHTML","newJS","replaceChildNodes","replaceNode","newNodes","NodeList","children","destroy","empty","replaceWith","notifyFilterContentUpdated","scanForPartials","tokens","partials","findPartial","i","token","cachePartials","parentage","fetchThemAll","partialName","indexOf","iconsystem","renderer","renderForPromise","renderPix","replaceNodeContents","prependNodeContents","node","newContent","prepend","domPrepend","appendNodeContents","domAppend"],"mappings":"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"}