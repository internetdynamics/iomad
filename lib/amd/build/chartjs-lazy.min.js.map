{"version":3,"file":"chartjs-lazy.min.js","sources":["../src/chartjs-lazy.js"],"sourcesContent":["/*!\r\n * Chart.js v4.2.1\r\n * https://www.chartjs.org\r\n * (c) 2023 Chart.js Contributors\r\n * Released under the MIT License\r\n */\r\n\r\n/**\r\n * Description of import into Moodle:\r\n *\r\n * - Download Chartjs source code (zip) file from https://github.com/chartjs/Chart.js/releases/latest.\r\n * - You must build Chart.js to generate the dist files (https://www.chartjs.org/docs/latest/developers/contributing.html#building-and-testing).\r\n *   Chart.js will generate a new file dist/chart.umd.js with minified format, in order to avoid the minification\r\n *   we need to modify rollup.config.js, find below code in the file:\r\n *   ```\r\n *   1. // UMD build\r\n *   2. // dist/chart.umd.js\r\n *   3. {\r\n *   4.     input: 'src/index.umd.ts',\r\n *   5.     plugins: plugins(true),\r\n *   6.     output: {\r\n *   7.       ...\r\n *   8.     },\r\n *   9. },\r\n *   ```\r\n *\r\n *   Change line 5 into:\r\n *   ```\r\n *   plugins: plugins(),\r\n *   ```\r\n *\r\n *   Save the file and run build script again.\r\n *\r\n * - Copy /dist/chart.umd.js content to lib/amd/src/chartjs-lazy.js.\r\n * - Remove below line in the lib/amd/src/chartjs-lazy.js:\r\n *   ```\r\n *   //# sourceMappingURL=chart.umd.js.map\r\n *   ```\r\n * - Convert line endings to LF-Unix format.\r\n * - Change the version number and the copyright year at the file header block.\r\n * - Keep these instructions in the file.\r\n * - Visit lib/tests/other/chartjstestpage.php to see if the library still works after the update.\r\n *\r\n */\r\n\r\n(function (global, factory) {\r\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\ntypeof define === 'function' && define.amd ? define(factory) :\r\n(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());\r\n})(this, (function () { 'use strict';\r\n\r\nvar plugins = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nget Colors () { return plugin_colors; },\r\nget Decimation () { return plugin_decimation; },\r\nget Filler () { return index; },\r\nget Legend () { return plugin_legend; },\r\nget SubTitle () { return plugin_subtitle; },\r\nget Title () { return plugin_title; },\r\nget Tooltip () { return plugin_tooltip; }\r\n});\r\n\r\n/**\r\n * @namespace Chart.helpers\r\n */ /**\r\n * An empty function that can be used, for example, for optional callback.\r\n */ function noop() {\r\n/* noop */ }\r\n/**\r\n * Returns a unique id, sequentially generated from a global variable.\r\n */ const uid = (()=>{\r\n    let id = 0;\r\n    return ()=>id++;\r\n})();\r\n/**\r\n * Returns true if `value` is neither null nor undefined, else returns false.\r\n * @param value - The value to test.\r\n * @since 2.7.0\r\n */ function isNullOrUndef(value) {\r\n    return value === null || typeof value === 'undefined';\r\n}\r\n/**\r\n * Returns true if `value` is an array (including typed arrays), else returns false.\r\n * @param value - The value to test.\r\n * @function\r\n */ function isArray(value) {\r\n    if (Array.isArray && Array.isArray(value)) {\r\n        return true;\r\n    }\r\n    const type = Object.prototype.toString.call(value);\r\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns true if `value` is an object (excluding null), else returns false.\r\n * @param value - The value to test.\r\n * @since 2.7.0\r\n */ function isObject(value) {\r\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\r\n}\r\n/**\r\n * Returns true if `value` is a finite number, else returns false\r\n * @param value  - The value to test.\r\n */ function isNumberFinite(value) {\r\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\r\n}\r\n/**\r\n * Returns `value` if finite, else returns `defaultValue`.\r\n * @param value - The value to return if defined.\r\n * @param defaultValue - The value to return if `value` is not finite.\r\n */ function finiteOrDefault(value, defaultValue) {\r\n    return isNumberFinite(value) ? value : defaultValue;\r\n}\r\n/**\r\n * Returns `value` if defined, else returns `defaultValue`.\r\n * @param value - The value to return if defined.\r\n * @param defaultValue - The value to return if `value` is undefined.\r\n */ function valueOrDefault(value, defaultValue) {\r\n    return typeof value === 'undefined' ? defaultValue : value;\r\n}\r\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\r\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\r\n/**\r\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\r\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\r\n * @param fn - The function to call.\r\n * @param args - The arguments with which `fn` should be called.\r\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\r\n */ function callback(fn, args, thisArg) {\r\n    if (fn && typeof fn.call === 'function') {\r\n        return fn.apply(thisArg, args);\r\n    }\r\n}\r\nfunction each(loopable, fn, thisArg, reverse) {\r\n    let i, len, keys;\r\n    if (isArray(loopable)) {\r\n        len = loopable.length;\r\n        if (reverse) {\r\n            for(i = len - 1; i >= 0; i--){\r\n                fn.call(thisArg, loopable[i], i);\r\n            }\r\n        } else {\r\n            for(i = 0; i < len; i++){\r\n                fn.call(thisArg, loopable[i], i);\r\n            }\r\n        }\r\n    } else if (isObject(loopable)) {\r\n        keys = Object.keys(loopable);\r\n        len = keys.length;\r\n        for(i = 0; i < len; i++){\r\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\r\n * @param a0 - The array to compare\r\n * @param a1 - The array to compare\r\n * @private\r\n */ function _elementsEqual(a0, a1) {\r\n    let i, ilen, v0, v1;\r\n    if (!a0 || !a1 || a0.length !== a1.length) {\r\n        return false;\r\n    }\r\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\r\n        v0 = a0[i];\r\n        v1 = a1[i];\r\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n * @param source - The value to clone.\r\n */ function clone$1(source) {\r\n    if (isArray(source)) {\r\n        return source.map(clone$1);\r\n    }\r\n    if (isObject(source)) {\r\n        const target = Object.create(null);\r\n        const keys = Object.keys(source);\r\n        const klen = keys.length;\r\n        let k = 0;\r\n        for(; k < klen; ++k){\r\n            target[keys[k]] = clone$1(source[keys[k]]);\r\n        }\r\n        return target;\r\n    }\r\n    return source;\r\n}\r\nfunction isValidKey(key) {\r\n    return [\r\n        '__proto__',\r\n        'prototype',\r\n        'constructor'\r\n    ].indexOf(key) === -1;\r\n}\r\n/**\r\n * The default merger when Chart.helpers.merge is called without merger option.\r\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\r\n * @private\r\n */ function _merger(key, target, source, options) {\r\n    if (!isValidKey(key)) {\r\n        return;\r\n    }\r\n    const tval = target[key];\r\n    const sval = source[key];\r\n    if (isObject(tval) && isObject(sval)) {\r\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n        merge(tval, sval, options);\r\n    } else {\r\n        target[key] = clone$1(sval);\r\n    }\r\n}\r\nfunction merge(target, source, options) {\r\n    const sources = isArray(source) ? source : [\r\n        source\r\n    ];\r\n    const ilen = sources.length;\r\n    if (!isObject(target)) {\r\n        return target;\r\n    }\r\n    options = options || {};\r\n    const merger = options.merger || _merger;\r\n    let current;\r\n    for(let i = 0; i < ilen; ++i){\r\n        current = sources[i];\r\n        if (!isObject(current)) {\r\n            continue;\r\n        }\r\n        const keys = Object.keys(current);\r\n        for(let k = 0, klen = keys.length; k < klen; ++k){\r\n            merger(keys[k], target, current, options);\r\n        }\r\n    }\r\n    return target;\r\n}\r\nfunction mergeIf(target, source) {\r\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n    return merge(target, source, {\r\n        merger: _mergerIf\r\n    });\r\n}\r\n/**\r\n * Merges source[key] in target[key] only if target[key] is undefined.\r\n * @private\r\n */ function _mergerIf(key, target, source) {\r\n    if (!isValidKey(key)) {\r\n        return;\r\n    }\r\n    const tval = target[key];\r\n    const sval = source[key];\r\n    if (isObject(tval) && isObject(sval)) {\r\n        mergeIf(tval, sval);\r\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\r\n        target[key] = clone$1(sval);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */ function _deprecated(scope, value, previous, current) {\r\n    if (value !== undefined) {\r\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\r\n    }\r\n}\r\n// resolveObjectKey resolver cache\r\nconst keyResolvers = {\r\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\r\n    '': (v)=>v,\r\n    // default resolvers\r\n    x: (o)=>o.x,\r\n    y: (o)=>o.y\r\n};\r\n/**\r\n * @private\r\n */ function _splitKey(key) {\r\n    const parts = key.split('.');\r\n    const keys = [];\r\n    let tmp = '';\r\n    for (const part of parts){\r\n        tmp += part;\r\n        if (tmp.endsWith('\\\\')) {\r\n            tmp = tmp.slice(0, -1) + '.';\r\n        } else {\r\n            keys.push(tmp);\r\n            tmp = '';\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nfunction _getKeyResolver(key) {\r\n    const keys = _splitKey(key);\r\n    return (obj)=>{\r\n        for (const k of keys){\r\n            if (k === '') {\r\n                break;\r\n            }\r\n            obj = obj && obj[k];\r\n        }\r\n        return obj;\r\n    };\r\n}\r\nfunction resolveObjectKey(obj, key) {\r\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\r\n    return resolver(obj);\r\n}\r\n/**\r\n * @private\r\n */ function _capitalize(str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\nconst defined = (value)=>typeof value !== 'undefined';\r\nconst isFunction = (value)=>typeof value === 'function';\r\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\r\nconst setsEqual = (a, b)=>{\r\n    if (a.size !== b.size) {\r\n        return false;\r\n    }\r\n    for (const item of a){\r\n        if (!b.has(item)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n/**\r\n * @param e - The event\r\n * @private\r\n */ function _isClickEvent(e) {\r\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\r\n}\r\n\r\n/**\r\n * @alias Chart.helpers.math\r\n * @namespace\r\n */ const PI = Math.PI;\r\nconst TAU = 2 * PI;\r\nconst PITAU = TAU + PI;\r\nconst INFINITY = Number.POSITIVE_INFINITY;\r\nconst RAD_PER_DEG = PI / 180;\r\nconst HALF_PI = PI / 2;\r\nconst QUARTER_PI = PI / 4;\r\nconst TWO_THIRDS_PI = PI * 2 / 3;\r\nconst log10 = Math.log10;\r\nconst sign = Math.sign;\r\nfunction almostEquals(x, y, epsilon) {\r\n    return Math.abs(x - y) < epsilon;\r\n}\r\n/**\r\n * Implementation of the nice number algorithm used in determining where axis labels will go\r\n */ function niceNum(range) {\r\n    const roundedRange = Math.round(range);\r\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\r\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\r\n    const fraction = range / niceRange;\r\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\r\n    return niceFraction * niceRange;\r\n}\r\n/**\r\n * Returns an array of factors sorted from 1 to sqrt(value)\r\n * @private\r\n */ function _factorize(value) {\r\n    const result = [];\r\n    const sqrt = Math.sqrt(value);\r\n    let i;\r\n    for(i = 1; i < sqrt; i++){\r\n        if (value % i === 0) {\r\n            result.push(i);\r\n            result.push(value / i);\r\n        }\r\n    }\r\n    if (sqrt === (sqrt | 0)) {\r\n        result.push(sqrt);\r\n    }\r\n    result.sort((a, b)=>a - b).pop();\r\n    return result;\r\n}\r\nfunction isNumber(n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n}\r\nfunction almostWhole(x, epsilon) {\r\n    const rounded = Math.round(x);\r\n    return rounded - epsilon <= x && rounded + epsilon >= x;\r\n}\r\n/**\r\n * @private\r\n */ function _setMinAndMaxByKey(array, target, property) {\r\n    let i, ilen, value;\r\n    for(i = 0, ilen = array.length; i < ilen; i++){\r\n        value = array[i][property];\r\n        if (!isNaN(value)) {\r\n            target.min = Math.min(target.min, value);\r\n            target.max = Math.max(target.max, value);\r\n        }\r\n    }\r\n}\r\nfunction toRadians(degrees) {\r\n    return degrees * (PI / 180);\r\n}\r\nfunction toDegrees(radians) {\r\n    return radians * (180 / PI);\r\n}\r\n/**\r\n * Returns the number of decimal places\r\n * i.e. the number of digits after the decimal point, of the value of this Number.\r\n * @param x - A number.\r\n * @returns The number of decimal places.\r\n * @private\r\n */ function _decimalPlaces(x) {\r\n    if (!isNumberFinite(x)) {\r\n        return;\r\n    }\r\n    let e = 1;\r\n    let p = 0;\r\n    while(Math.round(x * e) / e !== x){\r\n        e *= 10;\r\n        p++;\r\n    }\r\n    return p;\r\n}\r\n// Gets the angle from vertical upright to the point about a centre.\r\nfunction getAngleFromPoint(centrePoint, anglePoint) {\r\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\r\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n    if (angle < -0.5 * PI) {\r\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\r\n    }\r\n    return {\r\n        angle,\r\n        distance: radialDistanceFromCenter\r\n    };\r\n}\r\nfunction distanceBetweenPoints(pt1, pt2) {\r\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n}\r\n/**\r\n * Shortest distance between angles, in either direction.\r\n * @private\r\n */ function _angleDiff(a, b) {\r\n    return (a - b + PITAU) % TAU - PI;\r\n}\r\n/**\r\n * Normalize angle to be between 0 and 2*PI\r\n * @private\r\n */ function _normalizeAngle(a) {\r\n    return (a % TAU + TAU) % TAU;\r\n}\r\n/**\r\n * @private\r\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\r\n    const a = _normalizeAngle(angle);\r\n    const s = _normalizeAngle(start);\r\n    const e = _normalizeAngle(end);\r\n    const angleToStart = _normalizeAngle(s - a);\r\n    const angleToEnd = _normalizeAngle(e - a);\r\n    const startToAngle = _normalizeAngle(a - s);\r\n    const endToAngle = _normalizeAngle(a - e);\r\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\r\n}\r\n/**\r\n * Limit `value` between `min` and `max`\r\n * @param value\r\n * @param min\r\n * @param max\r\n * @private\r\n */ function _limitValue(value, min, max) {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\n/**\r\n * @param {number} value\r\n * @private\r\n */ function _int16Range(value) {\r\n    return _limitValue(value, -32768, 32767);\r\n}\r\n/**\r\n * @param value\r\n * @param start\r\n * @param end\r\n * @param [epsilon]\r\n * @private\r\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\r\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\r\n}\r\n\r\nfunction _lookup(table, value, cmp) {\r\n    cmp = cmp || ((index)=>table[index] < value);\r\n    let hi = table.length - 1;\r\n    let lo = 0;\r\n    let mid;\r\n    while(hi - lo > 1){\r\n        mid = lo + hi >> 1;\r\n        if (cmp(mid)) {\r\n            lo = mid;\r\n        } else {\r\n            hi = mid;\r\n        }\r\n    }\r\n    return {\r\n        lo,\r\n        hi\r\n    };\r\n}\r\n/**\r\n * Binary search\r\n * @param table - the table search. must be sorted!\r\n * @param key - property name for the value in each entry\r\n * @param value - value to find\r\n * @param last - lookup last index\r\n * @private\r\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\r\n        const ti = table[index][key];\r\n        return ti < value || ti === value && table[index + 1][key] === value;\r\n    } : (index)=>table[index][key] < value);\r\n/**\r\n * Reverse binary search\r\n * @param table - the table search. must be sorted!\r\n * @param key - property name for the value in each entry\r\n * @param value - value to find\r\n * @private\r\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\r\n/**\r\n * Return subset of `values` between `min` and `max` inclusive.\r\n * Values are assumed to be in sorted order.\r\n * @param values - sorted array of values\r\n * @param min - min value\r\n * @param max - max value\r\n */ function _filterBetween(values, min, max) {\r\n    let start = 0;\r\n    let end = values.length;\r\n    while(start < end && values[start] < min){\r\n        start++;\r\n    }\r\n    while(end > start && values[end - 1] > max){\r\n        end--;\r\n    }\r\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\r\n}\r\nconst arrayEvents = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'splice',\r\n    'unshift'\r\n];\r\nfunction listenArrayEvents(array, listener) {\r\n    if (array._chartjs) {\r\n        array._chartjs.listeners.push(listener);\r\n        return;\r\n    }\r\n    Object.defineProperty(array, '_chartjs', {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value: {\r\n            listeners: [\r\n                listener\r\n            ]\r\n        }\r\n    });\r\n    arrayEvents.forEach((key)=>{\r\n        const method = '_onData' + _capitalize(key);\r\n        const base = array[key];\r\n        Object.defineProperty(array, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            value (...args) {\r\n                const res = base.apply(this, args);\r\n                array._chartjs.listeners.forEach((object)=>{\r\n                    if (typeof object[method] === 'function') {\r\n                        object[method](...args);\r\n                    }\r\n                });\r\n                return res;\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction unlistenArrayEvents(array, listener) {\r\n    const stub = array._chartjs;\r\n    if (!stub) {\r\n        return;\r\n    }\r\n    const listeners = stub.listeners;\r\n    const index = listeners.indexOf(listener);\r\n    if (index !== -1) {\r\n        listeners.splice(index, 1);\r\n    }\r\n    if (listeners.length > 0) {\r\n        return;\r\n    }\r\n    arrayEvents.forEach((key)=>{\r\n        delete array[key];\r\n    });\r\n    delete array._chartjs;\r\n}\r\n/**\r\n * @param items\r\n */ function _arrayUnique(items) {\r\n    const set = new Set();\r\n    let i, ilen;\r\n    for(i = 0, ilen = items.length; i < ilen; ++i){\r\n        set.add(items[i]);\r\n    }\r\n    if (set.size === ilen) {\r\n        return items;\r\n    }\r\n    return Array.from(set);\r\n}\r\n\r\nfunction fontString(pixelSize, fontStyle, fontFamily) {\r\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n}\r\n/**\r\n* Request animation polyfill\r\n*/ const requestAnimFrame = function() {\r\n    if (typeof window === 'undefined') {\r\n        return function(callback) {\r\n            return callback();\r\n        };\r\n    }\r\n    return window.requestAnimationFrame;\r\n}();\r\n/**\r\n * Throttles calling `fn` once per animation frame\r\n * Latest arguments are used on the actual call\r\n */ function throttled(fn, thisArg) {\r\n    let argsToUse = [];\r\n    let ticking = false;\r\n    return function(...args) {\r\n        // Save the args for use later\r\n        argsToUse = args;\r\n        if (!ticking) {\r\n            ticking = true;\r\n            requestAnimFrame.call(window, ()=>{\r\n                ticking = false;\r\n                fn.apply(thisArg, argsToUse);\r\n            });\r\n        }\r\n    };\r\n}\r\n/**\r\n * Debounces calling `fn` for `delay` ms\r\n */ function debounce(fn, delay) {\r\n    let timeout;\r\n    return function(...args) {\r\n        if (delay) {\r\n            clearTimeout(timeout);\r\n            timeout = setTimeout(fn, delay, args);\r\n        } else {\r\n            fn.apply(this, args);\r\n        }\r\n        return delay;\r\n    };\r\n}\r\n/**\r\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\r\n * @private\r\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\r\n/**\r\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\r\n * @private\r\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\r\n/**\r\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\r\n * @private\r\n */ const _textX = (align, left, right, rtl)=>{\r\n    const check = rtl ? 'left' : 'right';\r\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\r\n};\r\n/**\r\n * Return start and count of visible points.\r\n * @private\r\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\r\n    const pointCount = points.length;\r\n    let start = 0;\r\n    let count = pointCount;\r\n    if (meta._sorted) {\r\n        const { iScale , _parsed  } = meta;\r\n        const axis = iScale.axis;\r\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\r\n        if (minDefined) {\r\n            start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed\r\n            _lookupByKey(_parsed, iScale.axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\r\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\r\n        }\r\n        if (maxDefined) {\r\n            count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed\r\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\r\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\r\n        } else {\r\n            count = pointCount - start;\r\n        }\r\n    }\r\n    return {\r\n        start,\r\n        count\r\n    };\r\n}\r\n/**\r\n * Checks if the scale ranges have changed.\r\n * @param {object} meta - dataset meta.\r\n * @returns {boolean}\r\n * @private\r\n */ function _scaleRangesChanged(meta) {\r\n    const { xScale , yScale , _scaleRanges  } = meta;\r\n    const newRanges = {\r\n        xmin: xScale.min,\r\n        xmax: xScale.max,\r\n        ymin: yScale.min,\r\n        ymax: yScale.max\r\n    };\r\n    if (!_scaleRanges) {\r\n        meta._scaleRanges = newRanges;\r\n        return true;\r\n    }\r\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\r\n    Object.assign(_scaleRanges, newRanges);\r\n    return changed;\r\n}\r\n\r\nclass Animator {\r\n    constructor(){\r\n        this._request = null;\r\n        this._charts = new Map();\r\n        this._running = false;\r\n        this._lastDate = undefined;\r\n    }\r\n _notify(chart, anims, date, type) {\r\n        const callbacks = anims.listeners[type];\r\n        const numSteps = anims.duration;\r\n        callbacks.forEach((fn)=>fn({\r\n                chart,\r\n                initial: anims.initial,\r\n                numSteps,\r\n                currentStep: Math.min(date - anims.start, numSteps)\r\n            }));\r\n    }\r\n _refresh() {\r\n        if (this._request) {\r\n            return;\r\n        }\r\n        this._running = true;\r\n        this._request = requestAnimFrame.call(window, ()=>{\r\n            this._update();\r\n            this._request = null;\r\n            if (this._running) {\r\n                this._refresh();\r\n            }\r\n        });\r\n    }\r\n _update(date = Date.now()) {\r\n        let remaining = 0;\r\n        this._charts.forEach((anims, chart)=>{\r\n            if (!anims.running || !anims.items.length) {\r\n                return;\r\n            }\r\n            const items = anims.items;\r\n            let i = items.length - 1;\r\n            let draw = false;\r\n            let item;\r\n            for(; i >= 0; --i){\r\n                item = items[i];\r\n                if (item._active) {\r\n                    if (item._total > anims.duration) {\r\n                        anims.duration = item._total;\r\n                    }\r\n                    item.tick(date);\r\n                    draw = true;\r\n                } else {\r\n                    items[i] = items[items.length - 1];\r\n                    items.pop();\r\n                }\r\n            }\r\n            if (draw) {\r\n                chart.draw();\r\n                this._notify(chart, anims, date, 'progress');\r\n            }\r\n            if (!items.length) {\r\n                anims.running = false;\r\n                this._notify(chart, anims, date, 'complete');\r\n                anims.initial = false;\r\n            }\r\n            remaining += items.length;\r\n        });\r\n        this._lastDate = date;\r\n        if (remaining === 0) {\r\n            this._running = false;\r\n        }\r\n    }\r\n _getAnims(chart) {\r\n        const charts = this._charts;\r\n        let anims = charts.get(chart);\r\n        if (!anims) {\r\n            anims = {\r\n                running: false,\r\n                initial: true,\r\n                items: [],\r\n                listeners: {\r\n                    complete: [],\r\n                    progress: []\r\n                }\r\n            };\r\n            charts.set(chart, anims);\r\n        }\r\n        return anims;\r\n    }\r\n listen(chart, event, cb) {\r\n        this._getAnims(chart).listeners[event].push(cb);\r\n    }\r\n add(chart, items) {\r\n        if (!items || !items.length) {\r\n            return;\r\n        }\r\n        this._getAnims(chart).items.push(...items);\r\n    }\r\n has(chart) {\r\n        return this._getAnims(chart).items.length > 0;\r\n    }\r\n start(chart) {\r\n        const anims = this._charts.get(chart);\r\n        if (!anims) {\r\n            return;\r\n        }\r\n        anims.running = true;\r\n        anims.start = Date.now();\r\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\r\n        this._refresh();\r\n    }\r\n    running(chart) {\r\n        if (!this._running) {\r\n            return false;\r\n        }\r\n        const anims = this._charts.get(chart);\r\n        if (!anims || !anims.running || !anims.items.length) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n stop(chart) {\r\n        const anims = this._charts.get(chart);\r\n        if (!anims || !anims.items.length) {\r\n            return;\r\n        }\r\n        const items = anims.items;\r\n        let i = items.length - 1;\r\n        for(; i >= 0; --i){\r\n            items[i].cancel();\r\n        }\r\n        anims.items = [];\r\n        this._notify(chart, anims, Date.now(), 'complete');\r\n    }\r\n remove(chart) {\r\n        return this._charts.delete(chart);\r\n    }\r\n}\r\nvar animator = /* #__PURE__ */ new Animator();\r\n\r\n/*!\r\n * @kurkle/color v0.3.0\r\n * https://github.com/kurkle/color#readme\r\n * (c) 2022 Jukka Kurkela\r\n * Released under the MIT License\r\n */\r\nfunction round(v) {\r\n  return v + 0.5 | 0;\r\n}\r\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\r\nfunction p2b(v) {\r\n  return lim(round(v * 2.55), 0, 255);\r\n}\r\nfunction n2b(v) {\r\n  return lim(round(v * 255), 0, 255);\r\n}\r\nfunction b2n(v) {\r\n  return lim(round(v / 2.55) / 100, 0, 1);\r\n}\r\nfunction n2p(v) {\r\n  return lim(round(v * 100), 0, 100);\r\n}\r\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\r\nconst hex = [...'0123456789ABCDEF'];\r\nconst h1 = b => hex[b & 0xF];\r\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\r\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\r\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\r\nfunction hexParse(str) {\r\n  var len = str.length;\r\n  var ret;\r\n  if (str[0] === '#') {\r\n    if (len === 4 || len === 5) {\r\n      ret = {\r\n        r: 255 & map$1[str[1]] * 17,\r\n        g: 255 & map$1[str[2]] * 17,\r\n        b: 255 & map$1[str[3]] * 17,\r\n        a: len === 5 ? map$1[str[4]] * 17 : 255\r\n      };\r\n    } else if (len === 7 || len === 9) {\r\n      ret = {\r\n        r: map$1[str[1]] << 4 | map$1[str[2]],\r\n        g: map$1[str[3]] << 4 | map$1[str[4]],\r\n        b: map$1[str[5]] << 4 | map$1[str[6]],\r\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\r\n      };\r\n    }\r\n  }\r\n  return ret;\r\n}\r\nconst alpha = (a, f) => a < 255 ? f(a) : '';\r\nfunction hexString(v) {\r\n  var f = isShort(v) ? h1 : h2;\r\n  return v\r\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\r\n    : undefined;\r\n}\r\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\nfunction hsl2rgbn(h, s, l) {\r\n  const a = s * Math.min(l, 1 - l);\r\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\r\n  return [f(0), f(8), f(4)];\r\n}\r\nfunction hsv2rgbn(h, s, v) {\r\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\r\n  return [f(5), f(3), f(1)];\r\n}\r\nfunction hwb2rgbn(h, w, b) {\r\n  const rgb = hsl2rgbn(h, 1, 0.5);\r\n  let i;\r\n  if (w + b > 1) {\r\n    i = 1 / (w + b);\r\n    w *= i;\r\n    b *= i;\r\n  }\r\n  for (i = 0; i < 3; i++) {\r\n    rgb[i] *= 1 - w - b;\r\n    rgb[i] += w;\r\n  }\r\n  return rgb;\r\n}\r\nfunction hueValue(r, g, b, d, max) {\r\n  if (r === max) {\r\n    return ((g - b) / d) + (g < b ? 6 : 0);\r\n  }\r\n  if (g === max) {\r\n    return (b - r) / d + 2;\r\n  }\r\n  return (r - g) / d + 4;\r\n}\r\nfunction rgb2hsl(v) {\r\n  const range = 255;\r\n  const r = v.r / range;\r\n  const g = v.g / range;\r\n  const b = v.b / range;\r\n  const max = Math.max(r, g, b);\r\n  const min = Math.min(r, g, b);\r\n  const l = (max + min) / 2;\r\n  let h, s, d;\r\n  if (max !== min) {\r\n    d = max - min;\r\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n    h = hueValue(r, g, b, d, max);\r\n    h = h * 60 + 0.5;\r\n  }\r\n  return [h | 0, s || 0, l];\r\n}\r\nfunction calln(f, a, b, c) {\r\n  return (\r\n    Array.isArray(a)\r\n      ? f(a[0], a[1], a[2])\r\n      : f(a, b, c)\r\n  ).map(n2b);\r\n}\r\nfunction hsl2rgb(h, s, l) {\r\n  return calln(hsl2rgbn, h, s, l);\r\n}\r\nfunction hwb2rgb(h, w, b) {\r\n  return calln(hwb2rgbn, h, w, b);\r\n}\r\nfunction hsv2rgb(h, s, v) {\r\n  return calln(hsv2rgbn, h, s, v);\r\n}\r\nfunction hue(h) {\r\n  return (h % 360 + 360) % 360;\r\n}\r\nfunction hueParse(str) {\r\n  const m = HUE_RE.exec(str);\r\n  let a = 255;\r\n  let v;\r\n  if (!m) {\r\n    return;\r\n  }\r\n  if (m[5] !== v) {\r\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\r\n  }\r\n  const h = hue(+m[2]);\r\n  const p1 = +m[3] / 100;\r\n  const p2 = +m[4] / 100;\r\n  if (m[1] === 'hwb') {\r\n    v = hwb2rgb(h, p1, p2);\r\n  } else if (m[1] === 'hsv') {\r\n    v = hsv2rgb(h, p1, p2);\r\n  } else {\r\n    v = hsl2rgb(h, p1, p2);\r\n  }\r\n  return {\r\n    r: v[0],\r\n    g: v[1],\r\n    b: v[2],\r\n    a: a\r\n  };\r\n}\r\nfunction rotate(v, deg) {\r\n  var h = rgb2hsl(v);\r\n  h[0] = hue(h[0] + deg);\r\n  h = hsl2rgb(h);\r\n  v.r = h[0];\r\n  v.g = h[1];\r\n  v.b = h[2];\r\n}\r\nfunction hslString(v) {\r\n  if (!v) {\r\n    return;\r\n  }\r\n  const a = rgb2hsl(v);\r\n  const h = a[0];\r\n  const s = n2p(a[1]);\r\n  const l = n2p(a[2]);\r\n  return v.a < 255\r\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\r\n    : `hsl(${h}, ${s}%, ${l}%)`;\r\n}\r\nconst map$2 = {\r\n  x: 'dark',\r\n  Z: 'light',\r\n  Y: 're',\r\n  X: 'blu',\r\n  W: 'gr',\r\n  V: 'medium',\r\n  U: 'slate',\r\n  A: 'ee',\r\n  T: 'ol',\r\n  S: 'or',\r\n  B: 'ra',\r\n  C: 'lateg',\r\n  D: 'ights',\r\n  R: 'in',\r\n  Q: 'turquois',\r\n  E: 'hi',\r\n  P: 'ro',\r\n  O: 'al',\r\n  N: 'le',\r\n  M: 'de',\r\n  L: 'yello',\r\n  F: 'en',\r\n  K: 'ch',\r\n  G: 'arks',\r\n  H: 'ea',\r\n  I: 'ightg',\r\n  J: 'wh'\r\n};\r\nconst names$1 = {\r\n  OiceXe: 'f0f8ff',\r\n  antiquewEte: 'faebd7',\r\n  aqua: 'ffff',\r\n  aquamarRe: '7fffd4',\r\n  azuY: 'f0ffff',\r\n  beige: 'f5f5dc',\r\n  bisque: 'ffe4c4',\r\n  black: '0',\r\n  blanKedOmond: 'ffebcd',\r\n  Xe: 'ff',\r\n  XeviTet: '8a2be2',\r\n  bPwn: 'a52a2a',\r\n  burlywood: 'deb887',\r\n  caMtXe: '5f9ea0',\r\n  KartYuse: '7fff00',\r\n  KocTate: 'd2691e',\r\n  cSO: 'ff7f50',\r\n  cSnflowerXe: '6495ed',\r\n  cSnsilk: 'fff8dc',\r\n  crimson: 'dc143c',\r\n  cyan: 'ffff',\r\n  xXe: '8b',\r\n  xcyan: '8b8b',\r\n  xgTMnPd: 'b8860b',\r\n  xWay: 'a9a9a9',\r\n  xgYF: '6400',\r\n  xgYy: 'a9a9a9',\r\n  xkhaki: 'bdb76b',\r\n  xmagFta: '8b008b',\r\n  xTivegYF: '556b2f',\r\n  xSange: 'ff8c00',\r\n  xScEd: '9932cc',\r\n  xYd: '8b0000',\r\n  xsOmon: 'e9967a',\r\n  xsHgYF: '8fbc8f',\r\n  xUXe: '483d8b',\r\n  xUWay: '2f4f4f',\r\n  xUgYy: '2f4f4f',\r\n  xQe: 'ced1',\r\n  xviTet: '9400d3',\r\n  dAppRk: 'ff1493',\r\n  dApskyXe: 'bfff',\r\n  dimWay: '696969',\r\n  dimgYy: '696969',\r\n  dodgerXe: '1e90ff',\r\n  fiYbrick: 'b22222',\r\n  flSOwEte: 'fffaf0',\r\n  foYstWAn: '228b22',\r\n  fuKsia: 'ff00ff',\r\n  gaRsbSo: 'dcdcdc',\r\n  ghostwEte: 'f8f8ff',\r\n  gTd: 'ffd700',\r\n  gTMnPd: 'daa520',\r\n  Way: '808080',\r\n  gYF: '8000',\r\n  gYFLw: 'adff2f',\r\n  gYy: '808080',\r\n  honeyMw: 'f0fff0',\r\n  hotpRk: 'ff69b4',\r\n  RdianYd: 'cd5c5c',\r\n  Rdigo: '4b0082',\r\n  ivSy: 'fffff0',\r\n  khaki: 'f0e68c',\r\n  lavFMr: 'e6e6fa',\r\n  lavFMrXsh: 'fff0f5',\r\n  lawngYF: '7cfc00',\r\n  NmoncEffon: 'fffacd',\r\n  ZXe: 'add8e6',\r\n  ZcSO: 'f08080',\r\n  Zcyan: 'e0ffff',\r\n  ZgTMnPdLw: 'fafad2',\r\n  ZWay: 'd3d3d3',\r\n  ZgYF: '90ee90',\r\n  ZgYy: 'd3d3d3',\r\n  ZpRk: 'ffb6c1',\r\n  ZsOmon: 'ffa07a',\r\n  ZsHgYF: '20b2aa',\r\n  ZskyXe: '87cefa',\r\n  ZUWay: '778899',\r\n  ZUgYy: '778899',\r\n  ZstAlXe: 'b0c4de',\r\n  ZLw: 'ffffe0',\r\n  lime: 'ff00',\r\n  limegYF: '32cd32',\r\n  lRF: 'faf0e6',\r\n  magFta: 'ff00ff',\r\n  maPon: '800000',\r\n  VaquamarRe: '66cdaa',\r\n  VXe: 'cd',\r\n  VScEd: 'ba55d3',\r\n  VpurpN: '9370db',\r\n  VsHgYF: '3cb371',\r\n  VUXe: '7b68ee',\r\n  VsprRggYF: 'fa9a',\r\n  VQe: '48d1cc',\r\n  VviTetYd: 'c71585',\r\n  midnightXe: '191970',\r\n  mRtcYam: 'f5fffa',\r\n  mistyPse: 'ffe4e1',\r\n  moccasR: 'ffe4b5',\r\n  navajowEte: 'ffdead',\r\n  navy: '80',\r\n  Tdlace: 'fdf5e6',\r\n  Tive: '808000',\r\n  TivedBb: '6b8e23',\r\n  Sange: 'ffa500',\r\n  SangeYd: 'ff4500',\r\n  ScEd: 'da70d6',\r\n  pOegTMnPd: 'eee8aa',\r\n  pOegYF: '98fb98',\r\n  pOeQe: 'afeeee',\r\n  pOeviTetYd: 'db7093',\r\n  papayawEp: 'ffefd5',\r\n  pHKpuff: 'ffdab9',\r\n  peru: 'cd853f',\r\n  pRk: 'ffc0cb',\r\n  plum: 'dda0dd',\r\n  powMrXe: 'b0e0e6',\r\n  purpN: '800080',\r\n  YbeccapurpN: '663399',\r\n  Yd: 'ff0000',\r\n  Psybrown: 'bc8f8f',\r\n  PyOXe: '4169e1',\r\n  saddNbPwn: '8b4513',\r\n  sOmon: 'fa8072',\r\n  sandybPwn: 'f4a460',\r\n  sHgYF: '2e8b57',\r\n  sHshell: 'fff5ee',\r\n  siFna: 'a0522d',\r\n  silver: 'c0c0c0',\r\n  skyXe: '87ceeb',\r\n  UXe: '6a5acd',\r\n  UWay: '708090',\r\n  UgYy: '708090',\r\n  snow: 'fffafa',\r\n  sprRggYF: 'ff7f',\r\n  stAlXe: '4682b4',\r\n  tan: 'd2b48c',\r\n  teO: '8080',\r\n  tEstN: 'd8bfd8',\r\n  tomato: 'ff6347',\r\n  Qe: '40e0d0',\r\n  viTet: 'ee82ee',\r\n  JHt: 'f5deb3',\r\n  wEte: 'ffffff',\r\n  wEtesmoke: 'f5f5f5',\r\n  Lw: 'ffff00',\r\n  LwgYF: '9acd32'\r\n};\r\nfunction unpack() {\r\n  const unpacked = {};\r\n  const keys = Object.keys(names$1);\r\n  const tkeys = Object.keys(map$2);\r\n  let i, j, k, ok, nk;\r\n  for (i = 0; i < keys.length; i++) {\r\n    ok = nk = keys[i];\r\n    for (j = 0; j < tkeys.length; j++) {\r\n      k = tkeys[j];\r\n      nk = nk.replace(k, map$2[k]);\r\n    }\r\n    k = parseInt(names$1[ok], 16);\r\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\r\n  }\r\n  return unpacked;\r\n}\r\nlet names;\r\nfunction nameParse(str) {\r\n  if (!names) {\r\n    names = unpack();\r\n    names.transparent = [0, 0, 0, 0];\r\n  }\r\n  const a = names[str.toLowerCase()];\r\n  return a && {\r\n    r: a[0],\r\n    g: a[1],\r\n    b: a[2],\r\n    a: a.length === 4 ? a[3] : 255\r\n  };\r\n}\r\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\nfunction rgbParse(str) {\r\n  const m = RGB_RE.exec(str);\r\n  let a = 255;\r\n  let r, g, b;\r\n  if (!m) {\r\n    return;\r\n  }\r\n  if (m[7] !== r) {\r\n    const v = +m[7];\r\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\r\n  }\r\n  r = +m[1];\r\n  g = +m[3];\r\n  b = +m[5];\r\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\r\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\r\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\r\n  return {\r\n    r: r,\r\n    g: g,\r\n    b: b,\r\n    a: a\r\n  };\r\n}\r\nfunction rgbString(v) {\r\n  return v && (\r\n    v.a < 255\r\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\r\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\r\n  );\r\n}\r\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\r\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\r\nfunction interpolate$1(rgb1, rgb2, t) {\r\n  const r = from(b2n(rgb1.r));\r\n  const g = from(b2n(rgb1.g));\r\n  const b = from(b2n(rgb1.b));\r\n  return {\r\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\r\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\r\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\r\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\r\n  };\r\n}\r\nfunction modHSL(v, i, ratio) {\r\n  if (v) {\r\n    let tmp = rgb2hsl(v);\r\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\r\n    tmp = hsl2rgb(tmp);\r\n    v.r = tmp[0];\r\n    v.g = tmp[1];\r\n    v.b = tmp[2];\r\n  }\r\n}\r\nfunction clone(v, proto) {\r\n  return v ? Object.assign(proto || {}, v) : v;\r\n}\r\nfunction fromObject(input) {\r\n  var v = {r: 0, g: 0, b: 0, a: 255};\r\n  if (Array.isArray(input)) {\r\n    if (input.length >= 3) {\r\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\r\n      if (input.length > 3) {\r\n        v.a = n2b(input[3]);\r\n      }\r\n    }\r\n  } else {\r\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\r\n    v.a = n2b(v.a);\r\n  }\r\n  return v;\r\n}\r\nfunction functionParse(str) {\r\n  if (str.charAt(0) === 'r') {\r\n    return rgbParse(str);\r\n  }\r\n  return hueParse(str);\r\n}\r\nclass Color {\r\n  constructor(input) {\r\n    if (input instanceof Color) {\r\n      return input;\r\n    }\r\n    const type = typeof input;\r\n    let v;\r\n    if (type === 'object') {\r\n      v = fromObject(input);\r\n    } else if (type === 'string') {\r\n      v = hexParse(input) || nameParse(input) || functionParse(input);\r\n    }\r\n    this._rgb = v;\r\n    this._valid = !!v;\r\n  }\r\n  get valid() {\r\n    return this._valid;\r\n  }\r\n  get rgb() {\r\n    var v = clone(this._rgb);\r\n    if (v) {\r\n      v.a = b2n(v.a);\r\n    }\r\n    return v;\r\n  }\r\n  set rgb(obj) {\r\n    this._rgb = fromObject(obj);\r\n  }\r\n  rgbString() {\r\n    return this._valid ? rgbString(this._rgb) : undefined;\r\n  }\r\n  hexString() {\r\n    return this._valid ? hexString(this._rgb) : undefined;\r\n  }\r\n  hslString() {\r\n    return this._valid ? hslString(this._rgb) : undefined;\r\n  }\r\n  mix(color, weight) {\r\n    if (color) {\r\n      const c1 = this.rgb;\r\n      const c2 = color.rgb;\r\n      let w2;\r\n      const p = weight === w2 ? 0.5 : weight;\r\n      const w = 2 * p - 1;\r\n      const a = c1.a - c2.a;\r\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n      w2 = 1 - w1;\r\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\r\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\r\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\r\n      c1.a = p * c1.a + (1 - p) * c2.a;\r\n      this.rgb = c1;\r\n    }\r\n    return this;\r\n  }\r\n  interpolate(color, t) {\r\n    if (color) {\r\n      this._rgb = interpolate$1(this._rgb, color._rgb, t);\r\n    }\r\n    return this;\r\n  }\r\n  clone() {\r\n    return new Color(this.rgb);\r\n  }\r\n  alpha(a) {\r\n    this._rgb.a = n2b(a);\r\n    return this;\r\n  }\r\n  clearer(ratio) {\r\n    const rgb = this._rgb;\r\n    rgb.a *= 1 - ratio;\r\n    return this;\r\n  }\r\n  greyscale() {\r\n    const rgb = this._rgb;\r\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\r\n    rgb.r = rgb.g = rgb.b = val;\r\n    return this;\r\n  }\r\n  opaquer(ratio) {\r\n    const rgb = this._rgb;\r\n    rgb.a *= 1 + ratio;\r\n    return this;\r\n  }\r\n  negate() {\r\n    const v = this._rgb;\r\n    v.r = 255 - v.r;\r\n    v.g = 255 - v.g;\r\n    v.b = 255 - v.b;\r\n    return this;\r\n  }\r\n  lighten(ratio) {\r\n    modHSL(this._rgb, 2, ratio);\r\n    return this;\r\n  }\r\n  darken(ratio) {\r\n    modHSL(this._rgb, 2, -ratio);\r\n    return this;\r\n  }\r\n  saturate(ratio) {\r\n    modHSL(this._rgb, 1, ratio);\r\n    return this;\r\n  }\r\n  desaturate(ratio) {\r\n    modHSL(this._rgb, 1, -ratio);\r\n    return this;\r\n  }\r\n  rotate(deg) {\r\n    rotate(this._rgb, deg);\r\n    return this;\r\n  }\r\n}\r\n\r\nfunction isPatternOrGradient(value) {\r\n    if (value && typeof value === 'object') {\r\n        const type = value.toString();\r\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\r\n    }\r\n    return false;\r\n}\r\nfunction color(value) {\r\n    return isPatternOrGradient(value) ? value : new Color(value);\r\n}\r\nfunction getHoverColor(value) {\r\n    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\r\n}\r\n\r\nconst numbers = [\r\n    'x',\r\n    'y',\r\n    'borderWidth',\r\n    'radius',\r\n    'tension'\r\n];\r\nconst colors = [\r\n    'color',\r\n    'borderColor',\r\n    'backgroundColor'\r\n];\r\nfunction applyAnimationsDefaults(defaults) {\r\n    defaults.set('animation', {\r\n        delay: undefined,\r\n        duration: 1000,\r\n        easing: 'easeOutQuart',\r\n        fn: undefined,\r\n        from: undefined,\r\n        loop: undefined,\r\n        to: undefined,\r\n        type: undefined\r\n    });\r\n    defaults.describe('animation', {\r\n        _fallback: false,\r\n        _indexable: false,\r\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\r\n    });\r\n    defaults.set('animations', {\r\n        colors: {\r\n            type: 'color',\r\n            properties: colors\r\n        },\r\n        numbers: {\r\n            type: 'number',\r\n            properties: numbers\r\n        }\r\n    });\r\n    defaults.describe('animations', {\r\n        _fallback: 'animation'\r\n    });\r\n    defaults.set('transitions', {\r\n        active: {\r\n            animation: {\r\n                duration: 400\r\n            }\r\n        },\r\n        resize: {\r\n            animation: {\r\n                duration: 0\r\n            }\r\n        },\r\n        show: {\r\n            animations: {\r\n                colors: {\r\n                    from: 'transparent'\r\n                },\r\n                visible: {\r\n                    type: 'boolean',\r\n                    duration: 0\r\n                }\r\n            }\r\n        },\r\n        hide: {\r\n            animations: {\r\n                colors: {\r\n                    to: 'transparent'\r\n                },\r\n                visible: {\r\n                    type: 'boolean',\r\n                    easing: 'linear',\r\n                    fn: (v)=>v | 0\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction applyLayoutsDefaults(defaults) {\r\n    defaults.set('layout', {\r\n        autoPadding: true,\r\n        padding: {\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0,\r\n            left: 0\r\n        }\r\n    });\r\n}\r\n\r\nconst intlCache = new Map();\r\nfunction getNumberFormat(locale, options) {\r\n    options = options || {};\r\n    const cacheKey = locale + JSON.stringify(options);\r\n    let formatter = intlCache.get(cacheKey);\r\n    if (!formatter) {\r\n        formatter = new Intl.NumberFormat(locale, options);\r\n        intlCache.set(cacheKey, formatter);\r\n    }\r\n    return formatter;\r\n}\r\nfunction formatNumber(num, locale, options) {\r\n    return getNumberFormat(locale, options).format(num);\r\n}\r\n\r\nconst formatters = {\r\n values (value) {\r\n        return isArray(value) ?  value : '' + value;\r\n    },\r\n numeric (tickValue, index, ticks) {\r\n        if (tickValue === 0) {\r\n            return '0';\r\n        }\r\n        const locale = this.chart.options.locale;\r\n        let notation;\r\n        let delta = tickValue;\r\n        if (ticks.length > 1) {\r\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\r\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\r\n                notation = 'scientific';\r\n            }\r\n            delta = calculateDelta(tickValue, ticks);\r\n        }\r\n        const logDelta = log10(Math.abs(delta));\r\n        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\r\n        const options = {\r\n            notation,\r\n            minimumFractionDigits: numDecimal,\r\n            maximumFractionDigits: numDecimal\r\n        };\r\n        Object.assign(options, this.options.ticks.format);\r\n        return formatNumber(tickValue, locale, options);\r\n    },\r\n logarithmic (tickValue, index, ticks) {\r\n        if (tickValue === 0) {\r\n            return '0';\r\n        }\r\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\r\n        if ([\r\n            1,\r\n            2,\r\n            3,\r\n            5,\r\n            10,\r\n            15\r\n        ].includes(remain) || index > 0.8 * ticks.length) {\r\n            return formatters.numeric.call(this, tickValue, index, ticks);\r\n        }\r\n        return '';\r\n    }\r\n};\r\nfunction calculateDelta(tickValue, ticks) {\r\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\r\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\r\n        delta = tickValue - Math.floor(tickValue);\r\n    }\r\n    return delta;\r\n}\r\n var Ticks = {\r\n    formatters\r\n};\r\n\r\nfunction applyScaleDefaults(defaults) {\r\n    defaults.set('scale', {\r\n        display: true,\r\n        offset: false,\r\n        reverse: false,\r\n        beginAtZero: false,\r\n bounds: 'ticks',\r\n grace: 0,\r\n        grid: {\r\n            display: true,\r\n            lineWidth: 1,\r\n            drawOnChartArea: true,\r\n            drawTicks: true,\r\n            tickLength: 8,\r\n            tickWidth: (_ctx, options)=>options.lineWidth,\r\n            tickColor: (_ctx, options)=>options.color,\r\n            offset: false\r\n        },\r\n        border: {\r\n            display: true,\r\n            dash: [],\r\n            dashOffset: 0.0,\r\n            width: 1\r\n        },\r\n        title: {\r\n            display: false,\r\n            text: '',\r\n            padding: {\r\n                top: 4,\r\n                bottom: 4\r\n            }\r\n        },\r\n        ticks: {\r\n            minRotation: 0,\r\n            maxRotation: 50,\r\n            mirror: false,\r\n            textStrokeWidth: 0,\r\n            textStrokeColor: '',\r\n            padding: 3,\r\n            display: true,\r\n            autoSkip: true,\r\n            autoSkipPadding: 3,\r\n            labelOffset: 0,\r\n            callback: Ticks.formatters.values,\r\n            minor: {},\r\n            major: {},\r\n            align: 'center',\r\n            crossAlign: 'near',\r\n            showLabelBackdrop: false,\r\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\r\n            backdropPadding: 2\r\n        }\r\n    });\r\n    defaults.route('scale.ticks', 'color', '', 'color');\r\n    defaults.route('scale.grid', 'color', '', 'borderColor');\r\n    defaults.route('scale.border', 'color', '', 'borderColor');\r\n    defaults.route('scale.title', 'color', '', 'color');\r\n    defaults.describe('scale', {\r\n        _fallback: false,\r\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\r\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\r\n    });\r\n    defaults.describe('scales', {\r\n        _fallback: 'scale'\r\n    });\r\n    defaults.describe('scale.ticks', {\r\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\r\n        _indexable: (name)=>name !== 'backdropPadding'\r\n    });\r\n}\r\n\r\nconst overrides = Object.create(null);\r\nconst descriptors = Object.create(null);\r\n function getScope$1(node, key) {\r\n    if (!key) {\r\n        return node;\r\n    }\r\n    const keys = key.split('.');\r\n    for(let i = 0, n = keys.length; i < n; ++i){\r\n        const k = keys[i];\r\n        node = node[k] || (node[k] = Object.create(null));\r\n    }\r\n    return node;\r\n}\r\nfunction set(root, scope, values) {\r\n    if (typeof scope === 'string') {\r\n        return merge(getScope$1(root, scope), values);\r\n    }\r\n    return merge(getScope$1(root, ''), scope);\r\n}\r\n class Defaults {\r\n    constructor(_descriptors, _appliers){\r\n        this.animation = undefined;\r\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\r\n        this.borderColor = 'rgba(0,0,0,0.1)';\r\n        this.color = '#666';\r\n        this.datasets = {};\r\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\r\n        this.elements = {};\r\n        this.events = [\r\n            'mousemove',\r\n            'mouseout',\r\n            'click',\r\n            'touchstart',\r\n            'touchmove'\r\n        ];\r\n        this.font = {\r\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n            size: 12,\r\n            style: 'normal',\r\n            lineHeight: 1.2,\r\n            weight: null\r\n        };\r\n        this.hover = {};\r\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\r\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\r\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\r\n        this.indexAxis = 'x';\r\n        this.interaction = {\r\n            mode: 'nearest',\r\n            intersect: true,\r\n            includeInvisible: false\r\n        };\r\n        this.maintainAspectRatio = true;\r\n        this.onHover = null;\r\n        this.onClick = null;\r\n        this.parsing = true;\r\n        this.plugins = {};\r\n        this.responsive = true;\r\n        this.scale = undefined;\r\n        this.scales = {};\r\n        this.showLine = true;\r\n        this.drawActiveElementsOnTop = true;\r\n        this.describe(_descriptors);\r\n        this.apply(_appliers);\r\n    }\r\n set(scope, values) {\r\n        return set(this, scope, values);\r\n    }\r\n get(scope) {\r\n        return getScope$1(this, scope);\r\n    }\r\n describe(scope, values) {\r\n        return set(descriptors, scope, values);\r\n    }\r\n    override(scope, values) {\r\n        return set(overrides, scope, values);\r\n    }\r\n route(scope, name, targetScope, targetName) {\r\n        const scopeObject = getScope$1(this, scope);\r\n        const targetScopeObject = getScope$1(this, targetScope);\r\n        const privateName = '_' + name;\r\n        Object.defineProperties(scopeObject, {\r\n            [privateName]: {\r\n                value: scopeObject[name],\r\n                writable: true\r\n            },\r\n            [name]: {\r\n                enumerable: true,\r\n                get () {\r\n                    const local = this[privateName];\r\n                    const target = targetScopeObject[targetName];\r\n                    if (isObject(local)) {\r\n                        return Object.assign({}, target, local);\r\n                    }\r\n                    return valueOrDefault(local, target);\r\n                },\r\n                set (value) {\r\n                    this[privateName] = value;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    apply(appliers) {\r\n        appliers.forEach((apply)=>apply(this));\r\n    }\r\n}\r\nvar defaults = /* #__PURE__ */ new Defaults({\r\n    _scriptable: (name)=>!name.startsWith('on'),\r\n    _indexable: (name)=>name !== 'events',\r\n    hover: {\r\n        _fallback: 'interaction'\r\n    },\r\n    interaction: {\r\n        _scriptable: false,\r\n        _indexable: false\r\n    }\r\n}, [\r\n    applyAnimationsDefaults,\r\n    applyLayoutsDefaults,\r\n    applyScaleDefaults\r\n]);\r\n\r\n/**\r\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\r\n * necessary to avoid duplicates with `export * from './helpers`; see\r\n * https://github.com/microsoft/TypeScript/issues/46011\r\n * @typedef { import('../core/core.controller.js').default } dom.Chart\r\n * @typedef { import('../../types').ChartEvent } ChartEvent\r\n */ /**\r\n * @private\r\n */ function _isDomSupported() {\r\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\r\n}\r\n/**\r\n * @private\r\n */ function _getParentNode(domNode) {\r\n    let parent = domNode.parentNode;\r\n    if (parent && parent.toString() === '[object ShadowRoot]') {\r\n        parent = parent.host;\r\n    }\r\n    return parent;\r\n}\r\n/**\r\n * convert max-width/max-height values that may be percentages into a number\r\n * @private\r\n */ function parseMaxStyle(styleValue, node, parentProperty) {\r\n    let valueInPixels;\r\n    if (typeof styleValue === 'string') {\r\n        valueInPixels = parseInt(styleValue, 10);\r\n        if (styleValue.indexOf('%') !== -1) {\r\n            // percentage * size in dimension\r\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\r\n        }\r\n    } else {\r\n        valueInPixels = styleValue;\r\n    }\r\n    return valueInPixels;\r\n}\r\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\r\nfunction getStyle(el, property) {\r\n    return getComputedStyle(el).getPropertyValue(property);\r\n}\r\nconst positions = [\r\n    'top',\r\n    'right',\r\n    'bottom',\r\n    'left'\r\n];\r\nfunction getPositionedStyle(styles, style, suffix) {\r\n    const result = {};\r\n    suffix = suffix ? '-' + suffix : '';\r\n    for(let i = 0; i < 4; i++){\r\n        const pos = positions[i];\r\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\r\n    }\r\n    result.width = result.left + result.right;\r\n    result.height = result.top + result.bottom;\r\n    return result;\r\n}\r\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\r\n/**\r\n * @param e\r\n * @param canvas\r\n * @returns Canvas position\r\n */ function getCanvasPosition(e, canvas) {\r\n    const touches = e.touches;\r\n    const source = touches && touches.length ? touches[0] : e;\r\n    const { offsetX , offsetY  } = source;\r\n    let box = false;\r\n    let x, y;\r\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\r\n        x = offsetX;\r\n        y = offsetY;\r\n    } else {\r\n        const rect = canvas.getBoundingClientRect();\r\n        x = source.clientX - rect.left;\r\n        y = source.clientY - rect.top;\r\n        box = true;\r\n    }\r\n    return {\r\n        x,\r\n        y,\r\n        box\r\n    };\r\n}\r\n/**\r\n * Gets an event's x, y coordinates, relative to the chart area\r\n * @param event\r\n * @param chart\r\n * @returns x and y coordinates of the event\r\n */ function getRelativePosition(event, chart) {\r\n    if ('native' in event) {\r\n        return event;\r\n    }\r\n    const { canvas , currentDevicePixelRatio  } = chart;\r\n    const style = getComputedStyle(canvas);\r\n    const borderBox = style.boxSizing === 'border-box';\r\n    const paddings = getPositionedStyle(style, 'padding');\r\n    const borders = getPositionedStyle(style, 'border', 'width');\r\n    const { x , y , box  } = getCanvasPosition(event, canvas);\r\n    const xOffset = paddings.left + (box && borders.left);\r\n    const yOffset = paddings.top + (box && borders.top);\r\n    let { width , height  } = chart;\r\n    if (borderBox) {\r\n        width -= paddings.width + borders.width;\r\n        height -= paddings.height + borders.height;\r\n    }\r\n    return {\r\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\r\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\r\n    };\r\n}\r\nfunction getContainerSize(canvas, width, height) {\r\n    let maxWidth, maxHeight;\r\n    if (width === undefined || height === undefined) {\r\n        const container = _getParentNode(canvas);\r\n        if (!container) {\r\n            width = canvas.clientWidth;\r\n            height = canvas.clientHeight;\r\n        } else {\r\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\r\n            const containerStyle = getComputedStyle(container);\r\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\r\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\r\n            width = rect.width - containerPadding.width - containerBorder.width;\r\n            height = rect.height - containerPadding.height - containerBorder.height;\r\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\r\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\r\n        }\r\n    }\r\n    return {\r\n        width,\r\n        height,\r\n        maxWidth: maxWidth || INFINITY,\r\n        maxHeight: maxHeight || INFINITY\r\n    };\r\n}\r\nconst round1 = (v)=>Math.round(v * 10) / 10;\r\n// eslint-disable-next-line complexity\r\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\r\n    const style = getComputedStyle(canvas);\r\n    const margins = getPositionedStyle(style, 'margin');\r\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\r\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\r\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\r\n    let { width , height  } = containerSize;\r\n    if (style.boxSizing === 'content-box') {\r\n        const borders = getPositionedStyle(style, 'border', 'width');\r\n        const paddings = getPositionedStyle(style, 'padding');\r\n        width -= paddings.width + borders.width;\r\n        height -= paddings.height + borders.height;\r\n    }\r\n    width = Math.max(0, width - margins.width);\r\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\r\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\r\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\r\n    if (width && !height) {\r\n        // https://github.com/chartjs/Chart.js/issues/4659\r\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\r\n        height = round1(width / 2);\r\n    }\r\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\r\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\r\n        height = containerSize.height;\r\n        width = round1(Math.floor(height * aspectRatio));\r\n    }\r\n    return {\r\n        width,\r\n        height\r\n    };\r\n}\r\n/**\r\n * @param chart\r\n * @param forceRatio\r\n * @param forceStyle\r\n * @returns True if the canvas context size or transformation has changed.\r\n */ function retinaScale(chart, forceRatio, forceStyle) {\r\n    const pixelRatio = forceRatio || 1;\r\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\r\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\r\n    chart.height = Math.floor(chart.height);\r\n    chart.width = Math.floor(chart.width);\r\n    const canvas = chart.canvas;\r\n    // If no style has been set on the canvas, the render size is used as display size,\r\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\r\n    // See https://github.com/chartjs/Chart.js/issues/3575\r\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\r\n        canvas.style.height = `${chart.height}px`;\r\n        canvas.style.width = `${chart.width}px`;\r\n    }\r\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\r\n        chart.currentDevicePixelRatio = pixelRatio;\r\n        canvas.height = deviceHeight;\r\n        canvas.width = deviceWidth;\r\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Detects support for options object argument in addEventListener.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n * @private\r\n */ const supportsEventListenerOptions = function() {\r\n    let passiveSupported = false;\r\n    try {\r\n        const options = {\r\n            get passive () {\r\n                passiveSupported = true;\r\n                return false;\r\n            }\r\n        };\r\n        window.addEventListener('test', null, options);\r\n        window.removeEventListener('test', null, options);\r\n    } catch (e) {\r\n    // continue regardless of error\r\n    }\r\n    return passiveSupported;\r\n}();\r\n/**\r\n * The \"used\" size is the final value of a dimension property after all calculations have\r\n * been performed. This method uses the computed style of `element` but returns undefined\r\n * if the computed style is not expressed in pixels. That can happen in some cases where\r\n * `element` has a size relative to its parent and this last one is not yet displayed,\r\n * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n * @returns Size in pixels or undefined if unknown.\r\n */ function readUsedSize(element, property) {\r\n    const value = getStyle(element, property);\r\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n    return matches ? +matches[1] : undefined;\r\n}\r\n\r\nfunction toFontString(font) {\r\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\r\n        return null;\r\n    }\r\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\r\n}\r\n function _measureText(ctx, data, gc, longest, string) {\r\n    let textWidth = data[string];\r\n    if (!textWidth) {\r\n        textWidth = data[string] = ctx.measureText(string).width;\r\n        gc.push(string);\r\n    }\r\n    if (textWidth > longest) {\r\n        longest = textWidth;\r\n    }\r\n    return longest;\r\n}\r\n function _longestText(ctx, font, arrayOfThings, cache) {\r\n    cache = cache || {};\r\n    let data = cache.data = cache.data || {};\r\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\r\n    if (cache.font !== font) {\r\n        data = cache.data = {};\r\n        gc = cache.garbageCollect = [];\r\n        cache.font = font;\r\n    }\r\n    ctx.save();\r\n    ctx.font = font;\r\n    let longest = 0;\r\n    const ilen = arrayOfThings.length;\r\n    let i, j, jlen, thing, nestedThing;\r\n    for(i = 0; i < ilen; i++){\r\n        thing = arrayOfThings[i];\r\n        if (thing !== undefined && thing !== null && isArray(thing) !== true) {\r\n            longest = _measureText(ctx, data, gc, longest, thing);\r\n        } else if (isArray(thing)) {\r\n            for(j = 0, jlen = thing.length; j < jlen; j++){\r\n                nestedThing = thing[j];\r\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\r\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ctx.restore();\r\n    const gcLen = gc.length / 2;\r\n    if (gcLen > arrayOfThings.length) {\r\n        for(i = 0; i < gcLen; i++){\r\n            delete data[gc[i]];\r\n        }\r\n        gc.splice(0, gcLen);\r\n    }\r\n    return longest;\r\n}\r\n function _alignPixel(chart, pixel, width) {\r\n    const devicePixelRatio = chart.currentDevicePixelRatio;\r\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\r\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\r\n}\r\n function clearCanvas(canvas, ctx) {\r\n    ctx = ctx || canvas.getContext('2d');\r\n    ctx.save();\r\n    ctx.resetTransform();\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.restore();\r\n}\r\nfunction drawPoint(ctx, options, x, y) {\r\n    drawPointLegend(ctx, options, x, y, null);\r\n}\r\nfunction drawPointLegend(ctx, options, x, y, w) {\r\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\r\n    const style = options.pointStyle;\r\n    const rotation = options.rotation;\r\n    const radius = options.radius;\r\n    let rad = (rotation || 0) * RAD_PER_DEG;\r\n    if (style && typeof style === 'object') {\r\n        type = style.toString();\r\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n            ctx.save();\r\n            ctx.translate(x, y);\r\n            ctx.rotate(rad);\r\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n            ctx.restore();\r\n            return;\r\n        }\r\n    }\r\n    if (isNaN(radius) || radius <= 0) {\r\n        return;\r\n    }\r\n    ctx.beginPath();\r\n    switch(style){\r\n        default:\r\n            if (w) {\r\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\r\n            } else {\r\n                ctx.arc(x, y, radius, 0, TAU);\r\n            }\r\n            ctx.closePath();\r\n            break;\r\n        case 'triangle':\r\n            width = w ? w / 2 : radius;\r\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\r\n            rad += TWO_THIRDS_PI;\r\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\r\n            rad += TWO_THIRDS_PI;\r\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\r\n            ctx.closePath();\r\n            break;\r\n        case 'rectRounded':\r\n            cornerRadius = radius * 0.516;\r\n            size = radius - cornerRadius;\r\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\r\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\r\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n            ctx.closePath();\r\n            break;\r\n        case 'rect':\r\n            if (!rotation) {\r\n                size = Math.SQRT1_2 * radius;\r\n                width = w ? w / 2 : size;\r\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\r\n                break;\r\n            }\r\n            rad += QUARTER_PI;\r\n         case 'rectRot':\r\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n            xOffset = Math.cos(rad) * radius;\r\n            yOffset = Math.sin(rad) * radius;\r\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n            ctx.moveTo(x - xOffsetW, y - yOffset);\r\n            ctx.lineTo(x + yOffsetW, y - xOffset);\r\n            ctx.lineTo(x + xOffsetW, y + yOffset);\r\n            ctx.lineTo(x - yOffsetW, y + xOffset);\r\n            ctx.closePath();\r\n            break;\r\n        case 'crossRot':\r\n            rad += QUARTER_PI;\r\n         case 'cross':\r\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n            xOffset = Math.cos(rad) * radius;\r\n            yOffset = Math.sin(rad) * radius;\r\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n            ctx.moveTo(x - xOffsetW, y - yOffset);\r\n            ctx.lineTo(x + xOffsetW, y + yOffset);\r\n            ctx.moveTo(x + yOffsetW, y - xOffset);\r\n            ctx.lineTo(x - yOffsetW, y + xOffset);\r\n            break;\r\n        case 'star':\r\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n            xOffset = Math.cos(rad) * radius;\r\n            yOffset = Math.sin(rad) * radius;\r\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n            ctx.moveTo(x - xOffsetW, y - yOffset);\r\n            ctx.lineTo(x + xOffsetW, y + yOffset);\r\n            ctx.moveTo(x + yOffsetW, y - xOffset);\r\n            ctx.lineTo(x - yOffsetW, y + xOffset);\r\n            rad += QUARTER_PI;\r\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n            xOffset = Math.cos(rad) * radius;\r\n            yOffset = Math.sin(rad) * radius;\r\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n            ctx.moveTo(x - xOffsetW, y - yOffset);\r\n            ctx.lineTo(x + xOffsetW, y + yOffset);\r\n            ctx.moveTo(x + yOffsetW, y - xOffset);\r\n            ctx.lineTo(x - yOffsetW, y + xOffset);\r\n            break;\r\n        case 'line':\r\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\r\n            yOffset = Math.sin(rad) * radius;\r\n            ctx.moveTo(x - xOffset, y - yOffset);\r\n            ctx.lineTo(x + xOffset, y + yOffset);\r\n            break;\r\n        case 'dash':\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\r\n            break;\r\n        case false:\r\n            ctx.closePath();\r\n            break;\r\n    }\r\n    ctx.fill();\r\n    if (options.borderWidth > 0) {\r\n        ctx.stroke();\r\n    }\r\n}\r\n function _isPointInArea(point, area, margin) {\r\n    margin = margin || 0.5;\r\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\r\n}\r\nfunction clipArea(ctx, area) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n    ctx.clip();\r\n}\r\nfunction unclipArea(ctx) {\r\n    ctx.restore();\r\n}\r\n function _steppedLineTo(ctx, previous, target, flip, mode) {\r\n    if (!previous) {\r\n        return ctx.lineTo(target.x, target.y);\r\n    }\r\n    if (mode === 'middle') {\r\n        const midpoint = (previous.x + target.x) / 2.0;\r\n        ctx.lineTo(midpoint, previous.y);\r\n        ctx.lineTo(midpoint, target.y);\r\n    } else if (mode === 'after' !== !!flip) {\r\n        ctx.lineTo(previous.x, target.y);\r\n    } else {\r\n        ctx.lineTo(target.x, previous.y);\r\n    }\r\n    ctx.lineTo(target.x, target.y);\r\n}\r\n function _bezierCurveTo(ctx, previous, target, flip) {\r\n    if (!previous) {\r\n        return ctx.lineTo(target.x, target.y);\r\n    }\r\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\r\n}\r\n function renderText(ctx, text, x, y, font, opts = {}) {\r\n    const lines = isArray(text) ? text : [\r\n        text\r\n    ];\r\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\r\n    let i, line;\r\n    ctx.save();\r\n    ctx.font = font.string;\r\n    setRenderOpts(ctx, opts);\r\n    for(i = 0; i < lines.length; ++i){\r\n        line = lines[i];\r\n        if (opts.backdrop) {\r\n            drawBackdrop(ctx, opts.backdrop);\r\n        }\r\n        if (stroke) {\r\n            if (opts.strokeColor) {\r\n                ctx.strokeStyle = opts.strokeColor;\r\n            }\r\n            if (!isNullOrUndef(opts.strokeWidth)) {\r\n                ctx.lineWidth = opts.strokeWidth;\r\n            }\r\n            ctx.strokeText(line, x, y, opts.maxWidth);\r\n        }\r\n        ctx.fillText(line, x, y, opts.maxWidth);\r\n        decorateText(ctx, x, y, line, opts);\r\n        y += font.lineHeight;\r\n    }\r\n    ctx.restore();\r\n}\r\nfunction setRenderOpts(ctx, opts) {\r\n    if (opts.translation) {\r\n        ctx.translate(opts.translation[0], opts.translation[1]);\r\n    }\r\n    if (!isNullOrUndef(opts.rotation)) {\r\n        ctx.rotate(opts.rotation);\r\n    }\r\n    if (opts.color) {\r\n        ctx.fillStyle = opts.color;\r\n    }\r\n    if (opts.textAlign) {\r\n        ctx.textAlign = opts.textAlign;\r\n    }\r\n    if (opts.textBaseline) {\r\n        ctx.textBaseline = opts.textBaseline;\r\n    }\r\n}\r\nfunction decorateText(ctx, x, y, line, opts) {\r\n    if (opts.strikethrough || opts.underline) {\r\n const metrics = ctx.measureText(line);\r\n        const left = x - metrics.actualBoundingBoxLeft;\r\n        const right = x + metrics.actualBoundingBoxRight;\r\n        const top = y - metrics.actualBoundingBoxAscent;\r\n        const bottom = y + metrics.actualBoundingBoxDescent;\r\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\r\n        ctx.strokeStyle = ctx.fillStyle;\r\n        ctx.beginPath();\r\n        ctx.lineWidth = opts.decorationWidth || 2;\r\n        ctx.moveTo(left, yDecoration);\r\n        ctx.lineTo(right, yDecoration);\r\n        ctx.stroke();\r\n    }\r\n}\r\nfunction drawBackdrop(ctx, opts) {\r\n    const oldColor = ctx.fillStyle;\r\n    ctx.fillStyle = opts.color;\r\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\r\n    ctx.fillStyle = oldColor;\r\n}\r\n function addRoundedRectPath(ctx, rect) {\r\n    const { x , y , w , h , radius  } = rect;\r\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\r\n    ctx.lineTo(x, y + h - radius.bottomLeft);\r\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\r\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\r\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\r\n    ctx.lineTo(x + w, y + radius.topRight);\r\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\r\n    ctx.lineTo(x + radius.topLeft, y);\r\n}\r\n\r\nfunction _createResolver(scopes, prefixes = [\r\n    ''\r\n], rootScopes = scopes, fallback, getTarget = ()=>scopes[0]) {\r\n    if (!defined(fallback)) {\r\n        fallback = _resolve('_fallback', scopes);\r\n    }\r\n    const cache = {\r\n        [Symbol.toStringTag]: 'Object',\r\n        _cacheable: true,\r\n        _scopes: scopes,\r\n        _rootScopes: rootScopes,\r\n        _fallback: fallback,\r\n        _getTarget: getTarget,\r\n        override: (scope)=>_createResolver([\r\n                scope,\r\n                ...scopes\r\n            ], prefixes, rootScopes, fallback)\r\n    };\r\n    return new Proxy(cache, {\r\n deleteProperty (target, prop) {\r\n            delete target[prop];\r\n            delete target._keys;\r\n            delete scopes[0][prop];\r\n            return true;\r\n        },\r\n get (target, prop) {\r\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\r\n        },\r\n getOwnPropertyDescriptor (target, prop) {\r\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\r\n        },\r\n getPrototypeOf () {\r\n            return Reflect.getPrototypeOf(scopes[0]);\r\n        },\r\n has (target, prop) {\r\n            return getKeysFromAllScopes(target).includes(prop);\r\n        },\r\n ownKeys (target) {\r\n            return getKeysFromAllScopes(target);\r\n        },\r\n set (target, prop, value) {\r\n            const storage = target._storage || (target._storage = getTarget());\r\n            target[prop] = storage[prop] = value;\r\n            delete target._keys;\r\n            return true;\r\n        }\r\n    });\r\n}\r\n function _attachContext(proxy, context, subProxy, descriptorDefaults) {\r\n    const cache = {\r\n        _cacheable: false,\r\n        _proxy: proxy,\r\n        _context: context,\r\n        _subProxy: subProxy,\r\n        _stack: new Set(),\r\n        _descriptors: _descriptors(proxy, descriptorDefaults),\r\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\r\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\r\n    };\r\n    return new Proxy(cache, {\r\n deleteProperty (target, prop) {\r\n            delete target[prop];\r\n            delete proxy[prop];\r\n            return true;\r\n        },\r\n get (target, prop, receiver) {\r\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\r\n        },\r\n getOwnPropertyDescriptor (target, prop) {\r\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\r\n                enumerable: true,\r\n                configurable: true\r\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\r\n        },\r\n getPrototypeOf () {\r\n            return Reflect.getPrototypeOf(proxy);\r\n        },\r\n has (target, prop) {\r\n            return Reflect.has(proxy, prop);\r\n        },\r\n ownKeys () {\r\n            return Reflect.ownKeys(proxy);\r\n        },\r\n set (target, prop, value) {\r\n            proxy[prop] = value;\r\n            delete target[prop];\r\n            return true;\r\n        }\r\n    });\r\n}\r\n function _descriptors(proxy, defaults = {\r\n    scriptable: true,\r\n    indexable: true\r\n}) {\r\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\r\n    return {\r\n        allKeys: _allKeys,\r\n        scriptable: _scriptable,\r\n        indexable: _indexable,\r\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\r\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\r\n    };\r\n}\r\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\r\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\r\nfunction _cached(target, prop, resolve) {\r\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\r\n        return target[prop];\r\n    }\r\n    const value = resolve();\r\n    target[prop] = value;\r\n    return value;\r\n}\r\nfunction _resolveWithContext(target, prop, receiver) {\r\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\r\n    let value = _proxy[prop];\r\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\r\n        value = _resolveScriptable(prop, value, target, receiver);\r\n    }\r\n    if (isArray(value) && value.length) {\r\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\r\n    }\r\n    if (needsSubResolver(prop, value)) {\r\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\r\n    }\r\n    return value;\r\n}\r\nfunction _resolveScriptable(prop, value, target, receiver) {\r\n    const { _proxy , _context , _subProxy , _stack  } = target;\r\n    if (_stack.has(prop)) {\r\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\r\n    }\r\n    _stack.add(prop);\r\n    value = value(_context, _subProxy || receiver);\r\n    _stack.delete(prop);\r\n    if (needsSubResolver(prop, value)) {\r\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\r\n    }\r\n    return value;\r\n}\r\nfunction _resolveArray(prop, value, target, isIndexable) {\r\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\r\n    if (defined(_context.index) && isIndexable(prop)) {\r\n        value = value[_context.index % value.length];\r\n    } else if (isObject(value[0])) {\r\n        const arr = value;\r\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\r\n        value = [];\r\n        for (const item of arr){\r\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\r\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction resolveFallback(fallback, prop, value) {\r\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\r\n}\r\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\r\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\r\n    for (const parent of parentScopes){\r\n        const scope = getScope(key, parent);\r\n        if (scope) {\r\n            set.add(scope);\r\n            const fallback = resolveFallback(scope._fallback, key, value);\r\n            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\r\n                return fallback;\r\n            }\r\n        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\r\n            return null;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction createSubResolver(parentScopes, resolver, prop, value) {\r\n    const rootScopes = resolver._rootScopes;\r\n    const fallback = resolveFallback(resolver._fallback, prop, value);\r\n    const allScopes = [\r\n        ...parentScopes,\r\n        ...rootScopes\r\n    ];\r\n    const set = new Set();\r\n    set.add(value);\r\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\r\n    if (key === null) {\r\n        return false;\r\n    }\r\n    if (defined(fallback) && fallback !== prop) {\r\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\r\n        if (key === null) {\r\n            return false;\r\n        }\r\n    }\r\n    return _createResolver(Array.from(set), [\r\n        ''\r\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\r\n}\r\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\r\n    while(key){\r\n        key = addScopes(set, allScopes, key, fallback, item);\r\n    }\r\n    return key;\r\n}\r\nfunction subGetTarget(resolver, prop, value) {\r\n    const parent = resolver._getTarget();\r\n    if (!(prop in parent)) {\r\n        parent[prop] = {};\r\n    }\r\n    const target = parent[prop];\r\n    if (isArray(target) && isObject(value)) {\r\n        return value;\r\n    }\r\n    return target || {};\r\n}\r\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\r\n    let value;\r\n    for (const prefix of prefixes){\r\n        value = _resolve(readKey(prefix, prop), scopes);\r\n        if (defined(value)) {\r\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\r\n        }\r\n    }\r\n}\r\nfunction _resolve(key, scopes) {\r\n    for (const scope of scopes){\r\n        if (!scope) {\r\n            continue;\r\n        }\r\n        const value = scope[key];\r\n        if (defined(value)) {\r\n            return value;\r\n        }\r\n    }\r\n}\r\nfunction getKeysFromAllScopes(target) {\r\n    let keys = target._keys;\r\n    if (!keys) {\r\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\r\n    }\r\n    return keys;\r\n}\r\nfunction resolveKeysFromAllScopes(scopes) {\r\n    const set = new Set();\r\n    for (const scope of scopes){\r\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\r\n            set.add(key);\r\n        }\r\n    }\r\n    return Array.from(set);\r\n}\r\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\r\n    const { iScale  } = meta;\r\n    const { key ='r'  } = this._parsing;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n    for(i = 0, ilen = count; i < ilen; ++i){\r\n        index = i + start;\r\n        item = data[index];\r\n        parsed[i] = {\r\n            r: iScale.parse(resolveObjectKey(item, key), index)\r\n        };\r\n    }\r\n    return parsed;\r\n}\r\n\r\nconst EPSILON = Number.EPSILON || 1e-14;\r\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\r\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\r\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\r\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\r\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n    // This function must also respect \"skipped\" points\r\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\r\n    const current = middlePoint;\r\n    const next = afterPoint.skip ? middlePoint : afterPoint;\r\n    const d01 = distanceBetweenPoints(current, previous);\r\n    const d12 = distanceBetweenPoints(next, current);\r\n    let s01 = d01 / (d01 + d12);\r\n    let s12 = d12 / (d01 + d12);\r\n    // If all points are the same, s01 & s02 will be inf\r\n    s01 = isNaN(s01) ? 0 : s01;\r\n    s12 = isNaN(s12) ? 0 : s12;\r\n    const fa = t * s01; // scaling factor for triangle Ta\r\n    const fb = t * s12;\r\n    return {\r\n        previous: {\r\n            x: current.x - fa * (next.x - previous.x),\r\n            y: current.y - fa * (next.y - previous.y)\r\n        },\r\n        next: {\r\n            x: current.x + fb * (next.x - previous.x),\r\n            y: current.y + fb * (next.y - previous.y)\r\n        }\r\n    };\r\n}\r\n/**\r\n * Adjust tangents to ensure monotonic properties\r\n */ function monotoneAdjust(points, deltaK, mK) {\r\n    const pointsLen = points.length;\r\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\r\n    let pointAfter = getPoint(points, 0);\r\n    for(let i = 0; i < pointsLen - 1; ++i){\r\n        pointCurrent = pointAfter;\r\n        pointAfter = getPoint(points, i + 1);\r\n        if (!pointCurrent || !pointAfter) {\r\n            continue;\r\n        }\r\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\r\n            mK[i] = mK[i + 1] = 0;\r\n            continue;\r\n        }\r\n        alphaK = mK[i] / deltaK[i];\r\n        betaK = mK[i + 1] / deltaK[i];\r\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n        if (squaredMagnitude <= 9) {\r\n            continue;\r\n        }\r\n        tauK = 3 / Math.sqrt(squaredMagnitude);\r\n        mK[i] = alphaK * tauK * deltaK[i];\r\n        mK[i + 1] = betaK * tauK * deltaK[i];\r\n    }\r\n}\r\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\r\n    const valueAxis = getValueAxis(indexAxis);\r\n    const pointsLen = points.length;\r\n    let delta, pointBefore, pointCurrent;\r\n    let pointAfter = getPoint(points, 0);\r\n    for(let i = 0; i < pointsLen; ++i){\r\n        pointBefore = pointCurrent;\r\n        pointCurrent = pointAfter;\r\n        pointAfter = getPoint(points, i + 1);\r\n        if (!pointCurrent) {\r\n            continue;\r\n        }\r\n        const iPixel = pointCurrent[indexAxis];\r\n        const vPixel = pointCurrent[valueAxis];\r\n        if (pointBefore) {\r\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\r\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\r\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\r\n        }\r\n        if (pointAfter) {\r\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\r\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\r\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\r\n        }\r\n    }\r\n}\r\n/**\r\n * This function calculates Bézier control points in a similar way than |splineCurve|,\r\n * but preserves monotonicity of the provided data and ensures no local extremums are added\r\n * between the dataset discrete points due to the interpolation.\r\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\r\n */ function splineCurveMonotone(points, indexAxis = 'x') {\r\n    const valueAxis = getValueAxis(indexAxis);\r\n    const pointsLen = points.length;\r\n    const deltaK = Array(pointsLen).fill(0);\r\n    const mK = Array(pointsLen);\r\n    // Calculate slopes (deltaK) and initialize tangents (mK)\r\n    let i, pointBefore, pointCurrent;\r\n    let pointAfter = getPoint(points, 0);\r\n    for(i = 0; i < pointsLen; ++i){\r\n        pointBefore = pointCurrent;\r\n        pointCurrent = pointAfter;\r\n        pointAfter = getPoint(points, i + 1);\r\n        if (!pointCurrent) {\r\n            continue;\r\n        }\r\n        if (pointAfter) {\r\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\r\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\r\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\r\n        }\r\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\r\n    }\r\n    monotoneAdjust(points, deltaK, mK);\r\n    monotoneCompute(points, mK, indexAxis);\r\n}\r\nfunction capControlPoint(pt, min, max) {\r\n    return Math.max(Math.min(pt, max), min);\r\n}\r\nfunction capBezierPoints(points, area) {\r\n    let i, ilen, point, inArea, inAreaPrev;\r\n    let inAreaNext = _isPointInArea(points[0], area);\r\n    for(i = 0, ilen = points.length; i < ilen; ++i){\r\n        inAreaPrev = inArea;\r\n        inArea = inAreaNext;\r\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\r\n        if (!inArea) {\r\n            continue;\r\n        }\r\n        point = points[i];\r\n        if (inAreaPrev) {\r\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\r\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\r\n        }\r\n        if (inAreaNext) {\r\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\r\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\r\n        }\r\n    }\r\n}\r\n/**\r\n * @private\r\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\r\n    let i, ilen, point, controlPoints;\r\n    // Only consider points that are drawn in case the spanGaps option is used\r\n    if (options.spanGaps) {\r\n        points = points.filter((pt)=>!pt.skip);\r\n    }\r\n    if (options.cubicInterpolationMode === 'monotone') {\r\n        splineCurveMonotone(points, indexAxis);\r\n    } else {\r\n        let prev = loop ? points[points.length - 1] : points[0];\r\n        for(i = 0, ilen = points.length; i < ilen; ++i){\r\n            point = points[i];\r\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\r\n            point.cp1x = controlPoints.previous.x;\r\n            point.cp1y = controlPoints.previous.y;\r\n            point.cp2x = controlPoints.next.x;\r\n            point.cp2y = controlPoints.next.y;\r\n            prev = point;\r\n        }\r\n    }\r\n    if (options.capBezierPoints) {\r\n        capBezierPoints(points, area);\r\n    }\r\n}\r\n\r\nconst atEdge = (t)=>t === 0 || t === 1;\r\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\r\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\r\n/**\r\n * Easing functions adapted from Robert Penner's easing equations.\r\n * @namespace Chart.helpers.easing.effects\r\n * @see http://www.robertpenner.com/easing/\r\n */ const effects = {\r\n    linear: (t)=>t,\r\n    easeInQuad: (t)=>t * t,\r\n    easeOutQuad: (t)=>-t * (t - 2),\r\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\r\n    easeInCubic: (t)=>t * t * t,\r\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\r\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\r\n    easeInQuart: (t)=>t * t * t * t,\r\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\r\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\r\n    easeInQuint: (t)=>t * t * t * t * t,\r\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\r\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\r\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\r\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\r\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\r\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\r\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\r\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\r\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\r\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\r\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\r\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\r\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\r\n    easeInOutElastic (t) {\r\n        const s = 0.1125;\r\n        const p = 0.45;\r\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\r\n    },\r\n    easeInBack (t) {\r\n        const s = 1.70158;\r\n        return t * t * ((s + 1) * t - s);\r\n    },\r\n    easeOutBack (t) {\r\n        const s = 1.70158;\r\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\r\n    },\r\n    easeInOutBack (t) {\r\n        let s = 1.70158;\r\n        if ((t /= 0.5) < 1) {\r\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\r\n        }\r\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\r\n    },\r\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\r\n    easeOutBounce (t) {\r\n        const m = 7.5625;\r\n        const d = 2.75;\r\n        if (t < 1 / d) {\r\n            return m * t * t;\r\n        }\r\n        if (t < 2 / d) {\r\n            return m * (t -= 1.5 / d) * t + 0.75;\r\n        }\r\n        if (t < 2.5 / d) {\r\n            return m * (t -= 2.25 / d) * t + 0.9375;\r\n        }\r\n        return m * (t -= 2.625 / d) * t + 0.984375;\r\n    },\r\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\r\n};\r\n\r\n/**\r\n * @private\r\n */ function _pointInLine(p1, p2, t, mode) {\r\n    return {\r\n        x: p1.x + t * (p2.x - p1.x),\r\n        y: p1.y + t * (p2.y - p1.y)\r\n    };\r\n}\r\n/**\r\n * @private\r\n */ function _steppedInterpolation(p1, p2, t, mode) {\r\n    return {\r\n        x: p1.x + t * (p2.x - p1.x),\r\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\r\n    };\r\n}\r\n/**\r\n * @private\r\n */ function _bezierInterpolation(p1, p2, t, mode) {\r\n    const cp1 = {\r\n        x: p1.cp2x,\r\n        y: p1.cp2y\r\n    };\r\n    const cp2 = {\r\n        x: p2.cp1x,\r\n        y: p2.cp1y\r\n    };\r\n    const a = _pointInLine(p1, cp1, t);\r\n    const b = _pointInLine(cp1, cp2, t);\r\n    const c = _pointInLine(cp2, p2, t);\r\n    const d = _pointInLine(a, b, t);\r\n    const e = _pointInLine(b, c, t);\r\n    return _pointInLine(d, e, t);\r\n}\r\n\r\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\r\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\r\n/**\r\n * @alias Chart.helpers.options\r\n * @namespace\r\n */ /**\r\n * Converts the given line height `value` in pixels for a specific font `size`.\r\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\r\n * @param size - The font size (in pixels) used to resolve relative `value`.\r\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\r\n * @since 2.7.0\r\n */ function toLineHeight(value, size) {\r\n    const matches = ('' + value).match(LINE_HEIGHT);\r\n    if (!matches || matches[1] === 'normal') {\r\n        return size * 1.2;\r\n    }\r\n    value = +matches[2];\r\n    switch(matches[3]){\r\n        case 'px':\r\n            return value;\r\n        case '%':\r\n            value /= 100;\r\n            break;\r\n    }\r\n    return size * value;\r\n}\r\nconst numberOrZero = (v)=>+v || 0;\r\nfunction _readValueToProps(value, props) {\r\n    const ret = {};\r\n    const objProps = isObject(props);\r\n    const keys = objProps ? Object.keys(props) : props;\r\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\r\n    for (const prop of keys){\r\n        ret[prop] = numberOrZero(read(prop));\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Converts the given value into a TRBL object.\r\n * @param value - If a number, set the value to all TRBL component,\r\n *  else, if an object, use defined properties and sets undefined ones to 0.\r\n *  x / y are shorthands for same value for left/right and top/bottom.\r\n * @returns The padding values (top, right, bottom, left)\r\n * @since 3.0.0\r\n */ function toTRBL(value) {\r\n    return _readValueToProps(value, {\r\n        top: 'y',\r\n        right: 'x',\r\n        bottom: 'y',\r\n        left: 'x'\r\n    });\r\n}\r\n/**\r\n * Converts the given value into a TRBL corners object (similar with css border-radius).\r\n * @param value - If a number, set the value to all TRBL corner components,\r\n *  else, if an object, use defined properties and sets undefined ones to 0.\r\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\r\n * @since 3.0.0\r\n */ function toTRBLCorners(value) {\r\n    return _readValueToProps(value, [\r\n        'topLeft',\r\n        'topRight',\r\n        'bottomLeft',\r\n        'bottomRight'\r\n    ]);\r\n}\r\n/**\r\n * Converts the given value into a padding object with pre-computed width/height.\r\n * @param value - If a number, set the value to all TRBL component,\r\n *  else, if an object, use defined properties and sets undefined ones to 0.\r\n *  x / y are shorthands for same value for left/right and top/bottom.\r\n * @returns The padding values (top, right, bottom, left, width, height)\r\n * @since 2.7.0\r\n */ function toPadding(value) {\r\n    const obj = toTRBL(value);\r\n    obj.width = obj.left + obj.right;\r\n    obj.height = obj.top + obj.bottom;\r\n    return obj;\r\n}\r\n/**\r\n * Parses font options and returns the font object.\r\n * @param options - A object that contains font options to be parsed.\r\n * @param fallback - A object that contains fallback font options.\r\n * @return The font object.\r\n * @private\r\n */ function toFont(options, fallback) {\r\n    options = options || {};\r\n    fallback = fallback || defaults.font;\r\n    let size = valueOrDefault(options.size, fallback.size);\r\n    if (typeof size === 'string') {\r\n        size = parseInt(size, 10);\r\n    }\r\n    let style = valueOrDefault(options.style, fallback.style);\r\n    if (style && !('' + style).match(FONT_STYLE)) {\r\n        console.warn('Invalid font style specified: \"' + style + '\"');\r\n        style = undefined;\r\n    }\r\n    const font = {\r\n        family: valueOrDefault(options.family, fallback.family),\r\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\r\n        size,\r\n        style,\r\n        weight: valueOrDefault(options.weight, fallback.weight),\r\n        string: ''\r\n    };\r\n    font.string = toFontString(font);\r\n    return font;\r\n}\r\n/**\r\n * Evaluates the given `inputs` sequentially and returns the first defined value.\r\n * @param inputs - An array of values, falling back to the last value.\r\n * @param context - If defined and the current value is a function, the value\r\n * is called with `context` as first argument and the result becomes the new input.\r\n * @param index - If defined and the current value is an array, the value\r\n * at `index` become the new input.\r\n * @param info - object to return information about resolution in\r\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\r\n * @since 2.7.0\r\n */ function resolve(inputs, context, index, info) {\r\n    let cacheable = true;\r\n    let i, ilen, value;\r\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\r\n        value = inputs[i];\r\n        if (value === undefined) {\r\n            continue;\r\n        }\r\n        if (context !== undefined && typeof value === 'function') {\r\n            value = value(context);\r\n            cacheable = false;\r\n        }\r\n        if (index !== undefined && isArray(value)) {\r\n            value = value[index % value.length];\r\n            cacheable = false;\r\n        }\r\n        if (value !== undefined) {\r\n            if (info && !cacheable) {\r\n                info.cacheable = false;\r\n            }\r\n            return value;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @param minmax\r\n * @param grace\r\n * @param beginAtZero\r\n * @private\r\n */ function _addGrace(minmax, grace, beginAtZero) {\r\n    const { min , max  } = minmax;\r\n    const change = toDimension(grace, (max - min) / 2);\r\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\r\n    return {\r\n        min: keepZero(min, -Math.abs(change)),\r\n        max: keepZero(max, change)\r\n    };\r\n}\r\nfunction createContext(parentContext, context) {\r\n    return Object.assign(Object.create(parentContext), context);\r\n}\r\n\r\nconst getRightToLeftAdapter = function(rectX, width) {\r\n    return {\r\n        x (x) {\r\n            return rectX + rectX + width - x;\r\n        },\r\n        setWidth (w) {\r\n            width = w;\r\n        },\r\n        textAlign (align) {\r\n            if (align === 'center') {\r\n                return align;\r\n            }\r\n            return align === 'right' ? 'left' : 'right';\r\n        },\r\n        xPlus (x, value) {\r\n            return x - value;\r\n        },\r\n        leftForLtr (x, itemWidth) {\r\n            return x - itemWidth;\r\n        }\r\n    };\r\n};\r\nconst getLeftToRightAdapter = function() {\r\n    return {\r\n        x (x) {\r\n            return x;\r\n        },\r\n        setWidth (w) {},\r\n        textAlign (align) {\r\n            return align;\r\n        },\r\n        xPlus (x, value) {\r\n            return x + value;\r\n        },\r\n        leftForLtr (x, _itemWidth) {\r\n            return x;\r\n        }\r\n    };\r\n};\r\nfunction getRtlAdapter(rtl, rectX, width) {\r\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\r\n}\r\nfunction overrideTextDirection(ctx, direction) {\r\n    let style, original;\r\n    if (direction === 'ltr' || direction === 'rtl') {\r\n        style = ctx.canvas.style;\r\n        original = [\r\n            style.getPropertyValue('direction'),\r\n            style.getPropertyPriority('direction')\r\n        ];\r\n        style.setProperty('direction', direction, 'important');\r\n        ctx.prevTextDirection = original;\r\n    }\r\n}\r\nfunction restoreTextDirection(ctx, original) {\r\n    if (original !== undefined) {\r\n        delete ctx.prevTextDirection;\r\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\r\n    }\r\n}\r\n\r\nfunction propertyFn(property) {\r\n    if (property === 'angle') {\r\n        return {\r\n            between: _angleBetween,\r\n            compare: _angleDiff,\r\n            normalize: _normalizeAngle\r\n        };\r\n    }\r\n    return {\r\n        between: _isBetween,\r\n        compare: (a, b)=>a - b,\r\n        normalize: (x)=>x\r\n    };\r\n}\r\nfunction normalizeSegment({ start , end , count , loop , style  }) {\r\n    return {\r\n        start: start % count,\r\n        end: end % count,\r\n        loop: loop && (end - start + 1) % count === 0,\r\n        style\r\n    };\r\n}\r\nfunction getSegment(segment, points, bounds) {\r\n    const { property , start: startBound , end: endBound  } = bounds;\r\n    const { between , normalize  } = propertyFn(property);\r\n    const count = points.length;\r\n    let { start , end , loop  } = segment;\r\n    let i, ilen;\r\n    if (loop) {\r\n        start += count;\r\n        end += count;\r\n        for(i = 0, ilen = count; i < ilen; ++i){\r\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\r\n                break;\r\n            }\r\n            start--;\r\n            end--;\r\n        }\r\n        start %= count;\r\n        end %= count;\r\n    }\r\n    if (end < start) {\r\n        end += count;\r\n    }\r\n    return {\r\n        start,\r\n        end,\r\n        loop,\r\n        style: segment.style\r\n    };\r\n}\r\n function _boundSegment(segment, points, bounds) {\r\n    if (!bounds) {\r\n        return [\r\n            segment\r\n        ];\r\n    }\r\n    const { property , start: startBound , end: endBound  } = bounds;\r\n    const count = points.length;\r\n    const { compare , between , normalize  } = propertyFn(property);\r\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\r\n    const result = [];\r\n    let inside = false;\r\n    let subStart = null;\r\n    let value, point, prevValue;\r\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\r\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\r\n    const shouldStart = ()=>inside || startIsBefore();\r\n    const shouldStop = ()=>!inside || endIsBefore();\r\n    for(let i = start, prev = start; i <= end; ++i){\r\n        point = points[i % count];\r\n        if (point.skip) {\r\n            continue;\r\n        }\r\n        value = normalize(point[property]);\r\n        if (value === prevValue) {\r\n            continue;\r\n        }\r\n        inside = between(value, startBound, endBound);\r\n        if (subStart === null && shouldStart()) {\r\n            subStart = compare(value, startBound) === 0 ? i : prev;\r\n        }\r\n        if (subStart !== null && shouldStop()) {\r\n            result.push(normalizeSegment({\r\n                start: subStart,\r\n                end: i,\r\n                loop,\r\n                count,\r\n                style\r\n            }));\r\n            subStart = null;\r\n        }\r\n        prev = i;\r\n        prevValue = value;\r\n    }\r\n    if (subStart !== null) {\r\n        result.push(normalizeSegment({\r\n            start: subStart,\r\n            end,\r\n            loop,\r\n            count,\r\n            style\r\n        }));\r\n    }\r\n    return result;\r\n}\r\n function _boundSegments(line, bounds) {\r\n    const result = [];\r\n    const segments = line.segments;\r\n    for(let i = 0; i < segments.length; i++){\r\n        const sub = _boundSegment(segments[i], line.points, bounds);\r\n        if (sub.length) {\r\n            result.push(...sub);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n function findStartAndEnd(points, count, loop, spanGaps) {\r\n    let start = 0;\r\n    let end = count - 1;\r\n    if (loop && !spanGaps) {\r\n        while(start < count && !points[start].skip){\r\n            start++;\r\n        }\r\n    }\r\n    while(start < count && points[start].skip){\r\n        start++;\r\n    }\r\n    start %= count;\r\n    if (loop) {\r\n        end += start;\r\n    }\r\n    while(end > start && points[end % count].skip){\r\n        end--;\r\n    }\r\n    end %= count;\r\n    return {\r\n        start,\r\n        end\r\n    };\r\n}\r\n function solidSegments(points, start, max, loop) {\r\n    const count = points.length;\r\n    const result = [];\r\n    let last = start;\r\n    let prev = points[start];\r\n    let end;\r\n    for(end = start + 1; end <= max; ++end){\r\n        const cur = points[end % count];\r\n        if (cur.skip || cur.stop) {\r\n            if (!prev.skip) {\r\n                loop = false;\r\n                result.push({\r\n                    start: start % count,\r\n                    end: (end - 1) % count,\r\n                    loop\r\n                });\r\n                start = last = cur.stop ? end : null;\r\n            }\r\n        } else {\r\n            last = end;\r\n            if (prev.skip) {\r\n                start = end;\r\n            }\r\n        }\r\n        prev = cur;\r\n    }\r\n    if (last !== null) {\r\n        result.push({\r\n            start: start % count,\r\n            end: last % count,\r\n            loop\r\n        });\r\n    }\r\n    return result;\r\n}\r\n function _computeSegments(line, segmentOptions) {\r\n    const points = line.points;\r\n    const spanGaps = line.options.spanGaps;\r\n    const count = points.length;\r\n    if (!count) {\r\n        return [];\r\n    }\r\n    const loop = !!line._loop;\r\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\r\n    if (spanGaps === true) {\r\n        return splitByStyles(line, [\r\n            {\r\n                start,\r\n                end,\r\n                loop\r\n            }\r\n        ], points, segmentOptions);\r\n    }\r\n    const max = end < start ? end + count : end;\r\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\r\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\r\n}\r\n function splitByStyles(line, segments, points, segmentOptions) {\r\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\r\n        return segments;\r\n    }\r\n    return doSplitByStyles(line, segments, points, segmentOptions);\r\n}\r\n function doSplitByStyles(line, segments, points, segmentOptions) {\r\n    const chartContext = line._chart.getContext();\r\n    const baseStyle = readStyle(line.options);\r\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\r\n    const count = points.length;\r\n    const result = [];\r\n    let prevStyle = baseStyle;\r\n    let start = segments[0].start;\r\n    let i = start;\r\n    function addStyle(s, e, l, st) {\r\n        const dir = spanGaps ? -1 : 1;\r\n        if (s === e) {\r\n            return;\r\n        }\r\n        s += count;\r\n        while(points[s % count].skip){\r\n            s -= dir;\r\n        }\r\n        while(points[e % count].skip){\r\n            e += dir;\r\n        }\r\n        if (s % count !== e % count) {\r\n            result.push({\r\n                start: s % count,\r\n                end: e % count,\r\n                loop: l,\r\n                style: st\r\n            });\r\n            prevStyle = st;\r\n            start = e % count;\r\n        }\r\n    }\r\n    for (const segment of segments){\r\n        start = spanGaps ? start : segment.start;\r\n        let prev = points[start % count];\r\n        let style;\r\n        for(i = start + 1; i <= segment.end; i++){\r\n            const pt = points[i % count];\r\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\r\n                type: 'segment',\r\n                p0: prev,\r\n                p1: pt,\r\n                p0DataIndex: (i - 1) % count,\r\n                p1DataIndex: i % count,\r\n                datasetIndex\r\n            })));\r\n            if (styleChanged(style, prevStyle)) {\r\n                addStyle(start, i - 1, segment.loop, prevStyle);\r\n            }\r\n            prev = pt;\r\n            prevStyle = style;\r\n        }\r\n        if (start < i - 1) {\r\n            addStyle(start, i - 1, segment.loop, prevStyle);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction readStyle(options) {\r\n    return {\r\n        backgroundColor: options.backgroundColor,\r\n        borderCapStyle: options.borderCapStyle,\r\n        borderDash: options.borderDash,\r\n        borderDashOffset: options.borderDashOffset,\r\n        borderJoinStyle: options.borderJoinStyle,\r\n        borderWidth: options.borderWidth,\r\n        borderColor: options.borderColor\r\n    };\r\n}\r\nfunction styleChanged(style, prevStyle) {\r\n    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\r\n}\r\n\r\nvar helpers = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\neasingEffects: effects,\r\nisPatternOrGradient: isPatternOrGradient,\r\ncolor: color,\r\ngetHoverColor: getHoverColor,\r\nnoop: noop,\r\nuid: uid,\r\nisNullOrUndef: isNullOrUndef,\r\nisArray: isArray,\r\nisObject: isObject,\r\nisFinite: isNumberFinite,\r\nfiniteOrDefault: finiteOrDefault,\r\nvalueOrDefault: valueOrDefault,\r\ntoPercentage: toPercentage,\r\ntoDimension: toDimension,\r\ncallback: callback,\r\neach: each,\r\n_elementsEqual: _elementsEqual,\r\nclone: clone$1,\r\n_merger: _merger,\r\nmerge: merge,\r\nmergeIf: mergeIf,\r\n_mergerIf: _mergerIf,\r\n_deprecated: _deprecated,\r\n_splitKey: _splitKey,\r\nresolveObjectKey: resolveObjectKey,\r\n_capitalize: _capitalize,\r\ndefined: defined,\r\nisFunction: isFunction,\r\nsetsEqual: setsEqual,\r\n_isClickEvent: _isClickEvent,\r\ntoFontString: toFontString,\r\n_measureText: _measureText,\r\n_longestText: _longestText,\r\n_alignPixel: _alignPixel,\r\nclearCanvas: clearCanvas,\r\ndrawPoint: drawPoint,\r\ndrawPointLegend: drawPointLegend,\r\n_isPointInArea: _isPointInArea,\r\nclipArea: clipArea,\r\nunclipArea: unclipArea,\r\n_steppedLineTo: _steppedLineTo,\r\n_bezierCurveTo: _bezierCurveTo,\r\nrenderText: renderText,\r\naddRoundedRectPath: addRoundedRectPath,\r\n_lookup: _lookup,\r\n_lookupByKey: _lookupByKey,\r\n_rlookupByKey: _rlookupByKey,\r\n_filterBetween: _filterBetween,\r\nlistenArrayEvents: listenArrayEvents,\r\nunlistenArrayEvents: unlistenArrayEvents,\r\n_arrayUnique: _arrayUnique,\r\n_createResolver: _createResolver,\r\n_attachContext: _attachContext,\r\n_descriptors: _descriptors,\r\n_parseObjectDataRadialScale: _parseObjectDataRadialScale,\r\nsplineCurve: splineCurve,\r\nsplineCurveMonotone: splineCurveMonotone,\r\n_updateBezierControlPoints: _updateBezierControlPoints,\r\n_isDomSupported: _isDomSupported,\r\n_getParentNode: _getParentNode,\r\ngetStyle: getStyle,\r\ngetRelativePosition: getRelativePosition,\r\ngetMaximumSize: getMaximumSize,\r\nretinaScale: retinaScale,\r\nsupportsEventListenerOptions: supportsEventListenerOptions,\r\nreadUsedSize: readUsedSize,\r\nfontString: fontString,\r\nrequestAnimFrame: requestAnimFrame,\r\nthrottled: throttled,\r\ndebounce: debounce,\r\n_toLeftRightCenter: _toLeftRightCenter,\r\n_alignStartEnd: _alignStartEnd,\r\n_textX: _textX,\r\n_getStartAndCountOfVisiblePoints: _getStartAndCountOfVisiblePoints,\r\n_scaleRangesChanged: _scaleRangesChanged,\r\n_pointInLine: _pointInLine,\r\n_steppedInterpolation: _steppedInterpolation,\r\n_bezierInterpolation: _bezierInterpolation,\r\nformatNumber: formatNumber,\r\ntoLineHeight: toLineHeight,\r\n_readValueToProps: _readValueToProps,\r\ntoTRBL: toTRBL,\r\ntoTRBLCorners: toTRBLCorners,\r\ntoPadding: toPadding,\r\ntoFont: toFont,\r\nresolve: resolve,\r\n_addGrace: _addGrace,\r\ncreateContext: createContext,\r\nPI: PI,\r\nTAU: TAU,\r\nPITAU: PITAU,\r\nINFINITY: INFINITY,\r\nRAD_PER_DEG: RAD_PER_DEG,\r\nHALF_PI: HALF_PI,\r\nQUARTER_PI: QUARTER_PI,\r\nTWO_THIRDS_PI: TWO_THIRDS_PI,\r\nlog10: log10,\r\nsign: sign,\r\nalmostEquals: almostEquals,\r\nniceNum: niceNum,\r\n_factorize: _factorize,\r\nisNumber: isNumber,\r\nalmostWhole: almostWhole,\r\n_setMinAndMaxByKey: _setMinAndMaxByKey,\r\ntoRadians: toRadians,\r\ntoDegrees: toDegrees,\r\n_decimalPlaces: _decimalPlaces,\r\ngetAngleFromPoint: getAngleFromPoint,\r\ndistanceBetweenPoints: distanceBetweenPoints,\r\n_angleDiff: _angleDiff,\r\n_normalizeAngle: _normalizeAngle,\r\n_angleBetween: _angleBetween,\r\n_limitValue: _limitValue,\r\n_int16Range: _int16Range,\r\n_isBetween: _isBetween,\r\ngetRtlAdapter: getRtlAdapter,\r\noverrideTextDirection: overrideTextDirection,\r\nrestoreTextDirection: restoreTextDirection,\r\n_boundSegment: _boundSegment,\r\n_boundSegments: _boundSegments,\r\n_computeSegments: _computeSegments\r\n});\r\n\r\nfunction binarySearch(metaset, axis, value, intersect) {\r\n    const { controller , data , _sorted  } = metaset;\r\n    const iScale = controller._cachedMeta.iScale;\r\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\r\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\r\n        if (!intersect) {\r\n            return lookupMethod(data, axis, value);\r\n        } else if (controller._sharedOptions) {\r\n            const el = data[0];\r\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\r\n            if (range) {\r\n                const start = lookupMethod(data, axis, value - range);\r\n                const end = lookupMethod(data, axis, value + range);\r\n                return {\r\n                    lo: start.lo,\r\n                    hi: end.hi\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        lo: 0,\r\n        hi: data.length - 1\r\n    };\r\n}\r\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    const value = position[axis];\r\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\r\n        const { index , data  } = metasets[i];\r\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\r\n        for(let j = lo; j <= hi; ++j){\r\n            const element = data[j];\r\n            if (!element.skip) {\r\n                handler(element, index, j);\r\n            }\r\n        }\r\n    }\r\n}\r\n function getDistanceMetricForAxis(axis) {\r\n    const useX = axis.indexOf('x') !== -1;\r\n    const useY = axis.indexOf('y') !== -1;\r\n    return function(pt1, pt2) {\r\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n    };\r\n}\r\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\r\n    const items = [];\r\n    if (!includeInvisible && !chart.isPointInArea(position)) {\r\n        return items;\r\n    }\r\n    const evaluationFunc = function(element, datasetIndex, index) {\r\n        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\r\n            return;\r\n        }\r\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n            items.push({\r\n                element,\r\n                datasetIndex,\r\n                index\r\n            });\r\n        }\r\n    };\r\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\r\n    return items;\r\n}\r\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\r\n    let items = [];\r\n    function evaluationFunc(element, datasetIndex, index) {\r\n        const { startAngle , endAngle  } = element.getProps([\r\n            'startAngle',\r\n            'endAngle'\r\n        ], useFinalPosition);\r\n        const { angle  } = getAngleFromPoint(element, {\r\n            x: position.x,\r\n            y: position.y\r\n        });\r\n        if (_angleBetween(angle, startAngle, endAngle)) {\r\n            items.push({\r\n                element,\r\n                datasetIndex,\r\n                index\r\n            });\r\n        }\r\n    }\r\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n    return items;\r\n}\r\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n    let items = [];\r\n    const distanceMetric = getDistanceMetricForAxis(axis);\r\n    let minDistance = Number.POSITIVE_INFINITY;\r\n    function evaluationFunc(element, datasetIndex, index) {\r\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\r\n        if (intersect && !inRange) {\r\n            return;\r\n        }\r\n        const center = element.getCenterPoint(useFinalPosition);\r\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\r\n        if (!pointInArea && !inRange) {\r\n            return;\r\n        }\r\n        const distance = distanceMetric(position, center);\r\n        if (distance < minDistance) {\r\n            items = [\r\n                {\r\n                    element,\r\n                    datasetIndex,\r\n                    index\r\n                }\r\n            ];\r\n            minDistance = distance;\r\n        } else if (distance === minDistance) {\r\n            items.push({\r\n                element,\r\n                datasetIndex,\r\n                index\r\n            });\r\n        }\r\n    }\r\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n    return items;\r\n}\r\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n    if (!includeInvisible && !chart.isPointInArea(position)) {\r\n        return [];\r\n    }\r\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\r\n}\r\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\r\n    const items = [];\r\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\r\n    let intersectsItem = false;\r\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\r\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\r\n            items.push({\r\n                element,\r\n                datasetIndex,\r\n                index\r\n            });\r\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\r\n        }\r\n    });\r\n    if (intersect && !intersectsItem) {\r\n        return [];\r\n    }\r\n    return items;\r\n}\r\n var Interaction = {\r\n    evaluateInteractionItems,\r\n    modes: {\r\n index (chart, e, options, useFinalPosition) {\r\n            const position = getRelativePosition(e, chart);\r\n            const axis = options.axis || 'x';\r\n            const includeInvisible = options.includeInvisible || false;\r\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n            const elements = [];\r\n            if (!items.length) {\r\n                return [];\r\n            }\r\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\r\n                const index = items[0].index;\r\n                const element = meta.data[index];\r\n                if (element && !element.skip) {\r\n                    elements.push({\r\n                        element,\r\n                        datasetIndex: meta.index,\r\n                        index\r\n                    });\r\n                }\r\n            });\r\n            return elements;\r\n        },\r\n dataset (chart, e, options, useFinalPosition) {\r\n            const position = getRelativePosition(e, chart);\r\n            const axis = options.axis || 'xy';\r\n            const includeInvisible = options.includeInvisible || false;\r\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n            if (items.length > 0) {\r\n                const datasetIndex = items[0].datasetIndex;\r\n                const data = chart.getDatasetMeta(datasetIndex).data;\r\n                items = [];\r\n                for(let i = 0; i < data.length; ++i){\r\n                    items.push({\r\n                        element: data[i],\r\n                        datasetIndex,\r\n                        index: i\r\n                    });\r\n                }\r\n            }\r\n            return items;\r\n        },\r\n point (chart, e, options, useFinalPosition) {\r\n            const position = getRelativePosition(e, chart);\r\n            const axis = options.axis || 'xy';\r\n            const includeInvisible = options.includeInvisible || false;\r\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\r\n        },\r\n nearest (chart, e, options, useFinalPosition) {\r\n            const position = getRelativePosition(e, chart);\r\n            const axis = options.axis || 'xy';\r\n            const includeInvisible = options.includeInvisible || false;\r\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\r\n        },\r\n x (chart, e, options, useFinalPosition) {\r\n            const position = getRelativePosition(e, chart);\r\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\r\n        },\r\n y (chart, e, options, useFinalPosition) {\r\n            const position = getRelativePosition(e, chart);\r\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\r\n        }\r\n    }\r\n};\r\n\r\nconst STATIC_POSITIONS = [\r\n    'left',\r\n    'top',\r\n    'right',\r\n    'bottom'\r\n];\r\nfunction filterByPosition(array, position) {\r\n    return array.filter((v)=>v.pos === position);\r\n}\r\nfunction filterDynamicPositionByAxis(array, axis) {\r\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\r\n}\r\nfunction sortByWeight(array, reverse) {\r\n    return array.sort((a, b)=>{\r\n        const v0 = reverse ? b : a;\r\n        const v1 = reverse ? a : b;\r\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\r\n    });\r\n}\r\nfunction wrapBoxes(boxes) {\r\n    const layoutBoxes = [];\r\n    let i, ilen, box, pos, stack, stackWeight;\r\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\r\n        box = boxes[i];\r\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\r\n        layoutBoxes.push({\r\n            index: i,\r\n            box,\r\n            pos,\r\n            horizontal: box.isHorizontal(),\r\n            weight: box.weight,\r\n            stack: stack && pos + stack,\r\n            stackWeight\r\n        });\r\n    }\r\n    return layoutBoxes;\r\n}\r\nfunction buildStacks(layouts) {\r\n    const stacks = {};\r\n    for (const wrap of layouts){\r\n        const { stack , pos , stackWeight  } = wrap;\r\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\r\n            continue;\r\n        }\r\n        const _stack = stacks[stack] || (stacks[stack] = {\r\n            count: 0,\r\n            placed: 0,\r\n            weight: 0,\r\n            size: 0\r\n        });\r\n        _stack.count++;\r\n        _stack.weight += stackWeight;\r\n    }\r\n    return stacks;\r\n}\r\n function setLayoutDims(layouts, params) {\r\n    const stacks = buildStacks(layouts);\r\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\r\n    let i, ilen, layout;\r\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\r\n        layout = layouts[i];\r\n        const { fullSize  } = layout.box;\r\n        const stack = stacks[layout.stack];\r\n        const factor = stack && layout.stackWeight / stack.weight;\r\n        if (layout.horizontal) {\r\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\r\n            layout.height = hBoxMaxHeight;\r\n        } else {\r\n            layout.width = vBoxMaxWidth;\r\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\r\n        }\r\n    }\r\n    return stacks;\r\n}\r\nfunction buildLayoutBoxes(boxes) {\r\n    const layoutBoxes = wrapBoxes(boxes);\r\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\r\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\r\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\r\n    return {\r\n        fullSize,\r\n        leftAndTop: left.concat(top),\r\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\r\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n        vertical: left.concat(right).concat(centerVertical),\r\n        horizontal: top.concat(bottom).concat(centerHorizontal)\r\n    };\r\n}\r\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\r\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n}\r\nfunction updateMaxPadding(maxPadding, boxPadding) {\r\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n}\r\nfunction updateDims(chartArea, params, layout, stacks) {\r\n    const { pos , box  } = layout;\r\n    const maxPadding = chartArea.maxPadding;\r\n    if (!isObject(pos)) {\r\n        if (layout.size) {\r\n            chartArea[pos] -= layout.size;\r\n        }\r\n        const stack = stacks[layout.stack] || {\r\n            size: 0,\r\n            count: 1\r\n        };\r\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\r\n        layout.size = stack.size / stack.count;\r\n        chartArea[pos] += layout.size;\r\n    }\r\n    if (box.getPadding) {\r\n        updateMaxPadding(maxPadding, box.getPadding());\r\n    }\r\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\r\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\r\n    const widthChanged = newWidth !== chartArea.w;\r\n    const heightChanged = newHeight !== chartArea.h;\r\n    chartArea.w = newWidth;\r\n    chartArea.h = newHeight;\r\n    return layout.horizontal ? {\r\n        same: widthChanged,\r\n        other: heightChanged\r\n    } : {\r\n        same: heightChanged,\r\n        other: widthChanged\r\n    };\r\n}\r\nfunction handleMaxPadding(chartArea) {\r\n    const maxPadding = chartArea.maxPadding;\r\n    function updatePos(pos) {\r\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n        chartArea[pos] += change;\r\n        return change;\r\n    }\r\n    chartArea.y += updatePos('top');\r\n    chartArea.x += updatePos('left');\r\n    updatePos('right');\r\n    updatePos('bottom');\r\n}\r\nfunction getMargins(horizontal, chartArea) {\r\n    const maxPadding = chartArea.maxPadding;\r\n    function marginForPositions(positions) {\r\n        const margin = {\r\n            left: 0,\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0\r\n        };\r\n        positions.forEach((pos)=>{\r\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n        });\r\n        return margin;\r\n    }\r\n    return horizontal ? marginForPositions([\r\n        'left',\r\n        'right'\r\n    ]) : marginForPositions([\r\n        'top',\r\n        'bottom'\r\n    ]);\r\n}\r\nfunction fitBoxes(boxes, chartArea, params, stacks) {\r\n    const refitBoxes = [];\r\n    let i, ilen, layout, box, refit, changed;\r\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\r\n        layout = boxes[i];\r\n        box = layout.box;\r\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\r\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\r\n        refit |= same && refitBoxes.length;\r\n        changed = changed || other;\r\n        if (!box.fullSize) {\r\n            refitBoxes.push(layout);\r\n        }\r\n    }\r\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\r\n}\r\nfunction setBoxDims(box, left, top, width, height) {\r\n    box.top = top;\r\n    box.left = left;\r\n    box.right = left + width;\r\n    box.bottom = top + height;\r\n    box.width = width;\r\n    box.height = height;\r\n}\r\nfunction placeBoxes(boxes, chartArea, params, stacks) {\r\n    const userPadding = params.padding;\r\n    let { x , y  } = chartArea;\r\n    for (const layout of boxes){\r\n        const box = layout.box;\r\n        const stack = stacks[layout.stack] || {\r\n            count: 1,\r\n            placed: 0,\r\n            weight: 1\r\n        };\r\n        const weight = layout.stackWeight / stack.weight || 1;\r\n        if (layout.horizontal) {\r\n            const width = chartArea.w * weight;\r\n            const height = stack.size || box.height;\r\n            if (defined(stack.start)) {\r\n                y = stack.start;\r\n            }\r\n            if (box.fullSize) {\r\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\r\n            } else {\r\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\r\n            }\r\n            stack.start = y;\r\n            stack.placed += width;\r\n            y = box.bottom;\r\n        } else {\r\n            const height1 = chartArea.h * weight;\r\n            const width1 = stack.size || box.width;\r\n            if (defined(stack.start)) {\r\n                x = stack.start;\r\n            }\r\n            if (box.fullSize) {\r\n                setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);\r\n            } else {\r\n                setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);\r\n            }\r\n            stack.start = x;\r\n            stack.placed += height1;\r\n            x = box.right;\r\n        }\r\n    }\r\n    chartArea.x = x;\r\n    chartArea.y = y;\r\n}\r\nvar layouts = {\r\n addBox (chart, item) {\r\n        if (!chart.boxes) {\r\n            chart.boxes = [];\r\n        }\r\n        item.fullSize = item.fullSize || false;\r\n        item.position = item.position || 'top';\r\n        item.weight = item.weight || 0;\r\n        item._layers = item._layers || function() {\r\n            return [\r\n                {\r\n                    z: 0,\r\n                    draw (chartArea) {\r\n                        item.draw(chartArea);\r\n                    }\r\n                }\r\n            ];\r\n        };\r\n        chart.boxes.push(item);\r\n    },\r\n removeBox (chart, layoutItem) {\r\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n        if (index !== -1) {\r\n            chart.boxes.splice(index, 1);\r\n        }\r\n    },\r\n configure (chart, item, options) {\r\n        item.fullSize = options.fullSize;\r\n        item.position = options.position;\r\n        item.weight = options.weight;\r\n    },\r\n update (chart, width, height, minPadding) {\r\n        if (!chart) {\r\n            return;\r\n        }\r\n        const padding = toPadding(chart.options.layout.padding);\r\n        const availableWidth = Math.max(width - padding.width, 0);\r\n        const availableHeight = Math.max(height - padding.height, 0);\r\n        const boxes = buildLayoutBoxes(chart.boxes);\r\n        const verticalBoxes = boxes.vertical;\r\n        const horizontalBoxes = boxes.horizontal;\r\n        each(chart.boxes, (box)=>{\r\n            if (typeof box.beforeLayout === 'function') {\r\n                box.beforeLayout();\r\n            }\r\n        });\r\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\r\n        const params = Object.freeze({\r\n            outerWidth: width,\r\n            outerHeight: height,\r\n            padding,\r\n            availableWidth,\r\n            availableHeight,\r\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\r\n            hBoxMaxHeight: availableHeight / 2\r\n        });\r\n        const maxPadding = Object.assign({}, padding);\r\n        updateMaxPadding(maxPadding, toPadding(minPadding));\r\n        const chartArea = Object.assign({\r\n            maxPadding,\r\n            w: availableWidth,\r\n            h: availableHeight,\r\n            x: padding.left,\r\n            y: padding.top\r\n        }, padding);\r\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\r\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\r\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n        }\r\n        handleMaxPadding(chartArea);\r\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\r\n        chartArea.x += chartArea.w;\r\n        chartArea.y += chartArea.h;\r\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\r\n        chart.chartArea = {\r\n            left: chartArea.left,\r\n            top: chartArea.top,\r\n            right: chartArea.left + chartArea.w,\r\n            bottom: chartArea.top + chartArea.h,\r\n            height: chartArea.h,\r\n            width: chartArea.w\r\n        };\r\n        each(boxes.chartArea, (layout)=>{\r\n            const box = layout.box;\r\n            Object.assign(box, chart.chartArea);\r\n            box.update(chartArea.w, chartArea.h, {\r\n                left: 0,\r\n                top: 0,\r\n                right: 0,\r\n                bottom: 0\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nclass BasePlatform {\r\n acquireContext(canvas, aspectRatio) {}\r\n releaseContext(context) {\r\n        return false;\r\n    }\r\n addEventListener(chart, type, listener) {}\r\n removeEventListener(chart, type, listener) {}\r\n getDevicePixelRatio() {\r\n        return 1;\r\n    }\r\n getMaximumSize(element, width, height, aspectRatio) {\r\n        width = Math.max(0, width || element.width);\r\n        height = height || element.height;\r\n        return {\r\n            width,\r\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\r\n        };\r\n    }\r\n isAttached(canvas) {\r\n        return true;\r\n    }\r\n updateConfig(config) {\r\n    }\r\n}\r\n\r\nclass BasicPlatform extends BasePlatform {\r\n    acquireContext(item) {\r\n        return item && item.getContext && item.getContext('2d') || null;\r\n    }\r\n    updateConfig(config) {\r\n        config.options.animation = false;\r\n    }\r\n}\r\n\r\nconst EXPANDO_KEY = '$chartjs';\r\n const EVENT_TYPES = {\r\n    touchstart: 'mousedown',\r\n    touchmove: 'mousemove',\r\n    touchend: 'mouseup',\r\n    pointerenter: 'mouseenter',\r\n    pointerdown: 'mousedown',\r\n    pointermove: 'mousemove',\r\n    pointerup: 'mouseup',\r\n    pointerleave: 'mouseout',\r\n    pointerout: 'mouseout'\r\n};\r\nconst isNullOrEmpty = (value)=>value === null || value === '';\r\n function initCanvas(canvas, aspectRatio) {\r\n    const style = canvas.style;\r\n    const renderHeight = canvas.getAttribute('height');\r\n    const renderWidth = canvas.getAttribute('width');\r\n    canvas[EXPANDO_KEY] = {\r\n        initial: {\r\n            height: renderHeight,\r\n            width: renderWidth,\r\n            style: {\r\n                display: style.display,\r\n                height: style.height,\r\n                width: style.width\r\n            }\r\n        }\r\n    };\r\n    style.display = style.display || 'block';\r\n    style.boxSizing = style.boxSizing || 'border-box';\r\n    if (isNullOrEmpty(renderWidth)) {\r\n        const displayWidth = readUsedSize(canvas, 'width');\r\n        if (displayWidth !== undefined) {\r\n            canvas.width = displayWidth;\r\n        }\r\n    }\r\n    if (isNullOrEmpty(renderHeight)) {\r\n        if (canvas.style.height === '') {\r\n            canvas.height = canvas.width / (aspectRatio || 2);\r\n        } else {\r\n            const displayHeight = readUsedSize(canvas, 'height');\r\n            if (displayHeight !== undefined) {\r\n                canvas.height = displayHeight;\r\n            }\r\n        }\r\n    }\r\n    return canvas;\r\n}\r\nconst eventListenerOptions = supportsEventListenerOptions ? {\r\n    passive: true\r\n} : false;\r\nfunction addListener(node, type, listener) {\r\n    node.addEventListener(type, listener, eventListenerOptions);\r\n}\r\nfunction removeListener(chart, type, listener) {\r\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\nfunction fromNativeEvent(event, chart) {\r\n    const type = EVENT_TYPES[event.type] || event.type;\r\n    const { x , y  } = getRelativePosition(event, chart);\r\n    return {\r\n        type,\r\n        chart,\r\n        native: event,\r\n        x: x !== undefined ? x : null,\r\n        y: y !== undefined ? y : null\r\n    };\r\n}\r\nfunction nodeListContains(nodeList, canvas) {\r\n    for (const node of nodeList){\r\n        if (node === canvas || node.contains(canvas)) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction createAttachObserver(chart, type, listener) {\r\n    const canvas = chart.canvas;\r\n    const observer = new MutationObserver((entries)=>{\r\n        let trigger = false;\r\n        for (const entry of entries){\r\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\r\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\r\n        }\r\n        if (trigger) {\r\n            listener();\r\n        }\r\n    });\r\n    observer.observe(document, {\r\n        childList: true,\r\n        subtree: true\r\n    });\r\n    return observer;\r\n}\r\nfunction createDetachObserver(chart, type, listener) {\r\n    const canvas = chart.canvas;\r\n    const observer = new MutationObserver((entries)=>{\r\n        let trigger = false;\r\n        for (const entry of entries){\r\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\r\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\r\n        }\r\n        if (trigger) {\r\n            listener();\r\n        }\r\n    });\r\n    observer.observe(document, {\r\n        childList: true,\r\n        subtree: true\r\n    });\r\n    return observer;\r\n}\r\nconst drpListeningCharts = new Map();\r\nlet oldDevicePixelRatio = 0;\r\nfunction onWindowResize() {\r\n    const dpr = window.devicePixelRatio;\r\n    if (dpr === oldDevicePixelRatio) {\r\n        return;\r\n    }\r\n    oldDevicePixelRatio = dpr;\r\n    drpListeningCharts.forEach((resize, chart)=>{\r\n        if (chart.currentDevicePixelRatio !== dpr) {\r\n            resize();\r\n        }\r\n    });\r\n}\r\nfunction listenDevicePixelRatioChanges(chart, resize) {\r\n    if (!drpListeningCharts.size) {\r\n        window.addEventListener('resize', onWindowResize);\r\n    }\r\n    drpListeningCharts.set(chart, resize);\r\n}\r\nfunction unlistenDevicePixelRatioChanges(chart) {\r\n    drpListeningCharts.delete(chart);\r\n    if (!drpListeningCharts.size) {\r\n        window.removeEventListener('resize', onWindowResize);\r\n    }\r\n}\r\nfunction createResizeObserver(chart, type, listener) {\r\n    const canvas = chart.canvas;\r\n    const container = canvas && _getParentNode(canvas);\r\n    if (!container) {\r\n        return;\r\n    }\r\n    const resize = throttled((width, height)=>{\r\n        const w = container.clientWidth;\r\n        listener(width, height);\r\n        if (w < container.clientWidth) {\r\n            listener();\r\n        }\r\n    }, window);\r\n    const observer = new ResizeObserver((entries)=>{\r\n        const entry = entries[0];\r\n        const width = entry.contentRect.width;\r\n        const height = entry.contentRect.height;\r\n        if (width === 0 && height === 0) {\r\n            return;\r\n        }\r\n        resize(width, height);\r\n    });\r\n    observer.observe(container);\r\n    listenDevicePixelRatioChanges(chart, resize);\r\n    return observer;\r\n}\r\nfunction releaseObserver(chart, type, observer) {\r\n    if (observer) {\r\n        observer.disconnect();\r\n    }\r\n    if (type === 'resize') {\r\n        unlistenDevicePixelRatioChanges(chart);\r\n    }\r\n}\r\nfunction createProxyAndListen(chart, type, listener) {\r\n    const canvas = chart.canvas;\r\n    const proxy = throttled((event)=>{\r\n        if (chart.ctx !== null) {\r\n            listener(fromNativeEvent(event, chart));\r\n        }\r\n    }, chart);\r\n    addListener(canvas, type, proxy);\r\n    return proxy;\r\n}\r\n class DomPlatform extends BasePlatform {\r\n acquireContext(canvas, aspectRatio) {\r\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\r\n        if (context && context.canvas === canvas) {\r\n            initCanvas(canvas, aspectRatio);\r\n            return context;\r\n        }\r\n        return null;\r\n    }\r\n releaseContext(context) {\r\n        const canvas = context.canvas;\r\n        if (!canvas[EXPANDO_KEY]) {\r\n            return false;\r\n        }\r\n        const initial = canvas[EXPANDO_KEY].initial;\r\n        [\r\n            'height',\r\n            'width'\r\n        ].forEach((prop)=>{\r\n            const value = initial[prop];\r\n            if (isNullOrUndef(value)) {\r\n                canvas.removeAttribute(prop);\r\n            } else {\r\n                canvas.setAttribute(prop, value);\r\n            }\r\n        });\r\n        const style = initial.style || {};\r\n        Object.keys(style).forEach((key)=>{\r\n            canvas.style[key] = style[key];\r\n        });\r\n        canvas.width = canvas.width;\r\n        delete canvas[EXPANDO_KEY];\r\n        return true;\r\n    }\r\n addEventListener(chart, type, listener) {\r\n        this.removeEventListener(chart, type);\r\n        const proxies = chart.$proxies || (chart.$proxies = {});\r\n        const handlers = {\r\n            attach: createAttachObserver,\r\n            detach: createDetachObserver,\r\n            resize: createResizeObserver\r\n        };\r\n        const handler = handlers[type] || createProxyAndListen;\r\n        proxies[type] = handler(chart, type, listener);\r\n    }\r\n removeEventListener(chart, type) {\r\n        const proxies = chart.$proxies || (chart.$proxies = {});\r\n        const proxy = proxies[type];\r\n        if (!proxy) {\r\n            return;\r\n        }\r\n        const handlers = {\r\n            attach: releaseObserver,\r\n            detach: releaseObserver,\r\n            resize: releaseObserver\r\n        };\r\n        const handler = handlers[type] || removeListener;\r\n        handler(chart, type, proxy);\r\n        proxies[type] = undefined;\r\n    }\r\n    getDevicePixelRatio() {\r\n        return window.devicePixelRatio;\r\n    }\r\n getMaximumSize(canvas, width, height, aspectRatio) {\r\n        return getMaximumSize(canvas, width, height, aspectRatio);\r\n    }\r\n isAttached(canvas) {\r\n        const container = _getParentNode(canvas);\r\n        return !!(container && container.isConnected);\r\n    }\r\n}\r\n\r\nfunction _detectPlatform(canvas) {\r\n    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\r\n        return BasicPlatform;\r\n    }\r\n    return DomPlatform;\r\n}\r\n\r\nvar platforms = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\n_detectPlatform: _detectPlatform,\r\nBasePlatform: BasePlatform,\r\nBasicPlatform: BasicPlatform,\r\nDomPlatform: DomPlatform\r\n});\r\n\r\nconst transparent = 'transparent';\r\nconst interpolators = {\r\n    boolean (from, to, factor) {\r\n        return factor > 0.5 ? to : from;\r\n    },\r\n color (from, to, factor) {\r\n        const c0 = color(from || transparent);\r\n        const c1 = c0.valid && color(to || transparent);\r\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\r\n    },\r\n    number (from, to, factor) {\r\n        return from + (to - from) * factor;\r\n    }\r\n};\r\nclass Animation {\r\n    constructor(cfg, target, prop, to){\r\n        const currentValue = target[prop];\r\n        to = resolve([\r\n            cfg.to,\r\n            to,\r\n            currentValue,\r\n            cfg.from\r\n        ]);\r\n        const from = resolve([\r\n            cfg.from,\r\n            currentValue,\r\n            to\r\n        ]);\r\n        this._active = true;\r\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\r\n        this._easing = effects[cfg.easing] || effects.linear;\r\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\r\n        this._duration = this._total = Math.floor(cfg.duration);\r\n        this._loop = !!cfg.loop;\r\n        this._target = target;\r\n        this._prop = prop;\r\n        this._from = from;\r\n        this._to = to;\r\n        this._promises = undefined;\r\n    }\r\n    active() {\r\n        return this._active;\r\n    }\r\n    update(cfg, to, date) {\r\n        if (this._active) {\r\n            this._notify(false);\r\n            const currentValue = this._target[this._prop];\r\n            const elapsed = date - this._start;\r\n            const remain = this._duration - elapsed;\r\n            this._start = date;\r\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\r\n            this._total += elapsed;\r\n            this._loop = !!cfg.loop;\r\n            this._to = resolve([\r\n                cfg.to,\r\n                to,\r\n                currentValue,\r\n                cfg.from\r\n            ]);\r\n            this._from = resolve([\r\n                cfg.from,\r\n                currentValue,\r\n                to\r\n            ]);\r\n        }\r\n    }\r\n    cancel() {\r\n        if (this._active) {\r\n            this.tick(Date.now());\r\n            this._active = false;\r\n            this._notify(false);\r\n        }\r\n    }\r\n    tick(date) {\r\n        const elapsed = date - this._start;\r\n        const duration = this._duration;\r\n        const prop = this._prop;\r\n        const from = this._from;\r\n        const loop = this._loop;\r\n        const to = this._to;\r\n        let factor;\r\n        this._active = from !== to && (loop || elapsed < duration);\r\n        if (!this._active) {\r\n            this._target[prop] = to;\r\n            this._notify(true);\r\n            return;\r\n        }\r\n        if (elapsed < 0) {\r\n            this._target[prop] = from;\r\n            return;\r\n        }\r\n        factor = elapsed / duration % 2;\r\n        factor = loop && factor > 1 ? 2 - factor : factor;\r\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\r\n        this._target[prop] = this._fn(from, to, factor);\r\n    }\r\n    wait() {\r\n        const promises = this._promises || (this._promises = []);\r\n        return new Promise((res, rej)=>{\r\n            promises.push({\r\n                res,\r\n                rej\r\n            });\r\n        });\r\n    }\r\n    _notify(resolved) {\r\n        const method = resolved ? 'res' : 'rej';\r\n        const promises = this._promises || [];\r\n        for(let i = 0; i < promises.length; i++){\r\n            promises[i][method]();\r\n        }\r\n    }\r\n}\r\n\r\nclass Animations {\r\n    constructor(chart, config){\r\n        this._chart = chart;\r\n        this._properties = new Map();\r\n        this.configure(config);\r\n    }\r\n    configure(config) {\r\n        if (!isObject(config)) {\r\n            return;\r\n        }\r\n        const animationOptions = Object.keys(defaults.animation);\r\n        const animatedProps = this._properties;\r\n        Object.getOwnPropertyNames(config).forEach((key)=>{\r\n            const cfg = config[key];\r\n            if (!isObject(cfg)) {\r\n                return;\r\n            }\r\n            const resolved = {};\r\n            for (const option of animationOptions){\r\n                resolved[option] = cfg[option];\r\n            }\r\n            (isArray(cfg.properties) && cfg.properties || [\r\n                key\r\n            ]).forEach((prop)=>{\r\n                if (prop === key || !animatedProps.has(prop)) {\r\n                    animatedProps.set(prop, resolved);\r\n                }\r\n            });\r\n        });\r\n    }\r\n _animateOptions(target, values) {\r\n        const newOptions = values.options;\r\n        const options = resolveTargetOptions(target, newOptions);\r\n        if (!options) {\r\n            return [];\r\n        }\r\n        const animations = this._createAnimations(options, newOptions);\r\n        if (newOptions.$shared) {\r\n            awaitAll(target.options.$animations, newOptions).then(()=>{\r\n                target.options = newOptions;\r\n            }, ()=>{\r\n            });\r\n        }\r\n        return animations;\r\n    }\r\n _createAnimations(target, values) {\r\n        const animatedProps = this._properties;\r\n        const animations = [];\r\n        const running = target.$animations || (target.$animations = {});\r\n        const props = Object.keys(values);\r\n        const date = Date.now();\r\n        let i;\r\n        for(i = props.length - 1; i >= 0; --i){\r\n            const prop = props[i];\r\n            if (prop.charAt(0) === '$') {\r\n                continue;\r\n            }\r\n            if (prop === 'options') {\r\n                animations.push(...this._animateOptions(target, values));\r\n                continue;\r\n            }\r\n            const value = values[prop];\r\n            let animation = running[prop];\r\n            const cfg = animatedProps.get(prop);\r\n            if (animation) {\r\n                if (cfg && animation.active()) {\r\n                    animation.update(cfg, value, date);\r\n                    continue;\r\n                } else {\r\n                    animation.cancel();\r\n                }\r\n            }\r\n            if (!cfg || !cfg.duration) {\r\n                target[prop] = value;\r\n                continue;\r\n            }\r\n            running[prop] = animation = new Animation(cfg, target, prop, value);\r\n            animations.push(animation);\r\n        }\r\n        return animations;\r\n    }\r\n update(target, values) {\r\n        if (this._properties.size === 0) {\r\n            Object.assign(target, values);\r\n            return;\r\n        }\r\n        const animations = this._createAnimations(target, values);\r\n        if (animations.length) {\r\n            animator.add(this._chart, animations);\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction awaitAll(animations, properties) {\r\n    const running = [];\r\n    const keys = Object.keys(properties);\r\n    for(let i = 0; i < keys.length; i++){\r\n        const anim = animations[keys[i]];\r\n        if (anim && anim.active()) {\r\n            running.push(anim.wait());\r\n        }\r\n    }\r\n    return Promise.all(running);\r\n}\r\nfunction resolveTargetOptions(target, newOptions) {\r\n    if (!newOptions) {\r\n        return;\r\n    }\r\n    let options = target.options;\r\n    if (!options) {\r\n        target.options = newOptions;\r\n        return;\r\n    }\r\n    if (options.$shared) {\r\n        target.options = options = Object.assign({}, options, {\r\n            $shared: false,\r\n            $animations: {}\r\n        });\r\n    }\r\n    return options;\r\n}\r\n\r\nfunction scaleClip(scale, allowedOverflow) {\r\n    const opts = scale && scale.options || {};\r\n    const reverse = opts.reverse;\r\n    const min = opts.min === undefined ? allowedOverflow : 0;\r\n    const max = opts.max === undefined ? allowedOverflow : 0;\r\n    return {\r\n        start: reverse ? max : min,\r\n        end: reverse ? min : max\r\n    };\r\n}\r\nfunction defaultClip(xScale, yScale, allowedOverflow) {\r\n    if (allowedOverflow === false) {\r\n        return false;\r\n    }\r\n    const x = scaleClip(xScale, allowedOverflow);\r\n    const y = scaleClip(yScale, allowedOverflow);\r\n    return {\r\n        top: y.end,\r\n        right: x.end,\r\n        bottom: y.start,\r\n        left: x.start\r\n    };\r\n}\r\nfunction toClip(value) {\r\n    let t, r, b, l;\r\n    if (isObject(value)) {\r\n        t = value.top;\r\n        r = value.right;\r\n        b = value.bottom;\r\n        l = value.left;\r\n    } else {\r\n        t = r = b = l = value;\r\n    }\r\n    return {\r\n        top: t,\r\n        right: r,\r\n        bottom: b,\r\n        left: l,\r\n        disabled: value === false\r\n    };\r\n}\r\nfunction getSortedDatasetIndices(chart, filterVisible) {\r\n    const keys = [];\r\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\r\n    let i, ilen;\r\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\r\n        keys.push(metasets[i].index);\r\n    }\r\n    return keys;\r\n}\r\nfunction applyStack(stack, value, dsIndex, options = {}) {\r\n    const keys = stack.keys;\r\n    const singleMode = options.mode === 'single';\r\n    let i, ilen, datasetIndex, otherValue;\r\n    if (value === null) {\r\n        return;\r\n    }\r\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\r\n        datasetIndex = +keys[i];\r\n        if (datasetIndex === dsIndex) {\r\n            if (options.all) {\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        otherValue = stack.values[datasetIndex];\r\n        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\r\n            value += otherValue;\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction convertObjectDataToArray(data) {\r\n    const keys = Object.keys(data);\r\n    const adata = new Array(keys.length);\r\n    let i, ilen, key;\r\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\r\n        key = keys[i];\r\n        adata[i] = {\r\n            x: key,\r\n            y: data[key]\r\n        };\r\n    }\r\n    return adata;\r\n}\r\nfunction isStacked(scale, meta) {\r\n    const stacked = scale && scale.options.stacked;\r\n    return stacked || stacked === undefined && meta.stack !== undefined;\r\n}\r\nfunction getStackKey(indexScale, valueScale, meta) {\r\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\r\n}\r\nfunction getUserBounds(scale) {\r\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\r\n    return {\r\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\r\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\r\n    };\r\n}\r\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\r\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\r\n    return subStack[indexValue] || (subStack[indexValue] = {});\r\n}\r\nfunction getLastIndexInStack(stack, vScale, positive, type) {\r\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\r\n        const value = stack[meta.index];\r\n        if (positive && value > 0 || !positive && value < 0) {\r\n            return meta.index;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction updateStacks(controller, parsed) {\r\n    const { chart , _cachedMeta: meta  } = controller;\r\n    const stacks = chart._stacks || (chart._stacks = {});\r\n    const { iScale , vScale , index: datasetIndex  } = meta;\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const key = getStackKey(iScale, vScale, meta);\r\n    const ilen = parsed.length;\r\n    let stack;\r\n    for(let i = 0; i < ilen; ++i){\r\n        const item = parsed[i];\r\n        const { [iAxis]: index , [vAxis]: value  } = item;\r\n        const itemStacks = item._stacks || (item._stacks = {});\r\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\r\n        stack[datasetIndex] = value;\r\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\r\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\r\n        const visualValues = stack._visualValues || (stack._visualValues = {});\r\n        visualValues[datasetIndex] = value;\r\n    }\r\n}\r\nfunction getFirstScaleId(chart, axis) {\r\n    const scales = chart.scales;\r\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\r\n}\r\nfunction createDatasetContext(parent, index) {\r\n    return createContext(parent, {\r\n        active: false,\r\n        dataset: undefined,\r\n        datasetIndex: index,\r\n        index,\r\n        mode: 'default',\r\n        type: 'dataset'\r\n    });\r\n}\r\nfunction createDataContext(parent, index, element) {\r\n    return createContext(parent, {\r\n        active: false,\r\n        dataIndex: index,\r\n        parsed: undefined,\r\n        raw: undefined,\r\n        element,\r\n        index,\r\n        mode: 'default',\r\n        type: 'data'\r\n    });\r\n}\r\nfunction clearStacks(meta, items) {\r\n    const datasetIndex = meta.controller.index;\r\n    const axis = meta.vScale && meta.vScale.axis;\r\n    if (!axis) {\r\n        return;\r\n    }\r\n    items = items || meta._parsed;\r\n    for (const parsed of items){\r\n        const stacks = parsed._stacks;\r\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\r\n            return;\r\n        }\r\n        delete stacks[axis][datasetIndex];\r\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\r\n            delete stacks[axis]._visualValues[datasetIndex];\r\n        }\r\n    }\r\n}\r\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\r\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\r\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\r\n        keys: getSortedDatasetIndices(chart, true),\r\n        values: null\r\n    };\r\nclass DatasetController {\r\n static defaults = {};\r\n static datasetElementType = null;\r\n static dataElementType = null;\r\n constructor(chart, datasetIndex){\r\n        this.chart = chart;\r\n        this._ctx = chart.ctx;\r\n        this.index = datasetIndex;\r\n        this._cachedDataOpts = {};\r\n        this._cachedMeta = this.getMeta();\r\n        this._type = this._cachedMeta.type;\r\n        this.options = undefined;\r\n         this._parsing = false;\r\n        this._data = undefined;\r\n        this._objectData = undefined;\r\n        this._sharedOptions = undefined;\r\n        this._drawStart = undefined;\r\n        this._drawCount = undefined;\r\n        this.enableOptionSharing = false;\r\n        this.supportsDecimation = false;\r\n        this.$context = undefined;\r\n        this._syncList = [];\r\n        this.datasetElementType = new.target.datasetElementType;\r\n        this.dataElementType = new.target.dataElementType;\r\n        this.initialize();\r\n    }\r\n    initialize() {\r\n        const meta = this._cachedMeta;\r\n        this.configure();\r\n        this.linkScales();\r\n        meta._stacked = isStacked(meta.vScale, meta);\r\n        this.addElements();\r\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\r\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\r\n        }\r\n    }\r\n    updateIndex(datasetIndex) {\r\n        if (this.index !== datasetIndex) {\r\n            clearStacks(this._cachedMeta);\r\n        }\r\n        this.index = datasetIndex;\r\n    }\r\n    linkScales() {\r\n        const chart = this.chart;\r\n        const meta = this._cachedMeta;\r\n        const dataset = this.getDataset();\r\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\r\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\r\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\r\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\r\n        const indexAxis = meta.indexAxis;\r\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\r\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\r\n        meta.xScale = this.getScaleForId(xid);\r\n        meta.yScale = this.getScaleForId(yid);\r\n        meta.rScale = this.getScaleForId(rid);\r\n        meta.iScale = this.getScaleForId(iid);\r\n        meta.vScale = this.getScaleForId(vid);\r\n    }\r\n    getDataset() {\r\n        return this.chart.data.datasets[this.index];\r\n    }\r\n    getMeta() {\r\n        return this.chart.getDatasetMeta(this.index);\r\n    }\r\n getScaleForId(scaleID) {\r\n        return this.chart.scales[scaleID];\r\n    }\r\n _getOtherScale(scale) {\r\n        const meta = this._cachedMeta;\r\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\r\n    }\r\n    reset() {\r\n        this._update('reset');\r\n    }\r\n _destroy() {\r\n        const meta = this._cachedMeta;\r\n        if (this._data) {\r\n            unlistenArrayEvents(this._data, this);\r\n        }\r\n        if (meta._stacked) {\r\n            clearStacks(meta);\r\n        }\r\n    }\r\n _dataCheck() {\r\n        const dataset = this.getDataset();\r\n        const data = dataset.data || (dataset.data = []);\r\n        const _data = this._data;\r\n        if (isObject(data)) {\r\n            this._data = convertObjectDataToArray(data);\r\n        } else if (_data !== data) {\r\n            if (_data) {\r\n                unlistenArrayEvents(_data, this);\r\n                const meta = this._cachedMeta;\r\n                clearStacks(meta);\r\n                meta._parsed = [];\r\n            }\r\n            if (data && Object.isExtensible(data)) {\r\n                listenArrayEvents(data, this);\r\n            }\r\n            this._syncList = [];\r\n            this._data = data;\r\n        }\r\n    }\r\n    addElements() {\r\n        const meta = this._cachedMeta;\r\n        this._dataCheck();\r\n        if (this.datasetElementType) {\r\n            meta.dataset = new this.datasetElementType();\r\n        }\r\n    }\r\n    buildOrUpdateElements(resetNewElements) {\r\n        const meta = this._cachedMeta;\r\n        const dataset = this.getDataset();\r\n        let stackChanged = false;\r\n        this._dataCheck();\r\n        const oldStacked = meta._stacked;\r\n        meta._stacked = isStacked(meta.vScale, meta);\r\n        if (meta.stack !== dataset.stack) {\r\n            stackChanged = true;\r\n            clearStacks(meta);\r\n            meta.stack = dataset.stack;\r\n        }\r\n        this._resyncElements(resetNewElements);\r\n        if (stackChanged || oldStacked !== meta._stacked) {\r\n            updateStacks(this, meta._parsed);\r\n        }\r\n    }\r\n configure() {\r\n        const config = this.chart.config;\r\n        const scopeKeys = config.datasetScopeKeys(this._type);\r\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\r\n        this.options = config.createResolver(scopes, this.getContext());\r\n        this._parsing = this.options.parsing;\r\n        this._cachedDataOpts = {};\r\n    }\r\n parse(start, count) {\r\n        const { _cachedMeta: meta , _data: data  } = this;\r\n        const { iScale , _stacked  } = meta;\r\n        const iAxis = iScale.axis;\r\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\r\n        let prev = start > 0 && meta._parsed[start - 1];\r\n        let i, cur, parsed;\r\n        if (this._parsing === false) {\r\n            meta._parsed = data;\r\n            meta._sorted = true;\r\n            parsed = data;\r\n        } else {\r\n            if (isArray(data[start])) {\r\n                parsed = this.parseArrayData(meta, data, start, count);\r\n            } else if (isObject(data[start])) {\r\n                parsed = this.parseObjectData(meta, data, start, count);\r\n            } else {\r\n                parsed = this.parsePrimitiveData(meta, data, start, count);\r\n            }\r\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\r\n            for(i = 0; i < count; ++i){\r\n                meta._parsed[i + start] = cur = parsed[i];\r\n                if (sorted) {\r\n                    if (isNotInOrderComparedToPrev()) {\r\n                        sorted = false;\r\n                    }\r\n                    prev = cur;\r\n                }\r\n            }\r\n            meta._sorted = sorted;\r\n        }\r\n        if (_stacked) {\r\n            updateStacks(this, parsed);\r\n        }\r\n    }\r\n parsePrimitiveData(meta, data, start, count) {\r\n        const { iScale , vScale  } = meta;\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        const labels = iScale.getLabels();\r\n        const singleScale = iScale === vScale;\r\n        const parsed = new Array(count);\r\n        let i, ilen, index;\r\n        for(i = 0, ilen = count; i < ilen; ++i){\r\n            index = i + start;\r\n            parsed[i] = {\r\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\r\n                [vAxis]: vScale.parse(data[index], index)\r\n            };\r\n        }\r\n        return parsed;\r\n    }\r\n parseArrayData(meta, data, start, count) {\r\n        const { xScale , yScale  } = meta;\r\n        const parsed = new Array(count);\r\n        let i, ilen, index, item;\r\n        for(i = 0, ilen = count; i < ilen; ++i){\r\n            index = i + start;\r\n            item = data[index];\r\n            parsed[i] = {\r\n                x: xScale.parse(item[0], index),\r\n                y: yScale.parse(item[1], index)\r\n            };\r\n        }\r\n        return parsed;\r\n    }\r\n parseObjectData(meta, data, start, count) {\r\n        const { xScale , yScale  } = meta;\r\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\r\n        const parsed = new Array(count);\r\n        let i, ilen, index, item;\r\n        for(i = 0, ilen = count; i < ilen; ++i){\r\n            index = i + start;\r\n            item = data[index];\r\n            parsed[i] = {\r\n                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\r\n                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\r\n            };\r\n        }\r\n        return parsed;\r\n    }\r\n getParsed(index) {\r\n        return this._cachedMeta._parsed[index];\r\n    }\r\n getDataElement(index) {\r\n        return this._cachedMeta.data[index];\r\n    }\r\n applyStack(scale, parsed, mode) {\r\n        const chart = this.chart;\r\n        const meta = this._cachedMeta;\r\n        const value = parsed[scale.axis];\r\n        const stack = {\r\n            keys: getSortedDatasetIndices(chart, true),\r\n            values: parsed._stacks[scale.axis]._visualValues\r\n        };\r\n        return applyStack(stack, value, meta.index, {\r\n            mode\r\n        });\r\n    }\r\n updateRangeFromParsed(range, scale, parsed, stack) {\r\n        const parsedValue = parsed[scale.axis];\r\n        let value = parsedValue === null ? NaN : parsedValue;\r\n        const values = stack && parsed._stacks[scale.axis];\r\n        if (stack && values) {\r\n            stack.values = values;\r\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\r\n        }\r\n        range.min = Math.min(range.min, value);\r\n        range.max = Math.max(range.max, value);\r\n    }\r\n getMinMax(scale, canStack) {\r\n        const meta = this._cachedMeta;\r\n        const _parsed = meta._parsed;\r\n        const sorted = meta._sorted && scale === meta.iScale;\r\n        const ilen = _parsed.length;\r\n        const otherScale = this._getOtherScale(scale);\r\n        const stack = createStack(canStack, meta, this.chart);\r\n        const range = {\r\n            min: Number.POSITIVE_INFINITY,\r\n            max: Number.NEGATIVE_INFINITY\r\n        };\r\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\r\n        let i, parsed;\r\n        function _skip() {\r\n            parsed = _parsed[i];\r\n            const otherValue = parsed[otherScale.axis];\r\n            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\r\n        }\r\n        for(i = 0; i < ilen; ++i){\r\n            if (_skip()) {\r\n                continue;\r\n            }\r\n            this.updateRangeFromParsed(range, scale, parsed, stack);\r\n            if (sorted) {\r\n                break;\r\n            }\r\n        }\r\n        if (sorted) {\r\n            for(i = ilen - 1; i >= 0; --i){\r\n                if (_skip()) {\r\n                    continue;\r\n                }\r\n                this.updateRangeFromParsed(range, scale, parsed, stack);\r\n                break;\r\n            }\r\n        }\r\n        return range;\r\n    }\r\n    getAllParsedValues(scale) {\r\n        const parsed = this._cachedMeta._parsed;\r\n        const values = [];\r\n        let i, ilen, value;\r\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\r\n            value = parsed[i][scale.axis];\r\n            if (isNumberFinite(value)) {\r\n                values.push(value);\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n getMaxOverflow() {\r\n        return false;\r\n    }\r\n getLabelAndValue(index) {\r\n        const meta = this._cachedMeta;\r\n        const iScale = meta.iScale;\r\n        const vScale = meta.vScale;\r\n        const parsed = this.getParsed(index);\r\n        return {\r\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\r\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\r\n        };\r\n    }\r\n _update(mode) {\r\n        const meta = this._cachedMeta;\r\n        this.update(mode || 'default');\r\n        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\r\n    }\r\n update(mode) {}\r\n    draw() {\r\n        const ctx = this._ctx;\r\n        const chart = this.chart;\r\n        const meta = this._cachedMeta;\r\n        const elements = meta.data || [];\r\n        const area = chart.chartArea;\r\n        const active = [];\r\n        const start = this._drawStart || 0;\r\n        const count = this._drawCount || elements.length - start;\r\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\r\n        let i;\r\n        if (meta.dataset) {\r\n            meta.dataset.draw(ctx, area, start, count);\r\n        }\r\n        for(i = start; i < start + count; ++i){\r\n            const element = elements[i];\r\n            if (element.hidden) {\r\n                continue;\r\n            }\r\n            if (element.active && drawActiveElementsOnTop) {\r\n                active.push(element);\r\n            } else {\r\n                element.draw(ctx, area);\r\n            }\r\n        }\r\n        for(i = 0; i < active.length; ++i){\r\n            active[i].draw(ctx, area);\r\n        }\r\n    }\r\n getStyle(index, active) {\r\n        const mode = active ? 'active' : 'default';\r\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\r\n    }\r\n getContext(index, active, mode) {\r\n        const dataset = this.getDataset();\r\n        let context;\r\n        if (index >= 0 && index < this._cachedMeta.data.length) {\r\n            const element = this._cachedMeta.data[index];\r\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\r\n            context.parsed = this.getParsed(index);\r\n            context.raw = dataset.data[index];\r\n            context.index = context.dataIndex = index;\r\n        } else {\r\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\r\n            context.dataset = dataset;\r\n            context.index = context.datasetIndex = this.index;\r\n        }\r\n        context.active = !!active;\r\n        context.mode = mode;\r\n        return context;\r\n    }\r\n resolveDatasetElementOptions(mode) {\r\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\r\n    }\r\n resolveDataElementOptions(index, mode) {\r\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\r\n    }\r\n _resolveElementOptions(elementType, mode = 'default', index) {\r\n        const active = mode === 'active';\r\n        const cache = this._cachedDataOpts;\r\n        const cacheKey = elementType + '-' + mode;\r\n        const cached = cache[cacheKey];\r\n        const sharing = this.enableOptionSharing && defined(index);\r\n        if (cached) {\r\n            return cloneIfNotShared(cached, sharing);\r\n        }\r\n        const config = this.chart.config;\r\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\r\n        const prefixes = active ? [\r\n            `${elementType}Hover`,\r\n            'hover',\r\n            elementType,\r\n            ''\r\n        ] : [\r\n            elementType,\r\n            ''\r\n        ];\r\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n        const names = Object.keys(defaults.elements[elementType]);\r\n        const context = ()=>this.getContext(index, active, mode);\r\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\r\n        if (values.$shared) {\r\n            values.$shared = sharing;\r\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\r\n        }\r\n        return values;\r\n    }\r\n _resolveAnimations(index, transition, active) {\r\n        const chart = this.chart;\r\n        const cache = this._cachedDataOpts;\r\n        const cacheKey = `animation-${transition}`;\r\n        const cached = cache[cacheKey];\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n        let options;\r\n        if (chart.options.animation !== false) {\r\n            const config = this.chart.config;\r\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\r\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\r\n        }\r\n        const animations = new Animations(chart, options && options.animations);\r\n        if (options && options._cacheable) {\r\n            cache[cacheKey] = Object.freeze(animations);\r\n        }\r\n        return animations;\r\n    }\r\n getSharedOptions(options) {\r\n        if (!options.$shared) {\r\n            return;\r\n        }\r\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\r\n    }\r\n includeOptions(mode, sharedOptions) {\r\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\r\n    }\r\n _getSharedOptions(start, mode) {\r\n        const firstOpts = this.resolveDataElementOptions(start, mode);\r\n        const previouslySharedOptions = this._sharedOptions;\r\n        const sharedOptions = this.getSharedOptions(firstOpts);\r\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\r\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n        return {\r\n            sharedOptions,\r\n            includeOptions\r\n        };\r\n    }\r\n updateElement(element, index, properties, mode) {\r\n        if (isDirectUpdateMode(mode)) {\r\n            Object.assign(element, properties);\r\n        } else {\r\n            this._resolveAnimations(index, mode).update(element, properties);\r\n        }\r\n    }\r\n updateSharedOptions(sharedOptions, mode, newOptions) {\r\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\r\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\r\n        }\r\n    }\r\n _setStyle(element, index, mode, active) {\r\n        element.active = active;\r\n        const options = this.getStyle(index, active);\r\n        this._resolveAnimations(index, mode, active).update(element, {\r\n            options: !active && this.getSharedOptions(options) || options\r\n        });\r\n    }\r\n    removeHoverStyle(element, datasetIndex, index) {\r\n        this._setStyle(element, index, 'active', false);\r\n    }\r\n    setHoverStyle(element, datasetIndex, index) {\r\n        this._setStyle(element, index, 'active', true);\r\n    }\r\n _removeDatasetHoverStyle() {\r\n        const element = this._cachedMeta.dataset;\r\n        if (element) {\r\n            this._setStyle(element, undefined, 'active', false);\r\n        }\r\n    }\r\n _setDatasetHoverStyle() {\r\n        const element = this._cachedMeta.dataset;\r\n        if (element) {\r\n            this._setStyle(element, undefined, 'active', true);\r\n        }\r\n    }\r\n _resyncElements(resetNewElements) {\r\n        const data = this._data;\r\n        const elements = this._cachedMeta.data;\r\n        for (const [method, arg1, arg2] of this._syncList){\r\n            this[method](arg1, arg2);\r\n        }\r\n        this._syncList = [];\r\n        const numMeta = elements.length;\r\n        const numData = data.length;\r\n        const count = Math.min(numData, numMeta);\r\n        if (count) {\r\n            this.parse(0, count);\r\n        }\r\n        if (numData > numMeta) {\r\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\r\n        } else if (numData < numMeta) {\r\n            this._removeElements(numData, numMeta - numData);\r\n        }\r\n    }\r\n _insertElements(start, count, resetNewElements = true) {\r\n        const meta = this._cachedMeta;\r\n        const data = meta.data;\r\n        const end = start + count;\r\n        let i;\r\n        const move = (arr)=>{\r\n            arr.length += count;\r\n            for(i = arr.length - 1; i >= end; i--){\r\n                arr[i] = arr[i - count];\r\n            }\r\n        };\r\n        move(data);\r\n        for(i = start; i < end; ++i){\r\n            data[i] = new this.dataElementType();\r\n        }\r\n        if (this._parsing) {\r\n            move(meta._parsed);\r\n        }\r\n        this.parse(start, count);\r\n        if (resetNewElements) {\r\n            this.updateElements(data, start, count, 'reset');\r\n        }\r\n    }\r\n    updateElements(element, start, count, mode) {}\r\n _removeElements(start, count) {\r\n        const meta = this._cachedMeta;\r\n        if (this._parsing) {\r\n            const removed = meta._parsed.splice(start, count);\r\n            if (meta._stacked) {\r\n                clearStacks(meta, removed);\r\n            }\r\n        }\r\n        meta.data.splice(start, count);\r\n    }\r\n _sync(args) {\r\n        if (this._parsing) {\r\n            this._syncList.push(args);\r\n        } else {\r\n            const [method, arg1, arg2] = args;\r\n            this[method](arg1, arg2);\r\n        }\r\n        this.chart._dataChanges.push([\r\n            this.index,\r\n            ...args\r\n        ]);\r\n    }\r\n    _onDataPush() {\r\n        const count = arguments.length;\r\n        this._sync([\r\n            '_insertElements',\r\n            this.getDataset().data.length - count,\r\n            count\r\n        ]);\r\n    }\r\n    _onDataPop() {\r\n        this._sync([\r\n            '_removeElements',\r\n            this._cachedMeta.data.length - 1,\r\n            1\r\n        ]);\r\n    }\r\n    _onDataShift() {\r\n        this._sync([\r\n            '_removeElements',\r\n            0,\r\n            1\r\n        ]);\r\n    }\r\n    _onDataSplice(start, count) {\r\n        if (count) {\r\n            this._sync([\r\n                '_removeElements',\r\n                start,\r\n                count\r\n            ]);\r\n        }\r\n        const newCount = arguments.length - 2;\r\n        if (newCount) {\r\n            this._sync([\r\n                '_insertElements',\r\n                start,\r\n                newCount\r\n            ]);\r\n        }\r\n    }\r\n    _onDataUnshift() {\r\n        this._sync([\r\n            '_insertElements',\r\n            0,\r\n            arguments.length\r\n        ]);\r\n    }\r\n}\r\n\r\nclass Element {\r\n    static defaults = {};\r\n    static defaultRoutes = undefined;\r\n    active = false;\r\n    tooltipPosition(useFinalPosition) {\r\n        const { x , y  } = this.getProps([\r\n            'x',\r\n            'y'\r\n        ], useFinalPosition);\r\n        return {\r\n            x,\r\n            y\r\n        };\r\n    }\r\n    hasValue() {\r\n        return isNumber(this.x) && isNumber(this.y);\r\n    }\r\n    getProps(props, final) {\r\n        const anims = this.$animations;\r\n        if (!final || !anims) {\r\n            // let's not create an object, if not needed\r\n            return this;\r\n        }\r\n        const ret = {};\r\n        props.forEach((prop)=>{\r\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\r\n        });\r\n        return ret;\r\n    }\r\n}\r\n\r\nfunction autoSkip(scale, ticks) {\r\n    const tickOpts = scale.options.ticks;\r\n    const determinedMaxTicks = determineMaxTicks(scale);\r\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\r\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n    const numMajorIndices = majorIndices.length;\r\n    const first = majorIndices[0];\r\n    const last = majorIndices[numMajorIndices - 1];\r\n    const newTicks = [];\r\n    if (numMajorIndices > ticksLimit) {\r\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\r\n        return newTicks;\r\n    }\r\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\r\n    if (numMajorIndices > 0) {\r\n        let i, ilen;\r\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\r\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\r\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n        }\r\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n        return newTicks;\r\n    }\r\n    skip(ticks, newTicks, spacing);\r\n    return newTicks;\r\n}\r\nfunction determineMaxTicks(scale) {\r\n    const offset = scale.options.offset;\r\n    const tickLength = scale._tickSize();\r\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\r\n    const maxChart = scale._maxLength / tickLength;\r\n    return Math.floor(Math.min(maxScale, maxChart));\r\n}\r\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\r\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\r\n    const spacing = ticks.length / ticksLimit;\r\n    if (!evenMajorSpacing) {\r\n        return Math.max(spacing, 1);\r\n    }\r\n    const factors = _factorize(evenMajorSpacing);\r\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\r\n        const factor = factors[i];\r\n        if (factor > spacing) {\r\n            return factor;\r\n        }\r\n    }\r\n    return Math.max(spacing, 1);\r\n}\r\n function getMajorIndices(ticks) {\r\n    const result = [];\r\n    let i, ilen;\r\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\r\n        if (ticks[i].major) {\r\n            result.push(i);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\r\n    let count = 0;\r\n    let next = majorIndices[0];\r\n    let i;\r\n    spacing = Math.ceil(spacing);\r\n    for(i = 0; i < ticks.length; i++){\r\n        if (i === next) {\r\n            newTicks.push(ticks[i]);\r\n            count++;\r\n            next = majorIndices[count * spacing];\r\n        }\r\n    }\r\n}\r\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\r\n    const start = valueOrDefault(majorStart, 0);\r\n    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\r\n    let count = 0;\r\n    let length, i, next;\r\n    spacing = Math.ceil(spacing);\r\n    if (majorEnd) {\r\n        length = majorEnd - majorStart;\r\n        spacing = length / Math.floor(length / spacing);\r\n    }\r\n    next = start;\r\n    while(next < 0){\r\n        count++;\r\n        next = Math.round(start + count * spacing);\r\n    }\r\n    for(i = Math.max(start, 0); i < end; i++){\r\n        if (i === next) {\r\n            newTicks.push(ticks[i]);\r\n            count++;\r\n            next = Math.round(start + count * spacing);\r\n        }\r\n    }\r\n}\r\n function getEvenSpacing(arr) {\r\n    const len = arr.length;\r\n    let i, diff;\r\n    if (len < 2) {\r\n        return false;\r\n    }\r\n    for(diff = arr[0], i = 1; i < len; ++i){\r\n        if (arr[i] - arr[i - 1] !== diff) {\r\n            return false;\r\n        }\r\n    }\r\n    return diff;\r\n}\r\n\r\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\r\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\r\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\r\n function sample(arr, numItems) {\r\n    const result = [];\r\n    const increment = arr.length / numItems;\r\n    const len = arr.length;\r\n    let i = 0;\r\n    for(; i < len; i += increment){\r\n        result.push(arr[Math.floor(i)]);\r\n    }\r\n    return result;\r\n}\r\n function getPixelForGridLine(scale, index, offsetGridLines) {\r\n    const length = scale.ticks.length;\r\n    const validIndex = Math.min(index, length - 1);\r\n    const start = scale._startPixel;\r\n    const end = scale._endPixel;\r\n    const epsilon = 1e-6;\r\n    let lineValue = scale.getPixelForTick(validIndex);\r\n    let offset;\r\n    if (offsetGridLines) {\r\n        if (length === 1) {\r\n            offset = Math.max(lineValue - start, end - lineValue);\r\n        } else if (index === 0) {\r\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n        } else {\r\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n        }\r\n        lineValue += validIndex < index ? offset : -offset;\r\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n            return;\r\n        }\r\n    }\r\n    return lineValue;\r\n}\r\n function garbageCollect(caches, length) {\r\n    each(caches, (cache)=>{\r\n        const gc = cache.gc;\r\n        const gcLen = gc.length / 2;\r\n        let i;\r\n        if (gcLen > length) {\r\n            for(i = 0; i < gcLen; ++i){\r\n                delete cache.data[gc[i]];\r\n            }\r\n            gc.splice(0, gcLen);\r\n        }\r\n    });\r\n}\r\n function getTickMarkLength(options) {\r\n    return options.drawTicks ? options.tickLength : 0;\r\n}\r\n function getTitleHeight(options, fallback) {\r\n    if (!options.display) {\r\n        return 0;\r\n    }\r\n    const font = toFont(options.font, fallback);\r\n    const padding = toPadding(options.padding);\r\n    const lines = isArray(options.text) ? options.text.length : 1;\r\n    return lines * font.lineHeight + padding.height;\r\n}\r\nfunction createScaleContext(parent, scale) {\r\n    return createContext(parent, {\r\n        scale,\r\n        type: 'scale'\r\n    });\r\n}\r\nfunction createTickContext(parent, index, tick) {\r\n    return createContext(parent, {\r\n        tick,\r\n        index,\r\n        type: 'tick'\r\n    });\r\n}\r\nfunction titleAlign(align, position, reverse) {\r\n    let ret = _toLeftRightCenter(align);\r\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\r\n        ret = reverseAlign(ret);\r\n    }\r\n    return ret;\r\n}\r\nfunction titleArgs(scale, offset, position, align) {\r\n    const { top , left , bottom , right , chart  } = scale;\r\n    const { chartArea , scales  } = chart;\r\n    let rotation = 0;\r\n    let maxWidth, titleX, titleY;\r\n    const height = bottom - top;\r\n    const width = right - left;\r\n    if (scale.isHorizontal()) {\r\n        titleX = _alignStartEnd(align, left, right);\r\n        if (isObject(position)) {\r\n            const positionAxisID = Object.keys(position)[0];\r\n            const value = position[positionAxisID];\r\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\r\n        } else if (position === 'center') {\r\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\r\n        } else {\r\n            titleY = offsetFromEdge(scale, position, offset);\r\n        }\r\n        maxWidth = right - left;\r\n    } else {\r\n        if (isObject(position)) {\r\n            const positionAxisID1 = Object.keys(position)[0];\r\n            const value1 = position[positionAxisID1];\r\n            titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;\r\n        } else if (position === 'center') {\r\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\r\n        } else {\r\n            titleX = offsetFromEdge(scale, position, offset);\r\n        }\r\n        titleY = _alignStartEnd(align, bottom, top);\r\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\r\n    }\r\n    return {\r\n        titleX,\r\n        titleY,\r\n        maxWidth,\r\n        rotation\r\n    };\r\n}\r\nclass Scale extends Element {\r\n    constructor(cfg){\r\n        super();\r\n         this.id = cfg.id;\r\n         this.type = cfg.type;\r\n         this.options = undefined;\r\n         this.ctx = cfg.ctx;\r\n         this.chart = cfg.chart;\r\n         this.top = undefined;\r\n         this.bottom = undefined;\r\n         this.left = undefined;\r\n         this.right = undefined;\r\n         this.width = undefined;\r\n         this.height = undefined;\r\n        this._margins = {\r\n            left: 0,\r\n            right: 0,\r\n            top: 0,\r\n            bottom: 0\r\n        };\r\n         this.maxWidth = undefined;\r\n         this.maxHeight = undefined;\r\n         this.paddingTop = undefined;\r\n         this.paddingBottom = undefined;\r\n         this.paddingLeft = undefined;\r\n         this.paddingRight = undefined;\r\n         this.axis = undefined;\r\n         this.labelRotation = undefined;\r\n        this.min = undefined;\r\n        this.max = undefined;\r\n        this._range = undefined;\r\n         this.ticks = [];\r\n         this._gridLineItems = null;\r\n         this._labelItems = null;\r\n         this._labelSizes = null;\r\n        this._length = 0;\r\n        this._maxLength = 0;\r\n        this._longestTextCache = {};\r\n         this._startPixel = undefined;\r\n         this._endPixel = undefined;\r\n        this._reversePixels = false;\r\n        this._userMax = undefined;\r\n        this._userMin = undefined;\r\n        this._suggestedMax = undefined;\r\n        this._suggestedMin = undefined;\r\n        this._ticksLength = 0;\r\n        this._borderValue = 0;\r\n        this._cache = {};\r\n        this._dataLimitsCached = false;\r\n        this.$context = undefined;\r\n    }\r\n init(options) {\r\n        this.options = options.setContext(this.getContext());\r\n        this.axis = options.axis;\r\n        this._userMin = this.parse(options.min);\r\n        this._userMax = this.parse(options.max);\r\n        this._suggestedMin = this.parse(options.suggestedMin);\r\n        this._suggestedMax = this.parse(options.suggestedMax);\r\n    }\r\n parse(raw, index) {\r\n        return raw;\r\n    }\r\n getUserBounds() {\r\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\r\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\r\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\r\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\r\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\r\n        return {\r\n            min: finiteOrDefault(_userMin, _suggestedMin),\r\n            max: finiteOrDefault(_userMax, _suggestedMax),\r\n            minDefined: isNumberFinite(_userMin),\r\n            maxDefined: isNumberFinite(_userMax)\r\n        };\r\n    }\r\n getMinMax(canStack) {\r\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\r\n        let range;\r\n        if (minDefined && maxDefined) {\r\n            return {\r\n                min,\r\n                max\r\n            };\r\n        }\r\n        const metas = this.getMatchingVisibleMetas();\r\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\r\n            range = metas[i].controller.getMinMax(this, canStack);\r\n            if (!minDefined) {\r\n                min = Math.min(min, range.min);\r\n            }\r\n            if (!maxDefined) {\r\n                max = Math.max(max, range.max);\r\n            }\r\n        }\r\n        min = maxDefined && min > max ? max : min;\r\n        max = minDefined && min > max ? min : max;\r\n        return {\r\n            min: finiteOrDefault(min, finiteOrDefault(max, min)),\r\n            max: finiteOrDefault(max, finiteOrDefault(min, max))\r\n        };\r\n    }\r\n getPadding() {\r\n        return {\r\n            left: this.paddingLeft || 0,\r\n            top: this.paddingTop || 0,\r\n            right: this.paddingRight || 0,\r\n            bottom: this.paddingBottom || 0\r\n        };\r\n    }\r\n getTicks() {\r\n        return this.ticks;\r\n    }\r\n getLabels() {\r\n        const data = this.chart.data;\r\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n    }\r\n getLabelItems(chartArea = this.chart.chartArea) {\r\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\r\n        return items;\r\n    }\r\n    beforeLayout() {\r\n        this._cache = {};\r\n        this._dataLimitsCached = false;\r\n    }\r\n    beforeUpdate() {\r\n        callback(this.options.beforeUpdate, [\r\n            this\r\n        ]);\r\n    }\r\n update(maxWidth, maxHeight, margins) {\r\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\r\n        const sampleSize = tickOpts.sampleSize;\r\n        this.beforeUpdate();\r\n        this.maxWidth = maxWidth;\r\n        this.maxHeight = maxHeight;\r\n        this._margins = margins = Object.assign({\r\n            left: 0,\r\n            right: 0,\r\n            top: 0,\r\n            bottom: 0\r\n        }, margins);\r\n        this.ticks = null;\r\n        this._labelSizes = null;\r\n        this._gridLineItems = null;\r\n        this._labelItems = null;\r\n        this.beforeSetDimensions();\r\n        this.setDimensions();\r\n        this.afterSetDimensions();\r\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\r\n        if (!this._dataLimitsCached) {\r\n            this.beforeDataLimits();\r\n            this.determineDataLimits();\r\n            this.afterDataLimits();\r\n            this._range = _addGrace(this, grace, beginAtZero);\r\n            this._dataLimitsCached = true;\r\n        }\r\n        this.beforeBuildTicks();\r\n        this.ticks = this.buildTicks() || [];\r\n        this.afterBuildTicks();\r\n        const samplingEnabled = sampleSize < this.ticks.length;\r\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\r\n        this.configure();\r\n        this.beforeCalculateLabelRotation();\r\n        this.calculateLabelRotation();\r\n        this.afterCalculateLabelRotation();\r\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\r\n            this.ticks = autoSkip(this, this.ticks);\r\n            this._labelSizes = null;\r\n            this.afterAutoSkip();\r\n        }\r\n        if (samplingEnabled) {\r\n            this._convertTicksToLabels(this.ticks);\r\n        }\r\n        this.beforeFit();\r\n        this.fit();\r\n        this.afterFit();\r\n        this.afterUpdate();\r\n    }\r\n configure() {\r\n        let reversePixels = this.options.reverse;\r\n        let startPixel, endPixel;\r\n        if (this.isHorizontal()) {\r\n            startPixel = this.left;\r\n            endPixel = this.right;\r\n        } else {\r\n            startPixel = this.top;\r\n            endPixel = this.bottom;\r\n            reversePixels = !reversePixels;\r\n        }\r\n        this._startPixel = startPixel;\r\n        this._endPixel = endPixel;\r\n        this._reversePixels = reversePixels;\r\n        this._length = endPixel - startPixel;\r\n        this._alignToPixels = this.options.alignToPixels;\r\n    }\r\n    afterUpdate() {\r\n        callback(this.options.afterUpdate, [\r\n            this\r\n        ]);\r\n    }\r\n    beforeSetDimensions() {\r\n        callback(this.options.beforeSetDimensions, [\r\n            this\r\n        ]);\r\n    }\r\n    setDimensions() {\r\n        if (this.isHorizontal()) {\r\n            this.width = this.maxWidth;\r\n            this.left = 0;\r\n            this.right = this.width;\r\n        } else {\r\n            this.height = this.maxHeight;\r\n            this.top = 0;\r\n            this.bottom = this.height;\r\n        }\r\n        this.paddingLeft = 0;\r\n        this.paddingTop = 0;\r\n        this.paddingRight = 0;\r\n        this.paddingBottom = 0;\r\n    }\r\n    afterSetDimensions() {\r\n        callback(this.options.afterSetDimensions, [\r\n            this\r\n        ]);\r\n    }\r\n    _callHooks(name) {\r\n        this.chart.notifyPlugins(name, this.getContext());\r\n        callback(this.options[name], [\r\n            this\r\n        ]);\r\n    }\r\n    beforeDataLimits() {\r\n        this._callHooks('beforeDataLimits');\r\n    }\r\n    determineDataLimits() {}\r\n    afterDataLimits() {\r\n        this._callHooks('afterDataLimits');\r\n    }\r\n    beforeBuildTicks() {\r\n        this._callHooks('beforeBuildTicks');\r\n    }\r\n buildTicks() {\r\n        return [];\r\n    }\r\n    afterBuildTicks() {\r\n        this._callHooks('afterBuildTicks');\r\n    }\r\n    beforeTickToLabelConversion() {\r\n        callback(this.options.beforeTickToLabelConversion, [\r\n            this\r\n        ]);\r\n    }\r\n generateTickLabels(ticks) {\r\n        const tickOpts = this.options.ticks;\r\n        let i, ilen, tick;\r\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\r\n            tick = ticks[i];\r\n            tick.label = callback(tickOpts.callback, [\r\n                tick.value,\r\n                i,\r\n                ticks\r\n            ], this);\r\n        }\r\n    }\r\n    afterTickToLabelConversion() {\r\n        callback(this.options.afterTickToLabelConversion, [\r\n            this\r\n        ]);\r\n    }\r\n    beforeCalculateLabelRotation() {\r\n        callback(this.options.beforeCalculateLabelRotation, [\r\n            this\r\n        ]);\r\n    }\r\n    calculateLabelRotation() {\r\n        const options = this.options;\r\n        const tickOpts = options.ticks;\r\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\r\n        const minRotation = tickOpts.minRotation || 0;\r\n        const maxRotation = tickOpts.maxRotation;\r\n        let labelRotation = minRotation;\r\n        let tickWidth, maxHeight, maxLabelDiagonal;\r\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\r\n            this.labelRotation = minRotation;\r\n            return;\r\n        }\r\n        const labelSizes = this._getLabelSizes();\r\n        const maxLabelWidth = labelSizes.widest.width;\r\n        const maxLabelHeight = labelSizes.highest.height;\r\n        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\r\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n        if (maxLabelWidth + 6 > tickWidth) {\r\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\r\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\r\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n        }\r\n        this.labelRotation = labelRotation;\r\n    }\r\n    afterCalculateLabelRotation() {\r\n        callback(this.options.afterCalculateLabelRotation, [\r\n            this\r\n        ]);\r\n    }\r\n    afterAutoSkip() {}\r\n    beforeFit() {\r\n        callback(this.options.beforeFit, [\r\n            this\r\n        ]);\r\n    }\r\n    fit() {\r\n        const minSize = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\r\n        const display = this._isVisible();\r\n        const isHorizontal = this.isHorizontal();\r\n        if (display) {\r\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\r\n            if (isHorizontal) {\r\n                minSize.width = this.maxWidth;\r\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\r\n            } else {\r\n                minSize.height = this.maxHeight;\r\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\r\n            }\r\n            if (tickOpts.display && this.ticks.length) {\r\n                const { first , last , widest , highest  } = this._getLabelSizes();\r\n                const tickPadding = tickOpts.padding * 2;\r\n                const angleRadians = toRadians(this.labelRotation);\r\n                const cos = Math.cos(angleRadians);\r\n                const sin = Math.sin(angleRadians);\r\n                if (isHorizontal) {\r\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\r\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\r\n                } else {\r\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\r\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\r\n                }\r\n                this._calculatePadding(first, last, sin, cos);\r\n            }\r\n        }\r\n        this._handleMargins();\r\n        if (isHorizontal) {\r\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\r\n            this.height = minSize.height;\r\n        } else {\r\n            this.width = minSize.width;\r\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\r\n        }\r\n    }\r\n    _calculatePadding(first, last, sin, cos) {\r\n        const { ticks: { align , padding  } , position  } = this.options;\r\n        const isRotated = this.labelRotation !== 0;\r\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\r\n        if (this.isHorizontal()) {\r\n            const offsetLeft = this.getPixelForTick(0) - this.left;\r\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\r\n            let paddingLeft = 0;\r\n            let paddingRight = 0;\r\n            if (isRotated) {\r\n                if (labelsBelowTicks) {\r\n                    paddingLeft = cos * first.width;\r\n                    paddingRight = sin * last.height;\r\n                } else {\r\n                    paddingLeft = sin * first.height;\r\n                    paddingRight = cos * last.width;\r\n                }\r\n            } else if (align === 'start') {\r\n                paddingRight = last.width;\r\n            } else if (align === 'end') {\r\n                paddingLeft = first.width;\r\n            } else if (align !== 'inner') {\r\n                paddingLeft = first.width / 2;\r\n                paddingRight = last.width / 2;\r\n            }\r\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\r\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\r\n        } else {\r\n            let paddingTop = last.height / 2;\r\n            let paddingBottom = first.height / 2;\r\n            if (align === 'start') {\r\n                paddingTop = 0;\r\n                paddingBottom = first.height;\r\n            } else if (align === 'end') {\r\n                paddingTop = last.height;\r\n                paddingBottom = 0;\r\n            }\r\n            this.paddingTop = paddingTop + padding;\r\n            this.paddingBottom = paddingBottom + padding;\r\n        }\r\n    }\r\n _handleMargins() {\r\n        if (this._margins) {\r\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\r\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\r\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\r\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\r\n        }\r\n    }\r\n    afterFit() {\r\n        callback(this.options.afterFit, [\r\n            this\r\n        ]);\r\n    }\r\n isHorizontal() {\r\n        const { axis , position  } = this.options;\r\n        return position === 'top' || position === 'bottom' || axis === 'x';\r\n    }\r\n isFullSize() {\r\n        return this.options.fullSize;\r\n    }\r\n _convertTicksToLabels(ticks) {\r\n        this.beforeTickToLabelConversion();\r\n        this.generateTickLabels(ticks);\r\n        let i, ilen;\r\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\r\n            if (isNullOrUndef(ticks[i].label)) {\r\n                ticks.splice(i, 1);\r\n                ilen--;\r\n                i--;\r\n            }\r\n        }\r\n        this.afterTickToLabelConversion();\r\n    }\r\n _getLabelSizes() {\r\n        let labelSizes = this._labelSizes;\r\n        if (!labelSizes) {\r\n            const sampleSize = this.options.ticks.sampleSize;\r\n            let ticks = this.ticks;\r\n            if (sampleSize < ticks.length) {\r\n                ticks = sample(ticks, sampleSize);\r\n            }\r\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\r\n        }\r\n        return labelSizes;\r\n    }\r\n _computeLabelSizes(ticks, length, maxTicksLimit) {\r\n        const { ctx , _longestTextCache: caches  } = this;\r\n        const widths = [];\r\n        const heights = [];\r\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\r\n        let widestLabelSize = 0;\r\n        let highestLabelSize = 0;\r\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\r\n        for(i = 0; i < length; i += increment){\r\n            label = ticks[i].label;\r\n            tickFont = this._resolveTickFontOptions(i);\r\n            ctx.font = fontString = tickFont.string;\r\n            cache = caches[fontString] = caches[fontString] || {\r\n                data: {},\r\n                gc: []\r\n            };\r\n            lineHeight = tickFont.lineHeight;\r\n            width = height = 0;\r\n            if (!isNullOrUndef(label) && !isArray(label)) {\r\n                width = _measureText(ctx, cache.data, cache.gc, width, label);\r\n                height = lineHeight;\r\n            } else if (isArray(label)) {\r\n                for(j = 0, jlen = label.length; j < jlen; ++j){\r\n                    nestedLabel = label[j];\r\n                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n                        height += lineHeight;\r\n                    }\r\n                }\r\n            }\r\n            widths.push(width);\r\n            heights.push(height);\r\n            widestLabelSize = Math.max(width, widestLabelSize);\r\n            highestLabelSize = Math.max(height, highestLabelSize);\r\n        }\r\n        garbageCollect(caches, length);\r\n        const widest = widths.indexOf(widestLabelSize);\r\n        const highest = heights.indexOf(highestLabelSize);\r\n        const valueAt = (idx)=>({\r\n                width: widths[idx] || 0,\r\n                height: heights[idx] || 0\r\n            });\r\n        return {\r\n            first: valueAt(0),\r\n            last: valueAt(length - 1),\r\n            widest: valueAt(widest),\r\n            highest: valueAt(highest),\r\n            widths,\r\n            heights\r\n        };\r\n    }\r\n getLabelForValue(value) {\r\n        return value;\r\n    }\r\n getPixelForValue(value, index) {\r\n        return NaN;\r\n    }\r\n getValueForPixel(pixel) {}\r\n getPixelForTick(index) {\r\n        const ticks = this.ticks;\r\n        if (index < 0 || index > ticks.length - 1) {\r\n            return null;\r\n        }\r\n        return this.getPixelForValue(ticks[index].value);\r\n    }\r\n getPixelForDecimal(decimal) {\r\n        if (this._reversePixels) {\r\n            decimal = 1 - decimal;\r\n        }\r\n        const pixel = this._startPixel + decimal * this._length;\r\n        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\r\n    }\r\n getDecimalForPixel(pixel) {\r\n        const decimal = (pixel - this._startPixel) / this._length;\r\n        return this._reversePixels ? 1 - decimal : decimal;\r\n    }\r\n getBasePixel() {\r\n        return this.getPixelForValue(this.getBaseValue());\r\n    }\r\n getBaseValue() {\r\n        const { min , max  } = this;\r\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\r\n    }\r\n getContext(index) {\r\n        const ticks = this.ticks || [];\r\n        if (index >= 0 && index < ticks.length) {\r\n            const tick = ticks[index];\r\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\r\n        }\r\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\r\n    }\r\n _tickSize() {\r\n        const optionTicks = this.options.ticks;\r\n        const rot = toRadians(this.labelRotation);\r\n        const cos = Math.abs(Math.cos(rot));\r\n        const sin = Math.abs(Math.sin(rot));\r\n        const labelSizes = this._getLabelSizes();\r\n        const padding = optionTicks.autoSkipPadding || 0;\r\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\r\n    }\r\n _isVisible() {\r\n        const display = this.options.display;\r\n        if (display !== 'auto') {\r\n            return !!display;\r\n        }\r\n        return this.getMatchingVisibleMetas().length > 0;\r\n    }\r\n _computeGridLineItems(chartArea) {\r\n        const axis = this.axis;\r\n        const chart = this.chart;\r\n        const options = this.options;\r\n        const { grid , position , border  } = options;\r\n        const offset = grid.offset;\r\n        const isHorizontal = this.isHorizontal();\r\n        const ticks = this.ticks;\r\n        const ticksLength = ticks.length + (offset ? 1 : 0);\r\n        const tl = getTickMarkLength(grid);\r\n        const items = [];\r\n        const borderOpts = border.setContext(this.getContext());\r\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\r\n        const axisHalfWidth = axisWidth / 2;\r\n        const alignBorderValue = function(pixel) {\r\n            return _alignPixel(chart, pixel, axisWidth);\r\n        };\r\n        let borderValue, i, lineValue, alignedLineValue;\r\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\r\n        if (position === 'top') {\r\n            borderValue = alignBorderValue(this.bottom);\r\n            ty1 = this.bottom - tl;\r\n            ty2 = borderValue - axisHalfWidth;\r\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n            y2 = chartArea.bottom;\r\n        } else if (position === 'bottom') {\r\n            borderValue = alignBorderValue(this.top);\r\n            y1 = chartArea.top;\r\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n            ty1 = borderValue + axisHalfWidth;\r\n            ty2 = this.top + tl;\r\n        } else if (position === 'left') {\r\n            borderValue = alignBorderValue(this.right);\r\n            tx1 = this.right - tl;\r\n            tx2 = borderValue - axisHalfWidth;\r\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n            x2 = chartArea.right;\r\n        } else if (position === 'right') {\r\n            borderValue = alignBorderValue(this.left);\r\n            x1 = chartArea.left;\r\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n            tx1 = borderValue + axisHalfWidth;\r\n            tx2 = this.left + tl;\r\n        } else if (axis === 'x') {\r\n            if (position === 'center') {\r\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\r\n            } else if (isObject(position)) {\r\n                const positionAxisID = Object.keys(position)[0];\r\n                const value = position[positionAxisID];\r\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n            }\r\n            y1 = chartArea.top;\r\n            y2 = chartArea.bottom;\r\n            ty1 = borderValue + axisHalfWidth;\r\n            ty2 = ty1 + tl;\r\n        } else if (axis === 'y') {\r\n            if (position === 'center') {\r\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\r\n            } else if (isObject(position)) {\r\n                const positionAxisID1 = Object.keys(position)[0];\r\n                const value1 = position[positionAxisID1];\r\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));\r\n            }\r\n            tx1 = borderValue - axisHalfWidth;\r\n            tx2 = tx1 - tl;\r\n            x1 = chartArea.left;\r\n            x2 = chartArea.right;\r\n        }\r\n        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\r\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\r\n        for(i = 0; i < ticksLength; i += step){\r\n            const context = this.getContext(i);\r\n            const optsAtIndex = grid.setContext(context);\r\n            const optsAtIndexBorder = border.setContext(context);\r\n            const lineWidth = optsAtIndex.lineWidth;\r\n            const lineColor = optsAtIndex.color;\r\n            const borderDash = optsAtIndexBorder.dash || [];\r\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\r\n            const tickWidth = optsAtIndex.tickWidth;\r\n            const tickColor = optsAtIndex.tickColor;\r\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\r\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\r\n            lineValue = getPixelForGridLine(this, i, offset);\r\n            if (lineValue === undefined) {\r\n                continue;\r\n            }\r\n            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\r\n            if (isHorizontal) {\r\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\r\n            } else {\r\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\r\n            }\r\n            items.push({\r\n                tx1,\r\n                ty1,\r\n                tx2,\r\n                ty2,\r\n                x1,\r\n                y1,\r\n                x2,\r\n                y2,\r\n                width: lineWidth,\r\n                color: lineColor,\r\n                borderDash,\r\n                borderDashOffset,\r\n                tickWidth,\r\n                tickColor,\r\n                tickBorderDash,\r\n                tickBorderDashOffset\r\n            });\r\n        }\r\n        this._ticksLength = ticksLength;\r\n        this._borderValue = borderValue;\r\n        return items;\r\n    }\r\n _computeLabelItems(chartArea) {\r\n        const axis = this.axis;\r\n        const options = this.options;\r\n        const { position , ticks: optionTicks  } = options;\r\n        const isHorizontal = this.isHorizontal();\r\n        const ticks = this.ticks;\r\n        const { align , crossAlign , padding , mirror  } = optionTicks;\r\n        const tl = getTickMarkLength(options.grid);\r\n        const tickAndPadding = tl + padding;\r\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\r\n        const rotation = -toRadians(this.labelRotation);\r\n        const items = [];\r\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n        let textBaseline = 'middle';\r\n        if (position === 'top') {\r\n            y = this.bottom - hTickAndPadding;\r\n            textAlign = this._getXAxisLabelAlignment();\r\n        } else if (position === 'bottom') {\r\n            y = this.top + hTickAndPadding;\r\n            textAlign = this._getXAxisLabelAlignment();\r\n        } else if (position === 'left') {\r\n            const ret = this._getYAxisLabelAlignment(tl);\r\n            textAlign = ret.textAlign;\r\n            x = ret.x;\r\n        } else if (position === 'right') {\r\n            const ret1 = this._getYAxisLabelAlignment(tl);\r\n            textAlign = ret1.textAlign;\r\n            x = ret1.x;\r\n        } else if (axis === 'x') {\r\n            if (position === 'center') {\r\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\r\n            } else if (isObject(position)) {\r\n                const positionAxisID = Object.keys(position)[0];\r\n                const value = position[positionAxisID];\r\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\r\n            }\r\n            textAlign = this._getXAxisLabelAlignment();\r\n        } else if (axis === 'y') {\r\n            if (position === 'center') {\r\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\r\n            } else if (isObject(position)) {\r\n                const positionAxisID1 = Object.keys(position)[0];\r\n                const value1 = position[positionAxisID1];\r\n                x = this.chart.scales[positionAxisID1].getPixelForValue(value1);\r\n            }\r\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\r\n        }\r\n        if (axis === 'y') {\r\n            if (align === 'start') {\r\n                textBaseline = 'top';\r\n            } else if (align === 'end') {\r\n                textBaseline = 'bottom';\r\n            }\r\n        }\r\n        const labelSizes = this._getLabelSizes();\r\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\r\n            tick = ticks[i];\r\n            label = tick.label;\r\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\r\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\r\n            font = this._resolveTickFontOptions(i);\r\n            lineHeight = font.lineHeight;\r\n            lineCount = isArray(label) ? label.length : 1;\r\n            const halfCount = lineCount / 2;\r\n            const color = optsAtIndex.color;\r\n            const strokeColor = optsAtIndex.textStrokeColor;\r\n            const strokeWidth = optsAtIndex.textStrokeWidth;\r\n            let tickTextAlign = textAlign;\r\n            if (isHorizontal) {\r\n                x = pixel;\r\n                if (textAlign === 'inner') {\r\n                    if (i === ilen - 1) {\r\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\r\n                    } else if (i === 0) {\r\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\r\n                    } else {\r\n                        tickTextAlign = 'center';\r\n                    }\r\n                }\r\n                if (position === 'top') {\r\n                    if (crossAlign === 'near' || rotation !== 0) {\r\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\r\n                    } else if (crossAlign === 'center') {\r\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\r\n                    } else {\r\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\r\n                    }\r\n                } else {\r\n                    if (crossAlign === 'near' || rotation !== 0) {\r\n                        textOffset = lineHeight / 2;\r\n                    } else if (crossAlign === 'center') {\r\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\r\n                    } else {\r\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\r\n                    }\r\n                }\r\n                if (mirror) {\r\n                    textOffset *= -1;\r\n                }\r\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\r\n                    x += lineHeight / 2 * Math.sin(rotation);\r\n                }\r\n            } else {\r\n                y = pixel;\r\n                textOffset = (1 - lineCount) * lineHeight / 2;\r\n            }\r\n            let backdrop;\r\n            if (optsAtIndex.showLabelBackdrop) {\r\n                const labelPadding = toPadding(optsAtIndex.backdropPadding);\r\n                const height = labelSizes.heights[i];\r\n                const width = labelSizes.widths[i];\r\n                let top = textOffset - labelPadding.top;\r\n                let left = 0 - labelPadding.left;\r\n                switch(textBaseline){\r\n                    case 'middle':\r\n                        top -= height / 2;\r\n                        break;\r\n                    case 'bottom':\r\n                        top -= height;\r\n                        break;\r\n                }\r\n                switch(textAlign){\r\n                    case 'center':\r\n                        left -= width / 2;\r\n                        break;\r\n                    case 'right':\r\n                        left -= width;\r\n                        break;\r\n                }\r\n                backdrop = {\r\n                    left,\r\n                    top,\r\n                    width: width + labelPadding.width,\r\n                    height: height + labelPadding.height,\r\n                    color: optsAtIndex.backdropColor\r\n                };\r\n            }\r\n            items.push({\r\n                label,\r\n                font,\r\n                textOffset,\r\n                options: {\r\n                    rotation,\r\n                    color,\r\n                    strokeColor,\r\n                    strokeWidth,\r\n                    textAlign: tickTextAlign,\r\n                    textBaseline,\r\n                    translation: [\r\n                        x,\r\n                        y\r\n                    ],\r\n                    backdrop\r\n                }\r\n            });\r\n        }\r\n        return items;\r\n    }\r\n    _getXAxisLabelAlignment() {\r\n        const { position , ticks  } = this.options;\r\n        const rotation = -toRadians(this.labelRotation);\r\n        if (rotation) {\r\n            return position === 'top' ? 'left' : 'right';\r\n        }\r\n        let align = 'center';\r\n        if (ticks.align === 'start') {\r\n            align = 'left';\r\n        } else if (ticks.align === 'end') {\r\n            align = 'right';\r\n        } else if (ticks.align === 'inner') {\r\n            align = 'inner';\r\n        }\r\n        return align;\r\n    }\r\n    _getYAxisLabelAlignment(tl) {\r\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\r\n        const labelSizes = this._getLabelSizes();\r\n        const tickAndPadding = tl + padding;\r\n        const widest = labelSizes.widest.width;\r\n        let textAlign;\r\n        let x;\r\n        if (position === 'left') {\r\n            if (mirror) {\r\n                x = this.right + padding;\r\n                if (crossAlign === 'near') {\r\n                    textAlign = 'left';\r\n                } else if (crossAlign === 'center') {\r\n                    textAlign = 'center';\r\n                    x += widest / 2;\r\n                } else {\r\n                    textAlign = 'right';\r\n                    x += widest;\r\n                }\r\n            } else {\r\n                x = this.right - tickAndPadding;\r\n                if (crossAlign === 'near') {\r\n                    textAlign = 'right';\r\n                } else if (crossAlign === 'center') {\r\n                    textAlign = 'center';\r\n                    x -= widest / 2;\r\n                } else {\r\n                    textAlign = 'left';\r\n                    x = this.left;\r\n                }\r\n            }\r\n        } else if (position === 'right') {\r\n            if (mirror) {\r\n                x = this.left + padding;\r\n                if (crossAlign === 'near') {\r\n                    textAlign = 'right';\r\n                } else if (crossAlign === 'center') {\r\n                    textAlign = 'center';\r\n                    x -= widest / 2;\r\n                } else {\r\n                    textAlign = 'left';\r\n                    x -= widest;\r\n                }\r\n            } else {\r\n                x = this.left + tickAndPadding;\r\n                if (crossAlign === 'near') {\r\n                    textAlign = 'left';\r\n                } else if (crossAlign === 'center') {\r\n                    textAlign = 'center';\r\n                    x += widest / 2;\r\n                } else {\r\n                    textAlign = 'right';\r\n                    x = this.right;\r\n                }\r\n            }\r\n        } else {\r\n            textAlign = 'right';\r\n        }\r\n        return {\r\n            textAlign,\r\n            x\r\n        };\r\n    }\r\n _computeLabelArea() {\r\n        if (this.options.ticks.mirror) {\r\n            return;\r\n        }\r\n        const chart = this.chart;\r\n        const position = this.options.position;\r\n        if (position === 'left' || position === 'right') {\r\n            return {\r\n                top: 0,\r\n                left: this.left,\r\n                bottom: chart.height,\r\n                right: this.right\r\n            };\r\n        }\r\n        if (position === 'top' || position === 'bottom') {\r\n            return {\r\n                top: this.top,\r\n                left: 0,\r\n                bottom: this.bottom,\r\n                right: chart.width\r\n            };\r\n        }\r\n    }\r\n drawBackground() {\r\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\r\n        if (backgroundColor) {\r\n            ctx.save();\r\n            ctx.fillStyle = backgroundColor;\r\n            ctx.fillRect(left, top, width, height);\r\n            ctx.restore();\r\n        }\r\n    }\r\n    getLineWidthForValue(value) {\r\n        const grid = this.options.grid;\r\n        if (!this._isVisible() || !grid.display) {\r\n            return 0;\r\n        }\r\n        const ticks = this.ticks;\r\n        const index = ticks.findIndex((t)=>t.value === value);\r\n        if (index >= 0) {\r\n            const opts = grid.setContext(this.getContext(index));\r\n            return opts.lineWidth;\r\n        }\r\n        return 0;\r\n    }\r\n drawGrid(chartArea) {\r\n        const grid = this.options.grid;\r\n        const ctx = this.ctx;\r\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\r\n        let i, ilen;\r\n        const drawLine = (p1, p2, style)=>{\r\n            if (!style.width || !style.color) {\r\n                return;\r\n            }\r\n            ctx.save();\r\n            ctx.lineWidth = style.width;\r\n            ctx.strokeStyle = style.color;\r\n            ctx.setLineDash(style.borderDash || []);\r\n            ctx.lineDashOffset = style.borderDashOffset;\r\n            ctx.beginPath();\r\n            ctx.moveTo(p1.x, p1.y);\r\n            ctx.lineTo(p2.x, p2.y);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        };\r\n        if (grid.display) {\r\n            for(i = 0, ilen = items.length; i < ilen; ++i){\r\n                const item = items[i];\r\n                if (grid.drawOnChartArea) {\r\n                    drawLine({\r\n                        x: item.x1,\r\n                        y: item.y1\r\n                    }, {\r\n                        x: item.x2,\r\n                        y: item.y2\r\n                    }, item);\r\n                }\r\n                if (grid.drawTicks) {\r\n                    drawLine({\r\n                        x: item.tx1,\r\n                        y: item.ty1\r\n                    }, {\r\n                        x: item.tx2,\r\n                        y: item.ty2\r\n                    }, {\r\n                        color: item.tickColor,\r\n                        width: item.tickWidth,\r\n                        borderDash: item.tickBorderDash,\r\n                        borderDashOffset: item.tickBorderDashOffset\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n drawBorder() {\r\n        const { chart , ctx , options: { border , grid  }  } = this;\r\n        const borderOpts = border.setContext(this.getContext());\r\n        const axisWidth = border.display ? borderOpts.width : 0;\r\n        if (!axisWidth) {\r\n            return;\r\n        }\r\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\r\n        const borderValue = this._borderValue;\r\n        let x1, x2, y1, y2;\r\n        if (this.isHorizontal()) {\r\n            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\r\n            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\r\n            y1 = y2 = borderValue;\r\n        } else {\r\n            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\r\n            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\r\n            x1 = x2 = borderValue;\r\n        }\r\n        ctx.save();\r\n        ctx.lineWidth = borderOpts.width;\r\n        ctx.strokeStyle = borderOpts.color;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n drawLabels(chartArea) {\r\n        const optionTicks = this.options.ticks;\r\n        if (!optionTicks.display) {\r\n            return;\r\n        }\r\n        const ctx = this.ctx;\r\n        const area = this._computeLabelArea();\r\n        if (area) {\r\n            clipArea(ctx, area);\r\n        }\r\n        const items = this.getLabelItems(chartArea);\r\n        for (const item of items){\r\n            const renderTextOptions = item.options;\r\n            const tickFont = item.font;\r\n            const label = item.label;\r\n            const y = item.textOffset;\r\n            renderText(ctx, label, 0, y, tickFont, renderTextOptions);\r\n        }\r\n        if (area) {\r\n            unclipArea(ctx);\r\n        }\r\n    }\r\n drawTitle() {\r\n        const { ctx , options: { position , title , reverse  }  } = this;\r\n        if (!title.display) {\r\n            return;\r\n        }\r\n        const font = toFont(title.font);\r\n        const padding = toPadding(title.padding);\r\n        const align = title.align;\r\n        let offset = font.lineHeight / 2;\r\n        if (position === 'bottom' || position === 'center' || isObject(position)) {\r\n            offset += padding.bottom;\r\n            if (isArray(title.text)) {\r\n                offset += font.lineHeight * (title.text.length - 1);\r\n            }\r\n        } else {\r\n            offset += padding.top;\r\n        }\r\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\r\n        renderText(ctx, title.text, 0, 0, font, {\r\n            color: title.color,\r\n            maxWidth,\r\n            rotation,\r\n            textAlign: titleAlign(align, position, reverse),\r\n            textBaseline: 'middle',\r\n            translation: [\r\n                titleX,\r\n                titleY\r\n            ]\r\n        });\r\n    }\r\n    draw(chartArea) {\r\n        if (!this._isVisible()) {\r\n            return;\r\n        }\r\n        this.drawBackground();\r\n        this.drawGrid(chartArea);\r\n        this.drawBorder();\r\n        this.drawTitle();\r\n        this.drawLabels(chartArea);\r\n    }\r\n _layers() {\r\n        const opts = this.options;\r\n        const tz = opts.ticks && opts.ticks.z || 0;\r\n        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\r\n        const bz = valueOrDefault(opts.border && opts.border.z, 0);\r\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\r\n            return [\r\n                {\r\n                    z: tz,\r\n                    draw: (chartArea)=>{\r\n                        this.draw(chartArea);\r\n                    }\r\n                }\r\n            ];\r\n        }\r\n        return [\r\n            {\r\n                z: gz,\r\n                draw: (chartArea)=>{\r\n                    this.drawBackground();\r\n                    this.drawGrid(chartArea);\r\n                    this.drawTitle();\r\n                }\r\n            },\r\n            {\r\n                z: bz,\r\n                draw: ()=>{\r\n                    this.drawBorder();\r\n                }\r\n            },\r\n            {\r\n                z: tz,\r\n                draw: (chartArea)=>{\r\n                    this.drawLabels(chartArea);\r\n                }\r\n            }\r\n        ];\r\n    }\r\n getMatchingVisibleMetas(type) {\r\n        const metas = this.chart.getSortedVisibleDatasetMetas();\r\n        const axisID = this.axis + 'AxisID';\r\n        const result = [];\r\n        let i, ilen;\r\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\r\n            const meta = metas[i];\r\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\r\n                result.push(meta);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n _resolveTickFontOptions(index) {\r\n        const opts = this.options.ticks.setContext(this.getContext(index));\r\n        return toFont(opts.font);\r\n    }\r\n _maxDigits() {\r\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\r\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\r\n    }\r\n}\r\n\r\nclass TypedRegistry {\r\n    constructor(type, scope, override){\r\n        this.type = type;\r\n        this.scope = scope;\r\n        this.override = override;\r\n        this.items = Object.create(null);\r\n    }\r\n    isForType(type) {\r\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\r\n    }\r\n register(item) {\r\n        const proto = Object.getPrototypeOf(item);\r\n        let parentScope;\r\n        if (isIChartComponent(proto)) {\r\n            parentScope = this.register(proto);\r\n        }\r\n        const items = this.items;\r\n        const id = item.id;\r\n        const scope = this.scope + '.' + id;\r\n        if (!id) {\r\n            throw new Error('class does not have id: ' + item);\r\n        }\r\n        if (id in items) {\r\n            return scope;\r\n        }\r\n        items[id] = item;\r\n        registerDefaults(item, scope, parentScope);\r\n        if (this.override) {\r\n            defaults.override(item.id, item.overrides);\r\n        }\r\n        return scope;\r\n    }\r\n get(id) {\r\n        return this.items[id];\r\n    }\r\n unregister(item) {\r\n        const items = this.items;\r\n        const id = item.id;\r\n        const scope = this.scope;\r\n        if (id in items) {\r\n            delete items[id];\r\n        }\r\n        if (scope && id in defaults[scope]) {\r\n            delete defaults[scope][id];\r\n            if (this.override) {\r\n                delete overrides[id];\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction registerDefaults(item, scope, parentScope) {\r\n    const itemDefaults = merge(Object.create(null), [\r\n        parentScope ? defaults.get(parentScope) : {},\r\n        defaults.get(scope),\r\n        item.defaults\r\n    ]);\r\n    defaults.set(scope, itemDefaults);\r\n    if (item.defaultRoutes) {\r\n        routeDefaults(scope, item.defaultRoutes);\r\n    }\r\n    if (item.descriptors) {\r\n        defaults.describe(scope, item.descriptors);\r\n    }\r\n}\r\nfunction routeDefaults(scope, routes) {\r\n    Object.keys(routes).forEach((property)=>{\r\n        const propertyParts = property.split('.');\r\n        const sourceName = propertyParts.pop();\r\n        const sourceScope = [\r\n            scope\r\n        ].concat(propertyParts).join('.');\r\n        const parts = routes[property].split('.');\r\n        const targetName = parts.pop();\r\n        const targetScope = parts.join('.');\r\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\r\n    });\r\n}\r\nfunction isIChartComponent(proto) {\r\n    return 'id' in proto && 'defaults' in proto;\r\n}\r\n\r\nclass Registry {\r\n    constructor(){\r\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\r\n        this.elements = new TypedRegistry(Element, 'elements');\r\n        this.plugins = new TypedRegistry(Object, 'plugins');\r\n        this.scales = new TypedRegistry(Scale, 'scales');\r\n        this._typedRegistries = [\r\n            this.controllers,\r\n            this.scales,\r\n            this.elements\r\n        ];\r\n    }\r\n add(...args) {\r\n        this._each('register', args);\r\n    }\r\n    remove(...args) {\r\n        this._each('unregister', args);\r\n    }\r\n addControllers(...args) {\r\n        this._each('register', args, this.controllers);\r\n    }\r\n addElements(...args) {\r\n        this._each('register', args, this.elements);\r\n    }\r\n addPlugins(...args) {\r\n        this._each('register', args, this.plugins);\r\n    }\r\n addScales(...args) {\r\n        this._each('register', args, this.scales);\r\n    }\r\n getController(id) {\r\n        return this._get(id, this.controllers, 'controller');\r\n    }\r\n getElement(id) {\r\n        return this._get(id, this.elements, 'element');\r\n    }\r\n getPlugin(id) {\r\n        return this._get(id, this.plugins, 'plugin');\r\n    }\r\n getScale(id) {\r\n        return this._get(id, this.scales, 'scale');\r\n    }\r\n removeControllers(...args) {\r\n        this._each('unregister', args, this.controllers);\r\n    }\r\n removeElements(...args) {\r\n        this._each('unregister', args, this.elements);\r\n    }\r\n removePlugins(...args) {\r\n        this._each('unregister', args, this.plugins);\r\n    }\r\n removeScales(...args) {\r\n        this._each('unregister', args, this.scales);\r\n    }\r\n _each(method, args, typedRegistry) {\r\n        [\r\n            ...args\r\n        ].forEach((arg)=>{\r\n            const reg = typedRegistry || this._getRegistryForType(arg);\r\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\r\n                this._exec(method, reg, arg);\r\n            } else {\r\n                each(arg, (item)=>{\r\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\r\n                    this._exec(method, itemReg, item);\r\n                });\r\n            }\r\n        });\r\n    }\r\n _exec(method, registry, component) {\r\n        const camelMethod = _capitalize(method);\r\n        callback(component['before' + camelMethod], [], component);\r\n        registry[method](component);\r\n        callback(component['after' + camelMethod], [], component);\r\n    }\r\n _getRegistryForType(type) {\r\n        for(let i = 0; i < this._typedRegistries.length; i++){\r\n            const reg = this._typedRegistries[i];\r\n            if (reg.isForType(type)) {\r\n                return reg;\r\n            }\r\n        }\r\n        return this.plugins;\r\n    }\r\n _get(id, typedRegistry, type) {\r\n        const item = typedRegistry.get(id);\r\n        if (item === undefined) {\r\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\r\n        }\r\n        return item;\r\n    }\r\n}\r\nvar registry = /* #__PURE__ */ new Registry();\r\n\r\nclass PluginService {\r\n    constructor(){\r\n        this._init = [];\r\n    }\r\n notify(chart, hook, args, filter) {\r\n        if (hook === 'beforeInit') {\r\n            this._init = this._createDescriptors(chart, true);\r\n            this._notify(this._init, chart, 'install');\r\n        }\r\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\r\n        const result = this._notify(descriptors, chart, hook, args);\r\n        if (hook === 'afterDestroy') {\r\n            this._notify(descriptors, chart, 'stop');\r\n            this._notify(this._init, chart, 'uninstall');\r\n        }\r\n        return result;\r\n    }\r\n _notify(descriptors, chart, hook, args) {\r\n        args = args || {};\r\n        for (const descriptor of descriptors){\r\n            const plugin = descriptor.plugin;\r\n            const method = plugin[hook];\r\n            const params = [\r\n                chart,\r\n                args,\r\n                descriptor.options\r\n            ];\r\n            if (callback(method, params, plugin) === false && args.cancelable) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    invalidate() {\r\n        if (!isNullOrUndef(this._cache)) {\r\n            this._oldCache = this._cache;\r\n            this._cache = undefined;\r\n        }\r\n    }\r\n _descriptors(chart) {\r\n        if (this._cache) {\r\n            return this._cache;\r\n        }\r\n        const descriptors = this._cache = this._createDescriptors(chart);\r\n        this._notifyStateChanges(chart);\r\n        return descriptors;\r\n    }\r\n    _createDescriptors(chart, all) {\r\n        const config = chart && chart.config;\r\n        const options = valueOrDefault(config.options && config.options.plugins, {});\r\n        const plugins = allPlugins(config);\r\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\r\n    }\r\n _notifyStateChanges(chart) {\r\n        const previousDescriptors = this._oldCache || [];\r\n        const descriptors = this._cache;\r\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\r\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\r\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\r\n    }\r\n}\r\n function allPlugins(config) {\r\n    const localIds = {};\r\n    const plugins = [];\r\n    const keys = Object.keys(registry.plugins.items);\r\n    for(let i = 0; i < keys.length; i++){\r\n        plugins.push(registry.getPlugin(keys[i]));\r\n    }\r\n    const local = config.plugins || [];\r\n    for(let i1 = 0; i1 < local.length; i1++){\r\n        const plugin = local[i1];\r\n        if (plugins.indexOf(plugin) === -1) {\r\n            plugins.push(plugin);\r\n            localIds[plugin.id] = true;\r\n        }\r\n    }\r\n    return {\r\n        plugins,\r\n        localIds\r\n    };\r\n}\r\nfunction getOpts(options, all) {\r\n    if (!all && options === false) {\r\n        return null;\r\n    }\r\n    if (options === true) {\r\n        return {};\r\n    }\r\n    return options;\r\n}\r\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\r\n    const result = [];\r\n    const context = chart.getContext();\r\n    for (const plugin of plugins){\r\n        const id = plugin.id;\r\n        const opts = getOpts(options[id], all);\r\n        if (opts === null) {\r\n            continue;\r\n        }\r\n        result.push({\r\n            plugin,\r\n            options: pluginOpts(chart.config, {\r\n                plugin,\r\n                local: localIds[id]\r\n            }, opts, context)\r\n        });\r\n    }\r\n    return result;\r\n}\r\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\r\n    const keys = config.pluginScopeKeys(plugin);\r\n    const scopes = config.getOptionScopes(opts, keys);\r\n    if (local && plugin.defaults) {\r\n        scopes.push(plugin.defaults);\r\n    }\r\n    return config.createResolver(scopes, context, [\r\n        ''\r\n    ], {\r\n        scriptable: false,\r\n        indexable: false,\r\n        allKeys: true\r\n    });\r\n}\r\n\r\nfunction getIndexAxis(type, options) {\r\n    const datasetDefaults = defaults.datasets[type] || {};\r\n    const datasetOptions = (options.datasets || {})[type] || {};\r\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\r\n}\r\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\r\n    let axis = id;\r\n    if (id === '_index_') {\r\n        axis = indexAxis;\r\n    } else if (id === '_value_') {\r\n        axis = indexAxis === 'x' ? 'y' : 'x';\r\n    }\r\n    return axis;\r\n}\r\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\r\n    return axis === indexAxis ? '_index_' : '_value_';\r\n}\r\nfunction axisFromPosition(position) {\r\n    if (position === 'top' || position === 'bottom') {\r\n        return 'x';\r\n    }\r\n    if (position === 'left' || position === 'right') {\r\n        return 'y';\r\n    }\r\n}\r\nfunction determineAxis(id, scaleOptions) {\r\n    if (id === 'x' || id === 'y' || id === 'r') {\r\n        return id;\r\n    }\r\n    id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);\r\n    if (id) {\r\n        return id;\r\n    }\r\n    throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);\r\n}\r\nfunction mergeScaleConfig(config, options) {\r\n    const chartDefaults = overrides[config.type] || {\r\n        scales: {}\r\n    };\r\n    const configScales = options.scales || {};\r\n    const chartIndexAxis = getIndexAxis(config.type, options);\r\n    const scales = Object.create(null);\r\n    Object.keys(configScales).forEach((id)=>{\r\n        const scaleConf = configScales[id];\r\n        if (!isObject(scaleConf)) {\r\n            return console.error(`Invalid scale configuration for scale: ${id}`);\r\n        }\r\n        if (scaleConf._proxy) {\r\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\r\n        }\r\n        const axis = determineAxis(id, scaleConf);\r\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\r\n        const defaultScaleOptions = chartDefaults.scales || {};\r\n        scales[id] = mergeIf(Object.create(null), [\r\n            {\r\n                axis\r\n            },\r\n            scaleConf,\r\n            defaultScaleOptions[axis],\r\n            defaultScaleOptions[defaultId]\r\n        ]);\r\n    });\r\n    config.data.datasets.forEach((dataset)=>{\r\n        const type = dataset.type || config.type;\r\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\r\n        const datasetDefaults = overrides[type] || {};\r\n        const defaultScaleOptions = datasetDefaults.scales || {};\r\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\r\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\r\n            const id = dataset[axis + 'AxisID'] || axis;\r\n            scales[id] = scales[id] || Object.create(null);\r\n            mergeIf(scales[id], [\r\n                {\r\n                    axis\r\n                },\r\n                configScales[id],\r\n                defaultScaleOptions[defaultID]\r\n            ]);\r\n        });\r\n    });\r\n    Object.keys(scales).forEach((key)=>{\r\n        const scale = scales[key];\r\n        mergeIf(scale, [\r\n            defaults.scales[scale.type],\r\n            defaults.scale\r\n        ]);\r\n    });\r\n    return scales;\r\n}\r\nfunction initOptions(config) {\r\n    const options = config.options || (config.options = {});\r\n    options.plugins = valueOrDefault(options.plugins, {});\r\n    options.scales = mergeScaleConfig(config, options);\r\n}\r\nfunction initData(data) {\r\n    data = data || {};\r\n    data.datasets = data.datasets || [];\r\n    data.labels = data.labels || [];\r\n    return data;\r\n}\r\nfunction initConfig(config) {\r\n    config = config || {};\r\n    config.data = initData(config.data);\r\n    initOptions(config);\r\n    return config;\r\n}\r\nconst keyCache = new Map();\r\nconst keysCached = new Set();\r\nfunction cachedKeys(cacheKey, generate) {\r\n    let keys = keyCache.get(cacheKey);\r\n    if (!keys) {\r\n        keys = generate();\r\n        keyCache.set(cacheKey, keys);\r\n        keysCached.add(keys);\r\n    }\r\n    return keys;\r\n}\r\nconst addIfFound = (set, obj, key)=>{\r\n    const opts = resolveObjectKey(obj, key);\r\n    if (opts !== undefined) {\r\n        set.add(opts);\r\n    }\r\n};\r\nclass Config {\r\n    constructor(config){\r\n        this._config = initConfig(config);\r\n        this._scopeCache = new Map();\r\n        this._resolverCache = new Map();\r\n    }\r\n    get platform() {\r\n        return this._config.platform;\r\n    }\r\n    get type() {\r\n        return this._config.type;\r\n    }\r\n    set type(type) {\r\n        this._config.type = type;\r\n    }\r\n    get data() {\r\n        return this._config.data;\r\n    }\r\n    set data(data) {\r\n        this._config.data = initData(data);\r\n    }\r\n    get options() {\r\n        return this._config.options;\r\n    }\r\n    set options(options) {\r\n        this._config.options = options;\r\n    }\r\n    get plugins() {\r\n        return this._config.plugins;\r\n    }\r\n    update() {\r\n        const config = this._config;\r\n        this.clearCache();\r\n        initOptions(config);\r\n    }\r\n    clearCache() {\r\n        this._scopeCache.clear();\r\n        this._resolverCache.clear();\r\n    }\r\n datasetScopeKeys(datasetType) {\r\n        return cachedKeys(datasetType, ()=>[\r\n                [\r\n                    `datasets.${datasetType}`,\r\n                    ''\r\n                ]\r\n            ]);\r\n    }\r\n datasetAnimationScopeKeys(datasetType, transition) {\r\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\r\n                [\r\n                    `datasets.${datasetType}.transitions.${transition}`,\r\n                    `transitions.${transition}`\r\n                ],\r\n                [\r\n                    `datasets.${datasetType}`,\r\n                    ''\r\n                ]\r\n            ]);\r\n    }\r\n datasetElementScopeKeys(datasetType, elementType) {\r\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\r\n                [\r\n                    `datasets.${datasetType}.elements.${elementType}`,\r\n                    `datasets.${datasetType}`,\r\n                    `elements.${elementType}`,\r\n                    ''\r\n                ]\r\n            ]);\r\n    }\r\n pluginScopeKeys(plugin) {\r\n        const id = plugin.id;\r\n        const type = this.type;\r\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\r\n                [\r\n                    `plugins.${id}`,\r\n                    ...plugin.additionalOptionScopes || []\r\n                ]\r\n            ]);\r\n    }\r\n _cachedScopes(mainScope, resetCache) {\r\n        const _scopeCache = this._scopeCache;\r\n        let cache = _scopeCache.get(mainScope);\r\n        if (!cache || resetCache) {\r\n            cache = new Map();\r\n            _scopeCache.set(mainScope, cache);\r\n        }\r\n        return cache;\r\n    }\r\n getOptionScopes(mainScope, keyLists, resetCache) {\r\n        const { options , type  } = this;\r\n        const cache = this._cachedScopes(mainScope, resetCache);\r\n        const cached = cache.get(keyLists);\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n        const scopes = new Set();\r\n        keyLists.forEach((keys)=>{\r\n            if (mainScope) {\r\n                scopes.add(mainScope);\r\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\r\n            }\r\n            keys.forEach((key)=>addIfFound(scopes, options, key));\r\n            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));\r\n            keys.forEach((key)=>addIfFound(scopes, defaults, key));\r\n            keys.forEach((key)=>addIfFound(scopes, descriptors, key));\r\n        });\r\n        const array = Array.from(scopes);\r\n        if (array.length === 0) {\r\n            array.push(Object.create(null));\r\n        }\r\n        if (keysCached.has(keyLists)) {\r\n            cache.set(keyLists, array);\r\n        }\r\n        return array;\r\n    }\r\n chartOptionScopes() {\r\n        const { options , type  } = this;\r\n        return [\r\n            options,\r\n            overrides[type] || {},\r\n            defaults.datasets[type] || {},\r\n            {\r\n                type\r\n            },\r\n            defaults,\r\n            descriptors\r\n        ];\r\n    }\r\n resolveNamedOptions(scopes, names, context, prefixes = [\r\n        ''\r\n    ]) {\r\n        const result = {\r\n            $shared: true\r\n        };\r\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\r\n        let options = resolver;\r\n        if (needContext(resolver, names)) {\r\n            result.$shared = false;\r\n            context = isFunction(context) ? context() : context;\r\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\r\n            options = _attachContext(resolver, context, subResolver);\r\n        }\r\n        for (const prop of names){\r\n            result[prop] = options[prop];\r\n        }\r\n        return result;\r\n    }\r\n createResolver(scopes, context, prefixes = [\r\n        ''\r\n    ], descriptorDefaults) {\r\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\r\n        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\r\n    }\r\n}\r\nfunction getResolver(resolverCache, scopes, prefixes) {\r\n    let cache = resolverCache.get(scopes);\r\n    if (!cache) {\r\n        cache = new Map();\r\n        resolverCache.set(scopes, cache);\r\n    }\r\n    const cacheKey = prefixes.join();\r\n    let cached = cache.get(cacheKey);\r\n    if (!cached) {\r\n        const resolver = _createResolver(scopes, prefixes);\r\n        cached = {\r\n            resolver,\r\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\r\n        };\r\n        cache.set(cacheKey, cached);\r\n    }\r\n    return cached;\r\n}\r\nconst hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key)=>acc || isFunction(value[key]), false);\r\nfunction needContext(proxy, names) {\r\n    const { isScriptable , isIndexable  } = _descriptors(proxy);\r\n    for (const prop of names){\r\n        const scriptable = isScriptable(prop);\r\n        const indexable = isIndexable(prop);\r\n        const value = (indexable || scriptable) && proxy[prop];\r\n        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvar version = \"4.2.1\";\r\n\r\nconst KNOWN_POSITIONS = [\r\n    'top',\r\n    'bottom',\r\n    'left',\r\n    'right',\r\n    'chartArea'\r\n];\r\nfunction positionIsHorizontal(position, axis) {\r\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\r\n}\r\nfunction compare2Level(l1, l2) {\r\n    return function(a, b) {\r\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\r\n    };\r\n}\r\nfunction onAnimationsComplete(context) {\r\n    const chart = context.chart;\r\n    const animationOptions = chart.options.animation;\r\n    chart.notifyPlugins('afterRender');\r\n    callback(animationOptions && animationOptions.onComplete, [\r\n        context\r\n    ], chart);\r\n}\r\nfunction onAnimationProgress(context) {\r\n    const chart = context.chart;\r\n    const animationOptions = chart.options.animation;\r\n    callback(animationOptions && animationOptions.onProgress, [\r\n        context\r\n    ], chart);\r\n}\r\n function getCanvas(item) {\r\n    if (_isDomSupported() && typeof item === 'string') {\r\n        item = document.getElementById(item);\r\n    } else if (item && item.length) {\r\n        item = item[0];\r\n    }\r\n    if (item && item.canvas) {\r\n        item = item.canvas;\r\n    }\r\n    return item;\r\n}\r\nconst instances = {};\r\nconst getChart = (key)=>{\r\n    const canvas = getCanvas(key);\r\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\r\n};\r\nfunction moveNumericKeys(obj, start, move) {\r\n    const keys = Object.keys(obj);\r\n    for (const key of keys){\r\n        const intKey = +key;\r\n        if (intKey >= start) {\r\n            const value = obj[key];\r\n            delete obj[key];\r\n            if (move > 0 || intKey > start) {\r\n                obj[intKey + move] = value;\r\n            }\r\n        }\r\n    }\r\n}\r\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\r\n    if (!inChartArea || e.type === 'mouseout') {\r\n        return null;\r\n    }\r\n    if (isClick) {\r\n        return lastEvent;\r\n    }\r\n    return e;\r\n}\r\nfunction getDatasetArea(meta) {\r\n    const { xScale , yScale  } = meta;\r\n    if (xScale && yScale) {\r\n        return {\r\n            left: xScale.left,\r\n            right: xScale.right,\r\n            top: yScale.top,\r\n            bottom: yScale.bottom\r\n        };\r\n    }\r\n}\r\nclass Chart {\r\n    static defaults = defaults;\r\n    static instances = instances;\r\n    static overrides = overrides;\r\n    static registry = registry;\r\n    static version = version;\r\n    static getChart = getChart;\r\n    static register(...items) {\r\n        registry.add(...items);\r\n        invalidatePlugins();\r\n    }\r\n    static unregister(...items) {\r\n        registry.remove(...items);\r\n        invalidatePlugins();\r\n    }\r\n    constructor(item, userConfig){\r\n        const config = this.config = new Config(userConfig);\r\n        const initialCanvas = getCanvas(item);\r\n        const existingChart = getChart(initialCanvas);\r\n        if (existingChart) {\r\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\r\n        }\r\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\r\n        this.platform.updateConfig(config);\r\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\r\n        const canvas = context && context.canvas;\r\n        const height = canvas && canvas.height;\r\n        const width = canvas && canvas.width;\r\n        this.id = uid();\r\n        this.ctx = context;\r\n        this.canvas = canvas;\r\n        this.width = width;\r\n        this.height = height;\r\n        this._options = options;\r\n        this._aspectRatio = this.aspectRatio;\r\n        this._layers = [];\r\n        this._metasets = [];\r\n        this._stacks = undefined;\r\n        this.boxes = [];\r\n        this.currentDevicePixelRatio = undefined;\r\n        this.chartArea = undefined;\r\n        this._active = [];\r\n        this._lastEvent = undefined;\r\n        this._listeners = {};\r\n         this._responsiveListeners = undefined;\r\n        this._sortedMetasets = [];\r\n        this.scales = {};\r\n        this._plugins = new PluginService();\r\n        this.$proxies = {};\r\n        this._hiddenIndices = {};\r\n        this.attached = false;\r\n        this._animationsDisabled = undefined;\r\n        this.$context = undefined;\r\n        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);\r\n        this._dataChanges = [];\r\n        instances[this.id] = this;\r\n        if (!context || !canvas) {\r\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n            return;\r\n        }\r\n        animator.listen(this, 'complete', onAnimationsComplete);\r\n        animator.listen(this, 'progress', onAnimationProgress);\r\n        this._initialize();\r\n        if (this.attached) {\r\n            this.update();\r\n        }\r\n    }\r\n    get aspectRatio() {\r\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\r\n        if (!isNullOrUndef(aspectRatio)) {\r\n            return aspectRatio;\r\n        }\r\n        if (maintainAspectRatio && _aspectRatio) {\r\n            return _aspectRatio;\r\n        }\r\n        return height ? width / height : null;\r\n    }\r\n    get data() {\r\n        return this.config.data;\r\n    }\r\n    set data(data) {\r\n        this.config.data = data;\r\n    }\r\n    get options() {\r\n        return this._options;\r\n    }\r\n    set options(options) {\r\n        this.config.options = options;\r\n    }\r\n    get registry() {\r\n        return registry;\r\n    }\r\n _initialize() {\r\n        this.notifyPlugins('beforeInit');\r\n        if (this.options.responsive) {\r\n            this.resize();\r\n        } else {\r\n            retinaScale(this, this.options.devicePixelRatio);\r\n        }\r\n        this.bindEvents();\r\n        this.notifyPlugins('afterInit');\r\n        return this;\r\n    }\r\n    clear() {\r\n        clearCanvas(this.canvas, this.ctx);\r\n        return this;\r\n    }\r\n    stop() {\r\n        animator.stop(this);\r\n        return this;\r\n    }\r\n resize(width, height) {\r\n        if (!animator.running(this)) {\r\n            this._resize(width, height);\r\n        } else {\r\n            this._resizeBeforeDraw = {\r\n                width,\r\n                height\r\n            };\r\n        }\r\n    }\r\n    _resize(width, height) {\r\n        const options = this.options;\r\n        const canvas = this.canvas;\r\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\r\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\r\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\r\n        const mode = this.width ? 'resize' : 'attach';\r\n        this.width = newSize.width;\r\n        this.height = newSize.height;\r\n        this._aspectRatio = this.aspectRatio;\r\n        if (!retinaScale(this, newRatio, true)) {\r\n            return;\r\n        }\r\n        this.notifyPlugins('resize', {\r\n            size: newSize\r\n        });\r\n        callback(options.onResize, [\r\n            this,\r\n            newSize\r\n        ], this);\r\n        if (this.attached) {\r\n            if (this._doResize(mode)) {\r\n                this.render();\r\n            }\r\n        }\r\n    }\r\n    ensureScalesHaveIDs() {\r\n        const options = this.options;\r\n        const scalesOptions = options.scales || {};\r\n        each(scalesOptions, (axisOptions, axisID)=>{\r\n            axisOptions.id = axisID;\r\n        });\r\n    }\r\n buildOrUpdateScales() {\r\n        const options = this.options;\r\n        const scaleOpts = options.scales;\r\n        const scales = this.scales;\r\n        const updated = Object.keys(scales).reduce((obj, id)=>{\r\n            obj[id] = false;\r\n            return obj;\r\n        }, {});\r\n        let items = [];\r\n        if (scaleOpts) {\r\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\r\n                const scaleOptions = scaleOpts[id];\r\n                const axis = determineAxis(id, scaleOptions);\r\n                const isRadial = axis === 'r';\r\n                const isHorizontal = axis === 'x';\r\n                return {\r\n                    options: scaleOptions,\r\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\r\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\r\n                };\r\n            }));\r\n        }\r\n        each(items, (item)=>{\r\n            const scaleOptions = item.options;\r\n            const id = scaleOptions.id;\r\n            const axis = determineAxis(id, scaleOptions);\r\n            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\r\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\r\n                scaleOptions.position = item.dposition;\r\n            }\r\n            updated[id] = true;\r\n            let scale = null;\r\n            if (id in scales && scales[id].type === scaleType) {\r\n                scale = scales[id];\r\n            } else {\r\n                const scaleClass = registry.getScale(scaleType);\r\n                scale = new scaleClass({\r\n                    id,\r\n                    type: scaleType,\r\n                    ctx: this.ctx,\r\n                    chart: this\r\n                });\r\n                scales[scale.id] = scale;\r\n            }\r\n            scale.init(scaleOptions, options);\r\n        });\r\n        each(updated, (hasUpdated, id)=>{\r\n            if (!hasUpdated) {\r\n                delete scales[id];\r\n            }\r\n        });\r\n        each(scales, (scale)=>{\r\n            layouts.configure(this, scale, scale.options);\r\n            layouts.addBox(this, scale);\r\n        });\r\n    }\r\n _updateMetasets() {\r\n        const metasets = this._metasets;\r\n        const numData = this.data.datasets.length;\r\n        const numMeta = metasets.length;\r\n        metasets.sort((a, b)=>a.index - b.index);\r\n        if (numMeta > numData) {\r\n            for(let i = numData; i < numMeta; ++i){\r\n                this._destroyDatasetMeta(i);\r\n            }\r\n            metasets.splice(numData, numMeta - numData);\r\n        }\r\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\r\n    }\r\n _removeUnreferencedMetasets() {\r\n        const { _metasets: metasets , data: { datasets  }  } = this;\r\n        if (metasets.length > datasets.length) {\r\n            delete this._stacks;\r\n        }\r\n        metasets.forEach((meta, index)=>{\r\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\r\n                this._destroyDatasetMeta(index);\r\n            }\r\n        });\r\n    }\r\n    buildOrUpdateControllers() {\r\n        const newControllers = [];\r\n        const datasets = this.data.datasets;\r\n        let i, ilen;\r\n        this._removeUnreferencedMetasets();\r\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\r\n            const dataset = datasets[i];\r\n            let meta = this.getDatasetMeta(i);\r\n            const type = dataset.type || this.config.type;\r\n            if (meta.type && meta.type !== type) {\r\n                this._destroyDatasetMeta(i);\r\n                meta = this.getDatasetMeta(i);\r\n            }\r\n            meta.type = type;\r\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\r\n            meta.order = dataset.order || 0;\r\n            meta.index = i;\r\n            meta.label = '' + dataset.label;\r\n            meta.visible = this.isDatasetVisible(i);\r\n            if (meta.controller) {\r\n                meta.controller.updateIndex(i);\r\n                meta.controller.linkScales();\r\n            } else {\r\n                const ControllerClass = registry.getController(type);\r\n                const { datasetElementType , dataElementType  } = defaults.datasets[type];\r\n                Object.assign(ControllerClass, {\r\n                    dataElementType: registry.getElement(dataElementType),\r\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\r\n                });\r\n                meta.controller = new ControllerClass(this, i);\r\n                newControllers.push(meta.controller);\r\n            }\r\n        }\r\n        this._updateMetasets();\r\n        return newControllers;\r\n    }\r\n _resetElements() {\r\n        each(this.data.datasets, (dataset, datasetIndex)=>{\r\n            this.getDatasetMeta(datasetIndex).controller.reset();\r\n        }, this);\r\n    }\r\n reset() {\r\n        this._resetElements();\r\n        this.notifyPlugins('reset');\r\n    }\r\n    update(mode) {\r\n        const config = this.config;\r\n        config.update();\r\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n        const animsDisabled = this._animationsDisabled = !options.animation;\r\n        this._updateScales();\r\n        this._checkEventBindings();\r\n        this._updateHiddenIndices();\r\n        this._plugins.invalidate();\r\n        if (this.notifyPlugins('beforeUpdate', {\r\n            mode,\r\n            cancelable: true\r\n        }) === false) {\r\n            return;\r\n        }\r\n        const newControllers = this.buildOrUpdateControllers();\r\n        this.notifyPlugins('beforeElementsUpdate');\r\n        let minPadding = 0;\r\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\r\n            const { controller  } = this.getDatasetMeta(i);\r\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\r\n            controller.buildOrUpdateElements(reset);\r\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\r\n        }\r\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\r\n        this._updateLayout(minPadding);\r\n        if (!animsDisabled) {\r\n            each(newControllers, (controller)=>{\r\n                controller.reset();\r\n            });\r\n        }\r\n        this._updateDatasets(mode);\r\n        this.notifyPlugins('afterUpdate', {\r\n            mode\r\n        });\r\n        this._layers.sort(compare2Level('z', '_idx'));\r\n        const { _active , _lastEvent  } = this;\r\n        if (_lastEvent) {\r\n            this._eventHandler(_lastEvent, true);\r\n        } else if (_active.length) {\r\n            this._updateHoverStyles(_active, _active, true);\r\n        }\r\n        this.render();\r\n    }\r\n _updateScales() {\r\n        each(this.scales, (scale)=>{\r\n            layouts.removeBox(this, scale);\r\n        });\r\n        this.ensureScalesHaveIDs();\r\n        this.buildOrUpdateScales();\r\n    }\r\n _checkEventBindings() {\r\n        const options = this.options;\r\n        const existingEvents = new Set(Object.keys(this._listeners));\r\n        const newEvents = new Set(options.events);\r\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\r\n            this.unbindEvents();\r\n            this.bindEvents();\r\n        }\r\n    }\r\n _updateHiddenIndices() {\r\n        const { _hiddenIndices  } = this;\r\n        const changes = this._getUniformDataChanges() || [];\r\n        for (const { method , start , count  } of changes){\r\n            const move = method === '_removeElements' ? -count : count;\r\n            moveNumericKeys(_hiddenIndices, start, move);\r\n        }\r\n    }\r\n _getUniformDataChanges() {\r\n        const _dataChanges = this._dataChanges;\r\n        if (!_dataChanges || !_dataChanges.length) {\r\n            return;\r\n        }\r\n        this._dataChanges = [];\r\n        const datasetCount = this.data.datasets.length;\r\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\r\n        const changeSet = makeSet(0);\r\n        for(let i = 1; i < datasetCount; i++){\r\n            if (!setsEqual(changeSet, makeSet(i))) {\r\n                return;\r\n            }\r\n        }\r\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\r\n                method: a[1],\r\n                start: +a[2],\r\n                count: +a[3]\r\n            }));\r\n    }\r\n _updateLayout(minPadding) {\r\n        if (this.notifyPlugins('beforeLayout', {\r\n            cancelable: true\r\n        }) === false) {\r\n            return;\r\n        }\r\n        layouts.update(this, this.width, this.height, minPadding);\r\n        const area = this.chartArea;\r\n        const noArea = area.width <= 0 || area.height <= 0;\r\n        this._layers = [];\r\n        each(this.boxes, (box)=>{\r\n            if (noArea && box.position === 'chartArea') {\r\n                return;\r\n            }\r\n            if (box.configure) {\r\n                box.configure();\r\n            }\r\n            this._layers.push(...box._layers());\r\n        }, this);\r\n        this._layers.forEach((item, index)=>{\r\n            item._idx = index;\r\n        });\r\n        this.notifyPlugins('afterLayout');\r\n    }\r\n _updateDatasets(mode) {\r\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\r\n            mode,\r\n            cancelable: true\r\n        }) === false) {\r\n            return;\r\n        }\r\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\r\n            this.getDatasetMeta(i).controller.configure();\r\n        }\r\n        for(let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1){\r\n            this._updateDataset(i1, isFunction(mode) ? mode({\r\n                datasetIndex: i1\r\n            }) : mode);\r\n        }\r\n        this.notifyPlugins('afterDatasetsUpdate', {\r\n            mode\r\n        });\r\n    }\r\n _updateDataset(index, mode) {\r\n        const meta = this.getDatasetMeta(index);\r\n        const args = {\r\n            meta,\r\n            index,\r\n            mode,\r\n            cancelable: true\r\n        };\r\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\r\n            return;\r\n        }\r\n        meta.controller._update(mode);\r\n        args.cancelable = false;\r\n        this.notifyPlugins('afterDatasetUpdate', args);\r\n    }\r\n    render() {\r\n        if (this.notifyPlugins('beforeRender', {\r\n            cancelable: true\r\n        }) === false) {\r\n            return;\r\n        }\r\n        if (animator.has(this)) {\r\n            if (this.attached && !animator.running(this)) {\r\n                animator.start(this);\r\n            }\r\n        } else {\r\n            this.draw();\r\n            onAnimationsComplete({\r\n                chart: this\r\n            });\r\n        }\r\n    }\r\n    draw() {\r\n        let i;\r\n        if (this._resizeBeforeDraw) {\r\n            const { width , height  } = this._resizeBeforeDraw;\r\n            this._resize(width, height);\r\n            this._resizeBeforeDraw = null;\r\n        }\r\n        this.clear();\r\n        if (this.width <= 0 || this.height <= 0) {\r\n            return;\r\n        }\r\n        if (this.notifyPlugins('beforeDraw', {\r\n            cancelable: true\r\n        }) === false) {\r\n            return;\r\n        }\r\n        const layers = this._layers;\r\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\r\n            layers[i].draw(this.chartArea);\r\n        }\r\n        this._drawDatasets();\r\n        for(; i < layers.length; ++i){\r\n            layers[i].draw(this.chartArea);\r\n        }\r\n        this.notifyPlugins('afterDraw');\r\n    }\r\n _getSortedDatasetMetas(filterVisible) {\r\n        const metasets = this._sortedMetasets;\r\n        const result = [];\r\n        let i, ilen;\r\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\r\n            const meta = metasets[i];\r\n            if (!filterVisible || meta.visible) {\r\n                result.push(meta);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n getSortedVisibleDatasetMetas() {\r\n        return this._getSortedDatasetMetas(true);\r\n    }\r\n _drawDatasets() {\r\n        if (this.notifyPlugins('beforeDatasetsDraw', {\r\n            cancelable: true\r\n        }) === false) {\r\n            return;\r\n        }\r\n        const metasets = this.getSortedVisibleDatasetMetas();\r\n        for(let i = metasets.length - 1; i >= 0; --i){\r\n            this._drawDataset(metasets[i]);\r\n        }\r\n        this.notifyPlugins('afterDatasetsDraw');\r\n    }\r\n _drawDataset(meta) {\r\n        const ctx = this.ctx;\r\n        const clip = meta._clip;\r\n        const useClip = !clip.disabled;\r\n        const area = getDatasetArea(meta) || this.chartArea;\r\n        const args = {\r\n            meta,\r\n            index: meta.index,\r\n            cancelable: true\r\n        };\r\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\r\n            return;\r\n        }\r\n        if (useClip) {\r\n            clipArea(ctx, {\r\n                left: clip.left === false ? 0 : area.left - clip.left,\r\n                right: clip.right === false ? this.width : area.right + clip.right,\r\n                top: clip.top === false ? 0 : area.top - clip.top,\r\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\r\n            });\r\n        }\r\n        meta.controller.draw();\r\n        if (useClip) {\r\n            unclipArea(ctx);\r\n        }\r\n        args.cancelable = false;\r\n        this.notifyPlugins('afterDatasetDraw', args);\r\n    }\r\n isPointInArea(point) {\r\n        return _isPointInArea(point, this.chartArea, this._minPadding);\r\n    }\r\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\r\n        const method = Interaction.modes[mode];\r\n        if (typeof method === 'function') {\r\n            return method(this, e, options, useFinalPosition);\r\n        }\r\n        return [];\r\n    }\r\n    getDatasetMeta(datasetIndex) {\r\n        const dataset = this.data.datasets[datasetIndex];\r\n        const metasets = this._metasets;\r\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\r\n        if (!meta) {\r\n            meta = {\r\n                type: null,\r\n                data: [],\r\n                dataset: null,\r\n                controller: null,\r\n                hidden: null,\r\n                xAxisID: null,\r\n                yAxisID: null,\r\n                order: dataset && dataset.order || 0,\r\n                index: datasetIndex,\r\n                _dataset: dataset,\r\n                _parsed: [],\r\n                _sorted: false\r\n            };\r\n            metasets.push(meta);\r\n        }\r\n        return meta;\r\n    }\r\n    getContext() {\r\n        return this.$context || (this.$context = createContext(null, {\r\n            chart: this,\r\n            type: 'chart'\r\n        }));\r\n    }\r\n    getVisibleDatasetCount() {\r\n        return this.getSortedVisibleDatasetMetas().length;\r\n    }\r\n    isDatasetVisible(datasetIndex) {\r\n        const dataset = this.data.datasets[datasetIndex];\r\n        if (!dataset) {\r\n            return false;\r\n        }\r\n        const meta = this.getDatasetMeta(datasetIndex);\r\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\r\n    }\r\n    setDatasetVisibility(datasetIndex, visible) {\r\n        const meta = this.getDatasetMeta(datasetIndex);\r\n        meta.hidden = !visible;\r\n    }\r\n    toggleDataVisibility(index) {\r\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\r\n    }\r\n    getDataVisibility(index) {\r\n        return !this._hiddenIndices[index];\r\n    }\r\n _updateVisibility(datasetIndex, dataIndex, visible) {\r\n        const mode = visible ? 'show' : 'hide';\r\n        const meta = this.getDatasetMeta(datasetIndex);\r\n        const anims = meta.controller._resolveAnimations(undefined, mode);\r\n        if (defined(dataIndex)) {\r\n            meta.data[dataIndex].hidden = !visible;\r\n            this.update();\r\n        } else {\r\n            this.setDatasetVisibility(datasetIndex, visible);\r\n            anims.update(meta, {\r\n                visible\r\n            });\r\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\r\n        }\r\n    }\r\n    hide(datasetIndex, dataIndex) {\r\n        this._updateVisibility(datasetIndex, dataIndex, false);\r\n    }\r\n    show(datasetIndex, dataIndex) {\r\n        this._updateVisibility(datasetIndex, dataIndex, true);\r\n    }\r\n _destroyDatasetMeta(datasetIndex) {\r\n        const meta = this._metasets[datasetIndex];\r\n        if (meta && meta.controller) {\r\n            meta.controller._destroy();\r\n        }\r\n        delete this._metasets[datasetIndex];\r\n    }\r\n    _stop() {\r\n        let i, ilen;\r\n        this.stop();\r\n        animator.remove(this);\r\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\r\n            this._destroyDatasetMeta(i);\r\n        }\r\n    }\r\n    destroy() {\r\n        this.notifyPlugins('beforeDestroy');\r\n        const { canvas , ctx  } = this;\r\n        this._stop();\r\n        this.config.clearCache();\r\n        if (canvas) {\r\n            this.unbindEvents();\r\n            clearCanvas(canvas, ctx);\r\n            this.platform.releaseContext(ctx);\r\n            this.canvas = null;\r\n            this.ctx = null;\r\n        }\r\n        delete instances[this.id];\r\n        this.notifyPlugins('afterDestroy');\r\n    }\r\n    toBase64Image(...args) {\r\n        return this.canvas.toDataURL(...args);\r\n    }\r\n bindEvents() {\r\n        this.bindUserEvents();\r\n        if (this.options.responsive) {\r\n            this.bindResponsiveEvents();\r\n        } else {\r\n            this.attached = true;\r\n        }\r\n    }\r\n bindUserEvents() {\r\n        const listeners = this._listeners;\r\n        const platform = this.platform;\r\n        const _add = (type, listener)=>{\r\n            platform.addEventListener(this, type, listener);\r\n            listeners[type] = listener;\r\n        };\r\n        const listener = (e, x, y)=>{\r\n            e.offsetX = x;\r\n            e.offsetY = y;\r\n            this._eventHandler(e);\r\n        };\r\n        each(this.options.events, (type)=>_add(type, listener));\r\n    }\r\n bindResponsiveEvents() {\r\n        if (!this._responsiveListeners) {\r\n            this._responsiveListeners = {};\r\n        }\r\n        const listeners = this._responsiveListeners;\r\n        const platform = this.platform;\r\n        const _add = (type, listener)=>{\r\n            platform.addEventListener(this, type, listener);\r\n            listeners[type] = listener;\r\n        };\r\n        const _remove = (type, listener)=>{\r\n            if (listeners[type]) {\r\n                platform.removeEventListener(this, type, listener);\r\n                delete listeners[type];\r\n            }\r\n        };\r\n        const listener = (width, height)=>{\r\n            if (this.canvas) {\r\n                this.resize(width, height);\r\n            }\r\n        };\r\n        let detached;\r\n        const attached = ()=>{\r\n            _remove('attach', attached);\r\n            this.attached = true;\r\n            this.resize();\r\n            _add('resize', listener);\r\n            _add('detach', detached);\r\n        };\r\n        detached = ()=>{\r\n            this.attached = false;\r\n            _remove('resize', listener);\r\n            this._stop();\r\n            this._resize(0, 0);\r\n            _add('attach', attached);\r\n        };\r\n        if (platform.isAttached(this.canvas)) {\r\n            attached();\r\n        } else {\r\n            detached();\r\n        }\r\n    }\r\n unbindEvents() {\r\n        each(this._listeners, (listener, type)=>{\r\n            this.platform.removeEventListener(this, type, listener);\r\n        });\r\n        this._listeners = {};\r\n        each(this._responsiveListeners, (listener, type)=>{\r\n            this.platform.removeEventListener(this, type, listener);\r\n        });\r\n        this._responsiveListeners = undefined;\r\n    }\r\n    updateHoverStyle(items, mode, enabled) {\r\n        const prefix = enabled ? 'set' : 'remove';\r\n        let meta, item, i, ilen;\r\n        if (mode === 'dataset') {\r\n            meta = this.getDatasetMeta(items[0].datasetIndex);\r\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\r\n        }\r\n        for(i = 0, ilen = items.length; i < ilen; ++i){\r\n            item = items[i];\r\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\r\n            if (controller) {\r\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\r\n            }\r\n        }\r\n    }\r\n getActiveElements() {\r\n        return this._active || [];\r\n    }\r\n setActiveElements(activeElements) {\r\n        const lastActive = this._active || [];\r\n        const active = activeElements.map(({ datasetIndex , index  })=>{\r\n            const meta = this.getDatasetMeta(datasetIndex);\r\n            if (!meta) {\r\n                throw new Error('No dataset found at index ' + datasetIndex);\r\n            }\r\n            return {\r\n                datasetIndex,\r\n                element: meta.data[index],\r\n                index\r\n            };\r\n        });\r\n        const changed = !_elementsEqual(active, lastActive);\r\n        if (changed) {\r\n            this._active = active;\r\n            this._lastEvent = null;\r\n            this._updateHoverStyles(active, lastActive);\r\n        }\r\n    }\r\n notifyPlugins(hook, args, filter) {\r\n        return this._plugins.notify(this, hook, args, filter);\r\n    }\r\n isPluginEnabled(pluginId) {\r\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\r\n    }\r\n _updateHoverStyles(active, lastActive, replay) {\r\n        const hoverOptions = this.options.hover;\r\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\r\n        const deactivated = diff(lastActive, active);\r\n        const activated = replay ? active : diff(active, lastActive);\r\n        if (deactivated.length) {\r\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\r\n        }\r\n        if (activated.length && hoverOptions.mode) {\r\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\r\n        }\r\n    }\r\n _eventHandler(e, replay) {\r\n        const args = {\r\n            event: e,\r\n            replay,\r\n            cancelable: true,\r\n            inChartArea: this.isPointInArea(e)\r\n        };\r\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\r\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\r\n            return;\r\n        }\r\n        const changed = this._handleEvent(e, replay, args.inChartArea);\r\n        args.cancelable = false;\r\n        this.notifyPlugins('afterEvent', args, eventFilter);\r\n        if (changed || args.changed) {\r\n            this.render();\r\n        }\r\n        return this;\r\n    }\r\n _handleEvent(e, replay, inChartArea) {\r\n        const { _active: lastActive = [] , options  } = this;\r\n        const useFinalPosition = replay;\r\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\r\n        const isClick = _isClickEvent(e);\r\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\r\n        if (inChartArea) {\r\n            this._lastEvent = null;\r\n            callback(options.onHover, [\r\n                e,\r\n                active,\r\n                this\r\n            ], this);\r\n            if (isClick) {\r\n                callback(options.onClick, [\r\n                    e,\r\n                    active,\r\n                    this\r\n                ], this);\r\n            }\r\n        }\r\n        const changed = !_elementsEqual(active, lastActive);\r\n        if (changed || replay) {\r\n            this._active = active;\r\n            this._updateHoverStyles(active, lastActive, replay);\r\n        }\r\n        this._lastEvent = lastEvent;\r\n        return changed;\r\n    }\r\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\r\n        if (e.type === 'mouseout') {\r\n            return [];\r\n        }\r\n        if (!inChartArea) {\r\n            return lastActive;\r\n        }\r\n        const hoverOptions = this.options.hover;\r\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\r\n    }\r\n}\r\nfunction invalidatePlugins() {\r\n    return each(Chart.instances, (chart)=>chart._plugins.invalidate());\r\n}\r\n\r\n/**\r\n * @namespace Chart._adapters\r\n * @since 2.8.0\r\n * @private\r\n */ function abstract() {\r\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\r\n}\r\n/**\r\n * Date adapter (current used by the time scale)\r\n * @namespace Chart._adapters._date\r\n * @memberof Chart._adapters\r\n * @private\r\n */ class DateAdapterBase {\r\n    /**\r\n   * Override default date adapter methods.\r\n   * Accepts type parameter to define options type.\r\n   * @example\r\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\r\n   *   init() {\r\n   *     console.log(this.options.myAdapterOption);\r\n   *   }\r\n   * })\r\n   */ static override(members) {\r\n        Object.assign(DateAdapterBase.prototype, members);\r\n    }\r\n    constructor(options){\r\n        this.options = options || {};\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    init() {}\r\n    formats() {\r\n        return abstract();\r\n    }\r\n    parse() {\r\n        return abstract();\r\n    }\r\n    format() {\r\n        return abstract();\r\n    }\r\n    add() {\r\n        return abstract();\r\n    }\r\n    diff() {\r\n        return abstract();\r\n    }\r\n    startOf() {\r\n        return abstract();\r\n    }\r\n    endOf() {\r\n        return abstract();\r\n    }\r\n}\r\nvar _adapters = {\r\n    _date: DateAdapterBase\r\n};\r\n\r\nfunction getAllScaleValues(scale, type) {\r\n    if (!scale._cache.$bar) {\r\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\r\n        let values = [];\r\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\r\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\r\n        }\r\n        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));\r\n    }\r\n    return scale._cache.$bar;\r\n}\r\n function computeMinSampleSize(meta) {\r\n    const scale = meta.iScale;\r\n    const values = getAllScaleValues(scale, meta.type);\r\n    let min = scale._length;\r\n    let i, ilen, curr, prev;\r\n    const updateMinAndPrev = ()=>{\r\n        if (curr === 32767 || curr === -32768) {\r\n            return;\r\n        }\r\n        if (defined(prev)) {\r\n            min = Math.min(min, Math.abs(curr - prev) || min);\r\n        }\r\n        prev = curr;\r\n    };\r\n    for(i = 0, ilen = values.length; i < ilen; ++i){\r\n        curr = scale.getPixelForValue(values[i]);\r\n        updateMinAndPrev();\r\n    }\r\n    prev = undefined;\r\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\r\n        curr = scale.getPixelForTick(i);\r\n        updateMinAndPrev();\r\n    }\r\n    return min;\r\n}\r\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\r\n    const thickness = options.barThickness;\r\n    let size, ratio;\r\n    if (isNullOrUndef(thickness)) {\r\n        size = ruler.min * options.categoryPercentage;\r\n        ratio = options.barPercentage;\r\n    } else {\r\n        size = thickness * stackCount;\r\n        ratio = 1;\r\n    }\r\n    return {\r\n        chunk: size / stackCount,\r\n        ratio,\r\n        start: ruler.pixels[index] - size / 2\r\n    };\r\n}\r\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\r\n    const pixels = ruler.pixels;\r\n    const curr = pixels[index];\r\n    let prev = index > 0 ? pixels[index - 1] : null;\r\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n    const percent = options.categoryPercentage;\r\n    if (prev === null) {\r\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n    }\r\n    if (next === null) {\r\n        next = curr + curr - prev;\r\n    }\r\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n    const size = Math.abs(next - prev) / 2 * percent;\r\n    return {\r\n        chunk: size / stackCount,\r\n        ratio: options.barPercentage,\r\n        start\r\n    };\r\n}\r\nfunction parseFloatBar(entry, item, vScale, i) {\r\n    const startValue = vScale.parse(entry[0], i);\r\n    const endValue = vScale.parse(entry[1], i);\r\n    const min = Math.min(startValue, endValue);\r\n    const max = Math.max(startValue, endValue);\r\n    let barStart = min;\r\n    let barEnd = max;\r\n    if (Math.abs(min) > Math.abs(max)) {\r\n        barStart = max;\r\n        barEnd = min;\r\n    }\r\n    item[vScale.axis] = barEnd;\r\n    item._custom = {\r\n        barStart,\r\n        barEnd,\r\n        start: startValue,\r\n        end: endValue,\r\n        min,\r\n        max\r\n    };\r\n}\r\nfunction parseValue(entry, item, vScale, i) {\r\n    if (isArray(entry)) {\r\n        parseFloatBar(entry, item, vScale, i);\r\n    } else {\r\n        item[vScale.axis] = vScale.parse(entry, i);\r\n    }\r\n    return item;\r\n}\r\nfunction parseArrayOrPrimitive(meta, data, start, count) {\r\n    const iScale = meta.iScale;\r\n    const vScale = meta.vScale;\r\n    const labels = iScale.getLabels();\r\n    const singleScale = iScale === vScale;\r\n    const parsed = [];\r\n    let i, ilen, item, entry;\r\n    for(i = start, ilen = start + count; i < ilen; ++i){\r\n        entry = data[i];\r\n        item = {};\r\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\r\n        parsed.push(parseValue(entry, item, vScale, i));\r\n    }\r\n    return parsed;\r\n}\r\nfunction isFloatBar(custom) {\r\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\r\n}\r\nfunction barSign(size, vScale, actualBase) {\r\n    if (size !== 0) {\r\n        return sign(size);\r\n    }\r\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\r\n}\r\nfunction borderProps(properties) {\r\n    let reverse, start, end, top, bottom;\r\n    if (properties.horizontal) {\r\n        reverse = properties.base > properties.x;\r\n        start = 'left';\r\n        end = 'right';\r\n    } else {\r\n        reverse = properties.base < properties.y;\r\n        start = 'bottom';\r\n        end = 'top';\r\n    }\r\n    if (reverse) {\r\n        top = 'end';\r\n        bottom = 'start';\r\n    } else {\r\n        top = 'start';\r\n        bottom = 'end';\r\n    }\r\n    return {\r\n        start,\r\n        end,\r\n        reverse,\r\n        top,\r\n        bottom\r\n    };\r\n}\r\nfunction setBorderSkipped(properties, options, stack, index) {\r\n    let edge = options.borderSkipped;\r\n    const res = {};\r\n    if (!edge) {\r\n        properties.borderSkipped = res;\r\n        return;\r\n    }\r\n    if (edge === true) {\r\n        properties.borderSkipped = {\r\n            top: true,\r\n            right: true,\r\n            bottom: true,\r\n            left: true\r\n        };\r\n        return;\r\n    }\r\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\r\n    if (edge === 'middle' && stack) {\r\n        properties.enableBorderRadius = true;\r\n        if ((stack._top || 0) === index) {\r\n            edge = top;\r\n        } else if ((stack._bottom || 0) === index) {\r\n            edge = bottom;\r\n        } else {\r\n            res[parseEdge(bottom, start, end, reverse)] = true;\r\n            edge = top;\r\n        }\r\n    }\r\n    res[parseEdge(edge, start, end, reverse)] = true;\r\n    properties.borderSkipped = res;\r\n}\r\nfunction parseEdge(edge, a, b, reverse) {\r\n    if (reverse) {\r\n        edge = swap(edge, a, b);\r\n        edge = startEnd(edge, b, a);\r\n    } else {\r\n        edge = startEnd(edge, a, b);\r\n    }\r\n    return edge;\r\n}\r\nfunction swap(orig, v1, v2) {\r\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\nfunction startEnd(v, start, end) {\r\n    return v === 'start' ? start : v === 'end' ? end : v;\r\n}\r\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\r\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\r\n}\r\nclass BarController extends DatasetController {\r\n    static id = 'bar';\r\n static defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'bar',\r\n        categoryPercentage: 0.8,\r\n        barPercentage: 0.9,\r\n        grouped: true,\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: [\r\n                    'x',\r\n                    'y',\r\n                    'base',\r\n                    'width',\r\n                    'height'\r\n                ]\r\n            }\r\n        }\r\n    };\r\n static overrides = {\r\n        scales: {\r\n            _index_: {\r\n                type: 'category',\r\n                offset: true,\r\n                grid: {\r\n                    offset: true\r\n                }\r\n            },\r\n            _value_: {\r\n                type: 'linear',\r\n                beginAtZero: true\r\n            }\r\n        }\r\n    };\r\n parsePrimitiveData(meta, data, start, count) {\r\n        return parseArrayOrPrimitive(meta, data, start, count);\r\n    }\r\n parseArrayData(meta, data, start, count) {\r\n        return parseArrayOrPrimitive(meta, data, start, count);\r\n    }\r\n parseObjectData(meta, data, start, count) {\r\n        const { iScale , vScale  } = meta;\r\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\r\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n        const parsed = [];\r\n        let i, ilen, item, obj;\r\n        for(i = start, ilen = start + count; i < ilen; ++i){\r\n            obj = data[i];\r\n            item = {};\r\n            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\r\n            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\r\n        }\r\n        return parsed;\r\n    }\r\n updateRangeFromParsed(range, scale, parsed, stack) {\r\n        super.updateRangeFromParsed(range, scale, parsed, stack);\r\n        const custom = parsed._custom;\r\n        if (custom && scale === this._cachedMeta.vScale) {\r\n            range.min = Math.min(range.min, custom.min);\r\n            range.max = Math.max(range.max, custom.max);\r\n        }\r\n    }\r\n getMaxOverflow() {\r\n        return 0;\r\n    }\r\n getLabelAndValue(index) {\r\n        const meta = this._cachedMeta;\r\n        const { iScale , vScale  } = meta;\r\n        const parsed = this.getParsed(index);\r\n        const custom = parsed._custom;\r\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\r\n        return {\r\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\r\n            value\r\n        };\r\n    }\r\n    initialize() {\r\n        this.enableOptionSharing = true;\r\n        super.initialize();\r\n        const meta = this._cachedMeta;\r\n        meta.stack = this.getDataset().stack;\r\n    }\r\n    update(mode) {\r\n        const meta = this._cachedMeta;\r\n        this.updateElements(meta.data, 0, meta.data.length, mode);\r\n    }\r\n    updateElements(bars, start, count, mode) {\r\n        const reset = mode === 'reset';\r\n        const { index , _cachedMeta: { vScale  }  } = this;\r\n        const base = vScale.getBasePixel();\r\n        const horizontal = vScale.isHorizontal();\r\n        const ruler = this._getRuler();\r\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\r\n        for(let i = start; i < start + count; i++){\r\n            const parsed = this.getParsed(i);\r\n            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\r\n                base,\r\n                head: base\r\n            } : this._calculateBarValuePixels(i);\r\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\r\n            const stack = (parsed._stacks || {})[vScale.axis];\r\n            const properties = {\r\n                horizontal,\r\n                base: vpixels.base,\r\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\r\n                x: horizontal ? vpixels.head : ipixels.center,\r\n                y: horizontal ? ipixels.center : vpixels.head,\r\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\r\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\r\n            };\r\n            if (includeOptions) {\r\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\r\n            }\r\n            const options = properties.options || bars[i].options;\r\n            setBorderSkipped(properties, options, stack, index);\r\n            setInflateAmount(properties, options, ruler.ratio);\r\n            this.updateElement(bars[i], i, properties, mode);\r\n        }\r\n    }\r\n _getStacks(last, dataIndex) {\r\n        const { iScale  } = this._cachedMeta;\r\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\r\n        const stacked = iScale.options.stacked;\r\n        const stacks = [];\r\n        const skipNull = (meta)=>{\r\n            const parsed = meta.controller.getParsed(dataIndex);\r\n            const val = parsed && parsed[meta.vScale.axis];\r\n            if (isNullOrUndef(val) || isNaN(val)) {\r\n                return true;\r\n            }\r\n        };\r\n        for (const meta of metasets){\r\n            if (dataIndex !== undefined && skipNull(meta)) {\r\n                continue;\r\n            }\r\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\r\n                stacks.push(meta.stack);\r\n            }\r\n            if (meta.index === last) {\r\n                break;\r\n            }\r\n        }\r\n        if (!stacks.length) {\r\n            stacks.push(undefined);\r\n        }\r\n        return stacks;\r\n    }\r\n _getStackCount(index) {\r\n        return this._getStacks(undefined, index).length;\r\n    }\r\n _getStackIndex(datasetIndex, name, dataIndex) {\r\n        const stacks = this._getStacks(datasetIndex, dataIndex);\r\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\r\n        return index === -1 ? stacks.length - 1 : index;\r\n    }\r\n _getRuler() {\r\n        const opts = this.options;\r\n        const meta = this._cachedMeta;\r\n        const iScale = meta.iScale;\r\n        const pixels = [];\r\n        let i, ilen;\r\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\r\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\r\n        }\r\n        const barThickness = opts.barThickness;\r\n        const min = barThickness || computeMinSampleSize(meta);\r\n        return {\r\n            min,\r\n            pixels,\r\n            start: iScale._startPixel,\r\n            end: iScale._endPixel,\r\n            stackCount: this._getStackCount(),\r\n            scale: iScale,\r\n            grouped: opts.grouped,\r\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\r\n        };\r\n    }\r\n _calculateBarValuePixels(index) {\r\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\r\n        const actualBase = baseValue || 0;\r\n        const parsed = this.getParsed(index);\r\n        const custom = parsed._custom;\r\n        const floating = isFloatBar(custom);\r\n        let value = parsed[vScale.axis];\r\n        let start = 0;\r\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\r\n        let head, size;\r\n        if (length !== value) {\r\n            start = length - value;\r\n            length = value;\r\n        }\r\n        if (floating) {\r\n            value = custom.barStart;\r\n            length = custom.barEnd - custom.barStart;\r\n            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\r\n                start = 0;\r\n            }\r\n            start += value;\r\n        }\r\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\r\n        let base = vScale.getPixelForValue(startValue);\r\n        if (this.chart.getDataVisibility(index)) {\r\n            head = vScale.getPixelForValue(start + length);\r\n        } else {\r\n            head = base;\r\n        }\r\n        size = head - base;\r\n        if (Math.abs(size) < minBarLength) {\r\n            size = barSign(size, vScale, actualBase) * minBarLength;\r\n            if (value === actualBase) {\r\n                base -= size / 2;\r\n            }\r\n            const startPixel = vScale.getPixelForDecimal(0);\r\n            const endPixel = vScale.getPixelForDecimal(1);\r\n            const min = Math.min(startPixel, endPixel);\r\n            const max = Math.max(startPixel, endPixel);\r\n            base = Math.max(Math.min(base, max), min);\r\n            head = base + size;\r\n            if (_stacked && !floating) {\r\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\r\n            }\r\n        }\r\n        if (base === vScale.getPixelForValue(actualBase)) {\r\n            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\r\n            base += halfGrid;\r\n            size -= halfGrid;\r\n        }\r\n        return {\r\n            size,\r\n            base,\r\n            head,\r\n            center: head + size / 2\r\n        };\r\n    }\r\n _calculateBarIndexPixels(index, ruler) {\r\n        const scale = ruler.scale;\r\n        const options = this.options;\r\n        const skipNull = options.skipNull;\r\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\r\n        let center, size;\r\n        if (ruler.grouped) {\r\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\r\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\r\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\r\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\r\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\r\n        } else {\r\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\r\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\r\n        }\r\n        return {\r\n            base: center - size / 2,\r\n            head: center + size / 2,\r\n            center,\r\n            size\r\n        };\r\n    }\r\n    draw() {\r\n        const meta = this._cachedMeta;\r\n        const vScale = meta.vScale;\r\n        const rects = meta.data;\r\n        const ilen = rects.length;\r\n        let i = 0;\r\n        for(; i < ilen; ++i){\r\n            if (this.getParsed(i)[vScale.axis] !== null) {\r\n                rects[i].draw(this._ctx);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass BubbleController extends DatasetController {\r\n    static id = 'bubble';\r\n static defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'point',\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: [\r\n                    'x',\r\n                    'y',\r\n                    'borderWidth',\r\n                    'radius'\r\n                ]\r\n            }\r\n        }\r\n    };\r\n static overrides = {\r\n        scales: {\r\n            x: {\r\n                type: 'linear'\r\n            },\r\n            y: {\r\n                type: 'linear'\r\n            }\r\n        }\r\n    };\r\n    initialize() {\r\n        this.enableOptionSharing = true;\r\n        super.initialize();\r\n    }\r\n parsePrimitiveData(meta, data, start, count) {\r\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\r\n        for(let i = 0; i < parsed.length; i++){\r\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\r\n        }\r\n        return parsed;\r\n    }\r\n parseArrayData(meta, data, start, count) {\r\n        const parsed = super.parseArrayData(meta, data, start, count);\r\n        for(let i = 0; i < parsed.length; i++){\r\n            const item = data[start + i];\r\n            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\r\n        }\r\n        return parsed;\r\n    }\r\n parseObjectData(meta, data, start, count) {\r\n        const parsed = super.parseObjectData(meta, data, start, count);\r\n        for(let i = 0; i < parsed.length; i++){\r\n            const item = data[start + i];\r\n            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\r\n        }\r\n        return parsed;\r\n    }\r\n getMaxOverflow() {\r\n        const data = this._cachedMeta.data;\r\n        let max = 0;\r\n        for(let i = data.length - 1; i >= 0; --i){\r\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n        }\r\n        return max > 0 && max;\r\n    }\r\n getLabelAndValue(index) {\r\n        const meta = this._cachedMeta;\r\n        const labels = this.chart.data.labels || [];\r\n        const { xScale , yScale  } = meta;\r\n        const parsed = this.getParsed(index);\r\n        const x = xScale.getLabelForValue(parsed.x);\r\n        const y = yScale.getLabelForValue(parsed.y);\r\n        const r = parsed._custom;\r\n        return {\r\n            label: labels[index] || '',\r\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\r\n        };\r\n    }\r\n    update(mode) {\r\n        const points = this._cachedMeta.data;\r\n        this.updateElements(points, 0, points.length, mode);\r\n    }\r\n    updateElements(points, start, count, mode) {\r\n        const reset = mode === 'reset';\r\n        const { iScale , vScale  } = this._cachedMeta;\r\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        for(let i = start; i < start + count; i++){\r\n            const point = points[i];\r\n            const parsed = !reset && this.getParsed(i);\r\n            const properties = {};\r\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\r\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\r\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\r\n            if (includeOptions) {\r\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n                if (reset) {\r\n                    properties.options.radius = 0;\r\n                }\r\n            }\r\n            this.updateElement(point, i, properties, mode);\r\n        }\r\n    }\r\n resolveDataElementOptions(index, mode) {\r\n        const parsed = this.getParsed(index);\r\n        let values = super.resolveDataElementOptions(index, mode);\r\n        if (values.$shared) {\r\n            values = Object.assign({}, values, {\r\n                $shared: false\r\n            });\r\n        }\r\n        const radius = values.radius;\r\n        if (mode !== 'active') {\r\n            values.radius = 0;\r\n        }\r\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\r\n        return values;\r\n    }\r\n}\r\n\r\nfunction getRatioAndOffset(rotation, circumference, cutout) {\r\n    let ratioX = 1;\r\n    let ratioY = 1;\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n    if (circumference < TAU) {\r\n        const startAngle = rotation;\r\n        const endAngle = startAngle + circumference;\r\n        const startX = Math.cos(startAngle);\r\n        const startY = Math.sin(startAngle);\r\n        const endX = Math.cos(endAngle);\r\n        const endY = Math.sin(endAngle);\r\n        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\r\n        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\r\n        const maxX = calcMax(0, startX, endX);\r\n        const maxY = calcMax(HALF_PI, startY, endY);\r\n        const minX = calcMin(PI, startX, endX);\r\n        const minY = calcMin(PI + HALF_PI, startY, endY);\r\n        ratioX = (maxX - minX) / 2;\r\n        ratioY = (maxY - minY) / 2;\r\n        offsetX = -(maxX + minX) / 2;\r\n        offsetY = -(maxY + minY) / 2;\r\n    }\r\n    return {\r\n        ratioX,\r\n        ratioY,\r\n        offsetX,\r\n        offsetY\r\n    };\r\n}\r\nclass DoughnutController extends DatasetController {\r\n    static id = 'doughnut';\r\n static defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'arc',\r\n        animation: {\r\n            animateRotate: true,\r\n            animateScale: false\r\n        },\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: [\r\n                    'circumference',\r\n                    'endAngle',\r\n                    'innerRadius',\r\n                    'outerRadius',\r\n                    'startAngle',\r\n                    'x',\r\n                    'y',\r\n                    'offset',\r\n                    'borderWidth',\r\n                    'spacing'\r\n                ]\r\n            }\r\n        },\r\n        cutout: '50%',\r\n        rotation: 0,\r\n        circumference: 360,\r\n        radius: '100%',\r\n        spacing: 0,\r\n        indexAxis: 'r'\r\n    };\r\n    static descriptors = {\r\n        _scriptable: (name)=>name !== 'spacing',\r\n        _indexable: (name)=>name !== 'spacing'\r\n    };\r\n static overrides = {\r\n        aspectRatio: 1,\r\n        plugins: {\r\n            legend: {\r\n                labels: {\r\n                    generateLabels (chart) {\r\n                        const data = chart.data;\r\n                        if (data.labels.length && data.datasets.length) {\r\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\r\n                            return data.labels.map((label, i)=>{\r\n                                const meta = chart.getDatasetMeta(0);\r\n                                const style = meta.controller.getStyle(i);\r\n                                return {\r\n                                    text: label,\r\n                                    fillStyle: style.backgroundColor,\r\n                                    strokeStyle: style.borderColor,\r\n                                    fontColor: color,\r\n                                    lineWidth: style.borderWidth,\r\n                                    pointStyle: pointStyle,\r\n                                    hidden: !chart.getDataVisibility(i),\r\n                                    index: i\r\n                                };\r\n                            });\r\n                        }\r\n                        return [];\r\n                    }\r\n                },\r\n                onClick (e, legendItem, legend) {\r\n                    legend.chart.toggleDataVisibility(legendItem.index);\r\n                    legend.chart.update();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    constructor(chart, datasetIndex){\r\n        super(chart, datasetIndex);\r\n        this.enableOptionSharing = true;\r\n        this.innerRadius = undefined;\r\n        this.outerRadius = undefined;\r\n        this.offsetX = undefined;\r\n        this.offsetY = undefined;\r\n    }\r\n    linkScales() {}\r\n parse(start, count) {\r\n        const data = this.getDataset().data;\r\n        const meta = this._cachedMeta;\r\n        if (this._parsing === false) {\r\n            meta._parsed = data;\r\n        } else {\r\n            let getter = (i)=>+data[i];\r\n            if (isObject(data[start])) {\r\n                const { key ='value'  } = this._parsing;\r\n                getter = (i)=>+resolveObjectKey(data[i], key);\r\n            }\r\n            let i, ilen;\r\n            for(i = start, ilen = start + count; i < ilen; ++i){\r\n                meta._parsed[i] = getter(i);\r\n            }\r\n        }\r\n    }\r\n _getRotation() {\r\n        return toRadians(this.options.rotation - 90);\r\n    }\r\n _getCircumference() {\r\n        return toRadians(this.options.circumference);\r\n    }\r\n _getRotationExtents() {\r\n        let min = TAU;\r\n        let max = -TAU;\r\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\r\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\r\n                const controller = this.chart.getDatasetMeta(i).controller;\r\n                const rotation = controller._getRotation();\r\n                const circumference = controller._getCircumference();\r\n                min = Math.min(min, rotation);\r\n                max = Math.max(max, rotation + circumference);\r\n            }\r\n        }\r\n        return {\r\n            rotation: min,\r\n            circumference: max - min\r\n        };\r\n    }\r\n update(mode) {\r\n        const chart = this.chart;\r\n        const { chartArea  } = chart;\r\n        const meta = this._cachedMeta;\r\n        const arcs = meta.data;\r\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\r\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\r\n        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\r\n        const chartWeight = this._getRingWeight(this.index);\r\n        const { circumference , rotation  } = this._getRotationExtents();\r\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\r\n        const maxWidth = (chartArea.width - spacing) / ratioX;\r\n        const maxHeight = (chartArea.height - spacing) / ratioY;\r\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n        const outerRadius = toDimension(this.options.radius, maxRadius);\r\n        const innerRadius = Math.max(outerRadius * cutout, 0);\r\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\r\n        this.offsetX = offsetX * outerRadius;\r\n        this.offsetY = offsetY * outerRadius;\r\n        meta.total = this.calculateTotal();\r\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\r\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\r\n        this.updateElements(arcs, 0, arcs.length, mode);\r\n    }\r\n _circumference(i, reset) {\r\n        const opts = this.options;\r\n        const meta = this._cachedMeta;\r\n        const circumference = this._getCircumference();\r\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\r\n            return 0;\r\n        }\r\n        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\r\n    }\r\n    updateElements(arcs, start, count, mode) {\r\n        const reset = mode === 'reset';\r\n        const chart = this.chart;\r\n        const chartArea = chart.chartArea;\r\n        const opts = chart.options;\r\n        const animationOpts = opts.animation;\r\n        const centerX = (chartArea.left + chartArea.right) / 2;\r\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\r\n        const animateScale = reset && animationOpts.animateScale;\r\n        const innerRadius = animateScale ? 0 : this.innerRadius;\r\n        const outerRadius = animateScale ? 0 : this.outerRadius;\r\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\r\n        let startAngle = this._getRotation();\r\n        let i;\r\n        for(i = 0; i < start; ++i){\r\n            startAngle += this._circumference(i, reset);\r\n        }\r\n        for(i = start; i < start + count; ++i){\r\n            const circumference = this._circumference(i, reset);\r\n            const arc = arcs[i];\r\n            const properties = {\r\n                x: centerX + this.offsetX,\r\n                y: centerY + this.offsetY,\r\n                startAngle,\r\n                endAngle: startAngle + circumference,\r\n                circumference,\r\n                outerRadius,\r\n                innerRadius\r\n            };\r\n            if (includeOptions) {\r\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\r\n            }\r\n            startAngle += circumference;\r\n            this.updateElement(arc, i, properties, mode);\r\n        }\r\n    }\r\n    calculateTotal() {\r\n        const meta = this._cachedMeta;\r\n        const metaData = meta.data;\r\n        let total = 0;\r\n        let i;\r\n        for(i = 0; i < metaData.length; i++){\r\n            const value = meta._parsed[i];\r\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\r\n                total += Math.abs(value);\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    calculateCircumference(value) {\r\n        const total = this._cachedMeta.total;\r\n        if (total > 0 && !isNaN(value)) {\r\n            return TAU * (Math.abs(value) / total);\r\n        }\r\n        return 0;\r\n    }\r\n    getLabelAndValue(index) {\r\n        const meta = this._cachedMeta;\r\n        const chart = this.chart;\r\n        const labels = chart.data.labels || [];\r\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\r\n        return {\r\n            label: labels[index] || '',\r\n            value\r\n        };\r\n    }\r\n    getMaxBorderWidth(arcs) {\r\n        let max = 0;\r\n        const chart = this.chart;\r\n        let i, ilen, meta, controller, options;\r\n        if (!arcs) {\r\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\r\n                if (chart.isDatasetVisible(i)) {\r\n                    meta = chart.getDatasetMeta(i);\r\n                    arcs = meta.data;\r\n                    controller = meta.controller;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!arcs) {\r\n            return 0;\r\n        }\r\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\r\n            options = controller.resolveDataElementOptions(i);\r\n            if (options.borderAlign !== 'inner') {\r\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    getMaxOffset(arcs) {\r\n        let max = 0;\r\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\r\n            const options = this.resolveDataElementOptions(i);\r\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\r\n        }\r\n        return max;\r\n    }\r\n _getRingWeightOffset(datasetIndex) {\r\n        let ringWeightOffset = 0;\r\n        for(let i = 0; i < datasetIndex; ++i){\r\n            if (this.chart.isDatasetVisible(i)) {\r\n                ringWeightOffset += this._getRingWeight(i);\r\n            }\r\n        }\r\n        return ringWeightOffset;\r\n    }\r\n _getRingWeight(datasetIndex) {\r\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\r\n    }\r\n _getVisibleDatasetWeightTotal() {\r\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\r\n    }\r\n}\r\n\r\nclass LineController extends DatasetController {\r\n    static id = 'line';\r\n static defaults = {\r\n        datasetElementType: 'line',\r\n        dataElementType: 'point',\r\n        showLine: true,\r\n        spanGaps: false\r\n    };\r\n static overrides = {\r\n        scales: {\r\n            _index_: {\r\n                type: 'category'\r\n            },\r\n            _value_: {\r\n                type: 'linear'\r\n            }\r\n        }\r\n    };\r\n    initialize() {\r\n        this.enableOptionSharing = true;\r\n        this.supportsDecimation = true;\r\n        super.initialize();\r\n    }\r\n    update(mode) {\r\n        const meta = this._cachedMeta;\r\n        const { dataset: line , data: points = [] , _dataset  } = meta;\r\n        const animationsDisabled = this.chart._animationsDisabled;\r\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n        this._drawStart = start;\r\n        this._drawCount = count;\r\n        if (_scaleRangesChanged(meta)) {\r\n            start = 0;\r\n            count = points.length;\r\n        }\r\n        line._chart = this.chart;\r\n        line._datasetIndex = this.index;\r\n        line._decimated = !!_dataset._decimated;\r\n        line.points = points;\r\n        const options = this.resolveDatasetElementOptions(mode);\r\n        if (!this.options.showLine) {\r\n            options.borderWidth = 0;\r\n        }\r\n        options.segment = this.options.segment;\r\n        this.updateElement(line, undefined, {\r\n            animated: !animationsDisabled,\r\n            options\r\n        }, mode);\r\n        this.updateElements(points, start, count, mode);\r\n    }\r\n    updateElements(points, start, count, mode) {\r\n        const reset = mode === 'reset';\r\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\r\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        const { spanGaps , segment  } = this.options;\r\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n        const end = start + count;\r\n        const pointsCount = points.length;\r\n        let prevParsed = start > 0 && this.getParsed(start - 1);\r\n        for(let i = 0; i < pointsCount; ++i){\r\n            const point = points[i];\r\n            const properties = directUpdate ? point : {};\r\n            if (i < start || i >= end) {\r\n                properties.skip = true;\r\n                continue;\r\n            }\r\n            const parsed = this.getParsed(i);\r\n            const nullData = isNullOrUndef(parsed[vAxis]);\r\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\r\n            if (segment) {\r\n                properties.parsed = parsed;\r\n                properties.raw = _dataset.data[i];\r\n            }\r\n            if (includeOptions) {\r\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n            }\r\n            if (!directUpdate) {\r\n                this.updateElement(point, i, properties, mode);\r\n            }\r\n            prevParsed = parsed;\r\n        }\r\n    }\r\n getMaxOverflow() {\r\n        const meta = this._cachedMeta;\r\n        const dataset = meta.dataset;\r\n        const border = dataset.options && dataset.options.borderWidth || 0;\r\n        const data = meta.data || [];\r\n        if (!data.length) {\r\n            return border;\r\n        }\r\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n        return Math.max(border, firstPoint, lastPoint) / 2;\r\n    }\r\n    draw() {\r\n        const meta = this._cachedMeta;\r\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\r\n        super.draw();\r\n    }\r\n}\r\n\r\nclass PolarAreaController extends DatasetController {\r\n    static id = 'polarArea';\r\n static defaults = {\r\n        dataElementType: 'arc',\r\n        animation: {\r\n            animateRotate: true,\r\n            animateScale: true\r\n        },\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: [\r\n                    'x',\r\n                    'y',\r\n                    'startAngle',\r\n                    'endAngle',\r\n                    'innerRadius',\r\n                    'outerRadius'\r\n                ]\r\n            }\r\n        },\r\n        indexAxis: 'r',\r\n        startAngle: 0\r\n    };\r\n static overrides = {\r\n        aspectRatio: 1,\r\n        plugins: {\r\n            legend: {\r\n                labels: {\r\n                    generateLabels (chart) {\r\n                        const data = chart.data;\r\n                        if (data.labels.length && data.datasets.length) {\r\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\r\n                            return data.labels.map((label, i)=>{\r\n                                const meta = chart.getDatasetMeta(0);\r\n                                const style = meta.controller.getStyle(i);\r\n                                return {\r\n                                    text: label,\r\n                                    fillStyle: style.backgroundColor,\r\n                                    strokeStyle: style.borderColor,\r\n                                    fontColor: color,\r\n                                    lineWidth: style.borderWidth,\r\n                                    pointStyle: pointStyle,\r\n                                    hidden: !chart.getDataVisibility(i),\r\n                                    index: i\r\n                                };\r\n                            });\r\n                        }\r\n                        return [];\r\n                    }\r\n                },\r\n                onClick (e, legendItem, legend) {\r\n                    legend.chart.toggleDataVisibility(legendItem.index);\r\n                    legend.chart.update();\r\n                }\r\n            }\r\n        },\r\n        scales: {\r\n            r: {\r\n                type: 'radialLinear',\r\n                angleLines: {\r\n                    display: false\r\n                },\r\n                beginAtZero: true,\r\n                grid: {\r\n                    circular: true\r\n                },\r\n                pointLabels: {\r\n                    display: false\r\n                },\r\n                startAngle: 0\r\n            }\r\n        }\r\n    };\r\n    constructor(chart, datasetIndex){\r\n        super(chart, datasetIndex);\r\n        this.innerRadius = undefined;\r\n        this.outerRadius = undefined;\r\n    }\r\n    getLabelAndValue(index) {\r\n        const meta = this._cachedMeta;\r\n        const chart = this.chart;\r\n        const labels = chart.data.labels || [];\r\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\r\n        return {\r\n            label: labels[index] || '',\r\n            value\r\n        };\r\n    }\r\n    parseObjectData(meta, data, start, count) {\r\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n    }\r\n    update(mode) {\r\n        const arcs = this._cachedMeta.data;\r\n        this._updateRadius();\r\n        this.updateElements(arcs, 0, arcs.length, mode);\r\n    }\r\n getMinMax() {\r\n        const meta = this._cachedMeta;\r\n        const range = {\r\n            min: Number.POSITIVE_INFINITY,\r\n            max: Number.NEGATIVE_INFINITY\r\n        };\r\n        meta.data.forEach((element, index)=>{\r\n            const parsed = this.getParsed(index).r;\r\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\r\n                if (parsed < range.min) {\r\n                    range.min = parsed;\r\n                }\r\n                if (parsed > range.max) {\r\n                    range.max = parsed;\r\n                }\r\n            }\r\n        });\r\n        return range;\r\n    }\r\n _updateRadius() {\r\n        const chart = this.chart;\r\n        const chartArea = chart.chartArea;\r\n        const opts = chart.options;\r\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n        const outerRadius = Math.max(minSize / 2, 0);\r\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\r\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\r\n        this.outerRadius = outerRadius - radiusLength * this.index;\r\n        this.innerRadius = this.outerRadius - radiusLength;\r\n    }\r\n    updateElements(arcs, start, count, mode) {\r\n        const reset = mode === 'reset';\r\n        const chart = this.chart;\r\n        const opts = chart.options;\r\n        const animationOpts = opts.animation;\r\n        const scale = this._cachedMeta.rScale;\r\n        const centerX = scale.xCenter;\r\n        const centerY = scale.yCenter;\r\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\r\n        let angle = datasetStartAngle;\r\n        let i;\r\n        const defaultAngle = 360 / this.countVisibleElements();\r\n        for(i = 0; i < start; ++i){\r\n            angle += this._computeAngle(i, mode, defaultAngle);\r\n        }\r\n        for(i = start; i < start + count; i++){\r\n            const arc = arcs[i];\r\n            let startAngle = angle;\r\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\r\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\r\n            angle = endAngle;\r\n            if (reset) {\r\n                if (animationOpts.animateScale) {\r\n                    outerRadius = 0;\r\n                }\r\n                if (animationOpts.animateRotate) {\r\n                    startAngle = endAngle = datasetStartAngle;\r\n                }\r\n            }\r\n            const properties = {\r\n                x: centerX,\r\n                y: centerY,\r\n                innerRadius: 0,\r\n                outerRadius,\r\n                startAngle,\r\n                endAngle,\r\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\r\n            };\r\n            this.updateElement(arc, i, properties, mode);\r\n        }\r\n    }\r\n    countVisibleElements() {\r\n        const meta = this._cachedMeta;\r\n        let count = 0;\r\n        meta.data.forEach((element, index)=>{\r\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\r\n                count++;\r\n            }\r\n        });\r\n        return count;\r\n    }\r\n _computeAngle(index, mode, defaultAngle) {\r\n        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\r\n    }\r\n}\r\n\r\nclass PieController extends DoughnutController {\r\n    static id = 'pie';\r\n static defaults = {\r\n        cutout: 0,\r\n        rotation: 0,\r\n        circumference: 360,\r\n        radius: '100%'\r\n    };\r\n}\r\n\r\nclass RadarController extends DatasetController {\r\n    static id = 'radar';\r\n static defaults = {\r\n        datasetElementType: 'line',\r\n        dataElementType: 'point',\r\n        indexAxis: 'r',\r\n        showLine: true,\r\n        elements: {\r\n            line: {\r\n                fill: 'start'\r\n            }\r\n        }\r\n    };\r\n static overrides = {\r\n        aspectRatio: 1,\r\n        scales: {\r\n            r: {\r\n                type: 'radialLinear'\r\n            }\r\n        }\r\n    };\r\n getLabelAndValue(index) {\r\n        const vScale = this._cachedMeta.vScale;\r\n        const parsed = this.getParsed(index);\r\n        return {\r\n            label: vScale.getLabels()[index],\r\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\r\n        };\r\n    }\r\n    parseObjectData(meta, data, start, count) {\r\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n    }\r\n    update(mode) {\r\n        const meta = this._cachedMeta;\r\n        const line = meta.dataset;\r\n        const points = meta.data || [];\r\n        const labels = meta.iScale.getLabels();\r\n        line.points = points;\r\n        if (mode !== 'resize') {\r\n            const options = this.resolveDatasetElementOptions(mode);\r\n            if (!this.options.showLine) {\r\n                options.borderWidth = 0;\r\n            }\r\n            const properties = {\r\n                _loop: true,\r\n                _fullLoop: labels.length === points.length,\r\n                options\r\n            };\r\n            this.updateElement(line, undefined, properties, mode);\r\n        }\r\n        this.updateElements(points, 0, points.length, mode);\r\n    }\r\n    updateElements(points, start, count, mode) {\r\n        const scale = this._cachedMeta.rScale;\r\n        const reset = mode === 'reset';\r\n        for(let i = start; i < start + count; i++){\r\n            const point = points[i];\r\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\r\n            const x = reset ? scale.xCenter : pointPosition.x;\r\n            const y = reset ? scale.yCenter : pointPosition.y;\r\n            const properties = {\r\n                x,\r\n                y,\r\n                angle: pointPosition.angle,\r\n                skip: isNaN(x) || isNaN(y),\r\n                options\r\n            };\r\n            this.updateElement(point, i, properties, mode);\r\n        }\r\n    }\r\n}\r\n\r\nclass ScatterController extends DatasetController {\r\n    static id = 'scatter';\r\n static defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'point',\r\n        showLine: false,\r\n        fill: false\r\n    };\r\n static overrides = {\r\n        interaction: {\r\n            mode: 'point'\r\n        },\r\n        scales: {\r\n            x: {\r\n                type: 'linear'\r\n            },\r\n            y: {\r\n                type: 'linear'\r\n            }\r\n        }\r\n    };\r\n getLabelAndValue(index) {\r\n        const meta = this._cachedMeta;\r\n        const labels = this.chart.data.labels || [];\r\n        const { xScale , yScale  } = meta;\r\n        const parsed = this.getParsed(index);\r\n        const x = xScale.getLabelForValue(parsed.x);\r\n        const y = yScale.getLabelForValue(parsed.y);\r\n        return {\r\n            label: labels[index] || '',\r\n            value: '(' + x + ', ' + y + ')'\r\n        };\r\n    }\r\n    update(mode) {\r\n        const meta = this._cachedMeta;\r\n        const { data: points = []  } = meta;\r\n        const animationsDisabled = this.chart._animationsDisabled;\r\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n        this._drawStart = start;\r\n        this._drawCount = count;\r\n        if (_scaleRangesChanged(meta)) {\r\n            start = 0;\r\n            count = points.length;\r\n        }\r\n        if (this.options.showLine) {\r\n            const { dataset: line , _dataset  } = meta;\r\n            line._chart = this.chart;\r\n            line._datasetIndex = this.index;\r\n            line._decimated = !!_dataset._decimated;\r\n            line.points = points;\r\n            const options = this.resolveDatasetElementOptions(mode);\r\n            options.segment = this.options.segment;\r\n            this.updateElement(line, undefined, {\r\n                animated: !animationsDisabled,\r\n                options\r\n            }, mode);\r\n        }\r\n        this.updateElements(points, start, count, mode);\r\n    }\r\n    addElements() {\r\n        const { showLine  } = this.options;\r\n        if (!this.datasetElementType && showLine) {\r\n            this.datasetElementType = this.chart.registry.getElement('line');\r\n        }\r\n        super.addElements();\r\n    }\r\n    updateElements(points, start, count, mode) {\r\n        const reset = mode === 'reset';\r\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\r\n        const firstOpts = this.resolveDataElementOptions(start, mode);\r\n        const sharedOptions = this.getSharedOptions(firstOpts);\r\n        const includeOptions = this.includeOptions(mode, sharedOptions);\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        const { spanGaps , segment  } = this.options;\r\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n        let prevParsed = start > 0 && this.getParsed(start - 1);\r\n        for(let i = start; i < start + count; ++i){\r\n            const point = points[i];\r\n            const parsed = this.getParsed(i);\r\n            const properties = directUpdate ? point : {};\r\n            const nullData = isNullOrUndef(parsed[vAxis]);\r\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\r\n            if (segment) {\r\n                properties.parsed = parsed;\r\n                properties.raw = _dataset.data[i];\r\n            }\r\n            if (includeOptions) {\r\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n            }\r\n            if (!directUpdate) {\r\n                this.updateElement(point, i, properties, mode);\r\n            }\r\n            prevParsed = parsed;\r\n        }\r\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n    }\r\n getMaxOverflow() {\r\n        const meta = this._cachedMeta;\r\n        const data = meta.data || [];\r\n        if (!this.options.showLine) {\r\n            let max = 0;\r\n            for(let i = data.length - 1; i >= 0; --i){\r\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n            }\r\n            return max > 0 && max;\r\n        }\r\n        const dataset = meta.dataset;\r\n        const border = dataset.options && dataset.options.borderWidth || 0;\r\n        if (!data.length) {\r\n            return border;\r\n        }\r\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n        return Math.max(border, firstPoint, lastPoint) / 2;\r\n    }\r\n}\r\n\r\nvar controllers = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nBarController: BarController,\r\nBubbleController: BubbleController,\r\nDoughnutController: DoughnutController,\r\nLineController: LineController,\r\nPolarAreaController: PolarAreaController,\r\nPieController: PieController,\r\nRadarController: RadarController,\r\nScatterController: ScatterController\r\n});\r\n\r\nfunction clipArc(ctx, element, endAngle) {\r\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\r\n    let angleMargin = pixelMargin / outerRadius;\r\n    // Draw an inner border by clipping the arc and drawing a double-width border\r\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n    if (innerRadius > pixelMargin) {\r\n        angleMargin = pixelMargin / innerRadius;\r\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\r\n    } else {\r\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\r\n    }\r\n    ctx.closePath();\r\n    ctx.clip();\r\n}\r\nfunction toRadiusCorners(value) {\r\n    return _readValueToProps(value, [\r\n        'outerStart',\r\n        'outerEnd',\r\n        'innerStart',\r\n        'innerEnd'\r\n    ]);\r\n}\r\n/**\r\n * Parse border radius from the provided options\r\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\r\n    const o = toRadiusCorners(arc.options.borderRadius);\r\n    const halfThickness = (outerRadius - innerRadius) / 2;\r\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\r\n    // Outer limits are complicated. We want to compute the available angular distance at\r\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\r\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\r\n    //\r\n    // If the borderRadius is large, that value can become negative.\r\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\r\n    // we know that the thickness term will dominate and compute the limits at that point\r\n    const computeOuterLimit = (val)=>{\r\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\r\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\r\n    };\r\n    return {\r\n        outerStart: computeOuterLimit(o.outerStart),\r\n        outerEnd: computeOuterLimit(o.outerEnd),\r\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\r\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\r\n    };\r\n}\r\n/**\r\n * Convert (r, 𝜃) to (x, y)\r\n */ function rThetaToXY(r, theta, x, y) {\r\n    return {\r\n        x: x + r * Math.cos(theta),\r\n        y: y + r * Math.sin(theta)\r\n    };\r\n}\r\n/**\r\n * Path the arc, respecting border radius by separating into left and right halves.\r\n *\r\n *   Start      End\r\n *\r\n *    1--->a--->2    Outer\r\n *   /           \\\r\n *   8           3\r\n *   |           |\r\n *   |           |\r\n *   7           4\r\n *   \\           /\r\n *    6<---b<---5    Inner\r\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\r\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\r\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\r\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\r\n    let spacingOffset = 0;\r\n    const alpha = end - start;\r\n    if (spacing) {\r\n        // When spacing is present, it is the same for all items\r\n        // So we adjust the start and end angle of the arc such that\r\n        // the distance is the same as it would be without the spacing\r\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\r\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\r\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\r\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\r\n        spacingOffset = (alpha - adjustedAngle) / 2;\r\n    }\r\n    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\r\n    const angleOffset = (alpha - beta) / 2;\r\n    const startAngle = start + angleOffset + spacingOffset;\r\n    const endAngle = end - angleOffset - spacingOffset;\r\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\r\n    const outerStartAdjustedRadius = outerRadius - outerStart;\r\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\r\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\r\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\r\n    const innerStartAdjustedRadius = innerRadius + innerStart;\r\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\r\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\r\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\r\n    ctx.beginPath();\r\n    if (circular) {\r\n        // The first arc segments from point 1 to point a to point 2\r\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\r\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\r\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\r\n        // The corner segment from point 2 to point 3\r\n        if (outerEnd > 0) {\r\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\r\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\r\n        }\r\n        // The line from point 3 to point 4\r\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\r\n        ctx.lineTo(p4.x, p4.y);\r\n        // The corner segment from point 4 to point 5\r\n        if (innerEnd > 0) {\r\n            const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\r\n            ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\r\n        }\r\n        // The inner arc from point 5 to point b to point 6\r\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\r\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\r\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\r\n        // The corner segment from point 6 to point 7\r\n        if (innerStart > 0) {\r\n            const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\r\n            ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\r\n        }\r\n        // The line from point 7 to point 8\r\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\r\n        ctx.lineTo(p8.x, p8.y);\r\n        // The corner segment from point 8 to point 1\r\n        if (outerStart > 0) {\r\n            const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\r\n            ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\r\n        }\r\n    } else {\r\n        ctx.moveTo(x, y);\r\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\r\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\r\n        ctx.lineTo(outerStartX, outerStartY);\r\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\r\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\r\n        ctx.lineTo(outerEndX, outerEndY);\r\n    }\r\n    ctx.closePath();\r\n}\r\nfunction drawArc(ctx, element, offset, spacing, circular) {\r\n    const { fullCircles , startAngle , circumference  } = element;\r\n    let endAngle = element.endAngle;\r\n    if (fullCircles) {\r\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n        for(let i = 0; i < fullCircles; ++i){\r\n            ctx.fill();\r\n        }\r\n        if (!isNaN(circumference)) {\r\n            endAngle = startAngle + (circumference % TAU || TAU);\r\n        }\r\n    }\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    ctx.fill();\r\n    return endAngle;\r\n}\r\nfunction drawBorder(ctx, element, offset, spacing, circular) {\r\n    const { fullCircles , startAngle , circumference , options  } = element;\r\n    const { borderWidth , borderJoinStyle  } = options;\r\n    const inner = options.borderAlign === 'inner';\r\n    if (!borderWidth) {\r\n        return;\r\n    }\r\n    if (inner) {\r\n        ctx.lineWidth = borderWidth * 2;\r\n        ctx.lineJoin = borderJoinStyle || 'round';\r\n    } else {\r\n        ctx.lineWidth = borderWidth;\r\n        ctx.lineJoin = borderJoinStyle || 'bevel';\r\n    }\r\n    let endAngle = element.endAngle;\r\n    if (fullCircles) {\r\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n        for(let i = 0; i < fullCircles; ++i){\r\n            ctx.stroke();\r\n        }\r\n        if (!isNaN(circumference)) {\r\n            endAngle = startAngle + (circumference % TAU || TAU);\r\n        }\r\n    }\r\n    if (inner) {\r\n        clipArc(ctx, element, endAngle);\r\n    }\r\n    if (!fullCircles) {\r\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n        ctx.stroke();\r\n    }\r\n}\r\nclass ArcElement extends Element {\r\n    static id = 'arc';\r\n    static defaults = {\r\n        borderAlign: 'center',\r\n        borderColor: '#fff',\r\n        borderJoinStyle: undefined,\r\n        borderRadius: 0,\r\n        borderWidth: 2,\r\n        offset: 0,\r\n        spacing: 0,\r\n        angle: undefined,\r\n        circular: true\r\n    };\r\n    static defaultRoutes = {\r\n        backgroundColor: 'backgroundColor'\r\n    };\r\n    constructor(cfg){\r\n        super();\r\n        this.options = undefined;\r\n        this.circumference = undefined;\r\n        this.startAngle = undefined;\r\n        this.endAngle = undefined;\r\n        this.innerRadius = undefined;\r\n        this.outerRadius = undefined;\r\n        this.pixelMargin = 0;\r\n        this.fullCircles = 0;\r\n        if (cfg) {\r\n            Object.assign(this, cfg);\r\n        }\r\n    }\r\n    inRange(chartX, chartY, useFinalPosition) {\r\n        const point = this.getProps([\r\n            'x',\r\n            'y'\r\n        ], useFinalPosition);\r\n        const { angle , distance  } = getAngleFromPoint(point, {\r\n            x: chartX,\r\n            y: chartY\r\n        });\r\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\r\n            'startAngle',\r\n            'endAngle',\r\n            'innerRadius',\r\n            'outerRadius',\r\n            'circumference'\r\n        ], useFinalPosition);\r\n        const rAdjust = this.options.spacing / 2;\r\n        const _circumference = valueOrDefault(circumference, endAngle - startAngle);\r\n        const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\r\n        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\r\n        return betweenAngles && withinRadius;\r\n    }\r\n    getCenterPoint(useFinalPosition) {\r\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\r\n            'x',\r\n            'y',\r\n            'startAngle',\r\n            'endAngle',\r\n            'innerRadius',\r\n            'outerRadius'\r\n        ], useFinalPosition);\r\n        const { offset , spacing  } = this.options;\r\n        const halfAngle = (startAngle + endAngle) / 2;\r\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\r\n        return {\r\n            x: x + Math.cos(halfAngle) * halfRadius,\r\n            y: y + Math.sin(halfAngle) * halfRadius\r\n        };\r\n    }\r\n    tooltipPosition(useFinalPosition) {\r\n        return this.getCenterPoint(useFinalPosition);\r\n    }\r\n    draw(ctx) {\r\n        const { options , circumference  } = this;\r\n        const offset = (options.offset || 0) / 4;\r\n        const spacing = (options.spacing || 0) / 2;\r\n        const circular = options.circular;\r\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\r\n        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\r\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\r\n            return;\r\n        }\r\n        ctx.save();\r\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\r\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\r\n        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\r\n        const radiusOffset = offset * fix;\r\n        ctx.fillStyle = options.backgroundColor;\r\n        ctx.strokeStyle = options.borderColor;\r\n        drawArc(ctx, this, radiusOffset, spacing, circular);\r\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\nfunction setStyle(ctx, options, style = options) {\r\n    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\r\n    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\r\n    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\r\n    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\r\n    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\r\n    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\r\n}\r\nfunction lineTo(ctx, previous, target) {\r\n    ctx.lineTo(target.x, target.y);\r\n}\r\nfunction getLineMethod(options) {\r\n    if (options.stepped) {\r\n        return _steppedLineTo;\r\n    }\r\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n        return _bezierCurveTo;\r\n    }\r\n    return lineTo;\r\n}\r\nfunction pathVars(points, segment, params = {}) {\r\n    const count = points.length;\r\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\r\n    const { start: segmentStart , end: segmentEnd  } = segment;\r\n    const start = Math.max(paramsStart, segmentStart);\r\n    const end = Math.min(paramsEnd, segmentEnd);\r\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\r\n    return {\r\n        count,\r\n        start,\r\n        loop: segment.loop,\r\n        ilen: end < start && !outside ? count + end - start : end - start\r\n    };\r\n}\r\n function pathSegment(ctx, line, segment, params) {\r\n    const { points , options  } = line;\r\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\r\n    const lineMethod = getLineMethod(options);\r\n    let { move =true , reverse  } = params || {};\r\n    let i, point, prev;\r\n    for(i = 0; i <= ilen; ++i){\r\n        point = points[(start + (reverse ? ilen - i : i)) % count];\r\n        if (point.skip) {\r\n            continue;\r\n        } else if (move) {\r\n            ctx.moveTo(point.x, point.y);\r\n            move = false;\r\n        } else {\r\n            lineMethod(ctx, prev, point, reverse, options.stepped);\r\n        }\r\n        prev = point;\r\n    }\r\n    if (loop) {\r\n        point = points[(start + (reverse ? ilen : 0)) % count];\r\n        lineMethod(ctx, prev, point, reverse, options.stepped);\r\n    }\r\n    return !!loop;\r\n}\r\n function fastPathSegment(ctx, line, segment, params) {\r\n    const points = line.points;\r\n    const { count , start , ilen  } = pathVars(points, segment, params);\r\n    const { move =true , reverse  } = params || {};\r\n    let avgX = 0;\r\n    let countX = 0;\r\n    let i, point, prevX, minY, maxY, lastY;\r\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\r\n    const drawX = ()=>{\r\n        if (minY !== maxY) {\r\n            ctx.lineTo(avgX, maxY);\r\n            ctx.lineTo(avgX, minY);\r\n            ctx.lineTo(avgX, lastY);\r\n        }\r\n    };\r\n    if (move) {\r\n        point = points[pointIndex(0)];\r\n        ctx.moveTo(point.x, point.y);\r\n    }\r\n    for(i = 0; i <= ilen; ++i){\r\n        point = points[pointIndex(i)];\r\n        if (point.skip) {\r\n            continue;\r\n        }\r\n        const x = point.x;\r\n        const y = point.y;\r\n        const truncX = x | 0;\r\n        if (truncX === prevX) {\r\n            if (y < minY) {\r\n                minY = y;\r\n            } else if (y > maxY) {\r\n                maxY = y;\r\n            }\r\n            avgX = (countX * avgX + x) / ++countX;\r\n        } else {\r\n            drawX();\r\n            ctx.lineTo(x, y);\r\n            prevX = truncX;\r\n            countX = 0;\r\n            minY = maxY = y;\r\n        }\r\n        lastY = y;\r\n    }\r\n    drawX();\r\n}\r\n function _getSegmentMethod(line) {\r\n    const opts = line.options;\r\n    const borderDash = opts.borderDash && opts.borderDash.length;\r\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\r\n    return useFastPath ? fastPathSegment : pathSegment;\r\n}\r\n function _getInterpolationMethod(options) {\r\n    if (options.stepped) {\r\n        return _steppedInterpolation;\r\n    }\r\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n        return _bezierInterpolation;\r\n    }\r\n    return _pointInLine;\r\n}\r\nfunction strokePathWithCache(ctx, line, start, count) {\r\n    let path = line._path;\r\n    if (!path) {\r\n        path = line._path = new Path2D();\r\n        if (line.path(path, start, count)) {\r\n            path.closePath();\r\n        }\r\n    }\r\n    setStyle(ctx, line.options);\r\n    ctx.stroke(path);\r\n}\r\nfunction strokePathDirect(ctx, line, start, count) {\r\n    const { segments , options  } = line;\r\n    const segmentMethod = _getSegmentMethod(line);\r\n    for (const segment of segments){\r\n        setStyle(ctx, options, segment.style);\r\n        ctx.beginPath();\r\n        if (segmentMethod(ctx, line, segment, {\r\n            start,\r\n            end: start + count - 1\r\n        })) {\r\n            ctx.closePath();\r\n        }\r\n        ctx.stroke();\r\n    }\r\n}\r\nconst usePath2D = typeof Path2D === 'function';\r\nfunction draw(ctx, line, start, count) {\r\n    if (usePath2D && !line.options.segment) {\r\n        strokePathWithCache(ctx, line, start, count);\r\n    } else {\r\n        strokePathDirect(ctx, line, start, count);\r\n    }\r\n}\r\nclass LineElement extends Element {\r\n    static id = 'line';\r\n static defaults = {\r\n        borderCapStyle: 'butt',\r\n        borderDash: [],\r\n        borderDashOffset: 0,\r\n        borderJoinStyle: 'miter',\r\n        borderWidth: 3,\r\n        capBezierPoints: true,\r\n        cubicInterpolationMode: 'default',\r\n        fill: false,\r\n        spanGaps: false,\r\n        stepped: false,\r\n        tension: 0\r\n    };\r\n static defaultRoutes = {\r\n        backgroundColor: 'backgroundColor',\r\n        borderColor: 'borderColor'\r\n    };\r\n    static descriptors = {\r\n        _scriptable: true,\r\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\r\n    };\r\n    constructor(cfg){\r\n        super();\r\n        this.animated = true;\r\n        this.options = undefined;\r\n        this._chart = undefined;\r\n        this._loop = undefined;\r\n        this._fullLoop = undefined;\r\n        this._path = undefined;\r\n        this._points = undefined;\r\n        this._segments = undefined;\r\n        this._decimated = false;\r\n        this._pointsUpdated = false;\r\n        this._datasetIndex = undefined;\r\n        if (cfg) {\r\n            Object.assign(this, cfg);\r\n        }\r\n    }\r\n    updateControlPoints(chartArea, indexAxis) {\r\n        const options = this.options;\r\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\r\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\r\n            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\r\n            this._pointsUpdated = true;\r\n        }\r\n    }\r\n    set points(points) {\r\n        this._points = points;\r\n        delete this._segments;\r\n        delete this._path;\r\n        this._pointsUpdated = false;\r\n    }\r\n    get points() {\r\n        return this._points;\r\n    }\r\n    get segments() {\r\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\r\n    }\r\n first() {\r\n        const segments = this.segments;\r\n        const points = this.points;\r\n        return segments.length && points[segments[0].start];\r\n    }\r\n last() {\r\n        const segments = this.segments;\r\n        const points = this.points;\r\n        const count = segments.length;\r\n        return count && points[segments[count - 1].end];\r\n    }\r\n interpolate(point, property) {\r\n        const options = this.options;\r\n        const value = point[property];\r\n        const points = this.points;\r\n        const segments = _boundSegments(this, {\r\n            property,\r\n            start: value,\r\n            end: value\r\n        });\r\n        if (!segments.length) {\r\n            return;\r\n        }\r\n        const result = [];\r\n        const _interpolate = _getInterpolationMethod(options);\r\n        let i, ilen;\r\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\r\n            const { start , end  } = segments[i];\r\n            const p1 = points[start];\r\n            const p2 = points[end];\r\n            if (p1 === p2) {\r\n                result.push(p1);\r\n                continue;\r\n            }\r\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\r\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\r\n            interpolated[property] = point[property];\r\n            result.push(interpolated);\r\n        }\r\n        return result.length === 1 ? result[0] : result;\r\n    }\r\n pathSegment(ctx, segment, params) {\r\n        const segmentMethod = _getSegmentMethod(this);\r\n        return segmentMethod(ctx, this, segment, params);\r\n    }\r\n path(ctx, start, count) {\r\n        const segments = this.segments;\r\n        const segmentMethod = _getSegmentMethod(this);\r\n        let loop = this._loop;\r\n        start = start || 0;\r\n        count = count || this.points.length - start;\r\n        for (const segment of segments){\r\n            loop &= segmentMethod(ctx, this, segment, {\r\n                start,\r\n                end: start + count - 1\r\n            });\r\n        }\r\n        return !!loop;\r\n    }\r\n draw(ctx, chartArea, start, count) {\r\n        const options = this.options || {};\r\n        const points = this.points || [];\r\n        if (points.length && options.borderWidth) {\r\n            ctx.save();\r\n            draw(ctx, this, start, count);\r\n            ctx.restore();\r\n        }\r\n        if (this.animated) {\r\n            this._pointsUpdated = false;\r\n            this._path = undefined;\r\n        }\r\n    }\r\n}\r\n\r\nfunction inRange$1(el, pos, axis, useFinalPosition) {\r\n    const options = el.options;\r\n    const { [axis]: value  } = el.getProps([\r\n        axis\r\n    ], useFinalPosition);\r\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\r\n}\r\nclass PointElement extends Element {\r\n    static id = 'point';\r\n    /**\r\n   * @type {any}\r\n   */ static defaults = {\r\n        borderWidth: 1,\r\n        hitRadius: 1,\r\n        hoverBorderWidth: 1,\r\n        hoverRadius: 4,\r\n        pointStyle: 'circle',\r\n        radius: 3,\r\n        rotation: 0\r\n    };\r\n    /**\r\n   * @type {any}\r\n   */ static defaultRoutes = {\r\n        backgroundColor: 'backgroundColor',\r\n        borderColor: 'borderColor'\r\n    };\r\n    constructor(cfg){\r\n        super();\r\n        this.options = undefined;\r\n        this.parsed = undefined;\r\n        this.skip = undefined;\r\n        this.stop = undefined;\r\n        if (cfg) {\r\n            Object.assign(this, cfg);\r\n        }\r\n    }\r\n    inRange(mouseX, mouseY, useFinalPosition) {\r\n        const options = this.options;\r\n        const { x , y  } = this.getProps([\r\n            'x',\r\n            'y'\r\n        ], useFinalPosition);\r\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\r\n    }\r\n    inXRange(mouseX, useFinalPosition) {\r\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\r\n    }\r\n    inYRange(mouseY, useFinalPosition) {\r\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\r\n    }\r\n    getCenterPoint(useFinalPosition) {\r\n        const { x , y  } = this.getProps([\r\n            'x',\r\n            'y'\r\n        ], useFinalPosition);\r\n        return {\r\n            x,\r\n            y\r\n        };\r\n    }\r\n    size(options) {\r\n        options = options || this.options || {};\r\n        let radius = options.radius || 0;\r\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\r\n        const borderWidth = radius && options.borderWidth || 0;\r\n        return (radius + borderWidth) * 2;\r\n    }\r\n    draw(ctx, area) {\r\n        const options = this.options;\r\n        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\r\n            return;\r\n        }\r\n        ctx.strokeStyle = options.borderColor;\r\n        ctx.lineWidth = options.borderWidth;\r\n        ctx.fillStyle = options.backgroundColor;\r\n        drawPoint(ctx, options, this.x, this.y);\r\n    }\r\n    getRange() {\r\n        const options = this.options || {};\r\n        // @ts-expect-error Fallbacks should never be hit in practice\r\n        return options.radius + options.hitRadius;\r\n    }\r\n}\r\n\r\nfunction getBarBounds(bar, useFinalPosition) {\r\n    const { x , y , base , width , height  } =  bar.getProps([\r\n        'x',\r\n        'y',\r\n        'base',\r\n        'width',\r\n        'height'\r\n    ], useFinalPosition);\r\n    let left, right, top, bottom, half;\r\n    if (bar.horizontal) {\r\n        half = height / 2;\r\n        left = Math.min(x, base);\r\n        right = Math.max(x, base);\r\n        top = y - half;\r\n        bottom = y + half;\r\n    } else {\r\n        half = width / 2;\r\n        left = x - half;\r\n        right = x + half;\r\n        top = Math.min(y, base);\r\n        bottom = Math.max(y, base);\r\n    }\r\n    return {\r\n        left,\r\n        top,\r\n        right,\r\n        bottom\r\n    };\r\n}\r\nfunction skipOrLimit(skip, value, min, max) {\r\n    return skip ? 0 : _limitValue(value, min, max);\r\n}\r\nfunction parseBorderWidth(bar, maxW, maxH) {\r\n    const value = bar.options.borderWidth;\r\n    const skip = bar.borderSkipped;\r\n    const o = toTRBL(value);\r\n    return {\r\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\r\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\r\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\r\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\r\n    };\r\n}\r\nfunction parseBorderRadius(bar, maxW, maxH) {\r\n    const { enableBorderRadius  } = bar.getProps([\r\n        'enableBorderRadius'\r\n    ]);\r\n    const value = bar.options.borderRadius;\r\n    const o = toTRBLCorners(value);\r\n    const maxR = Math.min(maxW, maxH);\r\n    const skip = bar.borderSkipped;\r\n    const enableBorder = enableBorderRadius || isObject(value);\r\n    return {\r\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\r\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\r\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\r\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\r\n    };\r\n}\r\nfunction boundingRects(bar) {\r\n    const bounds = getBarBounds(bar);\r\n    const width = bounds.right - bounds.left;\r\n    const height = bounds.bottom - bounds.top;\r\n    const border = parseBorderWidth(bar, width / 2, height / 2);\r\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\r\n    return {\r\n        outer: {\r\n            x: bounds.left,\r\n            y: bounds.top,\r\n            w: width,\r\n            h: height,\r\n            radius\r\n        },\r\n        inner: {\r\n            x: bounds.left + border.l,\r\n            y: bounds.top + border.t,\r\n            w: width - border.l - border.r,\r\n            h: height - border.t - border.b,\r\n            radius: {\r\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\r\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\r\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\r\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction inRange(bar, x, y, useFinalPosition) {\r\n    const skipX = x === null;\r\n    const skipY = y === null;\r\n    const skipBoth = skipX && skipY;\r\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\r\n    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\r\n}\r\nfunction hasRadius(radius) {\r\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\r\n}\r\n function addNormalRectPath(ctx, rect) {\r\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n}\r\nfunction inflateRect(rect, amount, refRect = {}) {\r\n    const x = rect.x !== refRect.x ? -amount : 0;\r\n    const y = rect.y !== refRect.y ? -amount : 0;\r\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\r\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\r\n    return {\r\n        x: rect.x + x,\r\n        y: rect.y + y,\r\n        w: rect.w + w,\r\n        h: rect.h + h,\r\n        radius: rect.radius\r\n    };\r\n}\r\nclass BarElement extends Element {\r\n    static id = 'bar';\r\n static defaults = {\r\n        borderSkipped: 'start',\r\n        borderWidth: 0,\r\n        borderRadius: 0,\r\n        inflateAmount: 'auto',\r\n        pointStyle: undefined\r\n    };\r\n static defaultRoutes = {\r\n        backgroundColor: 'backgroundColor',\r\n        borderColor: 'borderColor'\r\n    };\r\n    constructor(cfg){\r\n        super();\r\n        this.options = undefined;\r\n        this.horizontal = undefined;\r\n        this.base = undefined;\r\n        this.width = undefined;\r\n        this.height = undefined;\r\n        this.inflateAmount = undefined;\r\n        if (cfg) {\r\n            Object.assign(this, cfg);\r\n        }\r\n    }\r\n    draw(ctx) {\r\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\r\n        const { inner , outer  } = boundingRects(this);\r\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\r\n        ctx.save();\r\n        if (outer.w !== inner.w || outer.h !== inner.h) {\r\n            ctx.beginPath();\r\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\r\n            ctx.clip();\r\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\r\n            ctx.fillStyle = borderColor;\r\n            ctx.fill('evenodd');\r\n        }\r\n        ctx.beginPath();\r\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\r\n        ctx.fillStyle = backgroundColor;\r\n        ctx.fill();\r\n        ctx.restore();\r\n    }\r\n    inRange(mouseX, mouseY, useFinalPosition) {\r\n        return inRange(this, mouseX, mouseY, useFinalPosition);\r\n    }\r\n    inXRange(mouseX, useFinalPosition) {\r\n        return inRange(this, mouseX, null, useFinalPosition);\r\n    }\r\n    inYRange(mouseY, useFinalPosition) {\r\n        return inRange(this, null, mouseY, useFinalPosition);\r\n    }\r\n    getCenterPoint(useFinalPosition) {\r\n        const { x , y , base , horizontal  } =  this.getProps([\r\n            'x',\r\n            'y',\r\n            'base',\r\n            'horizontal'\r\n        ], useFinalPosition);\r\n        return {\r\n            x: horizontal ? (x + base) / 2 : x,\r\n            y: horizontal ? y : (y + base) / 2\r\n        };\r\n    }\r\n    getRange(axis) {\r\n        return axis === 'x' ? this.width / 2 : this.height / 2;\r\n    }\r\n}\r\n\r\nvar elements = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nArcElement: ArcElement,\r\nLineElement: LineElement,\r\nPointElement: PointElement,\r\nBarElement: BarElement\r\n});\r\n\r\nconst addIfString = (labels, raw, index, addedLabels)=>{\r\n    if (typeof raw === 'string') {\r\n        index = labels.push(raw) - 1;\r\n        addedLabels.unshift({\r\n            index,\r\n            label: raw\r\n        });\r\n    } else if (isNaN(raw)) {\r\n        index = null;\r\n    }\r\n    return index;\r\n};\r\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\r\n    const first = labels.indexOf(raw);\r\n    if (first === -1) {\r\n        return addIfString(labels, raw, index, addedLabels);\r\n    }\r\n    const last = labels.lastIndexOf(raw);\r\n    return first !== last ? index : first;\r\n}\r\nconst validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);\r\nfunction _getLabelForValue(value) {\r\n    const labels = this.getLabels();\r\n    if (value >= 0 && value < labels.length) {\r\n        return labels[value];\r\n    }\r\n    return value;\r\n}\r\nclass CategoryScale extends Scale {\r\n    static id = 'category';\r\n static defaults = {\r\n        ticks: {\r\n            callback: _getLabelForValue\r\n        }\r\n    };\r\n    constructor(cfg){\r\n        super(cfg);\r\n         this._startValue = undefined;\r\n        this._valueRange = 0;\r\n        this._addedLabels = [];\r\n    }\r\n    init(scaleOptions) {\r\n        const added = this._addedLabels;\r\n        if (added.length) {\r\n            const labels = this.getLabels();\r\n            for (const { index , label  } of added){\r\n                if (labels[index] === label) {\r\n                    labels.splice(index, 1);\r\n                }\r\n            }\r\n            this._addedLabels = [];\r\n        }\r\n        super.init(scaleOptions);\r\n    }\r\n    parse(raw, index) {\r\n        if (isNullOrUndef(raw)) {\r\n            return null;\r\n        }\r\n        const labels = this.getLabels();\r\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\r\n        return validIndex(index, labels.length - 1);\r\n    }\r\n    determineDataLimits() {\r\n        const { minDefined , maxDefined  } = this.getUserBounds();\r\n        let { min , max  } = this.getMinMax(true);\r\n        if (this.options.bounds === 'ticks') {\r\n            if (!minDefined) {\r\n                min = 0;\r\n            }\r\n            if (!maxDefined) {\r\n                max = this.getLabels().length - 1;\r\n            }\r\n        }\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    buildTicks() {\r\n        const min = this.min;\r\n        const max = this.max;\r\n        const offset = this.options.offset;\r\n        const ticks = [];\r\n        let labels = this.getLabels();\r\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\r\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\r\n        this._startValue = this.min - (offset ? 0.5 : 0);\r\n        for(let value = min; value <= max; value++){\r\n            ticks.push({\r\n                value\r\n            });\r\n        }\r\n        return ticks;\r\n    }\r\n    getLabelForValue(value) {\r\n        return _getLabelForValue.call(this, value);\r\n    }\r\n configure() {\r\n        super.configure();\r\n        if (!this.isHorizontal()) {\r\n            this._reversePixels = !this._reversePixels;\r\n        }\r\n    }\r\n    getPixelForValue(value) {\r\n        if (typeof value !== 'number') {\r\n            value = this.parse(value);\r\n        }\r\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n    }\r\n    getPixelForTick(index) {\r\n        const ticks = this.ticks;\r\n        if (index < 0 || index > ticks.length - 1) {\r\n            return null;\r\n        }\r\n        return this.getPixelForValue(ticks[index].value);\r\n    }\r\n    getValueForPixel(pixel) {\r\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\r\n    }\r\n    getBasePixel() {\r\n        return this.bottom;\r\n    }\r\n}\r\n\r\nfunction generateTicks$1(generationOptions, dataRange) {\r\n    const ticks = [];\r\n    const MIN_SPACING = 1e-14;\r\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\r\n    const unit = step || 1;\r\n    const maxSpaces = maxTicks - 1;\r\n    const { min: rmin , max: rmax  } = dataRange;\r\n    const minDefined = !isNullOrUndef(min);\r\n    const maxDefined = !isNullOrUndef(max);\r\n    const countDefined = !isNullOrUndef(count);\r\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\r\n    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\r\n    let factor, niceMin, niceMax, numSpaces;\r\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\r\n        return [\r\n            {\r\n                value: rmin\r\n            },\r\n            {\r\n                value: rmax\r\n            }\r\n        ];\r\n    }\r\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n    if (numSpaces > maxSpaces) {\r\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\r\n    }\r\n    if (!isNullOrUndef(precision)) {\r\n        factor = Math.pow(10, precision);\r\n        spacing = Math.ceil(spacing * factor) / factor;\r\n    }\r\n    if (bounds === 'ticks') {\r\n        niceMin = Math.floor(rmin / spacing) * spacing;\r\n        niceMax = Math.ceil(rmax / spacing) * spacing;\r\n    } else {\r\n        niceMin = rmin;\r\n        niceMax = rmax;\r\n    }\r\n    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\r\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\r\n        spacing = (max - min) / numSpaces;\r\n        niceMin = min;\r\n        niceMax = max;\r\n    } else if (countDefined) {\r\n        niceMin = minDefined ? min : niceMin;\r\n        niceMax = maxDefined ? max : niceMax;\r\n        numSpaces = count - 1;\r\n        spacing = (niceMax - niceMin) / numSpaces;\r\n    } else {\r\n        numSpaces = (niceMax - niceMin) / spacing;\r\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n            numSpaces = Math.round(numSpaces);\r\n        } else {\r\n            numSpaces = Math.ceil(numSpaces);\r\n        }\r\n    }\r\n    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\r\n    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\r\n    niceMin = Math.round(niceMin * factor) / factor;\r\n    niceMax = Math.round(niceMax * factor) / factor;\r\n    let j = 0;\r\n    if (minDefined) {\r\n        if (includeBounds && niceMin !== min) {\r\n            ticks.push({\r\n                value: min\r\n            });\r\n            if (niceMin < min) {\r\n                j++;\r\n            }\r\n            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\r\n                j++;\r\n            }\r\n        } else if (niceMin < min) {\r\n            j++;\r\n        }\r\n    }\r\n    for(; j < numSpaces; ++j){\r\n        ticks.push({\r\n            value: Math.round((niceMin + j * spacing) * factor) / factor\r\n        });\r\n    }\r\n    if (maxDefined && includeBounds && niceMax !== max) {\r\n        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\r\n            ticks[ticks.length - 1].value = max;\r\n        } else {\r\n            ticks.push({\r\n                value: max\r\n            });\r\n        }\r\n    } else if (!maxDefined || niceMax === max) {\r\n        ticks.push({\r\n            value: niceMax\r\n        });\r\n    }\r\n    return ticks;\r\n}\r\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\r\n    const rad = toRadians(minRotation);\r\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\r\n    const length = 0.75 * minSpacing * ('' + value).length;\r\n    return Math.min(minSpacing / ratio, length);\r\n}\r\nclass LinearScaleBase extends Scale {\r\n    constructor(cfg){\r\n        super(cfg);\r\n         this.start = undefined;\r\n         this.end = undefined;\r\n         this._startValue = undefined;\r\n         this._endValue = undefined;\r\n        this._valueRange = 0;\r\n    }\r\n    parse(raw, index) {\r\n        if (isNullOrUndef(raw)) {\r\n            return null;\r\n        }\r\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\r\n            return null;\r\n        }\r\n        return +raw;\r\n    }\r\n    handleTickRangeOptions() {\r\n        const { beginAtZero  } = this.options;\r\n        const { minDefined , maxDefined  } = this.getUserBounds();\r\n        let { min , max  } = this;\r\n        const setMin = (v)=>min = minDefined ? min : v;\r\n        const setMax = (v)=>max = maxDefined ? max : v;\r\n        if (beginAtZero) {\r\n            const minSign = sign(min);\r\n            const maxSign = sign(max);\r\n            if (minSign < 0 && maxSign < 0) {\r\n                setMax(0);\r\n            } else if (minSign > 0 && maxSign > 0) {\r\n                setMin(0);\r\n            }\r\n        }\r\n        if (min === max) {\r\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\r\n            setMax(max + offset);\r\n            if (!beginAtZero) {\r\n                setMin(min - offset);\r\n            }\r\n        }\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    getTickLimit() {\r\n        const tickOpts = this.options.ticks;\r\n        let { maxTicksLimit , stepSize  } = tickOpts;\r\n        let maxTicks;\r\n        if (stepSize) {\r\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\r\n            if (maxTicks > 1000) {\r\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\r\n                maxTicks = 1000;\r\n            }\r\n        } else {\r\n            maxTicks = this.computeTickLimit();\r\n            maxTicksLimit = maxTicksLimit || 11;\r\n        }\r\n        if (maxTicksLimit) {\r\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\r\n        }\r\n        return maxTicks;\r\n    }\r\n computeTickLimit() {\r\n        return Number.POSITIVE_INFINITY;\r\n    }\r\n    buildTicks() {\r\n        const opts = this.options;\r\n        const tickOpts = opts.ticks;\r\n        let maxTicks = this.getTickLimit();\r\n        maxTicks = Math.max(2, maxTicks);\r\n        const numericGeneratorOptions = {\r\n            maxTicks,\r\n            bounds: opts.bounds,\r\n            min: opts.min,\r\n            max: opts.max,\r\n            precision: tickOpts.precision,\r\n            step: tickOpts.stepSize,\r\n            count: tickOpts.count,\r\n            maxDigits: this._maxDigits(),\r\n            horizontal: this.isHorizontal(),\r\n            minRotation: tickOpts.minRotation || 0,\r\n            includeBounds: tickOpts.includeBounds !== false\r\n        };\r\n        const dataRange = this._range || this;\r\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\r\n        if (opts.bounds === 'ticks') {\r\n            _setMinAndMaxByKey(ticks, this, 'value');\r\n        }\r\n        if (opts.reverse) {\r\n            ticks.reverse();\r\n            this.start = this.max;\r\n            this.end = this.min;\r\n        } else {\r\n            this.start = this.min;\r\n            this.end = this.max;\r\n        }\r\n        return ticks;\r\n    }\r\n configure() {\r\n        const ticks = this.ticks;\r\n        let start = this.min;\r\n        let end = this.max;\r\n        super.configure();\r\n        if (this.options.offset && ticks.length) {\r\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n            start -= offset;\r\n            end += offset;\r\n        }\r\n        this._startValue = start;\r\n        this._endValue = end;\r\n        this._valueRange = end - start;\r\n    }\r\n    getLabelForValue(value) {\r\n        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n    }\r\n}\r\n\r\nclass LinearScale extends LinearScaleBase {\r\n    static id = 'linear';\r\n static defaults = {\r\n        ticks: {\r\n            callback: Ticks.formatters.numeric\r\n        }\r\n    };\r\n    determineDataLimits() {\r\n        const { min , max  } = this.getMinMax(true);\r\n        this.min = isNumberFinite(min) ? min : 0;\r\n        this.max = isNumberFinite(max) ? max : 1;\r\n        this.handleTickRangeOptions();\r\n    }\r\n computeTickLimit() {\r\n        const horizontal = this.isHorizontal();\r\n        const length = horizontal ? this.width : this.height;\r\n        const minRotation = toRadians(this.options.ticks.minRotation);\r\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\r\n        const tickFont = this._resolveTickFontOptions(0);\r\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\r\n    }\r\n    getPixelForValue(value) {\r\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n    }\r\n    getValueForPixel(pixel) {\r\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n    }\r\n}\r\n\r\nconst log10Floor = (v)=>Math.floor(log10(v));\r\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\r\nfunction isMajor(tickVal) {\r\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\r\n    return remain === 1;\r\n}\r\nfunction steps(min, max, rangeExp) {\r\n    const rangeStep = Math.pow(10, rangeExp);\r\n    const start = Math.floor(min / rangeStep);\r\n    const end = Math.ceil(max / rangeStep);\r\n    return end - start;\r\n}\r\nfunction startExp(min, max) {\r\n    const range = max - min;\r\n    let rangeExp = log10Floor(range);\r\n    while(steps(min, max, rangeExp) > 10){\r\n        rangeExp++;\r\n    }\r\n    while(steps(min, max, rangeExp) < 10){\r\n        rangeExp--;\r\n    }\r\n    return Math.min(rangeExp, log10Floor(min));\r\n}\r\n function generateTicks(generationOptions, { min , max  }) {\r\n    min = finiteOrDefault(generationOptions.min, min);\r\n    const ticks = [];\r\n    const minExp = log10Floor(min);\r\n    let exp = startExp(min, max);\r\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n    const stepSize = Math.pow(10, exp);\r\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\r\n    const start = Math.round((min - base) * precision) / precision;\r\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\r\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\r\n    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\r\n    while(value < max){\r\n        ticks.push({\r\n            value,\r\n            major: isMajor(value),\r\n            significand\r\n        });\r\n        if (significand >= 10) {\r\n            significand = significand < 15 ? 15 : 20;\r\n        } else {\r\n            significand++;\r\n        }\r\n        if (significand >= 20) {\r\n            exp++;\r\n            significand = 2;\r\n            precision = exp >= 0 ? 1 : precision;\r\n        }\r\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\r\n    }\r\n    const lastTick = finiteOrDefault(generationOptions.max, value);\r\n    ticks.push({\r\n        value: lastTick,\r\n        major: isMajor(lastTick),\r\n        significand\r\n    });\r\n    return ticks;\r\n}\r\nclass LogarithmicScale extends Scale {\r\n    static id = 'logarithmic';\r\n static defaults = {\r\n        ticks: {\r\n            callback: Ticks.formatters.logarithmic,\r\n            major: {\r\n                enabled: true\r\n            }\r\n        }\r\n    };\r\n    constructor(cfg){\r\n        super(cfg);\r\n         this.start = undefined;\r\n         this.end = undefined;\r\n         this._startValue = undefined;\r\n        this._valueRange = 0;\r\n    }\r\n    parse(raw, index) {\r\n        const value = LinearScaleBase.prototype.parse.apply(this, [\r\n            raw,\r\n            index\r\n        ]);\r\n        if (value === 0) {\r\n            this._zero = true;\r\n            return undefined;\r\n        }\r\n        return isNumberFinite(value) && value > 0 ? value : null;\r\n    }\r\n    determineDataLimits() {\r\n        const { min , max  } = this.getMinMax(true);\r\n        this.min = isNumberFinite(min) ? Math.max(0, min) : null;\r\n        this.max = isNumberFinite(max) ? Math.max(0, max) : null;\r\n        if (this.options.beginAtZero) {\r\n            this._zero = true;\r\n        }\r\n        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\r\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\r\n        }\r\n        this.handleTickRangeOptions();\r\n    }\r\n    handleTickRangeOptions() {\r\n        const { minDefined , maxDefined  } = this.getUserBounds();\r\n        let min = this.min;\r\n        let max = this.max;\r\n        const setMin = (v)=>min = minDefined ? min : v;\r\n        const setMax = (v)=>max = maxDefined ? max : v;\r\n        if (min === max) {\r\n            if (min <= 0) {\r\n                setMin(1);\r\n                setMax(10);\r\n            } else {\r\n                setMin(changeExponent(min, -1));\r\n                setMax(changeExponent(max, +1));\r\n            }\r\n        }\r\n        if (min <= 0) {\r\n            setMin(changeExponent(max, -1));\r\n        }\r\n        if (max <= 0) {\r\n            setMax(changeExponent(min, +1));\r\n        }\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    buildTicks() {\r\n        const opts = this.options;\r\n        const generationOptions = {\r\n            min: this._userMin,\r\n            max: this._userMax\r\n        };\r\n        const ticks = generateTicks(generationOptions, this);\r\n        if (opts.bounds === 'ticks') {\r\n            _setMinAndMaxByKey(ticks, this, 'value');\r\n        }\r\n        if (opts.reverse) {\r\n            ticks.reverse();\r\n            this.start = this.max;\r\n            this.end = this.min;\r\n        } else {\r\n            this.start = this.min;\r\n            this.end = this.max;\r\n        }\r\n        return ticks;\r\n    }\r\n getLabelForValue(value) {\r\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n    }\r\n configure() {\r\n        const start = this.min;\r\n        super.configure();\r\n        this._startValue = log10(start);\r\n        this._valueRange = log10(this.max) - log10(start);\r\n    }\r\n    getPixelForValue(value) {\r\n        if (value === undefined || value === 0) {\r\n            value = this.min;\r\n        }\r\n        if (value === null || isNaN(value)) {\r\n            return NaN;\r\n        }\r\n        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\r\n    }\r\n    getValueForPixel(pixel) {\r\n        const decimal = this.getDecimalForPixel(pixel);\r\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\r\n    }\r\n}\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n    const tickOpts = opts.ticks;\r\n    if (tickOpts.display && opts.display) {\r\n        const padding = toPadding(tickOpts.backdropPadding);\r\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\r\n    }\r\n    return 0;\r\n}\r\nfunction measureLabelSize(ctx, font, label) {\r\n    label = isArray(label) ? label : [\r\n        label\r\n    ];\r\n    return {\r\n        w: _longestText(ctx, font.string, label),\r\n        h: label.length * font.lineHeight\r\n    };\r\n}\r\nfunction determineLimits(angle, pos, size, min, max) {\r\n    if (angle === min || angle === max) {\r\n        return {\r\n            start: pos - size / 2,\r\n            end: pos + size / 2\r\n        };\r\n    } else if (angle < min || angle > max) {\r\n        return {\r\n            start: pos - size,\r\n            end: pos\r\n        };\r\n    }\r\n    return {\r\n        start: pos,\r\n        end: pos + size\r\n    };\r\n}\r\n function fitWithPointLabels(scale) {\r\n    const orig = {\r\n        l: scale.left + scale._padding.left,\r\n        r: scale.right - scale._padding.right,\r\n        t: scale.top + scale._padding.top,\r\n        b: scale.bottom - scale._padding.bottom\r\n    };\r\n    const limits = Object.assign({}, orig);\r\n    const labelSizes = [];\r\n    const padding = [];\r\n    const valueCount = scale._pointLabels.length;\r\n    const pointLabelOpts = scale.options.pointLabels;\r\n    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\r\n    for(let i = 0; i < valueCount; i++){\r\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\r\n        padding[i] = opts.padding;\r\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\r\n        const plFont = toFont(opts.font);\r\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\r\n        labelSizes[i] = textSize;\r\n        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\r\n        const angle = Math.round(toDegrees(angleRadians));\r\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\r\n    }\r\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\r\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\r\n}\r\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\r\n    const sin = Math.abs(Math.sin(angle));\r\n    const cos = Math.abs(Math.cos(angle));\r\n    let x = 0;\r\n    let y = 0;\r\n    if (hLimits.start < orig.l) {\r\n        x = (orig.l - hLimits.start) / sin;\r\n        limits.l = Math.min(limits.l, orig.l - x);\r\n    } else if (hLimits.end > orig.r) {\r\n        x = (hLimits.end - orig.r) / sin;\r\n        limits.r = Math.max(limits.r, orig.r + x);\r\n    }\r\n    if (vLimits.start < orig.t) {\r\n        y = (orig.t - vLimits.start) / cos;\r\n        limits.t = Math.min(limits.t, orig.t - y);\r\n    } else if (vLimits.end > orig.b) {\r\n        y = (vLimits.end - orig.b) / cos;\r\n        limits.b = Math.max(limits.b, orig.b + y);\r\n    }\r\n}\r\nfunction buildPointLabelItems(scale, labelSizes, padding) {\r\n    const items = [];\r\n    const valueCount = scale._pointLabels.length;\r\n    const opts = scale.options;\r\n    const extra = getTickBackdropHeight(opts) / 2;\r\n    const outerDistance = scale.drawingArea;\r\n    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\r\n    for(let i = 0; i < valueCount; i++){\r\n        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\r\n        const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\r\n        const size = labelSizes[i];\r\n        const y = yForAngle(pointLabelPosition.y, size.h, angle);\r\n        const textAlign = getTextAlignForAngle(angle);\r\n        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\r\n        items.push({\r\n            x: pointLabelPosition.x,\r\n            y,\r\n            textAlign,\r\n            left,\r\n            top: y,\r\n            right: left + size.w,\r\n            bottom: y + size.h\r\n        });\r\n    }\r\n    return items;\r\n}\r\nfunction getTextAlignForAngle(angle) {\r\n    if (angle === 0 || angle === 180) {\r\n        return 'center';\r\n    } else if (angle < 180) {\r\n        return 'left';\r\n    }\r\n    return 'right';\r\n}\r\nfunction leftForTextAlign(x, w, align) {\r\n    if (align === 'right') {\r\n        x -= w;\r\n    } else if (align === 'center') {\r\n        x -= w / 2;\r\n    }\r\n    return x;\r\n}\r\nfunction yForAngle(y, h, angle) {\r\n    if (angle === 90 || angle === 270) {\r\n        y -= h / 2;\r\n    } else if (angle > 270 || angle < 90) {\r\n        y -= h;\r\n    }\r\n    return y;\r\n}\r\nfunction drawPointLabels(scale, labelCount) {\r\n    const { ctx , options: { pointLabels  }  } = scale;\r\n    for(let i = labelCount - 1; i >= 0; i--){\r\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\r\n        const plFont = toFont(optsAtIndex.font);\r\n        const { x , y , textAlign , left , top , right , bottom  } = scale._pointLabelItems[i];\r\n        const { backdropColor  } = optsAtIndex;\r\n        if (!isNullOrUndef(backdropColor)) {\r\n            const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\r\n            const padding = toPadding(optsAtIndex.backdropPadding);\r\n            ctx.fillStyle = backdropColor;\r\n            const backdropLeft = left - padding.left;\r\n            const backdropTop = top - padding.top;\r\n            const backdropWidth = right - left + padding.width;\r\n            const backdropHeight = bottom - top + padding.height;\r\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\r\n                ctx.beginPath();\r\n                addRoundedRectPath(ctx, {\r\n                    x: backdropLeft,\r\n                    y: backdropTop,\r\n                    w: backdropWidth,\r\n                    h: backdropHeight,\r\n                    radius: borderRadius\r\n                });\r\n                ctx.fill();\r\n            } else {\r\n                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\r\n            }\r\n        }\r\n        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\r\n            color: optsAtIndex.color,\r\n            textAlign: textAlign,\r\n            textBaseline: 'middle'\r\n        });\r\n    }\r\n}\r\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\r\n    const { ctx  } = scale;\r\n    if (circular) {\r\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\r\n    } else {\r\n        let pointPosition = scale.getPointPosition(0, radius);\r\n        ctx.moveTo(pointPosition.x, pointPosition.y);\r\n        for(let i = 1; i < labelCount; i++){\r\n            pointPosition = scale.getPointPosition(i, radius);\r\n            ctx.lineTo(pointPosition.x, pointPosition.y);\r\n        }\r\n    }\r\n}\r\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\r\n    const ctx = scale.ctx;\r\n    const circular = gridLineOpts.circular;\r\n    const { color , lineWidth  } = gridLineOpts;\r\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\r\n        return;\r\n    }\r\n    ctx.save();\r\n    ctx.strokeStyle = color;\r\n    ctx.lineWidth = lineWidth;\r\n    ctx.setLineDash(borderOpts.dash);\r\n    ctx.lineDashOffset = borderOpts.dashOffset;\r\n    ctx.beginPath();\r\n    pathRadiusLine(scale, radius, circular, labelCount);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n    ctx.restore();\r\n}\r\nfunction createPointLabelContext(parent, index, label) {\r\n    return createContext(parent, {\r\n        label,\r\n        index,\r\n        type: 'pointLabel'\r\n    });\r\n}\r\nclass RadialLinearScale extends LinearScaleBase {\r\n    static id = 'radialLinear';\r\n static defaults = {\r\n        display: true,\r\n        animate: true,\r\n        position: 'chartArea',\r\n        angleLines: {\r\n            display: true,\r\n            lineWidth: 1,\r\n            borderDash: [],\r\n            borderDashOffset: 0.0\r\n        },\r\n        grid: {\r\n            circular: false\r\n        },\r\n        startAngle: 0,\r\n        ticks: {\r\n            showLabelBackdrop: true,\r\n            callback: Ticks.formatters.numeric\r\n        },\r\n        pointLabels: {\r\n            backdropColor: undefined,\r\n            backdropPadding: 2,\r\n            display: true,\r\n            font: {\r\n                size: 10\r\n            },\r\n            callback (label) {\r\n                return label;\r\n            },\r\n            padding: 5,\r\n            centerPointLabels: false\r\n        }\r\n    };\r\n    static defaultRoutes = {\r\n        'angleLines.color': 'borderColor',\r\n        'pointLabels.color': 'color',\r\n        'ticks.color': 'color'\r\n    };\r\n    static descriptors = {\r\n        angleLines: {\r\n            _fallback: 'grid'\r\n        }\r\n    };\r\n    constructor(cfg){\r\n        super(cfg);\r\n         this.xCenter = undefined;\r\n         this.yCenter = undefined;\r\n         this.drawingArea = undefined;\r\n         this._pointLabels = [];\r\n        this._pointLabelItems = [];\r\n    }\r\n    setDimensions() {\r\n        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\r\n        const w = this.width = this.maxWidth - padding.width;\r\n        const h = this.height = this.maxHeight - padding.height;\r\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\r\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\r\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\r\n    }\r\n    determineDataLimits() {\r\n        const { min , max  } = this.getMinMax(false);\r\n        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\r\n        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\r\n        this.handleTickRangeOptions();\r\n    }\r\n computeTickLimit() {\r\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n    }\r\n    generateTickLabels(ticks) {\r\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\r\n        this._pointLabels = this.getLabels().map((value, index)=>{\r\n            const label = callback(this.options.pointLabels.callback, [\r\n                value,\r\n                index\r\n            ], this);\r\n            return label || label === 0 ? label : '';\r\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\r\n    }\r\n    fit() {\r\n        const opts = this.options;\r\n        if (opts.display && opts.pointLabels.display) {\r\n            fitWithPointLabels(this);\r\n        } else {\r\n            this.setCenterPoint(0, 0, 0, 0);\r\n        }\r\n    }\r\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\r\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\r\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\r\n    }\r\n    getIndexAngle(index) {\r\n        const angleMultiplier = TAU / (this._pointLabels.length || 1);\r\n        const startAngle = this.options.startAngle || 0;\r\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\r\n    }\r\n    getDistanceFromCenterForValue(value) {\r\n        if (isNullOrUndef(value)) {\r\n            return NaN;\r\n        }\r\n        const scalingFactor = this.drawingArea / (this.max - this.min);\r\n        if (this.options.reverse) {\r\n            return (this.max - value) * scalingFactor;\r\n        }\r\n        return (value - this.min) * scalingFactor;\r\n    }\r\n    getValueForDistanceFromCenter(distance) {\r\n        if (isNullOrUndef(distance)) {\r\n            return NaN;\r\n        }\r\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\r\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\r\n    }\r\n    getPointLabelContext(index) {\r\n        const pointLabels = this._pointLabels || [];\r\n        if (index >= 0 && index < pointLabels.length) {\r\n            const pointLabel = pointLabels[index];\r\n            return createPointLabelContext(this.getContext(), index, pointLabel);\r\n        }\r\n    }\r\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\r\n        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\r\n        return {\r\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\r\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\r\n            angle\r\n        };\r\n    }\r\n    getPointPositionForValue(index, value) {\r\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n    }\r\n    getBasePosition(index) {\r\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\r\n    }\r\n    getPointLabelPosition(index) {\r\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\r\n        return {\r\n            left,\r\n            top,\r\n            right,\r\n            bottom\r\n        };\r\n    }\r\n drawBackground() {\r\n        const { backgroundColor , grid: { circular  }  } = this.options;\r\n        if (backgroundColor) {\r\n            const ctx = this.ctx;\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\r\n            ctx.closePath();\r\n            ctx.fillStyle = backgroundColor;\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n    }\r\n drawGrid() {\r\n        const ctx = this.ctx;\r\n        const opts = this.options;\r\n        const { angleLines , grid , border  } = opts;\r\n        const labelCount = this._pointLabels.length;\r\n        let i, offset, position;\r\n        if (opts.pointLabels.display) {\r\n            drawPointLabels(this, labelCount);\r\n        }\r\n        if (grid.display) {\r\n            this.ticks.forEach((tick, index)=>{\r\n                if (index !== 0) {\r\n                    offset = this.getDistanceFromCenterForValue(tick.value);\r\n                    const context = this.getContext(index);\r\n                    const optsAtIndex = grid.setContext(context);\r\n                    const optsAtIndexBorder = border.setContext(context);\r\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\r\n                }\r\n            });\r\n        }\r\n        if (angleLines.display) {\r\n            ctx.save();\r\n            for(i = labelCount - 1; i >= 0; i--){\r\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\r\n                const { color , lineWidth  } = optsAtIndex;\r\n                if (!lineWidth || !color) {\r\n                    continue;\r\n                }\r\n                ctx.lineWidth = lineWidth;\r\n                ctx.strokeStyle = color;\r\n                ctx.setLineDash(optsAtIndex.borderDash);\r\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\r\n                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\r\n                position = this.getPointPosition(i, offset);\r\n                ctx.beginPath();\r\n                ctx.moveTo(this.xCenter, this.yCenter);\r\n                ctx.lineTo(position.x, position.y);\r\n                ctx.stroke();\r\n            }\r\n            ctx.restore();\r\n        }\r\n    }\r\n drawBorder() {}\r\n drawLabels() {\r\n        const ctx = this.ctx;\r\n        const opts = this.options;\r\n        const tickOpts = opts.ticks;\r\n        if (!tickOpts.display) {\r\n            return;\r\n        }\r\n        const startAngle = this.getIndexAngle(0);\r\n        let offset, width;\r\n        ctx.save();\r\n        ctx.translate(this.xCenter, this.yCenter);\r\n        ctx.rotate(startAngle);\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        this.ticks.forEach((tick, index)=>{\r\n            if (index === 0 && !opts.reverse) {\r\n                return;\r\n            }\r\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\r\n            const tickFont = toFont(optsAtIndex.font);\r\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\r\n            if (optsAtIndex.showLabelBackdrop) {\r\n                ctx.font = tickFont.string;\r\n                width = ctx.measureText(tick.label).width;\r\n                ctx.fillStyle = optsAtIndex.backdropColor;\r\n                const padding = toPadding(optsAtIndex.backdropPadding);\r\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\r\n            }\r\n            renderText(ctx, tick.label, 0, -offset, tickFont, {\r\n                color: optsAtIndex.color\r\n            });\r\n        });\r\n        ctx.restore();\r\n    }\r\n drawTitle() {}\r\n}\r\n\r\nconst INTERVALS = {\r\n    millisecond: {\r\n        common: true,\r\n        size: 1,\r\n        steps: 1000\r\n    },\r\n    second: {\r\n        common: true,\r\n        size: 1000,\r\n        steps: 60\r\n    },\r\n    minute: {\r\n        common: true,\r\n        size: 60000,\r\n        steps: 60\r\n    },\r\n    hour: {\r\n        common: true,\r\n        size: 3600000,\r\n        steps: 24\r\n    },\r\n    day: {\r\n        common: true,\r\n        size: 86400000,\r\n        steps: 30\r\n    },\r\n    week: {\r\n        common: false,\r\n        size: 604800000,\r\n        steps: 4\r\n    },\r\n    month: {\r\n        common: true,\r\n        size: 2.628e9,\r\n        steps: 12\r\n    },\r\n    quarter: {\r\n        common: false,\r\n        size: 7.884e9,\r\n        steps: 4\r\n    },\r\n    year: {\r\n        common: true,\r\n        size: 3.154e10\r\n    }\r\n};\r\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\r\n function sorter(a, b) {\r\n    return a - b;\r\n}\r\n function parse(scale, input) {\r\n    if (isNullOrUndef(input)) {\r\n        return null;\r\n    }\r\n    const adapter = scale._adapter;\r\n    const { parser , round , isoWeekday  } = scale._parseOpts;\r\n    let value = input;\r\n    if (typeof parser === 'function') {\r\n        value = parser(value);\r\n    }\r\n    if (!isNumberFinite(value)) {\r\n        value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);\r\n    }\r\n    if (value === null) {\r\n        return null;\r\n    }\r\n    if (round) {\r\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\r\n    }\r\n    return +value;\r\n}\r\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n    const ilen = UNITS.length;\r\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\r\n        const interval = INTERVALS[UNITS[i]];\r\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\r\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n            return UNITS[i];\r\n        }\r\n    }\r\n    return UNITS[ilen - 1];\r\n}\r\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\r\n        const unit = UNITS[i];\r\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n            return unit;\r\n        }\r\n    }\r\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\n function determineMajorUnit(unit) {\r\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\r\n        if (INTERVALS[UNITS[i]].common) {\r\n            return UNITS[i];\r\n        }\r\n    }\r\n}\r\n function addTick(ticks, time, timestamps) {\r\n    if (!timestamps) {\r\n        ticks[time] = true;\r\n    } else if (timestamps.length) {\r\n        const { lo , hi  } = _lookup(timestamps, time);\r\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\r\n        ticks[timestamp] = true;\r\n    }\r\n}\r\n function setMajorTicks(scale, ticks, map, majorUnit) {\r\n    const adapter = scale._adapter;\r\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\r\n    const last = ticks[ticks.length - 1].value;\r\n    let major, index;\r\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\r\n        index = map[major];\r\n        if (index >= 0) {\r\n            ticks[index].major = true;\r\n        }\r\n    }\r\n    return ticks;\r\n}\r\n function ticksFromTimestamps(scale, values, majorUnit) {\r\n    const ticks = [];\r\n     const map = {};\r\n    const ilen = values.length;\r\n    let i, value;\r\n    for(i = 0; i < ilen; ++i){\r\n        value = values[i];\r\n        map[value] = i;\r\n        ticks.push({\r\n            value,\r\n            major: false\r\n        });\r\n    }\r\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\nclass TimeScale extends Scale {\r\n    static id = 'time';\r\n static defaults = {\r\n bounds: 'data',\r\n        adapters: {},\r\n        time: {\r\n            parser: false,\r\n            unit: false,\r\n            round: false,\r\n            isoWeekday: false,\r\n            minUnit: 'millisecond',\r\n            displayFormats: {}\r\n        },\r\n        ticks: {\r\n source: 'auto',\r\n            callback: false,\r\n            major: {\r\n                enabled: false\r\n            }\r\n        }\r\n    };\r\n constructor(props){\r\n        super(props);\r\n         this._cache = {\r\n            data: [],\r\n            labels: [],\r\n            all: []\r\n        };\r\n         this._unit = 'day';\r\n         this._majorUnit = undefined;\r\n        this._offsets = {};\r\n        this._normalized = false;\r\n        this._parseOpts = undefined;\r\n    }\r\n    init(scaleOpts, opts = {}) {\r\n        const time = scaleOpts.time || (scaleOpts.time = {});\r\n         const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);\r\n        adapter.init(opts);\r\n        mergeIf(time.displayFormats, adapter.formats());\r\n        this._parseOpts = {\r\n            parser: time.parser,\r\n            round: time.round,\r\n            isoWeekday: time.isoWeekday\r\n        };\r\n        super.init(scaleOpts);\r\n        this._normalized = opts.normalized;\r\n    }\r\n parse(raw, index) {\r\n        if (raw === undefined) {\r\n            return null;\r\n        }\r\n        return parse(this, raw);\r\n    }\r\n    beforeLayout() {\r\n        super.beforeLayout();\r\n        this._cache = {\r\n            data: [],\r\n            labels: [],\r\n            all: []\r\n        };\r\n    }\r\n    determineDataLimits() {\r\n        const options = this.options;\r\n        const adapter = this._adapter;\r\n        const unit = options.time.unit || 'day';\r\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\r\n function _applyBounds(bounds) {\r\n            if (!minDefined && !isNaN(bounds.min)) {\r\n                min = Math.min(min, bounds.min);\r\n            }\r\n            if (!maxDefined && !isNaN(bounds.max)) {\r\n                max = Math.max(max, bounds.max);\r\n            }\r\n        }\r\n        if (!minDefined || !maxDefined) {\r\n            _applyBounds(this._getLabelBounds());\r\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\r\n                _applyBounds(this.getMinMax(false));\r\n            }\r\n        }\r\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\r\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\r\n        this.min = Math.min(min, max - 1);\r\n        this.max = Math.max(min + 1, max);\r\n    }\r\n _getLabelBounds() {\r\n        const arr = this.getLabelTimestamps();\r\n        let min = Number.POSITIVE_INFINITY;\r\n        let max = Number.NEGATIVE_INFINITY;\r\n        if (arr.length) {\r\n            min = arr[0];\r\n            max = arr[arr.length - 1];\r\n        }\r\n        return {\r\n            min,\r\n            max\r\n        };\r\n    }\r\n buildTicks() {\r\n        const options = this.options;\r\n        const timeOpts = options.time;\r\n        const tickOpts = options.ticks;\r\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\r\n        if (options.bounds === 'ticks' && timestamps.length) {\r\n            this.min = this._userMin || timestamps[0];\r\n            this.max = this._userMax || timestamps[timestamps.length - 1];\r\n        }\r\n        const min = this.min;\r\n        const max = this.max;\r\n        const ticks = _filterBetween(timestamps, min, max);\r\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\r\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\r\n        this.initOffsets(timestamps);\r\n        if (options.reverse) {\r\n            ticks.reverse();\r\n        }\r\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\r\n    }\r\n    afterAutoSkip() {\r\n        if (this.options.offsetAfterAutoskip) {\r\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\r\n        }\r\n    }\r\n initOffsets(timestamps = []) {\r\n        let start = 0;\r\n        let end = 0;\r\n        let first, last;\r\n        if (this.options.offset && timestamps.length) {\r\n            first = this.getDecimalForValue(timestamps[0]);\r\n            if (timestamps.length === 1) {\r\n                start = 1 - first;\r\n            } else {\r\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\r\n            }\r\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\r\n            if (timestamps.length === 1) {\r\n                end = last;\r\n            } else {\r\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\r\n            }\r\n        }\r\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\r\n        start = _limitValue(start, 0, limit);\r\n        end = _limitValue(end, 0, limit);\r\n        this._offsets = {\r\n            start,\r\n            end,\r\n            factor: 1 / (start + 1 + end)\r\n        };\r\n    }\r\n _generate() {\r\n        const adapter = this._adapter;\r\n        const min = this.min;\r\n        const max = this.max;\r\n        const options = this.options;\r\n        const timeOpts = options.time;\r\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\r\n        const stepSize = valueOrDefault(options.ticks.stepSize, 1);\r\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n        const hasWeekday = isNumber(weekday) || weekday === true;\r\n        const ticks = {};\r\n        let first = min;\r\n        let time, count;\r\n        if (hasWeekday) {\r\n            first = +adapter.startOf(first, 'isoWeek', weekday);\r\n        }\r\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\r\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\r\n        }\r\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\r\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\r\n            addTick(ticks, time, timestamps);\r\n        }\r\n        if (time === max || options.bounds === 'ticks' || count === 1) {\r\n            addTick(ticks, time, timestamps);\r\n        }\r\n        return Object.keys(ticks).sort((a, b)=>a - b).map((x)=>+x);\r\n    }\r\n getLabelForValue(value) {\r\n        const adapter = this._adapter;\r\n        const timeOpts = this.options.time;\r\n        if (timeOpts.tooltipFormat) {\r\n            return adapter.format(value, timeOpts.tooltipFormat);\r\n        }\r\n        return adapter.format(value, timeOpts.displayFormats.datetime);\r\n    }\r\n format(value, format) {\r\n        const options = this.options;\r\n        const formats = options.time.displayFormats;\r\n        const unit = this._unit;\r\n        const fmt = format || formats[unit];\r\n        return this._adapter.format(value, fmt);\r\n    }\r\n _tickFormatFunction(time, index, ticks, format) {\r\n        const options = this.options;\r\n        const formatter = options.ticks.callback;\r\n        if (formatter) {\r\n            return callback(formatter, [\r\n                time,\r\n                index,\r\n                ticks\r\n            ], this);\r\n        }\r\n        const formats = options.time.displayFormats;\r\n        const unit = this._unit;\r\n        const majorUnit = this._majorUnit;\r\n        const minorFormat = unit && formats[unit];\r\n        const majorFormat = majorUnit && formats[majorUnit];\r\n        const tick = ticks[index];\r\n        const major = majorUnit && majorFormat && tick && tick.major;\r\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\r\n    }\r\n generateTickLabels(ticks) {\r\n        let i, ilen, tick;\r\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\r\n            tick = ticks[i];\r\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\r\n        }\r\n    }\r\n getDecimalForValue(value) {\r\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\r\n    }\r\n getPixelForValue(value) {\r\n        const offsets = this._offsets;\r\n        const pos = this.getDecimalForValue(value);\r\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n    }\r\n getValueForPixel(pixel) {\r\n        const offsets = this._offsets;\r\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n        return this.min + pos * (this.max - this.min);\r\n    }\r\n _getLabelSize(label) {\r\n        const ticksOpts = this.options.ticks;\r\n        const tickLabelWidth = this.ctx.measureText(label).width;\r\n        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n        const cosRotation = Math.cos(angle);\r\n        const sinRotation = Math.sin(angle);\r\n        const tickFontSize = this._resolveTickFontOptions(0).size;\r\n        return {\r\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\r\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\r\n        };\r\n    }\r\n _getLabelCapacity(exampleTime) {\r\n        const timeOpts = this.options.time;\r\n        const displayFormats = timeOpts.displayFormats;\r\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\r\n            exampleTime\r\n        ], this._majorUnit), format);\r\n        const size = this._getLabelSize(exampleLabel);\r\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\r\n        return capacity > 0 ? capacity : 1;\r\n    }\r\n getDataTimestamps() {\r\n        let timestamps = this._cache.data || [];\r\n        let i, ilen;\r\n        if (timestamps.length) {\r\n            return timestamps;\r\n        }\r\n        const metas = this.getMatchingVisibleMetas();\r\n        if (this._normalized && metas.length) {\r\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\r\n        }\r\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\r\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\r\n        }\r\n        return this._cache.data = this.normalize(timestamps);\r\n    }\r\n getLabelTimestamps() {\r\n        const timestamps = this._cache.labels || [];\r\n        let i, ilen;\r\n        if (timestamps.length) {\r\n            return timestamps;\r\n        }\r\n        const labels = this.getLabels();\r\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\r\n            timestamps.push(parse(this, labels[i]));\r\n        }\r\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\r\n    }\r\n normalize(values) {\r\n        return _arrayUnique(values.sort(sorter));\r\n    }\r\n}\r\n\r\nfunction interpolate(table, val, reverse) {\r\n    let lo = 0;\r\n    let hi = table.length - 1;\r\n    let prevSource, nextSource, prevTarget, nextTarget;\r\n    if (reverse) {\r\n        if (val >= table[lo].pos && val <= table[hi].pos) {\r\n            ({ lo , hi  } = _lookupByKey(table, 'pos', val));\r\n        }\r\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\r\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\r\n    } else {\r\n        if (val >= table[lo].time && val <= table[hi].time) {\r\n            ({ lo , hi  } = _lookupByKey(table, 'time', val));\r\n        }\r\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\r\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\r\n    }\r\n    const span = nextSource - prevSource;\r\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\r\n}\r\nclass TimeSeriesScale extends TimeScale {\r\n    static id = 'timeseries';\r\n static defaults = TimeScale.defaults;\r\n constructor(props){\r\n        super(props);\r\n         this._table = [];\r\n         this._minPos = undefined;\r\n         this._tableRange = undefined;\r\n    }\r\n initOffsets() {\r\n        const timestamps = this._getTimestampsForTable();\r\n        const table = this._table = this.buildLookupTable(timestamps);\r\n        this._minPos = interpolate(table, this.min);\r\n        this._tableRange = interpolate(table, this.max) - this._minPos;\r\n        super.initOffsets(timestamps);\r\n    }\r\n buildLookupTable(timestamps) {\r\n        const { min , max  } = this;\r\n        const items = [];\r\n        const table = [];\r\n        let i, ilen, prev, curr, next;\r\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\r\n            curr = timestamps[i];\r\n            if (curr >= min && curr <= max) {\r\n                items.push(curr);\r\n            }\r\n        }\r\n        if (items.length < 2) {\r\n            return [\r\n                {\r\n                    time: min,\r\n                    pos: 0\r\n                },\r\n                {\r\n                    time: max,\r\n                    pos: 1\r\n                }\r\n            ];\r\n        }\r\n        for(i = 0, ilen = items.length; i < ilen; ++i){\r\n            next = items[i + 1];\r\n            prev = items[i - 1];\r\n            curr = items[i];\r\n            if (Math.round((next + prev) / 2) !== curr) {\r\n                table.push({\r\n                    time: curr,\r\n                    pos: i / (ilen - 1)\r\n                });\r\n            }\r\n        }\r\n        return table;\r\n    }\r\n _getTimestampsForTable() {\r\n        let timestamps = this._cache.all || [];\r\n        if (timestamps.length) {\r\n            return timestamps;\r\n        }\r\n        const data = this.getDataTimestamps();\r\n        const label = this.getLabelTimestamps();\r\n        if (data.length && label.length) {\r\n            timestamps = this.normalize(data.concat(label));\r\n        } else {\r\n            timestamps = data.length ? data : label;\r\n        }\r\n        timestamps = this._cache.all = timestamps;\r\n        return timestamps;\r\n    }\r\n getDecimalForValue(value) {\r\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\r\n    }\r\n getValueForPixel(pixel) {\r\n        const offsets = this._offsets;\r\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\r\n    }\r\n}\r\n\r\nvar scales = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nCategoryScale: CategoryScale,\r\nLinearScale: LinearScale,\r\nLogarithmicScale: LogarithmicScale,\r\nRadialLinearScale: RadialLinearScale,\r\nTimeScale: TimeScale,\r\nTimeSeriesScale: TimeSeriesScale\r\n});\r\n\r\nconst BORDER_COLORS = [\r\n    'rgb(54, 162, 235)',\r\n    'rgb(255, 99, 132)',\r\n    'rgb(255, 159, 64)',\r\n    'rgb(255, 205, 86)',\r\n    'rgb(75, 192, 192)',\r\n    'rgb(153, 102, 255)',\r\n    'rgb(201, 203, 207)' // grey\r\n];\r\n// Border colors with 50% transparency\r\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\r\nfunction getBorderColor(i) {\r\n    return BORDER_COLORS[i % BORDER_COLORS.length];\r\n}\r\nfunction getBackgroundColor(i) {\r\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\r\n}\r\nfunction colorizeDefaultDataset(dataset, i) {\r\n    dataset.borderColor = getBorderColor(i);\r\n    dataset.backgroundColor = getBackgroundColor(i);\r\n    return ++i;\r\n}\r\nfunction colorizeDoughnutDataset(dataset, i) {\r\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\r\n    return i;\r\n}\r\nfunction colorizePolarAreaDataset(dataset, i) {\r\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\r\n    return i;\r\n}\r\nfunction getColorizer(chart) {\r\n    let i = 0;\r\n    return (dataset, datasetIndex)=>{\r\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n        if (controller instanceof DoughnutController) {\r\n            i = colorizeDoughnutDataset(dataset, i);\r\n        } else if (controller instanceof PolarAreaController) {\r\n            i = colorizePolarAreaDataset(dataset, i);\r\n        } else if (controller) {\r\n            i = colorizeDefaultDataset(dataset, i);\r\n        }\r\n    };\r\n}\r\nfunction containsColorsDefinitions(descriptors) {\r\n    let k;\r\n    for(k in descriptors){\r\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction containsColorsDefinition(descriptor) {\r\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\r\n}\r\nvar plugin_colors = {\r\n    id: 'colors',\r\n    defaults: {\r\n        enabled: true,\r\n        forceOverride: false\r\n    },\r\n    beforeLayout (chart, _args, options) {\r\n        if (!options.enabled) {\r\n            return;\r\n        }\r\n        const { data: { datasets  } , options: chartOptions  } = chart.config;\r\n        const { elements  } = chartOptions;\r\n        if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements))) {\r\n            return;\r\n        }\r\n        const colorizer = getColorizer(chart);\r\n        datasets.forEach(colorizer);\r\n    }\r\n};\r\n\r\nfunction lttbDecimation(data, start, count, availableWidth, options) {\r\n const samples = options.samples || availableWidth;\r\n    if (samples >= count) {\r\n        return data.slice(start, start + count);\r\n    }\r\n    const decimated = [];\r\n    const bucketWidth = (count - 2) / (samples - 2);\r\n    let sampledIndex = 0;\r\n    const endIndex = start + count - 1;\r\n    let a = start;\r\n    let i, maxAreaPoint, maxArea, area, nextA;\r\n    decimated[sampledIndex++] = data[a];\r\n    for(i = 0; i < samples - 2; i++){\r\n        let avgX = 0;\r\n        let avgY = 0;\r\n        let j;\r\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\r\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\r\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\r\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\r\n            avgX += data[j].x;\r\n            avgY += data[j].y;\r\n        }\r\n        avgX /= avgRangeLength;\r\n        avgY /= avgRangeLength;\r\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\r\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\r\n        const { x: pointAx , y: pointAy  } = data[a];\r\n        maxArea = area = -1;\r\n        for(j = rangeOffs; j < rangeTo; j++){\r\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\r\n            if (area > maxArea) {\r\n                maxArea = area;\r\n                maxAreaPoint = data[j];\r\n                nextA = j;\r\n            }\r\n        }\r\n        decimated[sampledIndex++] = maxAreaPoint;\r\n        a = nextA;\r\n    }\r\n    decimated[sampledIndex++] = data[endIndex];\r\n    return decimated;\r\n}\r\nfunction minMaxDecimation(data, start, count, availableWidth) {\r\n    let avgX = 0;\r\n    let countX = 0;\r\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\r\n    const decimated = [];\r\n    const endIndex = start + count - 1;\r\n    const xMin = data[start].x;\r\n    const xMax = data[endIndex].x;\r\n    const dx = xMax - xMin;\r\n    for(i = start; i < start + count; ++i){\r\n        point = data[i];\r\n        x = (point.x - xMin) / dx * availableWidth;\r\n        y = point.y;\r\n        const truncX = x | 0;\r\n        if (truncX === prevX) {\r\n            if (y < minY) {\r\n                minY = y;\r\n                minIndex = i;\r\n            } else if (y > maxY) {\r\n                maxY = y;\r\n                maxIndex = i;\r\n            }\r\n            avgX = (countX * avgX + point.x) / ++countX;\r\n        } else {\r\n            const lastIndex = i - 1;\r\n            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\r\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\r\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\r\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\r\n                    decimated.push({\r\n                        ...data[intermediateIndex1],\r\n                        x: avgX\r\n                    });\r\n                }\r\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\r\n                    decimated.push({\r\n                        ...data[intermediateIndex2],\r\n                        x: avgX\r\n                    });\r\n                }\r\n            }\r\n            if (i > 0 && lastIndex !== startIndex) {\r\n                decimated.push(data[lastIndex]);\r\n            }\r\n            decimated.push(point);\r\n            prevX = truncX;\r\n            countX = 0;\r\n            minY = maxY = y;\r\n            minIndex = maxIndex = startIndex = i;\r\n        }\r\n    }\r\n    return decimated;\r\n}\r\nfunction cleanDecimatedDataset(dataset) {\r\n    if (dataset._decimated) {\r\n        const data = dataset._data;\r\n        delete dataset._decimated;\r\n        delete dataset._data;\r\n        Object.defineProperty(dataset, 'data', {\r\n            configurable: true,\r\n            enumerable: true,\r\n            writable: true,\r\n            value: data\r\n        });\r\n    }\r\n}\r\nfunction cleanDecimatedData(chart) {\r\n    chart.data.datasets.forEach((dataset)=>{\r\n        cleanDecimatedDataset(dataset);\r\n    });\r\n}\r\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\r\n    const pointCount = points.length;\r\n    let start = 0;\r\n    let count;\r\n    const { iScale  } = meta;\r\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\r\n    if (minDefined) {\r\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\r\n    }\r\n    if (maxDefined) {\r\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\r\n    } else {\r\n        count = pointCount - start;\r\n    }\r\n    return {\r\n        start,\r\n        count\r\n    };\r\n}\r\nvar plugin_decimation = {\r\n    id: 'decimation',\r\n    defaults: {\r\n        algorithm: 'min-max',\r\n        enabled: false\r\n    },\r\n    beforeElementsUpdate: (chart, args, options)=>{\r\n        if (!options.enabled) {\r\n            cleanDecimatedData(chart);\r\n            return;\r\n        }\r\n        const availableWidth = chart.width;\r\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\r\n            const { _data , indexAxis  } = dataset;\r\n            const meta = chart.getDatasetMeta(datasetIndex);\r\n            const data = _data || dataset.data;\r\n            if (resolve([\r\n                indexAxis,\r\n                chart.options.indexAxis\r\n            ]) === 'y') {\r\n                return;\r\n            }\r\n            if (!meta.controller.supportsDecimation) {\r\n                return;\r\n            }\r\n            const xAxis = chart.scales[meta.xAxisID];\r\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\r\n                return;\r\n            }\r\n            if (chart.options.parsing) {\r\n                return;\r\n            }\r\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\r\n            const threshold = options.threshold || 4 * availableWidth;\r\n            if (count <= threshold) {\r\n                cleanDecimatedDataset(dataset);\r\n                return;\r\n            }\r\n            if (isNullOrUndef(_data)) {\r\n                dataset._data = data;\r\n                delete dataset.data;\r\n                Object.defineProperty(dataset, 'data', {\r\n                    configurable: true,\r\n                    enumerable: true,\r\n                    get: function() {\r\n                        return this._decimated;\r\n                    },\r\n                    set: function(d) {\r\n                        this._data = d;\r\n                    }\r\n                });\r\n            }\r\n            let decimated;\r\n            switch(options.algorithm){\r\n                case 'lttb':\r\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\r\n                    break;\r\n                case 'min-max':\r\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\r\n            }\r\n            dataset._decimated = decimated;\r\n        });\r\n    },\r\n    destroy (chart) {\r\n        cleanDecimatedData(chart);\r\n    }\r\n};\r\n\r\nfunction _segments(line, target, property) {\r\n    const segments = line.segments;\r\n    const points = line.points;\r\n    const tpoints = target.points;\r\n    const parts = [];\r\n    for (const segment of segments){\r\n        let { start , end  } = segment;\r\n        end = _findSegmentEnd(start, end, points);\r\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\r\n        if (!target.segments) {\r\n            parts.push({\r\n                source: segment,\r\n                target: bounds,\r\n                start: points[start],\r\n                end: points[end]\r\n            });\r\n            continue;\r\n        }\r\n        const targetSegments = _boundSegments(target, bounds);\r\n        for (const tgt of targetSegments){\r\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\r\n            const fillSources = _boundSegment(segment, points, subBounds);\r\n            for (const fillSource of fillSources){\r\n                parts.push({\r\n                    source: fillSource,\r\n                    target: tgt,\r\n                    start: {\r\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\r\n                    },\r\n                    end: {\r\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    return parts;\r\n}\r\nfunction _getBounds(property, first, last, loop) {\r\n    if (loop) {\r\n        return;\r\n    }\r\n    let start = first[property];\r\n    let end = last[property];\r\n    if (property === 'angle') {\r\n        start = _normalizeAngle(start);\r\n        end = _normalizeAngle(end);\r\n    }\r\n    return {\r\n        property,\r\n        start,\r\n        end\r\n    };\r\n}\r\nfunction _pointsFromSegments(boundary, line) {\r\n    const { x =null , y =null  } = boundary || {};\r\n    const linePoints = line.points;\r\n    const points = [];\r\n    line.segments.forEach(({ start , end  })=>{\r\n        end = _findSegmentEnd(start, end, linePoints);\r\n        const first = linePoints[start];\r\n        const last = linePoints[end];\r\n        if (y !== null) {\r\n            points.push({\r\n                x: first.x,\r\n                y\r\n            });\r\n            points.push({\r\n                x: last.x,\r\n                y\r\n            });\r\n        } else if (x !== null) {\r\n            points.push({\r\n                x,\r\n                y: first.y\r\n            });\r\n            points.push({\r\n                x,\r\n                y: last.y\r\n            });\r\n        }\r\n    });\r\n    return points;\r\n}\r\nfunction _findSegmentEnd(start, end, points) {\r\n    for(; end > start; end--){\r\n        const point = points[end];\r\n        if (!isNaN(point.x) && !isNaN(point.y)) {\r\n            break;\r\n        }\r\n    }\r\n    return end;\r\n}\r\nfunction _getEdge(a, b, prop, fn) {\r\n    if (a && b) {\r\n        return fn(a[prop], b[prop]);\r\n    }\r\n    return a ? a[prop] : b ? b[prop] : 0;\r\n}\r\n\r\nfunction _createBoundaryLine(boundary, line) {\r\n    let points = [];\r\n    let _loop = false;\r\n    if (isArray(boundary)) {\r\n        _loop = true;\r\n        points = boundary;\r\n    } else {\r\n        points = _pointsFromSegments(boundary, line);\r\n    }\r\n    return points.length ? new LineElement({\r\n        points,\r\n        options: {\r\n            tension: 0\r\n        },\r\n        _loop,\r\n        _fullLoop: _loop\r\n    }) : null;\r\n}\r\nfunction _shouldApplyFill(source) {\r\n    return source && source.fill !== false;\r\n}\r\n\r\nfunction _resolveTarget(sources, index, propagate) {\r\n    const source = sources[index];\r\n    let fill = source.fill;\r\n    const visited = [\r\n        index\r\n    ];\r\n    let target;\r\n    if (!propagate) {\r\n        return fill;\r\n    }\r\n    while(fill !== false && visited.indexOf(fill) === -1){\r\n        if (!isNumberFinite(fill)) {\r\n            return fill;\r\n        }\r\n        target = sources[fill];\r\n        if (!target) {\r\n            return false;\r\n        }\r\n        if (target.visible) {\r\n            return fill;\r\n        }\r\n        visited.push(fill);\r\n        fill = target.fill;\r\n    }\r\n    return false;\r\n}\r\n function _decodeFill(line, index, count) {\r\n     const fill = parseFillOption(line);\r\n    if (isObject(fill)) {\r\n        return isNaN(fill.value) ? false : fill;\r\n    }\r\n    let target = parseFloat(fill);\r\n    if (isNumberFinite(target) && Math.floor(target) === target) {\r\n        return decodeTargetIndex(fill[0], index, target, count);\r\n    }\r\n    return [\r\n        'origin',\r\n        'start',\r\n        'end',\r\n        'stack',\r\n        'shape'\r\n    ].indexOf(fill) >= 0 && fill;\r\n}\r\nfunction decodeTargetIndex(firstCh, index, target, count) {\r\n    if (firstCh === '-' || firstCh === '+') {\r\n        target = index + target;\r\n    }\r\n    if (target === index || target < 0 || target >= count) {\r\n        return false;\r\n    }\r\n    return target;\r\n}\r\n function _getTargetPixel(fill, scale) {\r\n    let pixel = null;\r\n    if (fill === 'start') {\r\n        pixel = scale.bottom;\r\n    } else if (fill === 'end') {\r\n        pixel = scale.top;\r\n    } else if (isObject(fill)) {\r\n        pixel = scale.getPixelForValue(fill.value);\r\n    } else if (scale.getBasePixel) {\r\n        pixel = scale.getBasePixel();\r\n    }\r\n    return pixel;\r\n}\r\n function _getTargetValue(fill, scale, startValue) {\r\n    let value;\r\n    if (fill === 'start') {\r\n        value = startValue;\r\n    } else if (fill === 'end') {\r\n        value = scale.options.reverse ? scale.min : scale.max;\r\n    } else if (isObject(fill)) {\r\n        value = fill.value;\r\n    } else {\r\n        value = scale.getBaseValue();\r\n    }\r\n    return value;\r\n}\r\n function parseFillOption(line) {\r\n    const options = line.options;\r\n    const fillOption = options.fill;\r\n    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\r\n    if (fill === undefined) {\r\n        fill = !!options.backgroundColor;\r\n    }\r\n    if (fill === false || fill === null) {\r\n        return false;\r\n    }\r\n    if (fill === true) {\r\n        return 'origin';\r\n    }\r\n    return fill;\r\n}\r\n\r\nfunction _buildStackLine(source) {\r\n    const { scale , index , line  } = source;\r\n    const points = [];\r\n    const segments = line.segments;\r\n    const sourcePoints = line.points;\r\n    const linesBelow = getLinesBelow(scale, index);\r\n    linesBelow.push(_createBoundaryLine({\r\n        x: null,\r\n        y: scale.bottom\r\n    }, line));\r\n    for(let i = 0; i < segments.length; i++){\r\n        const segment = segments[i];\r\n        for(let j = segment.start; j <= segment.end; j++){\r\n            addPointsBelow(points, sourcePoints[j], linesBelow);\r\n        }\r\n    }\r\n    return new LineElement({\r\n        points,\r\n        options: {}\r\n    });\r\n}\r\n function getLinesBelow(scale, index) {\r\n    const below = [];\r\n    const metas = scale.getMatchingVisibleMetas('line');\r\n    for(let i = 0; i < metas.length; i++){\r\n        const meta = metas[i];\r\n        if (meta.index === index) {\r\n            break;\r\n        }\r\n        if (!meta.hidden) {\r\n            below.unshift(meta.dataset);\r\n        }\r\n    }\r\n    return below;\r\n}\r\n function addPointsBelow(points, sourcePoint, linesBelow) {\r\n    const postponed = [];\r\n    for(let j = 0; j < linesBelow.length; j++){\r\n        const line = linesBelow[j];\r\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\r\n        if (!point || first && last) {\r\n            continue;\r\n        }\r\n        if (first) {\r\n            postponed.unshift(point);\r\n        } else {\r\n            points.push(point);\r\n            if (!last) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    points.push(...postponed);\r\n}\r\n function findPoint(line, sourcePoint, property) {\r\n    const point = line.interpolate(sourcePoint, property);\r\n    if (!point) {\r\n        return {};\r\n    }\r\n    const pointValue = point[property];\r\n    const segments = line.segments;\r\n    const linePoints = line.points;\r\n    let first = false;\r\n    let last = false;\r\n    for(let i = 0; i < segments.length; i++){\r\n        const segment = segments[i];\r\n        const firstValue = linePoints[segment.start][property];\r\n        const lastValue = linePoints[segment.end][property];\r\n        if (_isBetween(pointValue, firstValue, lastValue)) {\r\n            first = pointValue === firstValue;\r\n            last = pointValue === lastValue;\r\n            break;\r\n        }\r\n    }\r\n    return {\r\n        first,\r\n        last,\r\n        point\r\n    };\r\n}\r\n\r\nclass simpleArc {\r\n    constructor(opts){\r\n        this.x = opts.x;\r\n        this.y = opts.y;\r\n        this.radius = opts.radius;\r\n    }\r\n    pathSegment(ctx, bounds, opts) {\r\n        const { x , y , radius  } = this;\r\n        bounds = bounds || {\r\n            start: 0,\r\n            end: TAU\r\n        };\r\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\r\n        return !opts.bounds;\r\n    }\r\n    interpolate(point) {\r\n        const { x , y , radius  } = this;\r\n        const angle = point.angle;\r\n        return {\r\n            x: x + Math.cos(angle) * radius,\r\n            y: y + Math.sin(angle) * radius,\r\n            angle\r\n        };\r\n    }\r\n}\r\n\r\nfunction _getTarget(source) {\r\n    const { chart , fill , line  } = source;\r\n    if (isNumberFinite(fill)) {\r\n        return getLineByIndex(chart, fill);\r\n    }\r\n    if (fill === 'stack') {\r\n        return _buildStackLine(source);\r\n    }\r\n    if (fill === 'shape') {\r\n        return true;\r\n    }\r\n    const boundary = computeBoundary(source);\r\n    if (boundary instanceof simpleArc) {\r\n        return boundary;\r\n    }\r\n    return _createBoundaryLine(boundary, line);\r\n}\r\n function getLineByIndex(chart, index) {\r\n    const meta = chart.getDatasetMeta(index);\r\n    const visible = meta && chart.isDatasetVisible(index);\r\n    return visible ? meta.dataset : null;\r\n}\r\nfunction computeBoundary(source) {\r\n    const scale = source.scale || {};\r\n    if (scale.getPointPositionForValue) {\r\n        return computeCircularBoundary(source);\r\n    }\r\n    return computeLinearBoundary(source);\r\n}\r\nfunction computeLinearBoundary(source) {\r\n    const { scale ={} , fill  } = source;\r\n    const pixel = _getTargetPixel(fill, scale);\r\n    if (isNumberFinite(pixel)) {\r\n        const horizontal = scale.isHorizontal();\r\n        return {\r\n            x: horizontal ? pixel : null,\r\n            y: horizontal ? null : pixel\r\n        };\r\n    }\r\n    return null;\r\n}\r\nfunction computeCircularBoundary(source) {\r\n    const { scale , fill  } = source;\r\n    const options = scale.options;\r\n    const length = scale.getLabels().length;\r\n    const start = options.reverse ? scale.max : scale.min;\r\n    const value = _getTargetValue(fill, scale, start);\r\n    const target = [];\r\n    if (options.grid.circular) {\r\n        const center = scale.getPointPositionForValue(0, start);\r\n        return new simpleArc({\r\n            x: center.x,\r\n            y: center.y,\r\n            radius: scale.getDistanceFromCenterForValue(value)\r\n        });\r\n    }\r\n    for(let i = 0; i < length; ++i){\r\n        target.push(scale.getPointPositionForValue(i, value));\r\n    }\r\n    return target;\r\n}\r\n\r\nfunction _drawfill(ctx, source, area) {\r\n    const target = _getTarget(source);\r\n    const { line , scale , axis  } = source;\r\n    const lineOpts = line.options;\r\n    const fillOption = lineOpts.fill;\r\n    const color = lineOpts.backgroundColor;\r\n    const { above =color , below =color  } = fillOption || {};\r\n    if (target && line.points.length) {\r\n        clipArea(ctx, area);\r\n        doFill(ctx, {\r\n            line,\r\n            target,\r\n            above,\r\n            below,\r\n            area,\r\n            scale,\r\n            axis\r\n        });\r\n        unclipArea(ctx);\r\n    }\r\n}\r\nfunction doFill(ctx, cfg) {\r\n    const { line , target , above , below , area , scale  } = cfg;\r\n    const property = line._loop ? 'angle' : cfg.axis;\r\n    ctx.save();\r\n    if (property === 'x' && below !== above) {\r\n        clipVertical(ctx, target, area.top);\r\n        fill(ctx, {\r\n            line,\r\n            target,\r\n            color: above,\r\n            scale,\r\n            property\r\n        });\r\n        ctx.restore();\r\n        ctx.save();\r\n        clipVertical(ctx, target, area.bottom);\r\n    }\r\n    fill(ctx, {\r\n        line,\r\n        target,\r\n        color: below,\r\n        scale,\r\n        property\r\n    });\r\n    ctx.restore();\r\n}\r\nfunction clipVertical(ctx, target, clipY) {\r\n    const { segments , points  } = target;\r\n    let first = true;\r\n    let lineLoop = false;\r\n    ctx.beginPath();\r\n    for (const segment of segments){\r\n        const { start , end  } = segment;\r\n        const firstPoint = points[start];\r\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\r\n        if (first) {\r\n            ctx.moveTo(firstPoint.x, firstPoint.y);\r\n            first = false;\r\n        } else {\r\n            ctx.lineTo(firstPoint.x, clipY);\r\n            ctx.lineTo(firstPoint.x, firstPoint.y);\r\n        }\r\n        lineLoop = !!target.pathSegment(ctx, segment, {\r\n            move: lineLoop\r\n        });\r\n        if (lineLoop) {\r\n            ctx.closePath();\r\n        } else {\r\n            ctx.lineTo(lastPoint.x, clipY);\r\n        }\r\n    }\r\n    ctx.lineTo(target.first().x, clipY);\r\n    ctx.closePath();\r\n    ctx.clip();\r\n}\r\nfunction fill(ctx, cfg) {\r\n    const { line , target , property , color , scale  } = cfg;\r\n    const segments = _segments(line, target, property);\r\n    for (const { source: src , target: tgt , start , end  } of segments){\r\n        const { style: { backgroundColor =color  } = {}  } = src;\r\n        const notShape = target !== true;\r\n        ctx.save();\r\n        ctx.fillStyle = backgroundColor;\r\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\r\n        ctx.beginPath();\r\n        const lineLoop = !!line.pathSegment(ctx, src);\r\n        let loop;\r\n        if (notShape) {\r\n            if (lineLoop) {\r\n                ctx.closePath();\r\n            } else {\r\n                interpolatedLineTo(ctx, target, end, property);\r\n            }\r\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\r\n                move: lineLoop,\r\n                reverse: true\r\n            });\r\n            loop = lineLoop && targetLoop;\r\n            if (!loop) {\r\n                interpolatedLineTo(ctx, target, start, property);\r\n            }\r\n        }\r\n        ctx.closePath();\r\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\r\n        ctx.restore();\r\n    }\r\n}\r\nfunction clipBounds(ctx, scale, bounds) {\r\n    const { top , bottom  } = scale.chart.chartArea;\r\n    const { property , start , end  } = bounds || {};\r\n    if (property === 'x') {\r\n        ctx.beginPath();\r\n        ctx.rect(start, top, end - start, bottom - top);\r\n        ctx.clip();\r\n    }\r\n}\r\nfunction interpolatedLineTo(ctx, target, point, property) {\r\n    const interpolatedPoint = target.interpolate(point, property);\r\n    if (interpolatedPoint) {\r\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\r\n    }\r\n}\r\n\r\nvar index = {\r\n    id: 'filler',\r\n    afterDatasetsUpdate (chart, _args, options) {\r\n        const count = (chart.data.datasets || []).length;\r\n        const sources = [];\r\n        let meta, i, line, source;\r\n        for(i = 0; i < count; ++i){\r\n            meta = chart.getDatasetMeta(i);\r\n            line = meta.dataset;\r\n            source = null;\r\n            if (line && line.options && line instanceof LineElement) {\r\n                source = {\r\n                    visible: chart.isDatasetVisible(i),\r\n                    index: i,\r\n                    fill: _decodeFill(line, i, count),\r\n                    chart,\r\n                    axis: meta.controller.options.indexAxis,\r\n                    scale: meta.vScale,\r\n                    line\r\n                };\r\n            }\r\n            meta.$filler = source;\r\n            sources.push(source);\r\n        }\r\n        for(i = 0; i < count; ++i){\r\n            source = sources[i];\r\n            if (!source || source.fill === false) {\r\n                continue;\r\n            }\r\n            source.fill = _resolveTarget(sources, i, options.propagate);\r\n        }\r\n    },\r\n    beforeDraw (chart, _args, options) {\r\n        const draw = options.drawTime === 'beforeDraw';\r\n        const metasets = chart.getSortedVisibleDatasetMetas();\r\n        const area = chart.chartArea;\r\n        for(let i = metasets.length - 1; i >= 0; --i){\r\n            const source = metasets[i].$filler;\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            source.line.updateControlPoints(area, source.axis);\r\n            if (draw && source.fill) {\r\n                _drawfill(chart.ctx, source, area);\r\n            }\r\n        }\r\n    },\r\n    beforeDatasetsDraw (chart, _args, options) {\r\n        if (options.drawTime !== 'beforeDatasetsDraw') {\r\n            return;\r\n        }\r\n        const metasets = chart.getSortedVisibleDatasetMetas();\r\n        for(let i = metasets.length - 1; i >= 0; --i){\r\n            const source = metasets[i].$filler;\r\n            if (_shouldApplyFill(source)) {\r\n                _drawfill(chart.ctx, source, chart.chartArea);\r\n            }\r\n        }\r\n    },\r\n    beforeDatasetDraw (chart, args, options) {\r\n        const source = args.meta.$filler;\r\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\r\n            return;\r\n        }\r\n        _drawfill(chart.ctx, source, chart.chartArea);\r\n    },\r\n    defaults: {\r\n        propagate: true,\r\n        drawTime: 'beforeDatasetDraw'\r\n    }\r\n};\r\n\r\nconst getBoxSize = (labelOpts, fontSize)=>{\r\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\r\n    if (labelOpts.usePointStyle) {\r\n        boxHeight = Math.min(boxHeight, fontSize);\r\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\r\n    }\r\n    return {\r\n        boxWidth,\r\n        boxHeight,\r\n        itemHeight: Math.max(fontSize, boxHeight)\r\n    };\r\n};\r\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\r\nclass Legend extends Element {\r\n constructor(config){\r\n        super();\r\n        this._added = false;\r\n        this.legendHitBoxes = [];\r\n this._hoveredItem = null;\r\n        this.doughnutMode = false;\r\n        this.chart = config.chart;\r\n        this.options = config.options;\r\n        this.ctx = config.ctx;\r\n        this.legendItems = undefined;\r\n        this.columnSizes = undefined;\r\n        this.lineWidths = undefined;\r\n        this.maxHeight = undefined;\r\n        this.maxWidth = undefined;\r\n        this.top = undefined;\r\n        this.bottom = undefined;\r\n        this.left = undefined;\r\n        this.right = undefined;\r\n        this.height = undefined;\r\n        this.width = undefined;\r\n        this._margins = undefined;\r\n        this.position = undefined;\r\n        this.weight = undefined;\r\n        this.fullSize = undefined;\r\n    }\r\n    update(maxWidth, maxHeight, margins) {\r\n        this.maxWidth = maxWidth;\r\n        this.maxHeight = maxHeight;\r\n        this._margins = margins;\r\n        this.setDimensions();\r\n        this.buildLabels();\r\n        this.fit();\r\n    }\r\n    setDimensions() {\r\n        if (this.isHorizontal()) {\r\n            this.width = this.maxWidth;\r\n            this.left = this._margins.left;\r\n            this.right = this.width;\r\n        } else {\r\n            this.height = this.maxHeight;\r\n            this.top = this._margins.top;\r\n            this.bottom = this.height;\r\n        }\r\n    }\r\n    buildLabels() {\r\n        const labelOpts = this.options.labels || {};\r\n        let legendItems = callback(labelOpts.generateLabels, [\r\n            this.chart\r\n        ], this) || [];\r\n        if (labelOpts.filter) {\r\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\r\n        }\r\n        if (labelOpts.sort) {\r\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\r\n        }\r\n        if (this.options.reverse) {\r\n            legendItems.reverse();\r\n        }\r\n        this.legendItems = legendItems;\r\n    }\r\n    fit() {\r\n        const { options , ctx  } = this;\r\n        if (!options.display) {\r\n            this.width = this.height = 0;\r\n            return;\r\n        }\r\n        const labelOpts = options.labels;\r\n        const labelFont = toFont(labelOpts.font);\r\n        const fontSize = labelFont.size;\r\n        const titleHeight = this._computeTitleHeight();\r\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\r\n        let width, height;\r\n        ctx.font = labelFont.string;\r\n        if (this.isHorizontal()) {\r\n            width = this.maxWidth;\r\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n        } else {\r\n            height = this.maxHeight;\r\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\r\n        }\r\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\r\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\r\n    }\r\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\r\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\r\n        const hitboxes = this.legendHitBoxes = [];\r\n        const lineWidths = this.lineWidths = [\r\n            0\r\n        ];\r\n        const lineHeight = itemHeight + padding;\r\n        let totalHeight = titleHeight;\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'middle';\r\n        let row = -1;\r\n        let top = -lineHeight;\r\n        this.legendItems.forEach((legendItem, i)=>{\r\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\r\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\r\n                totalHeight += lineHeight;\r\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n                top += lineHeight;\r\n                row++;\r\n            }\r\n            hitboxes[i] = {\r\n                left: 0,\r\n                top,\r\n                row,\r\n                width: itemWidth,\r\n                height: itemHeight\r\n            };\r\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\r\n        });\r\n        return totalHeight;\r\n    }\r\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\r\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\r\n        const hitboxes = this.legendHitBoxes = [];\r\n        const columnSizes = this.columnSizes = [];\r\n        const heightLimit = maxHeight - titleHeight;\r\n        let totalWidth = padding;\r\n        let currentColWidth = 0;\r\n        let currentColHeight = 0;\r\n        let left = 0;\r\n        let col = 0;\r\n        this.legendItems.forEach((legendItem, i)=>{\r\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\r\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\r\n                totalWidth += currentColWidth + padding;\r\n                columnSizes.push({\r\n                    width: currentColWidth,\r\n                    height: currentColHeight\r\n                });\r\n                left += currentColWidth + padding;\r\n                col++;\r\n                currentColWidth = currentColHeight = 0;\r\n            }\r\n            hitboxes[i] = {\r\n                left,\r\n                top: currentColHeight,\r\n                col,\r\n                width: itemWidth,\r\n                height: itemHeight\r\n            };\r\n            currentColWidth = Math.max(currentColWidth, itemWidth);\r\n            currentColHeight += itemHeight + padding;\r\n        });\r\n        totalWidth += currentColWidth;\r\n        columnSizes.push({\r\n            width: currentColWidth,\r\n            height: currentColHeight\r\n        });\r\n        return totalWidth;\r\n    }\r\n    adjustHitBoxes() {\r\n        if (!this.options.display) {\r\n            return;\r\n        }\r\n        const titleHeight = this._computeTitleHeight();\r\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\r\n        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\r\n        if (this.isHorizontal()) {\r\n            let row = 0;\r\n            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n            for (const hitbox of hitboxes){\r\n                if (row !== hitbox.row) {\r\n                    row = hitbox.row;\r\n                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n                }\r\n                hitbox.top += this.top + titleHeight + padding;\r\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\r\n                left += hitbox.width + padding;\r\n            }\r\n        } else {\r\n            let col = 0;\r\n            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n            for (const hitbox1 of hitboxes){\r\n                if (hitbox1.col !== col) {\r\n                    col = hitbox1.col;\r\n                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n                }\r\n                hitbox1.top = top;\r\n                hitbox1.left += this.left + padding;\r\n                hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);\r\n                top += hitbox1.height + padding;\r\n            }\r\n        }\r\n    }\r\n    isHorizontal() {\r\n        return this.options.position === 'top' || this.options.position === 'bottom';\r\n    }\r\n    draw() {\r\n        if (this.options.display) {\r\n            const ctx = this.ctx;\r\n            clipArea(ctx, this);\r\n            this._draw();\r\n            unclipArea(ctx);\r\n        }\r\n    }\r\n _draw() {\r\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\r\n        const { align , labels: labelOpts  } = opts;\r\n        const defaultColor = defaults.color;\r\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n        const labelFont = toFont(labelOpts.font);\r\n        const { padding  } = labelOpts;\r\n        const fontSize = labelFont.size;\r\n        const halfFontSize = fontSize / 2;\r\n        let cursor;\r\n        this.drawTitle();\r\n        ctx.textAlign = rtlHelper.textAlign('left');\r\n        ctx.textBaseline = 'middle';\r\n        ctx.lineWidth = 0.5;\r\n        ctx.font = labelFont.string;\r\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\r\n        const drawLegendBox = function(x, y, legendItem) {\r\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\r\n                return;\r\n            }\r\n            ctx.save();\r\n            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\r\n            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\r\n            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\r\n            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\r\n            ctx.lineWidth = lineWidth;\r\n            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\r\n            if (labelOpts.usePointStyle) {\r\n                const drawOptions = {\r\n                    radius: boxHeight * Math.SQRT2 / 2,\r\n                    pointStyle: legendItem.pointStyle,\r\n                    rotation: legendItem.rotation,\r\n                    borderWidth: lineWidth\r\n                };\r\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n                const centerY = y + halfFontSize;\r\n                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\r\n            } else {\r\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\r\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\r\n                const borderRadius = toTRBLCorners(legendItem.borderRadius);\r\n                ctx.beginPath();\r\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\r\n                    addRoundedRectPath(ctx, {\r\n                        x: xBoxLeft,\r\n                        y: yBoxTop,\r\n                        w: boxWidth,\r\n                        h: boxHeight,\r\n                        radius: borderRadius\r\n                    });\r\n                } else {\r\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\r\n                }\r\n                ctx.fill();\r\n                if (lineWidth !== 0) {\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n            ctx.restore();\r\n        };\r\n        const fillText = function(x, y, legendItem) {\r\n            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\r\n                strikethrough: legendItem.hidden,\r\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\r\n            });\r\n        };\r\n        const isHorizontal = this.isHorizontal();\r\n        const titleHeight = this._computeTitleHeight();\r\n        if (isHorizontal) {\r\n            cursor = {\r\n                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\r\n                y: this.top + padding + titleHeight,\r\n                line: 0\r\n            };\r\n        } else {\r\n            cursor = {\r\n                x: this.left + padding,\r\n                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\r\n                line: 0\r\n            };\r\n        }\r\n        overrideTextDirection(this.ctx, opts.textDirection);\r\n        const lineHeight = itemHeight + padding;\r\n        this.legendItems.forEach((legendItem, i)=>{\r\n            ctx.strokeStyle = legendItem.fontColor;\r\n            ctx.fillStyle = legendItem.fontColor;\r\n            const textWidth = ctx.measureText(legendItem.text).width;\r\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\r\n            const width = boxWidth + halfFontSize + textWidth;\r\n            let x = cursor.x;\r\n            let y = cursor.y;\r\n            rtlHelper.setWidth(this.width);\r\n            if (isHorizontal) {\r\n                if (i > 0 && x + width + padding > this.right) {\r\n                    y = cursor.y += lineHeight;\r\n                    cursor.line++;\r\n                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\r\n                }\r\n            } else if (i > 0 && y + lineHeight > this.bottom) {\r\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\r\n                cursor.line++;\r\n                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\r\n            }\r\n            const realX = rtlHelper.x(x);\r\n            drawLegendBox(realX, y, legendItem);\r\n            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\r\n            fillText(rtlHelper.x(x), y, legendItem);\r\n            if (isHorizontal) {\r\n                cursor.x += width + padding;\r\n            } else if (typeof legendItem.text !== 'string') {\r\n                const fontLineHeight = labelFont.lineHeight;\r\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);\r\n            } else {\r\n                cursor.y += lineHeight;\r\n            }\r\n        });\r\n        restoreTextDirection(this.ctx, opts.textDirection);\r\n    }\r\n drawTitle() {\r\n        const opts = this.options;\r\n        const titleOpts = opts.title;\r\n        const titleFont = toFont(titleOpts.font);\r\n        const titlePadding = toPadding(titleOpts.padding);\r\n        if (!titleOpts.display) {\r\n            return;\r\n        }\r\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n        const ctx = this.ctx;\r\n        const position = titleOpts.position;\r\n        const halfFontSize = titleFont.size / 2;\r\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\r\n        let y;\r\n        let left = this.left;\r\n        let maxWidth = this.width;\r\n        if (this.isHorizontal()) {\r\n            maxWidth = Math.max(...this.lineWidths);\r\n            y = this.top + topPaddingPlusHalfFontSize;\r\n            left = _alignStartEnd(opts.align, left, this.right - maxWidth);\r\n        } else {\r\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\r\n            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\r\n        }\r\n        const x = _alignStartEnd(position, left, left + maxWidth);\r\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\r\n        ctx.textBaseline = 'middle';\r\n        ctx.strokeStyle = titleOpts.color;\r\n        ctx.fillStyle = titleOpts.color;\r\n        ctx.font = titleFont.string;\r\n        renderText(ctx, titleOpts.text, x, y, titleFont);\r\n    }\r\n _computeTitleHeight() {\r\n        const titleOpts = this.options.title;\r\n        const titleFont = toFont(titleOpts.font);\r\n        const titlePadding = toPadding(titleOpts.padding);\r\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\r\n    }\r\n _getLegendItemAt(x, y) {\r\n        let i, hitBox, lh;\r\n        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\r\n            lh = this.legendHitBoxes;\r\n            for(i = 0; i < lh.length; ++i){\r\n                hitBox = lh[i];\r\n                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\r\n                    return this.legendItems[i];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n handleEvent(e) {\r\n        const opts = this.options;\r\n        if (!isListened(e.type, opts)) {\r\n            return;\r\n        }\r\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\r\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\r\n            const previous = this._hoveredItem;\r\n            const sameItem = itemsEqual(previous, hoveredItem);\r\n            if (previous && !sameItem) {\r\n                callback(opts.onLeave, [\r\n                    e,\r\n                    previous,\r\n                    this\r\n                ], this);\r\n            }\r\n            this._hoveredItem = hoveredItem;\r\n            if (hoveredItem && !sameItem) {\r\n                callback(opts.onHover, [\r\n                    e,\r\n                    hoveredItem,\r\n                    this\r\n                ], this);\r\n            }\r\n        } else if (hoveredItem) {\r\n            callback(opts.onClick, [\r\n                e,\r\n                hoveredItem,\r\n                this\r\n            ], this);\r\n        }\r\n    }\r\n}\r\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\r\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\r\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\r\n    return {\r\n        itemWidth,\r\n        itemHeight\r\n    };\r\n}\r\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\r\n    let legendItemText = legendItem.text;\r\n    if (legendItemText && typeof legendItemText !== 'string') {\r\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\r\n    }\r\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\r\n}\r\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\r\n    let itemHeight = _itemHeight;\r\n    if (typeof legendItem.text !== 'string') {\r\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\r\n    }\r\n    return itemHeight;\r\n}\r\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\r\n    const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;\r\n    return fontLineHeight * labelHeight;\r\n}\r\nfunction isListened(type, opts) {\r\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\r\n        return true;\r\n    }\r\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nvar plugin_legend = {\r\n    id: 'legend',\r\n _element: Legend,\r\n    start (chart, _args, options) {\r\n        const legend = chart.legend = new Legend({\r\n            ctx: chart.ctx,\r\n            options,\r\n            chart\r\n        });\r\n        layouts.configure(chart, legend, options);\r\n        layouts.addBox(chart, legend);\r\n    },\r\n    stop (chart) {\r\n        layouts.removeBox(chart, chart.legend);\r\n        delete chart.legend;\r\n    },\r\n    beforeUpdate (chart, _args, options) {\r\n        const legend = chart.legend;\r\n        layouts.configure(chart, legend, options);\r\n        legend.options = options;\r\n    },\r\n    afterUpdate (chart) {\r\n        const legend = chart.legend;\r\n        legend.buildLabels();\r\n        legend.adjustHitBoxes();\r\n    },\r\n    afterEvent (chart, args) {\r\n        if (!args.replay) {\r\n            chart.legend.handleEvent(args.event);\r\n        }\r\n    },\r\n    defaults: {\r\n        display: true,\r\n        position: 'top',\r\n        align: 'center',\r\n        fullSize: true,\r\n        reverse: false,\r\n        weight: 1000,\r\n        onClick (e, legendItem, legend) {\r\n            const index = legendItem.datasetIndex;\r\n            const ci = legend.chart;\r\n            if (ci.isDatasetVisible(index)) {\r\n                ci.hide(index);\r\n                legendItem.hidden = true;\r\n            } else {\r\n                ci.show(index);\r\n                legendItem.hidden = false;\r\n            }\r\n        },\r\n        onHover: null,\r\n        onLeave: null,\r\n        labels: {\r\n            color: (ctx)=>ctx.chart.options.color,\r\n            boxWidth: 40,\r\n            padding: 10,\r\n            generateLabels (chart) {\r\n                const datasets = chart.data.datasets;\r\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\r\n                return chart._getSortedDatasetMetas().map((meta)=>{\r\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n                    const borderWidth = toPadding(style.borderWidth);\r\n                    return {\r\n                        text: datasets[meta.index].label,\r\n                        fillStyle: style.backgroundColor,\r\n                        fontColor: color,\r\n                        hidden: !meta.visible,\r\n                        lineCap: style.borderCapStyle,\r\n                        lineDash: style.borderDash,\r\n                        lineDashOffset: style.borderDashOffset,\r\n                        lineJoin: style.borderJoinStyle,\r\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\r\n                        strokeStyle: style.borderColor,\r\n                        pointStyle: pointStyle || style.pointStyle,\r\n                        rotation: style.rotation,\r\n                        textAlign: textAlign || style.textAlign,\r\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\r\n                        datasetIndex: meta.index\r\n                    };\r\n                }, this);\r\n            }\r\n        },\r\n        title: {\r\n            color: (ctx)=>ctx.chart.options.color,\r\n            display: false,\r\n            position: 'center',\r\n            text: ''\r\n        }\r\n    },\r\n    descriptors: {\r\n        _scriptable: (name)=>!name.startsWith('on'),\r\n        labels: {\r\n            _scriptable: (name)=>![\r\n                    'generateLabels',\r\n                    'filter',\r\n                    'sort'\r\n                ].includes(name)\r\n        }\r\n    }\r\n};\r\n\r\nclass Title extends Element {\r\n constructor(config){\r\n        super();\r\n        this.chart = config.chart;\r\n        this.options = config.options;\r\n        this.ctx = config.ctx;\r\n        this._padding = undefined;\r\n        this.top = undefined;\r\n        this.bottom = undefined;\r\n        this.left = undefined;\r\n        this.right = undefined;\r\n        this.width = undefined;\r\n        this.height = undefined;\r\n        this.position = undefined;\r\n        this.weight = undefined;\r\n        this.fullSize = undefined;\r\n    }\r\n    update(maxWidth, maxHeight) {\r\n        const opts = this.options;\r\n        this.left = 0;\r\n        this.top = 0;\r\n        if (!opts.display) {\r\n            this.width = this.height = this.right = this.bottom = 0;\r\n            return;\r\n        }\r\n        this.width = this.right = maxWidth;\r\n        this.height = this.bottom = maxHeight;\r\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\r\n        this._padding = toPadding(opts.padding);\r\n        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\r\n        if (this.isHorizontal()) {\r\n            this.height = textSize;\r\n        } else {\r\n            this.width = textSize;\r\n        }\r\n    }\r\n    isHorizontal() {\r\n        const pos = this.options.position;\r\n        return pos === 'top' || pos === 'bottom';\r\n    }\r\n    _drawArgs(offset) {\r\n        const { top , left , bottom , right , options  } = this;\r\n        const align = options.align;\r\n        let rotation = 0;\r\n        let maxWidth, titleX, titleY;\r\n        if (this.isHorizontal()) {\r\n            titleX = _alignStartEnd(align, left, right);\r\n            titleY = top + offset;\r\n            maxWidth = right - left;\r\n        } else {\r\n            if (options.position === 'left') {\r\n                titleX = left + offset;\r\n                titleY = _alignStartEnd(align, bottom, top);\r\n                rotation = PI * -0.5;\r\n            } else {\r\n                titleX = right - offset;\r\n                titleY = _alignStartEnd(align, top, bottom);\r\n                rotation = PI * 0.5;\r\n            }\r\n            maxWidth = bottom - top;\r\n        }\r\n        return {\r\n            titleX,\r\n            titleY,\r\n            maxWidth,\r\n            rotation\r\n        };\r\n    }\r\n    draw() {\r\n        const ctx = this.ctx;\r\n        const opts = this.options;\r\n        if (!opts.display) {\r\n            return;\r\n        }\r\n        const fontOpts = toFont(opts.font);\r\n        const lineHeight = fontOpts.lineHeight;\r\n        const offset = lineHeight / 2 + this._padding.top;\r\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\r\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\r\n            color: opts.color,\r\n            maxWidth,\r\n            rotation,\r\n            textAlign: _toLeftRightCenter(opts.align),\r\n            textBaseline: 'middle',\r\n            translation: [\r\n                titleX,\r\n                titleY\r\n            ]\r\n        });\r\n    }\r\n}\r\nfunction createTitle(chart, titleOpts) {\r\n    const title = new Title({\r\n        ctx: chart.ctx,\r\n        options: titleOpts,\r\n        chart\r\n    });\r\n    layouts.configure(chart, title, titleOpts);\r\n    layouts.addBox(chart, title);\r\n    chart.titleBlock = title;\r\n}\r\nvar plugin_title = {\r\n    id: 'title',\r\n _element: Title,\r\n    start (chart, _args, options) {\r\n        createTitle(chart, options);\r\n    },\r\n    stop (chart) {\r\n        const titleBlock = chart.titleBlock;\r\n        layouts.removeBox(chart, titleBlock);\r\n        delete chart.titleBlock;\r\n    },\r\n    beforeUpdate (chart, _args, options) {\r\n        const title = chart.titleBlock;\r\n        layouts.configure(chart, title, options);\r\n        title.options = options;\r\n    },\r\n    defaults: {\r\n        align: 'center',\r\n        display: false,\r\n        font: {\r\n            weight: 'bold'\r\n        },\r\n        fullSize: true,\r\n        padding: 10,\r\n        position: 'top',\r\n        text: '',\r\n        weight: 2000\r\n    },\r\n    defaultRoutes: {\r\n        color: 'color'\r\n    },\r\n    descriptors: {\r\n        _scriptable: true,\r\n        _indexable: false\r\n    }\r\n};\r\n\r\nconst map = new WeakMap();\r\nvar plugin_subtitle = {\r\n    id: 'subtitle',\r\n    start (chart, _args, options) {\r\n        const title = new Title({\r\n            ctx: chart.ctx,\r\n            options,\r\n            chart\r\n        });\r\n        layouts.configure(chart, title, options);\r\n        layouts.addBox(chart, title);\r\n        map.set(chart, title);\r\n    },\r\n    stop (chart) {\r\n        layouts.removeBox(chart, map.get(chart));\r\n        map.delete(chart);\r\n    },\r\n    beforeUpdate (chart, _args, options) {\r\n        const title = map.get(chart);\r\n        layouts.configure(chart, title, options);\r\n        title.options = options;\r\n    },\r\n    defaults: {\r\n        align: 'center',\r\n        display: false,\r\n        font: {\r\n            weight: 'normal'\r\n        },\r\n        fullSize: true,\r\n        padding: 0,\r\n        position: 'top',\r\n        text: '',\r\n        weight: 1500\r\n    },\r\n    defaultRoutes: {\r\n        color: 'color'\r\n    },\r\n    descriptors: {\r\n        _scriptable: true,\r\n        _indexable: false\r\n    }\r\n};\r\n\r\nconst positioners = {\r\n average (items) {\r\n        if (!items.length) {\r\n            return false;\r\n        }\r\n        let i, len;\r\n        let x = 0;\r\n        let y = 0;\r\n        let count = 0;\r\n        for(i = 0, len = items.length; i < len; ++i){\r\n            const el = items[i].element;\r\n            if (el && el.hasValue()) {\r\n                const pos = el.tooltipPosition();\r\n                x += pos.x;\r\n                y += pos.y;\r\n                ++count;\r\n            }\r\n        }\r\n        return {\r\n            x: x / count,\r\n            y: y / count\r\n        };\r\n    },\r\n nearest (items, eventPosition) {\r\n        if (!items.length) {\r\n            return false;\r\n        }\r\n        let x = eventPosition.x;\r\n        let y = eventPosition.y;\r\n        let minDistance = Number.POSITIVE_INFINITY;\r\n        let i, len, nearestElement;\r\n        for(i = 0, len = items.length; i < len; ++i){\r\n            const el = items[i].element;\r\n            if (el && el.hasValue()) {\r\n                const center = el.getCenterPoint();\r\n                const d = distanceBetweenPoints(eventPosition, center);\r\n                if (d < minDistance) {\r\n                    minDistance = d;\r\n                    nearestElement = el;\r\n                }\r\n            }\r\n        }\r\n        if (nearestElement) {\r\n            const tp = nearestElement.tooltipPosition();\r\n            x = tp.x;\r\n            y = tp.y;\r\n        }\r\n        return {\r\n            x,\r\n            y\r\n        };\r\n    }\r\n};\r\nfunction pushOrConcat(base, toPush) {\r\n    if (toPush) {\r\n        if (isArray(toPush)) {\r\n            Array.prototype.push.apply(base, toPush);\r\n        } else {\r\n            base.push(toPush);\r\n        }\r\n    }\r\n    return base;\r\n}\r\n function splitNewlines(str) {\r\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n        return str.split('\\n');\r\n    }\r\n    return str;\r\n}\r\n function createTooltipItem(chart, item) {\r\n    const { element , datasetIndex , index  } = item;\r\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n    const { label , value  } = controller.getLabelAndValue(index);\r\n    return {\r\n        chart,\r\n        label,\r\n        parsed: controller.getParsed(index),\r\n        raw: chart.data.datasets[datasetIndex].data[index],\r\n        formattedValue: value,\r\n        dataset: controller.getDataset(),\r\n        dataIndex: index,\r\n        datasetIndex,\r\n        element\r\n    };\r\n}\r\n function getTooltipSize(tooltip, options) {\r\n    const ctx = tooltip.chart.ctx;\r\n    const { body , footer , title  } = tooltip;\r\n    const { boxWidth , boxHeight  } = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    const titleFont = toFont(options.titleFont);\r\n    const footerFont = toFont(options.footerFont);\r\n    const titleLineCount = title.length;\r\n    const footerLineCount = footer.length;\r\n    const bodyLineItemCount = body.length;\r\n    const padding = toPadding(options.padding);\r\n    let height = padding.height;\r\n    let width = 0;\r\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\r\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\r\n    if (titleLineCount) {\r\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\r\n    }\r\n    if (combinedBodyLength) {\r\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\r\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\r\n    }\r\n    if (footerLineCount) {\r\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\r\n    }\r\n    let widthPadding = 0;\r\n    const maxLineWidth = function(line) {\r\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n    };\r\n    ctx.save();\r\n    ctx.font = titleFont.string;\r\n    each(tooltip.title, maxLineWidth);\r\n    ctx.font = bodyFont.string;\r\n    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\r\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\r\n    each(body, (bodyItem)=>{\r\n        each(bodyItem.before, maxLineWidth);\r\n        each(bodyItem.lines, maxLineWidth);\r\n        each(bodyItem.after, maxLineWidth);\r\n    });\r\n    widthPadding = 0;\r\n    ctx.font = footerFont.string;\r\n    each(tooltip.footer, maxLineWidth);\r\n    ctx.restore();\r\n    width += padding.width;\r\n    return {\r\n        width,\r\n        height\r\n    };\r\n}\r\nfunction determineYAlign(chart, size) {\r\n    const { y , height  } = size;\r\n    if (y < height / 2) {\r\n        return 'top';\r\n    } else if (y > chart.height - height / 2) {\r\n        return 'bottom';\r\n    }\r\n    return 'center';\r\n}\r\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\r\n    const { x , width  } = size;\r\n    const caret = options.caretSize + options.caretPadding;\r\n    if (xAlign === 'left' && x + width + caret > chart.width) {\r\n        return true;\r\n    }\r\n    if (xAlign === 'right' && x - width - caret < 0) {\r\n        return true;\r\n    }\r\n}\r\nfunction determineXAlign(chart, options, size, yAlign) {\r\n    const { x , width  } = size;\r\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\r\n    let xAlign = 'center';\r\n    if (yAlign === 'center') {\r\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\r\n    } else if (x <= width / 2) {\r\n        xAlign = 'left';\r\n    } else if (x >= chartWidth - width / 2) {\r\n        xAlign = 'right';\r\n    }\r\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\r\n        xAlign = 'center';\r\n    }\r\n    return xAlign;\r\n}\r\n function determineAlignment(chart, options, size) {\r\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\r\n    return {\r\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\r\n        yAlign\r\n    };\r\n}\r\nfunction alignX(size, xAlign) {\r\n    let { x , width  } = size;\r\n    if (xAlign === 'right') {\r\n        x -= width;\r\n    } else if (xAlign === 'center') {\r\n        x -= width / 2;\r\n    }\r\n    return x;\r\n}\r\nfunction alignY(size, yAlign, paddingAndSize) {\r\n    let { y , height  } = size;\r\n    if (yAlign === 'top') {\r\n        y += paddingAndSize;\r\n    } else if (yAlign === 'bottom') {\r\n        y -= height + paddingAndSize;\r\n    } else {\r\n        y -= height / 2;\r\n    }\r\n    return y;\r\n}\r\n function getBackgroundPoint(options, size, alignment, chart) {\r\n    const { caretSize , caretPadding , cornerRadius  } = options;\r\n    const { xAlign , yAlign  } = alignment;\r\n    const paddingAndSize = caretSize + caretPadding;\r\n    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\r\n    let x = alignX(size, xAlign);\r\n    const y = alignY(size, yAlign, paddingAndSize);\r\n    if (yAlign === 'center') {\r\n        if (xAlign === 'left') {\r\n            x += paddingAndSize;\r\n        } else if (xAlign === 'right') {\r\n            x -= paddingAndSize;\r\n        }\r\n    } else if (xAlign === 'left') {\r\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\r\n    } else if (xAlign === 'right') {\r\n        x += Math.max(topRight, bottomRight) + caretSize;\r\n    }\r\n    return {\r\n        x: _limitValue(x, 0, chart.width - size.width),\r\n        y: _limitValue(y, 0, chart.height - size.height)\r\n    };\r\n}\r\nfunction getAlignedX(tooltip, align, options) {\r\n    const padding = toPadding(options.padding);\r\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\r\n}\r\n function getBeforeAfterBodyLines(callback) {\r\n    return pushOrConcat([], splitNewlines(callback));\r\n}\r\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\r\n    return createContext(parent, {\r\n        tooltip,\r\n        tooltipItems,\r\n        type: 'tooltip'\r\n    });\r\n}\r\nfunction overrideCallbacks(callbacks, context) {\r\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\r\n    return override ? callbacks.override(override) : callbacks;\r\n}\r\nconst defaultCallbacks = {\r\n    beforeTitle: noop,\r\n    title (tooltipItems) {\r\n        if (tooltipItems.length > 0) {\r\n            const item = tooltipItems[0];\r\n            const labels = item.chart.data.labels;\r\n            const labelCount = labels ? labels.length : 0;\r\n            if (this && this.options && this.options.mode === 'dataset') {\r\n                return item.dataset.label || '';\r\n            } else if (item.label) {\r\n                return item.label;\r\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\r\n                return labels[item.dataIndex];\r\n            }\r\n        }\r\n        return '';\r\n    },\r\n    afterTitle: noop,\r\n    beforeBody: noop,\r\n    beforeLabel: noop,\r\n    label (tooltipItem) {\r\n        if (this && this.options && this.options.mode === 'dataset') {\r\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\r\n        }\r\n        let label = tooltipItem.dataset.label || '';\r\n        if (label) {\r\n            label += ': ';\r\n        }\r\n        const value = tooltipItem.formattedValue;\r\n        if (!isNullOrUndef(value)) {\r\n            label += value;\r\n        }\r\n        return label;\r\n    },\r\n    labelColor (tooltipItem) {\r\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n        return {\r\n            borderColor: options.borderColor,\r\n            backgroundColor: options.backgroundColor,\r\n            borderWidth: options.borderWidth,\r\n            borderDash: options.borderDash,\r\n            borderDashOffset: options.borderDashOffset,\r\n            borderRadius: 0\r\n        };\r\n    },\r\n    labelTextColor () {\r\n        return this.options.bodyColor;\r\n    },\r\n    labelPointStyle (tooltipItem) {\r\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n        return {\r\n            pointStyle: options.pointStyle,\r\n            rotation: options.rotation\r\n        };\r\n    },\r\n    afterLabel: noop,\r\n    afterBody: noop,\r\n    beforeFooter: noop,\r\n    footer: noop,\r\n    afterFooter: noop\r\n};\r\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\r\n    const result = callbacks[name].call(ctx, arg);\r\n    if (typeof result === 'undefined') {\r\n        return defaultCallbacks[name].call(ctx, arg);\r\n    }\r\n    return result;\r\n}\r\nclass Tooltip extends Element {\r\n static positioners = positioners;\r\n    constructor(config){\r\n        super();\r\n        this.opacity = 0;\r\n        this._active = [];\r\n        this._eventPosition = undefined;\r\n        this._size = undefined;\r\n        this._cachedAnimations = undefined;\r\n        this._tooltipItems = [];\r\n        this.$animations = undefined;\r\n        this.$context = undefined;\r\n        this.chart = config.chart;\r\n        this.options = config.options;\r\n        this.dataPoints = undefined;\r\n        this.title = undefined;\r\n        this.beforeBody = undefined;\r\n        this.body = undefined;\r\n        this.afterBody = undefined;\r\n        this.footer = undefined;\r\n        this.xAlign = undefined;\r\n        this.yAlign = undefined;\r\n        this.x = undefined;\r\n        this.y = undefined;\r\n        this.height = undefined;\r\n        this.width = undefined;\r\n        this.caretX = undefined;\r\n        this.caretY = undefined;\r\n        this.labelColors = undefined;\r\n        this.labelPointStyles = undefined;\r\n        this.labelTextColors = undefined;\r\n    }\r\n    initialize(options) {\r\n        this.options = options;\r\n        this._cachedAnimations = undefined;\r\n        this.$context = undefined;\r\n    }\r\n _resolveAnimations() {\r\n        const cached = this._cachedAnimations;\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n        const chart = this.chart;\r\n        const options = this.options.setContext(this.getContext());\r\n        const opts = options.enabled && chart.options.animation && options.animations;\r\n        const animations = new Animations(this.chart, opts);\r\n        if (opts._cacheable) {\r\n            this._cachedAnimations = Object.freeze(animations);\r\n        }\r\n        return animations;\r\n    }\r\n getContext() {\r\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\r\n    }\r\n    getTitle(context, options) {\r\n        const { callbacks  } = options;\r\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\r\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\r\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\r\n        let lines = [];\r\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n        lines = pushOrConcat(lines, splitNewlines(title));\r\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n        return lines;\r\n    }\r\n    getBeforeBody(tooltipItems, options) {\r\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\r\n    }\r\n    getBody(tooltipItems, options) {\r\n        const { callbacks  } = options;\r\n        const bodyItems = [];\r\n        each(tooltipItems, (context)=>{\r\n            const bodyItem = {\r\n                before: [],\r\n                lines: [],\r\n                after: []\r\n            };\r\n            const scoped = overrideCallbacks(callbacks, context);\r\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\r\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\r\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\r\n            bodyItems.push(bodyItem);\r\n        });\r\n        return bodyItems;\r\n    }\r\n    getAfterBody(tooltipItems, options) {\r\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\r\n    }\r\n    getFooter(tooltipItems, options) {\r\n        const { callbacks  } = options;\r\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\r\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\r\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\r\n        let lines = [];\r\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n        lines = pushOrConcat(lines, splitNewlines(footer));\r\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n        return lines;\r\n    }\r\n _createItems(options) {\r\n        const active = this._active;\r\n        const data = this.chart.data;\r\n        const labelColors = [];\r\n        const labelPointStyles = [];\r\n        const labelTextColors = [];\r\n        let tooltipItems = [];\r\n        let i, len;\r\n        for(i = 0, len = active.length; i < len; ++i){\r\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\r\n        }\r\n        if (options.filter) {\r\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\r\n        }\r\n        if (options.itemSort) {\r\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\r\n        }\r\n        each(tooltipItems, (context)=>{\r\n            const scoped = overrideCallbacks(options.callbacks, context);\r\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\r\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\r\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\r\n        });\r\n        this.labelColors = labelColors;\r\n        this.labelPointStyles = labelPointStyles;\r\n        this.labelTextColors = labelTextColors;\r\n        this.dataPoints = tooltipItems;\r\n        return tooltipItems;\r\n    }\r\n    update(changed, replay) {\r\n        const options = this.options.setContext(this.getContext());\r\n        const active = this._active;\r\n        let properties;\r\n        let tooltipItems = [];\r\n        if (!active.length) {\r\n            if (this.opacity !== 0) {\r\n                properties = {\r\n                    opacity: 0\r\n                };\r\n            }\r\n        } else {\r\n            const position = positioners[options.position].call(this, active, this._eventPosition);\r\n            tooltipItems = this._createItems(options);\r\n            this.title = this.getTitle(tooltipItems, options);\r\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\r\n            this.body = this.getBody(tooltipItems, options);\r\n            this.afterBody = this.getAfterBody(tooltipItems, options);\r\n            this.footer = this.getFooter(tooltipItems, options);\r\n            const size = this._size = getTooltipSize(this, options);\r\n            const positionAndSize = Object.assign({}, position, size);\r\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\r\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\r\n            this.xAlign = alignment.xAlign;\r\n            this.yAlign = alignment.yAlign;\r\n            properties = {\r\n                opacity: 1,\r\n                x: backgroundPoint.x,\r\n                y: backgroundPoint.y,\r\n                width: size.width,\r\n                height: size.height,\r\n                caretX: position.x,\r\n                caretY: position.y\r\n            };\r\n        }\r\n        this._tooltipItems = tooltipItems;\r\n        this.$context = undefined;\r\n        if (properties) {\r\n            this._resolveAnimations().update(this, properties);\r\n        }\r\n        if (changed && options.external) {\r\n            options.external.call(this, {\r\n                chart: this.chart,\r\n                tooltip: this,\r\n                replay\r\n            });\r\n        }\r\n    }\r\n    drawCaret(tooltipPoint, ctx, size, options) {\r\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\r\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n    }\r\n    getCaretPosition(tooltipPoint, size, options) {\r\n        const { xAlign , yAlign  } = this;\r\n        const { caretSize , cornerRadius  } = options;\r\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\r\n        const { x: ptX , y: ptY  } = tooltipPoint;\r\n        const { width , height  } = size;\r\n        let x1, x2, x3, y1, y2, y3;\r\n        if (yAlign === 'center') {\r\n            y2 = ptY + height / 2;\r\n            if (xAlign === 'left') {\r\n                x1 = ptX;\r\n                x2 = x1 - caretSize;\r\n                y1 = y2 + caretSize;\r\n                y3 = y2 - caretSize;\r\n            } else {\r\n                x1 = ptX + width;\r\n                x2 = x1 + caretSize;\r\n                y1 = y2 - caretSize;\r\n                y3 = y2 + caretSize;\r\n            }\r\n            x3 = x1;\r\n        } else {\r\n            if (xAlign === 'left') {\r\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\r\n            } else if (xAlign === 'right') {\r\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\r\n            } else {\r\n                x2 = this.caretX;\r\n            }\r\n            if (yAlign === 'top') {\r\n                y1 = ptY;\r\n                y2 = y1 - caretSize;\r\n                x1 = x2 - caretSize;\r\n                x3 = x2 + caretSize;\r\n            } else {\r\n                y1 = ptY + height;\r\n                y2 = y1 + caretSize;\r\n                x1 = x2 + caretSize;\r\n                x3 = x2 - caretSize;\r\n            }\r\n            y3 = y1;\r\n        }\r\n        return {\r\n            x1,\r\n            x2,\r\n            x3,\r\n            y1,\r\n            y2,\r\n            y3\r\n        };\r\n    }\r\n    drawTitle(pt, ctx, options) {\r\n        const title = this.title;\r\n        const length = title.length;\r\n        let titleFont, titleSpacing, i;\r\n        if (length) {\r\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n            pt.x = getAlignedX(this, options.titleAlign, options);\r\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\r\n            ctx.textBaseline = 'middle';\r\n            titleFont = toFont(options.titleFont);\r\n            titleSpacing = options.titleSpacing;\r\n            ctx.fillStyle = options.titleColor;\r\n            ctx.font = titleFont.string;\r\n            for(i = 0; i < length; ++i){\r\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\r\n                pt.y += titleFont.lineHeight + titleSpacing;\r\n                if (i + 1 === length) {\r\n                    pt.y += options.titleMarginBottom - titleSpacing;\r\n                }\r\n            }\r\n        }\r\n    }\r\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\r\n        const labelColors = this.labelColors[i];\r\n        const labelPointStyle = this.labelPointStyles[i];\r\n        const { boxHeight , boxWidth , boxPadding  } = options;\r\n        const bodyFont = toFont(options.bodyFont);\r\n        const colorX = getAlignedX(this, 'left', options);\r\n        const rtlColorX = rtlHelper.x(colorX);\r\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\r\n        const colorY = pt.y + yOffSet;\r\n        if (options.usePointStyle) {\r\n            const drawOptions = {\r\n                radius: Math.min(boxWidth, boxHeight) / 2,\r\n                pointStyle: labelPointStyle.pointStyle,\r\n                rotation: labelPointStyle.rotation,\r\n                borderWidth: 1\r\n            };\r\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\r\n            const centerY = colorY + boxHeight / 2;\r\n            ctx.strokeStyle = options.multiKeyBackground;\r\n            ctx.fillStyle = options.multiKeyBackground;\r\n            drawPoint(ctx, drawOptions, centerX, centerY);\r\n            ctx.strokeStyle = labelColors.borderColor;\r\n            ctx.fillStyle = labelColors.backgroundColor;\r\n            drawPoint(ctx, drawOptions, centerX, centerY);\r\n        } else {\r\n            ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;\r\n            ctx.strokeStyle = labelColors.borderColor;\r\n            ctx.setLineDash(labelColors.borderDash || []);\r\n            ctx.lineDashOffset = labelColors.borderDashOffset || 0;\r\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\r\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\r\n            const borderRadius = toTRBLCorners(labelColors.borderRadius);\r\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\r\n                ctx.beginPath();\r\n                ctx.fillStyle = options.multiKeyBackground;\r\n                addRoundedRectPath(ctx, {\r\n                    x: outerX,\r\n                    y: colorY,\r\n                    w: boxWidth,\r\n                    h: boxHeight,\r\n                    radius: borderRadius\r\n                });\r\n                ctx.fill();\r\n                ctx.stroke();\r\n                ctx.fillStyle = labelColors.backgroundColor;\r\n                ctx.beginPath();\r\n                addRoundedRectPath(ctx, {\r\n                    x: innerX,\r\n                    y: colorY + 1,\r\n                    w: boxWidth - 2,\r\n                    h: boxHeight - 2,\r\n                    radius: borderRadius\r\n                });\r\n                ctx.fill();\r\n            } else {\r\n                ctx.fillStyle = options.multiKeyBackground;\r\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\r\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\r\n                ctx.fillStyle = labelColors.backgroundColor;\r\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\r\n            }\r\n        }\r\n        ctx.fillStyle = this.labelTextColors[i];\r\n    }\r\n    drawBody(pt, ctx, options) {\r\n        const { body  } = this;\r\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\r\n        const bodyFont = toFont(options.bodyFont);\r\n        let bodyLineHeight = bodyFont.lineHeight;\r\n        let xLinePadding = 0;\r\n        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n        const fillLineOfText = function(line) {\r\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\r\n            pt.y += bodyLineHeight + bodySpacing;\r\n        };\r\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\r\n        ctx.textAlign = bodyAlign;\r\n        ctx.textBaseline = 'middle';\r\n        ctx.font = bodyFont.string;\r\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\r\n        ctx.fillStyle = options.bodyColor;\r\n        each(this.beforeBody, fillLineOfText);\r\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\r\n        for(i = 0, ilen = body.length; i < ilen; ++i){\r\n            bodyItem = body[i];\r\n            textColor = this.labelTextColors[i];\r\n            ctx.fillStyle = textColor;\r\n            each(bodyItem.before, fillLineOfText);\r\n            lines = bodyItem.lines;\r\n            if (displayColors && lines.length) {\r\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\r\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\r\n            }\r\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\r\n                fillLineOfText(lines[j]);\r\n                bodyLineHeight = bodyFont.lineHeight;\r\n            }\r\n            each(bodyItem.after, fillLineOfText);\r\n        }\r\n        xLinePadding = 0;\r\n        bodyLineHeight = bodyFont.lineHeight;\r\n        each(this.afterBody, fillLineOfText);\r\n        pt.y -= bodySpacing;\r\n    }\r\n    drawFooter(pt, ctx, options) {\r\n        const footer = this.footer;\r\n        const length = footer.length;\r\n        let footerFont, i;\r\n        if (length) {\r\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n            pt.x = getAlignedX(this, options.footerAlign, options);\r\n            pt.y += options.footerMarginTop;\r\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\r\n            ctx.textBaseline = 'middle';\r\n            footerFont = toFont(options.footerFont);\r\n            ctx.fillStyle = options.footerColor;\r\n            ctx.font = footerFont.string;\r\n            for(i = 0; i < length; ++i){\r\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\r\n                pt.y += footerFont.lineHeight + options.footerSpacing;\r\n            }\r\n        }\r\n    }\r\n    drawBackground(pt, ctx, tooltipSize, options) {\r\n        const { xAlign , yAlign  } = this;\r\n        const { x , y  } = pt;\r\n        const { width , height  } = tooltipSize;\r\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);\r\n        ctx.fillStyle = options.backgroundColor;\r\n        ctx.strokeStyle = options.borderColor;\r\n        ctx.lineWidth = options.borderWidth;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + topLeft, y);\r\n        if (yAlign === 'top') {\r\n            this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x + width - topRight, y);\r\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\r\n        if (yAlign === 'center' && xAlign === 'right') {\r\n            this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x + width, y + height - bottomRight);\r\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\r\n        if (yAlign === 'bottom') {\r\n            this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x + bottomLeft, y + height);\r\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\r\n        if (yAlign === 'center' && xAlign === 'left') {\r\n            this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x, y + topLeft);\r\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        if (options.borderWidth > 0) {\r\n            ctx.stroke();\r\n        }\r\n    }\r\n _updateAnimationTarget(options) {\r\n        const chart = this.chart;\r\n        const anims = this.$animations;\r\n        const animX = anims && anims.x;\r\n        const animY = anims && anims.y;\r\n        if (animX || animY) {\r\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\r\n            if (!position) {\r\n                return;\r\n            }\r\n            const size = this._size = getTooltipSize(this, options);\r\n            const positionAndSize = Object.assign({}, position, this._size);\r\n            const alignment = determineAlignment(chart, options, positionAndSize);\r\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\r\n            if (animX._to !== point.x || animY._to !== point.y) {\r\n                this.xAlign = alignment.xAlign;\r\n                this.yAlign = alignment.yAlign;\r\n                this.width = size.width;\r\n                this.height = size.height;\r\n                this.caretX = position.x;\r\n                this.caretY = position.y;\r\n                this._resolveAnimations().update(this, point);\r\n            }\r\n        }\r\n    }\r\n _willRender() {\r\n        return !!this.opacity;\r\n    }\r\n    draw(ctx) {\r\n        const options = this.options.setContext(this.getContext());\r\n        let opacity = this.opacity;\r\n        if (!opacity) {\r\n            return;\r\n        }\r\n        this._updateAnimationTarget(options);\r\n        const tooltipSize = {\r\n            width: this.width,\r\n            height: this.height\r\n        };\r\n        const pt = {\r\n            x: this.x,\r\n            y: this.y\r\n        };\r\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\r\n        const padding = toPadding(options.padding);\r\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\r\n        if (options.enabled && hasTooltipContent) {\r\n            ctx.save();\r\n            ctx.globalAlpha = opacity;\r\n            this.drawBackground(pt, ctx, tooltipSize, options);\r\n            overrideTextDirection(ctx, options.textDirection);\r\n            pt.y += padding.top;\r\n            this.drawTitle(pt, ctx, options);\r\n            this.drawBody(pt, ctx, options);\r\n            this.drawFooter(pt, ctx, options);\r\n            restoreTextDirection(ctx, options.textDirection);\r\n            ctx.restore();\r\n        }\r\n    }\r\n getActiveElements() {\r\n        return this._active || [];\r\n    }\r\n setActiveElements(activeElements, eventPosition) {\r\n        const lastActive = this._active;\r\n        const active = activeElements.map(({ datasetIndex , index  })=>{\r\n            const meta = this.chart.getDatasetMeta(datasetIndex);\r\n            if (!meta) {\r\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\r\n            }\r\n            return {\r\n                datasetIndex,\r\n                element: meta.data[index],\r\n                index\r\n            };\r\n        });\r\n        const changed = !_elementsEqual(lastActive, active);\r\n        const positionChanged = this._positionChanged(active, eventPosition);\r\n        if (changed || positionChanged) {\r\n            this._active = active;\r\n            this._eventPosition = eventPosition;\r\n            this._ignoreReplayEvents = true;\r\n            this.update(true);\r\n        }\r\n    }\r\n handleEvent(e, replay, inChartArea = true) {\r\n        if (replay && this._ignoreReplayEvents) {\r\n            return false;\r\n        }\r\n        this._ignoreReplayEvents = false;\r\n        const options = this.options;\r\n        const lastActive = this._active || [];\r\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\r\n        const positionChanged = this._positionChanged(active, e);\r\n        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\r\n        if (changed) {\r\n            this._active = active;\r\n            if (options.enabled || options.external) {\r\n                this._eventPosition = {\r\n                    x: e.x,\r\n                    y: e.y\r\n                };\r\n                this.update(true, replay);\r\n            }\r\n        }\r\n        return changed;\r\n    }\r\n _getActiveElements(e, lastActive, replay, inChartArea) {\r\n        const options = this.options;\r\n        if (e.type === 'mouseout') {\r\n            return [];\r\n        }\r\n        if (!inChartArea) {\r\n            return lastActive;\r\n        }\r\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\r\n        if (options.reverse) {\r\n            active.reverse();\r\n        }\r\n        return active;\r\n    }\r\n _positionChanged(active, e) {\r\n        const { caretX , caretY , options  } = this;\r\n        const position = positioners[options.position].call(this, active, e);\r\n        return position !== false && (caretX !== position.x || caretY !== position.y);\r\n    }\r\n}\r\nvar plugin_tooltip = {\r\n    id: 'tooltip',\r\n    _element: Tooltip,\r\n    positioners,\r\n    afterInit (chart, _args, options) {\r\n        if (options) {\r\n            chart.tooltip = new Tooltip({\r\n                chart,\r\n                options\r\n            });\r\n        }\r\n    },\r\n    beforeUpdate (chart, _args, options) {\r\n        if (chart.tooltip) {\r\n            chart.tooltip.initialize(options);\r\n        }\r\n    },\r\n    reset (chart, _args, options) {\r\n        if (chart.tooltip) {\r\n            chart.tooltip.initialize(options);\r\n        }\r\n    },\r\n    afterDraw (chart) {\r\n        const tooltip = chart.tooltip;\r\n        if (tooltip && tooltip._willRender()) {\r\n            const args = {\r\n                tooltip\r\n            };\r\n            if (chart.notifyPlugins('beforeTooltipDraw', {\r\n                ...args,\r\n                cancelable: true\r\n            }) === false) {\r\n                return;\r\n            }\r\n            tooltip.draw(chart.ctx);\r\n            chart.notifyPlugins('afterTooltipDraw', args);\r\n        }\r\n    },\r\n    afterEvent (chart, args) {\r\n        if (chart.tooltip) {\r\n            const useFinalPosition = args.replay;\r\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\r\n                args.changed = true;\r\n            }\r\n        }\r\n    },\r\n    defaults: {\r\n        enabled: true,\r\n        external: null,\r\n        position: 'average',\r\n        backgroundColor: 'rgba(0,0,0,0.8)',\r\n        titleColor: '#fff',\r\n        titleFont: {\r\n            weight: 'bold'\r\n        },\r\n        titleSpacing: 2,\r\n        titleMarginBottom: 6,\r\n        titleAlign: 'left',\r\n        bodyColor: '#fff',\r\n        bodySpacing: 2,\r\n        bodyFont: {},\r\n        bodyAlign: 'left',\r\n        footerColor: '#fff',\r\n        footerSpacing: 2,\r\n        footerMarginTop: 6,\r\n        footerFont: {\r\n            weight: 'bold'\r\n        },\r\n        footerAlign: 'left',\r\n        padding: 6,\r\n        caretPadding: 2,\r\n        caretSize: 5,\r\n        cornerRadius: 6,\r\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\r\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\r\n        multiKeyBackground: '#fff',\r\n        displayColors: true,\r\n        boxPadding: 0,\r\n        borderColor: 'rgba(0,0,0,0)',\r\n        borderWidth: 0,\r\n        animation: {\r\n            duration: 400,\r\n            easing: 'easeOutQuart'\r\n        },\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: [\r\n                    'x',\r\n                    'y',\r\n                    'width',\r\n                    'height',\r\n                    'caretX',\r\n                    'caretY'\r\n                ]\r\n            },\r\n            opacity: {\r\n                easing: 'linear',\r\n                duration: 200\r\n            }\r\n        },\r\n        callbacks: defaultCallbacks\r\n    },\r\n    defaultRoutes: {\r\n        bodyFont: 'font',\r\n        footerFont: 'font',\r\n        titleFont: 'font'\r\n    },\r\n    descriptors: {\r\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\r\n        _indexable: false,\r\n        callbacks: {\r\n            _scriptable: false,\r\n            _indexable: false\r\n        },\r\n        animation: {\r\n            _fallback: false\r\n        },\r\n        animations: {\r\n            _fallback: 'animation'\r\n        }\r\n    },\r\n    additionalOptionScopes: [\r\n        'interaction'\r\n    ]\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n// Register built-ins\r\nChart.register(controllers, scales, elements, plugins);\r\nChart.helpers = {\r\n    ...helpers\r\n};\r\nChart._adapters = _adapters;\r\nChart.Animation = Animation;\r\nChart.Animations = Animations;\r\nChart.animator = animator;\r\nChart.controllers = registry.controllers.items;\r\nChart.DatasetController = DatasetController;\r\nChart.Element = Element;\r\nChart.elements = elements;\r\nChart.Interaction = Interaction;\r\nChart.layouts = layouts;\r\nChart.platforms = platforms;\r\nChart.Scale = Scale;\r\nChart.Ticks = Ticks;\r\n// Compatibility with ESM extensions\r\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\r\nChart.Chart = Chart;\r\nif (typeof window !== 'undefined') {\r\n    window.Chart = Chart;\r\n}\r\n\r\nreturn Chart;\r\n\r\n}));"],"names":["global","factory","this","plugins","Object","freeze","__proto__","Colors","plugin_colors","Decimation","plugin_decimation","Filler","index","Legend","plugin_legend","SubTitle","plugin_subtitle","Title","plugin_title","Tooltip","plugin_tooltip","noop","uid","id","isNullOrUndef","value","isArray","Array","type","prototype","toString","call","slice","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","dimension","endsWith","parseFloat","toDimension","callback","fn","args","thisArg","apply","each","loopable","reverse","i","len","keys","length","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","clone$1","source","map","target","create","klen","k","isValidKey","key","indexOf","_merger","options","tval","sval","merge","sources","merger","current","mergeIf","_mergerIf","hasOwnProperty","keyResolvers","v","x","o","y","_splitKey","parts","split","tmp","part","push","resolveObjectKey","obj","resolver","_getKeyResolver","_capitalize","str","charAt","toUpperCase","defined","isFunction","setsEqual","a","b","size","item","has","_isClickEvent","e","PI","Math","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","range","roundedRange","round","niceRange","pow","floor","fraction","_factorize","result","sqrt","sort","pop","isNumber","n","isNaN","almostWhole","rounded","_setMinAndMaxByKey","array","property","min","max","toRadians","degrees","toDegrees","radians","_decimalPlaces","p","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","s","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","_isBetween","_lookup","table","cmp","mid","hi","lo","_lookupByKey","last","ti","_rlookupByKey","_filterBetween","values","arrayEvents","listenArrayEvents","listener","_chartjs","listeners","defineProperty","configurable","enumerable","forEach","method","base","res","object","unlistenArrayEvents","stub","splice","_arrayUnique","items","set","Set","add","from","requestAnimFrame","window","requestAnimationFrame","throttled","argsToUse","ticking","debounce","delay","timeout","clearTimeout","setTimeout","_toLeftRightCenter","align","_alignStartEnd","_textX","left","right","rtl","_getStartAndCountOfVisiblePoints","meta","points","animationsDisabled","pointCount","count","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","assign","animator","constructor","_request","_charts","Map","_running","_lastDate","undefined","_notify","chart","anims","date","callbacks","numSteps","duration","initial","currentStep","_refresh","_update","Date","now","remaining","running","draw","_active","_total","tick","_getAnims","charts","get","complete","progress","listen","event","cb","reduce","acc","cur","_duration","stop","cancel","remove","delete","lim","l","h","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","c","d","f","hex","h1","h2","eq","hexString","r","g","isShort","alpha","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","w","rgb","rgb2hsl","hueValue","calln","hsl2rgb","hue","hueParse","m","exec","p1","p2","hwb2rgb","hsv2rgb","map$2","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","nameParse","unpacked","tkeys","j","ok","nk","replace","parseInt","unpack","transparent","toLowerCase","RGB_RE","to","modHSL","ratio","clone","proto","fromObject","input","functionParse","rgbParse","Color","ret","_rgb","_valid","valid","rgbString","hslString","mix","color","weight","c1","c2","w2","w1","interpolate","t","rgb1","rgb2","interpolate$1","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","isPatternOrGradient","getHoverColor","numbers","colors","intlCache","formatNumber","num","locale","cacheKey","JSON","stringify","formatter","Intl","NumberFormat","getNumberFormat","format","formatters","numeric","tickValue","ticks","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","includes","Ticks","overrides","descriptors","getScope$1","node","root","scope","defaults","_descriptors","_appliers","animation","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","local","appliers","_scriptable","startsWith","_indexable","_fallback","easing","loop","properties","active","resize","show","animations","visible","hide","autoPadding","padding","top","bottom","display","offset","beginAtZero","bounds","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","_isDomSupported","document","_getParentNode","domNode","parent","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","ownerDocument","defaultView","getStyle","el","getPropertyValue","positions","getPositionedStyle","styles","suffix","pos","height","getRelativePosition","canvas","currentDevicePixelRatio","borderBox","boxSizing","paddings","borders","box","touches","offsetX","offsetY","shadowRoot","useOffsetPos","rect","getBoundingClientRect","clientX","clientY","getCanvasPosition","xOffset","yOffset","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","maxWidth","maxHeight","containerSize","container","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","getContainerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","matches","match","toFontString","_measureText","data","gc","longest","string","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","halfWidth","clearCanvas","getContext","resetTransform","clearRect","drawPoint","drawPointLegend","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","fill","borderWidth","stroke","_isPointInArea","point","area","margin","clipArea","clip","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","renderText","opts","lines","strokeWidth","strokeColor","line","setRenderOpts","backdrop","drawBackdrop","strokeStyle","strokeText","fillText","decorateText","translation","fillStyle","textAlign","textBaseline","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","decorationWidth","oldColor","fillRect","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","_createResolver","scopes","prefixes","rootScopes","fallback","getTarget","_resolve","Symbol","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","prop","_keys","_cached","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","proxy","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","isScriptable","Error","join","needsSubResolver","createSubResolver","_resolveScriptable","isIndexable","arr","filter","_resolveArray","_resolveWithContext","allKeys","scriptable","indexable","_allKeys","readKey","prefix","resolve","resolveFallback","getScope","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","parsed","parse","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","next","d01","d12","s01","s12","fa","fb","monotoneAdjust","deltaK","mK","pointsLen","alphaK","betaK","tauK","squaredMagnitude","pointCurrent","pointAfter","monotoneCompute","valueAxis","pointBefore","iPixel","vPixel","splineCurveMonotone","slopeDelta","capControlPoint","pt","_updateBezierControlPoints","controlPoints","spanGaps","cubicInterpolationMode","prev","tension","capBezierPoints","inArea","inAreaPrev","inAreaNext","atEdge","elasticIn","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","LINE_HEIGHT","FONT_STYLE","toLineHeight","_readValueToProps","props","objProps","read","toTRBL","toTRBLCorners","toPadding","toFont","console","warn","inputs","info","cacheable","_addGrace","minmax","change","keepZero","createContext","parentContext","getRtlAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","_boundSegment","segment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","_boundSegments","segments","sub","_computeSegments","segmentOptions","_loop","findStartAndEnd","splitByStyles","solidSegments","_fullLoop","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","doSplitByStyles","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","helpers","easingEffects","_deprecated","fontString","pixelSize","fontStyle","fontFamily","binarySearch","metaset","controller","_cachedMeta","lookupMethod","_reversePixels","_sharedOptions","getRange","evaluateInteractionItems","position","handler","metasets","getSortedVisibleDatasetMetas","getIntersectItems","useFinalPosition","isPointInArea","chartArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","center","getCenterPoint","getNearestItems","startAngle","endAngle","getProps","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","dataset","getDatasetMeta","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","layouts","params","stacks","wrap","stack","stackWeight","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","factor","horizontal","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","other","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","update","setBoxDims","placeBoxes","userPadding","height1","width1","addBox","_layers","z","removeBox","layoutItem","configure","minPadding","layoutBoxes","isHorizontal","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","concat","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","total","updatePos","handleMaxPadding","BasePlatform","acquireContext","releaseContext","isAttached","updateConfig","config","BasicPlatform","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","entries","trigger","entry","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","native","fromNativeEvent","addListener","DomPlatform","renderHeight","getAttribute","renderWidth","displayWidth","displayHeight","initCanvas","removeAttribute","setAttribute","proxies","$proxies","attach","detach","isConnected","_detectPlatform","OffscreenCanvas","platforms","interpolators","boolean","c0","number","Animation","cfg","currentValue","_fn","_easing","_start","_target","_prop","_from","_to","_promises","elapsed","wait","promises","Promise","rej","resolved","Animations","_properties","animationOptions","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","$shared","$animations","resolveTargetOptions","_createAnimations","anim","all","awaitAll","then","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","_getSortedDatasetMetas","applyStack","dsIndex","singleMode","otherValue","isStacked","stacked","getOrCreateStack","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","_stacks","iAxis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","_visualValues","getFirstScaleId","shift","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","_cachedDataOpts","getMeta","_type","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","getScaleForId","rScale","scaleID","_getOtherScale","reset","_destroy","_dataCheck","adata","convertObjectDataToArray","isExtensible","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","parsedValue","NaN","getMinMax","canStack","otherScale","hidden","createStack","NEGATIVE_INFINITY","otherMin","otherMax","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","toClip","defaultClip","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","transition","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","Element","tooltipPosition","hasValue","final","tickOpts","determinedMaxTicks","_tickSize","maxScale","_length","maxChart","_maxLength","determineMaxTicks","ticksLimit","maxTicksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","first","newTicks","spacing","ceil","skipMajors","evenMajorSpacing","diff","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","edge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","_startPixel","_endPixel","lineValue","getPixelForTick","getTickMarkLength","getTitleHeight","titleAlign","reverseAlign","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","startPixel","endPixel","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","tickFont","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","idx","getValueForPixel","getPixelForDecimal","decimal","getDecimalForPixel","getBasePixel","getBaseValue","createTickContext","optionTicks","rot","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","positionAxisID1","value1","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","ret1","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","getLineWidthForValue","findIndex","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","titleX","titleY","titleArgs","tz","gz","bz","axisID","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","register","parentScope","isIChartComponent","itemDefaults","defaultRoutes","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","unregister","registry","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","component","camelMethod","PluginService","_init","notify","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","i1","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","some","pluginScopeKeys","getIndexAxis","datasetDefaults","determineAxis","scaleOptions","initOptions","chartDefaults","configScales","chartIndexAxis","scaleConf","error","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","mergeScaleConfig","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","Chart","invalidatePlugins","userConfig","initialCanvas","existingChart","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","newControllers","order","isDatasetVisible","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","ilen1","_updateDataset","layers","_drawDatasets","_drawDataset","useClip","getDatasetArea","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","_ref4","pluginId","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","lastEvent","determineLastEvent","abstract","DateAdapterBase","members","formats","startOf","endOf","_adapters","_date","computeMinSampleSize","$bar","visibleMetas","getAllScaleValues","curr","updateMinAndPrev","parseValue","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","borderSkipped","borderProps","enableBorderRadius","parseEdge","orig","v2","startEnd","setInflateAmount","inflateAmount","BarController","iAxisKey","vAxisKey","bars","ruler","_getRuler","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","_getStacks","grouped","skipNull","_getStackCount","_getStackIndex","pixels","barThickness","stackCount","categoryPercentage","barPercentage","baseValue","minBarLength","actualBase","floating","barSign","halfGrid","maxBarThickness","Infinity","percent","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","_index_","_value_","BubbleController","super","DoughnutController","innerRadius","outerRadius","getter","_getRotation","_getCircumference","circumference","_getRotationExtents","arcs","getMaxBorderWidth","getMaxOffset","maxSize","cutout","chartWeight","_getRingWeight","ratioX","ratioY","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","calculateTotal","_getRingWeightOffset","_circumference","animateRotate","calculateCircumference","animationOpts","centerX","centerY","animateScale","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","legend","generateLabels","fontColor","legendItem","LineController","_decimated","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","updateControlPoints","PolarAreaController","bind","_updateRadius","cutoutPercentage","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","angleLines","circular","pointLabels","PieController","RadarController","pointPosition","getPointPositionForValue","ScatterController","parseBorderRadius$1","angleDelta","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","pixelMargin","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","pCenter1","innerMidAdjustedAngle","pCenter2","p8","pCenter3","outerStartX","outerStartY","outerEndX","outerEndY","fullCircles","inner","lineJoin","angleMargin","clipArc","ArcElement","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","setStyle","lineCap","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","path","_path","strokePathWithCache","segmentMethod","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","_interpolate","_getInterpolationMethod","interpolated","inRange$1","hitRadius","PointElement","mouseX","mouseY","inXRange","inYRange","hoverRadius","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","BarElement","addRectPath","findOrAddLabel","addedLabels","unshift","addIfString","lastIndexOf","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","relativeLabelSize","minSpacing","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","maxTicks","stepSize","computeTickLimit","generationOptions","dataRange","precision","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks$1","LinearScale","log10Floor","changeExponent","isMajor","tickVal","steps","rangeExp","rangeStep","generateTicks","minExp","exp","startExp","lastTick","LogarithmicScale","_zero","getTickBackdropHeight","determineLimits","fitWithPointLabels","_padding","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","textSize","updateLimits","setCenterPoint","_pointLabelItems","extra","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","buildPointLabelItems","hLimits","vLimits","pathRadiusLine","labelCount","RadialLinearScale","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","getBasePosition","getPointLabelPosition","backdropLeft","backdropTop","backdropWidth","backdropHeight","drawPointLabels","gridLineOpts","drawRadiusLine","animate","INTERVALS","millisecond","common","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","time","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","_unit","_majorUnit","_offsets","_normalized","adapters","displayFormats","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","forceOverride","_args","chartOptions","colorizer","cleanDecimatedDataset","cleanDecimatedData","algorithm","beforeElementsUpdate","xAxis","decimated","getStartAndCountOfVisiblePointsSimplified","threshold","samples","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_ref8","_pointsFromSegments","_shouldApplyFill","_resolveTarget","propagate","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","below","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","above","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","$filler","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","adjustHitBoxes","rtlHelper","hitbox","hitbox1","_draw","defaultColor","halfFontSize","cursor","textDirection","lineDash","drawOptions","SQRT2","yBoxTop","xBoxLeft","drawLegendBox","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","sameItem","_element","afterEvent","ci","useBorderRadius","_drawArgs","fontOpts","titleBlock","createTitle","WeakMap","positioners","average","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","createTooltipItem","formattedValue","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","beforeTitle","tooltipItems","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","_ref9","positionChanged","_positionChanged","_ignoreReplayEvents","afterInit","afterDraw","exports","module","define","amd","globalThis","self"],"mappings":"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"}