{"version":3,"file":"changechecker.min.js","sources":["../src/changechecker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * This module provides change detection to forms, allowing a browser to warn the user before navigating away if changes\r\n * have been made.\r\n *\r\n * Two flags are stored for each form:\r\n * * a 'dirty' flag; and\r\n * * a 'submitted' flag.\r\n *\r\n * When the page is unloaded each watched form is checked. If the 'dirty' flag is set for any form, and the 'submitted'\r\n * flag is not set for any form, then a warning is shown.\r\n *\r\n * The 'dirty' flag is set when any form element is modified within a watched form.\r\n * The flag can also be set programatically. This may be required for custom form elements.\r\n *\r\n * It is not possible to customise the warning message in any modern browser.\r\n *\r\n * Please note that some browsers have controls on when these alerts may or may not be shown.\r\n * See {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload} for browser-specific\r\n * notes and references.\r\n *\r\n * @module     core_form/changechecker\r\n * @copyright  2021 Andrew Lyons <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n * @example <caption>Usage where the FormElement is already held</caption>\r\n *\r\n * import {watchForm} from 'core_form/changechecker';\r\n *\r\n * // Fetch the form element somehow.\r\n * watchForm(formElement);\r\n *\r\n * @example <caption>Usage from the child of a form - i.e. an input, button, div, etc.</caption>\r\n *\r\n * import {watchForm} from 'core_form/changechecker';\r\n *\r\n * // Watch the form by using a child of it.\r\n * watchForm(document.querySelector('input[data-foo=\"bar\"]'););\r\n *\r\n * @example <caption>Usage from within a template</caption>\r\n * <form id=\"mod_example-entry-{{uniqid}}\" ...>\r\n *   <!--\r\n *\r\n *   -->\r\n * </form>\r\n * {{#js}}\r\n * require(['core_form/changechecker'], function(changeChecker) {\r\n *     watchFormById('mod_example-entry-{{uniqid}}');\r\n * });\r\n * {{/js}}\r\n */\r\n\r\nimport {eventTypes} from 'core_editor/events';\r\nimport {get_string as getString} from 'core/str';\r\n\r\n/**\r\n * @property {Bool} initialised Whether the change checker has been initialised\r\n * @private\r\n */\r\nlet initialised = false;\r\n\r\n/**\r\n * @property {String} warningString The warning string to show on form change failure\r\n * @private\r\n */\r\nlet warningString;\r\n\r\n/**\r\n * @property {Array} watchedForms The list of watched forms\r\n * @private\r\n */\r\nlet watchedForms = [];\r\n\r\n/**\r\n * @property {Bool} formChangeCheckerDisabled Whether the form change checker has been actively disabled\r\n * @private\r\n */\r\nlet formChangeCheckerDisabled = false;\r\n\r\n/**\r\n * Get the nearest form element from a child element.\r\n *\r\n * @param {HTMLElement} formChild\r\n * @returns {HTMLFormElement|null}\r\n * @private\r\n */\r\nconst getFormFromChild = formChild => formChild.closest('form');\r\n\r\n/**\r\n * Watch the specified form for changes.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n */\r\nexport const watchForm = formNode => {\r\n    // Normalise the formNode.\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         // No form found.\r\n         return;\r\n    }\r\n\r\n    if (isWatchingForm(formNode)) {\r\n        // This form is already watched.\r\n        return;\r\n    }\r\n\r\n    watchedForms.push(formNode);\r\n};\r\n\r\n/**\r\n * Stop watching the specified form for changes.\r\n *\r\n * If the form was not watched, then no change is made.\r\n *\r\n * A child of the form may be passed instead.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n * @example <caption>Stop watching a form for changes</caption>\r\n * import {unWatchForm} from 'core_form/changechecker';\r\n *\r\n * // ...\r\n * document.addEventListener('click', e => {\r\n *     if (e.target.closest('[data-action=\"changePage\"]')) {\r\n *         unWatchForm(e.target);\r\n *     }\r\n * });\r\n */\r\nexport const unWatchForm = formNode => {\r\n    watchedForms = watchedForms.filter(watchedForm => !!watchedForm.contains(formNode));\r\n};\r\n\r\n/**\r\n * Reset the 'dirty' flag for all watched forms.\r\n *\r\n * If a form was previously marked as 'dirty', then this flag will be cleared and when the page is unloaded no warning\r\n * will be shown.\r\n *\r\n * @method\r\n */\r\nexport const resetAllFormDirtyStates = () => {\r\n    watchedForms.forEach(watchedForm => {\r\n        watchedForm.dataset.formSubmitted = \"false\";\r\n        watchedForm.dataset.formDirty = \"false\";\r\n    });\r\n};\r\n\r\n/**\r\n * Reset the 'dirty' flag of the specified form.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n */\r\nexport const resetFormDirtyState = formNode => {\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         return;\r\n    }\r\n\r\n    formNode.dataset.formSubmitted = \"false\";\r\n    formNode.dataset.formDirty = \"false\";\r\n};\r\n\r\n/**\r\n * Mark all forms as dirty.\r\n *\r\n * This function is only for backwards-compliance with the old YUI module and should not be used in any other situation.\r\n * It will be removed in Moodle 4.4.\r\n *\r\n * @method\r\n */\r\nexport const markAllFormsAsDirty = () => {\r\n    watchedForms.forEach(watchedForm => {\r\n        watchedForm.dataset.formDirty = \"true\";\r\n    });\r\n};\r\n\r\n/**\r\n * Mark a specific form as dirty.\r\n *\r\n * This behaviour may be required for custom form elements which are not caught by the standard change listeners.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n */\r\nexport const markFormAsDirty = formNode => {\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         return;\r\n    }\r\n\r\n    // Mark it as dirty.\r\n    formNode.dataset.formDirty = \"true\";\r\n};\r\n\r\n/**\r\n * Actively disable the form change checker.\r\n *\r\n * Please note that it cannot be re-enabled once disabled.\r\n *\r\n * @method\r\n */\r\nexport const disableAllChecks = () => {\r\n    formChangeCheckerDisabled = true;\r\n};\r\n\r\n/**\r\n * Check whether any watched from is dirty.\r\n *\r\n * @method\r\n * @returns {Bool}\r\n */\r\nexport const isAnyWatchedFormDirty = () => {\r\n    if (formChangeCheckerDisabled) {\r\n        // The form change checker is disabled.\r\n        return false;\r\n    }\r\n\r\n    const hasSubmittedForm = watchedForms.some(watchedForm => watchedForm.dataset.formSubmitted === \"true\");\r\n    if (hasSubmittedForm) {\r\n        // Do not warn about submitted forms, ever.\r\n        return false;\r\n    }\r\n\r\n    const hasDirtyForm = watchedForms.some(watchedForm => {\r\n        if (!watchedForm.isConnected) {\r\n            // The watched form is not connected to the DOM.\r\n            return false;\r\n        }\r\n\r\n        if (watchedForm.dataset.formDirty === \"true\") {\r\n            // The form has been marked as dirty.\r\n            return true;\r\n        }\r\n\r\n        // Elements currently holding focus will not have triggered change detection.\r\n        // Check whether the value matches the original value upon form load.\r\n        if (document.activeElement && document.activeElement.dataset.propertyIsEnumerable('initialValue')) {\r\n            const isActiveElementWatched = isWatchingForm(document.activeElement)\r\n                && !shouldIgnoreChangesForNode(document.activeElement);\r\n            const hasValueChanged = document.activeElement.dataset.initialValue !== document.activeElement.value;\r\n\r\n            if (isActiveElementWatched && hasValueChanged) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    });\r\n\r\n    if (hasDirtyForm) {\r\n        // At least one form is dirty.\r\n        return true;\r\n    }\r\n\r\n    // Handle TinyMCE editor instances.\r\n    // TinyMCE forms may not have been initialised at the time that startWatching is called.\r\n    // Check whether any tinyMCE editor is dirty.\r\n    if (typeof window.tinyMCE !== 'undefined' && window.tinyMCE.editors) {\r\n        if (window.tinyMCE.editors.some(editor => editor.isDirty())) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // No dirty forms detected.\r\n    return false;\r\n};\r\n\r\n/**\r\n * Get the watched form for the specified target.\r\n *\r\n * @method\r\n * @param   {HTMLNode} target\r\n * @returns {HTMLFormElement}\r\n * @private\r\n */\r\nconst getFormForNode = target => watchedForms.find(watchedForm => watchedForm.contains(target));\r\n\r\n/**\r\n * Whether the specified target is a watched form.\r\n *\r\n * @method\r\n * @param   {HTMLNode} target\r\n * @returns {Bool}\r\n * @private\r\n */\r\nconst isWatchingForm = target => watchedForms.some(watchedForm => watchedForm.contains(target));\r\n\r\n/**\r\n * Whether the specified target should ignore changes or not.\r\n *\r\n * @method\r\n * @param   {HTMLNode} target\r\n * @returns {Bool}\r\n * @private\r\n */\r\nconst shouldIgnoreChangesForNode = target => !!target.closest('.ignoredirty');\r\n\r\n/**\r\n * Mark a form as changed.\r\n *\r\n * @method\r\n * @param   {HTMLElement} changedNode An element in the form which was changed\r\n */\r\nexport const markFormChangedFromNode = changedNode => {\r\n    if (changedNode.dataset.formChangeCheckerOverride) {\r\n        // Changes to this form node disable the form change checker entirely.\r\n        // This is intended for select fields which cause an immediate redirect.\r\n        disableAllChecks();\r\n        return;\r\n    }\r\n\r\n    if (!isWatchingForm(changedNode)) {\r\n        return;\r\n    }\r\n\r\n    if (shouldIgnoreChangesForNode(changedNode)) {\r\n        return;\r\n    }\r\n\r\n    // Mark the form as dirty.\r\n    const formNode = getFormForNode(changedNode);\r\n    formNode.dataset.formDirty = \"true\";\r\n};\r\n\r\n/**\r\n * Mark a form as submitted.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode An element in the form to mark as submitted\r\n */\r\nexport const markFormSubmitted = formNode => {\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         return;\r\n    }\r\n\r\n    formNode.dataset.formSubmitted = \"true\";\r\n};\r\n\r\n/**\r\n * Mark all forms as submitted.\r\n *\r\n * This function is only for backwards-compliance with the old YUI module and should not be used in any other situation.\r\n * It will be removed in Moodle 4.4.\r\n *\r\n * @method\r\n */\r\nexport const markAllFormsSubmitted = () => {\r\n    watchedForms.forEach(watchedForm => markFormSubmitted(watchedForm));\r\n};\r\n\r\n/**\r\n * Handle the beforeunload event.\r\n *\r\n * @method\r\n * @param   {Event} e\r\n * @returns {string|null}\r\n * @private\r\n */\r\nconst beforeUnloadHandler = e => {\r\n    // Please note: The use of Promises in this function is forbidden.\r\n    // This is an event handler and _cannot_ be asynchronous.\r\n    let warnBeforeUnload = isAnyWatchedFormDirty() && !M.cfg.behatsiterunning;\r\n    if (warnBeforeUnload) {\r\n        // According to the specification, to show the confirmation dialog an event handler should call preventDefault()\r\n        // on the event.\r\n        e.preventDefault();\r\n\r\n        // However note that not all browsers support this method, and some instead require the event handler to\r\n        // implement one of two legacy methods:\r\n        // * assigning a string to the event's returnValue property; and\r\n        // * returning a string from the event handler.\r\n\r\n        // Assigning a string to the event's returnValue property.\r\n        e.returnValue = warningString;\r\n\r\n        // Returning a string from the event handler.\r\n        return e.returnValue;\r\n    }\r\n\r\n    // Attaching an event handler/listener to window or document's beforeunload event prevents browsers from using\r\n    // in-memory page navigation caches, like Firefox's Back-Forward cache or WebKit's Page Cache.\r\n    // Remove the handler.\r\n    window.removeEventListener('beforeunload', beforeUnloadHandler);\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Start watching for form changes.\r\n *\r\n * This function is called on module load, and should not normally be called.\r\n *\r\n * @method\r\n * @protected\r\n */\r\nexport const startWatching = () => {\r\n    if (initialised) {\r\n        return;\r\n    }\r\n\r\n    // Add legacy support to provide b/c for the old YUI version.\r\n    addLegacyFunctions();\r\n\r\n    document.addEventListener('change', e => {\r\n        if (!isWatchingForm(e.target)) {\r\n            return;\r\n        }\r\n\r\n        markFormChangedFromNode(e.target);\r\n    });\r\n\r\n    document.addEventListener('click', e => {\r\n        const ignoredButton = e.target.closest('[data-formchangechecker-ignore-submit]');\r\n        if (!ignoredButton) {\r\n            return;\r\n        }\r\n\r\n        const ownerForm = getFormFromChild(e.target);\r\n        if (ownerForm) {\r\n            ownerForm.dataset.ignoreSubmission = \"true\";\r\n        }\r\n    });\r\n\r\n    document.addEventListener('focusin', e => {\r\n        if (e.target.matches('input, textarea, select')) {\r\n            if (e.target.dataset.propertyIsEnumerable('initialValue')) {\r\n                // The initial value has already been set.\r\n                return;\r\n            }\r\n            e.target.dataset.initialValue = e.target.value;\r\n        }\r\n    });\r\n\r\n    document.addEventListener('submit', e => {\r\n        const formNode = getFormFromChild(e.target);\r\n        if (!formNode) {\r\n            // Weird, but watch for this anyway.\r\n            return;\r\n        }\r\n\r\n        if (formNode.dataset.ignoreSubmission) {\r\n            // This form was submitted by a button which requested that the form checked should not mark it as submitted.\r\n            formNode.dataset.ignoreSubmission = \"false\";\r\n            return;\r\n        }\r\n\r\n        markFormSubmitted(formNode);\r\n    });\r\n\r\n    document.addEventListener(eventTypes.editorContentRestored, e => {\r\n        if (e.target != document) {\r\n            resetFormDirtyState(e.target);\r\n        } else {\r\n            resetAllFormDirtyStates();\r\n        }\r\n    });\r\n\r\n    getString('changesmadereallygoaway', 'moodle')\r\n    .then(changesMadeString => {\r\n        warningString = changesMadeString;\r\n        return;\r\n    })\r\n    .catch();\r\n\r\n    window.addEventListener('beforeunload', beforeUnloadHandler);\r\n};\r\n\r\n/**\r\n * Add legacy functions for backwards compatability.\r\n *\r\n * @method\r\n * @private\r\n */\r\nconst addLegacyFunctions = () => {\r\n    // Create a curried function to log use of the old function and provide detail on its replacement.\r\n    const getLoggedLegacyFallback = (oldFunctionName, newFunctionName, newFunction) => (...args) => {\r\n        window.console.warn(\r\n            `The moodle-core-formchangechecker has been deprecated ` +\r\n            `and replaced with core_form/changechecker. ` +\r\n            `The ${oldFunctionName} function has been replaced with ${newFunctionName}.`\r\n        );\r\n        newFunction(...args);\r\n    };\r\n\r\n    /* eslint-disable */\r\n    window.M.core_formchangechecker = {\r\n        init: getLoggedLegacyFallback('init', 'watchFormById', watchFormById),\r\n        reset_form_dirty_state: getLoggedLegacyFallback('reset_form_dirty_state', 'resetFormDirtyState', resetAllFormDirtyStates),\r\n        set_form_changed: getLoggedLegacyFallback('set_form_changed', 'markFormAsDirty', markAllFormsAsDirty),\r\n        set_form_submitted: getLoggedLegacyFallback('set_form_submitted', 'markFormSubmitted', markAllFormsSubmitted),\r\n    };\r\n    /* eslint-enable */\r\n};\r\n\r\n/**\r\n * Watch the form matching the specified ID for changes.\r\n *\r\n * @method\r\n * @param   {String} formId\r\n */\r\nexport const watchFormById = formId => {\r\n    watchForm(document.getElementById(formId));\r\n};\r\n\r\n/**\r\n * Reset the dirty state of the form matching the specified ID..\r\n *\r\n * @method\r\n * @param   {String} formId\r\n */\r\nexport const resetFormDirtyStateById = formId => {\r\n    resetFormDirtyState(document.getElementById(formId));\r\n};\r\n\r\n/**\r\n * Mark the form matching the specified ID as dirty.\r\n *\r\n * @method\r\n * @param   {String} formId\r\n */\r\nexport const markFormAsDirtyById = formId => {\r\n    markFormAsDirty(document.getElementById(formId));\r\n};\r\n\r\n// Configure all event listeners.\r\nstartWatching();\r\n"],"names":["warningString","watchedForms","formChangeCheckerDisabled","getFormFromChild","formChild","closest","watchForm","formNode","isWatchingForm","push","filter","watchedForm","contains","resetAllFormDirtyStates","forEach","dataset","formSubmitted","formDirty","resetFormDirtyState","markAllFormsAsDirty","markFormAsDirty","disableAllChecks","isAnyWatchedFormDirty","some","isConnected","document","activeElement","propertyIsEnumerable","isActiveElementWatched","shouldIgnoreChangesForNode","hasValueChanged","initialValue","value","window","tinyMCE","editors","editor","isDirty","target","markFormChangedFromNode","changedNode","formChangeCheckerOverride","find","markFormSubmitted","markAllFormsSubmitted","beforeUnloadHandler","e","M","cfg","behatsiterunning","preventDefault","returnValue","removeEventListener","startWatching","addLegacyFunctions","addEventListener","ownerForm","ignoreSubmission","matches","eventTypes","editorContentRestored","then","changesMadeString","catch","getLoggedLegacyFallback","oldFunctionName","newFunctionName","newFunction","console","warn","core_formchangechecker","init","watchFormById","reset_form_dirty_state","set_form_changed","set_form_submitted","formId","getElementById"],"mappings":"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"}