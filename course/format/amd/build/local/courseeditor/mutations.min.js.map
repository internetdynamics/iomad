{"version":3,"file":"mutations.min.js","sources":["../../../src/local/courseeditor/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport ajax from 'core/ajax';\r\n\r\n/**\r\n * Default mutation manager\r\n *\r\n * @module     core_courseformat/local/courseeditor/mutations\r\n * @class     core_courseformat/local/courseeditor/mutations\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nexport default class {\r\n\r\n    // All course editor mutations for Moodle 4.0 will be located in this file.\r\n\r\n    /**\r\n     * Private method to call core_courseformat_update_course webservice.\r\n     *\r\n     * @method _callEditWebservice\r\n     * @param {string} action\r\n     * @param {number} courseId\r\n     * @param {array} ids\r\n     * @param {number} targetSectionId optional target section id (for moving actions)\r\n     * @param {number} targetCmId optional target cm id (for moving actions)\r\n     */\r\n    async _callEditWebservice(action, courseId, ids, targetSectionId, targetCmId) {\r\n        const args = {\r\n            action,\r\n            courseid: courseId,\r\n            ids,\r\n        };\r\n        if (targetSectionId) {\r\n            args.targetsectionid = targetSectionId;\r\n        }\r\n        if (targetCmId) {\r\n            args.targetcmid = targetCmId;\r\n        }\r\n        let ajaxresult = await ajax.call([{\r\n            methodname: 'core_courseformat_update_course',\r\n            args,\r\n        }])[0];\r\n        return JSON.parse(ajaxresult);\r\n    }\r\n\r\n    /**\r\n     * Execute a basic section state action.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} action the action name\r\n     * @param {array} sectionIds the section ids\r\n     * @param {number} targetSectionId optional target section id (for moving actions)\r\n     * @param {number} targetCmId optional target cm id (for moving actions)\r\n     */\r\n    async _sectionBasicAction(stateManager, action, sectionIds, targetSectionId, targetCmId) {\r\n        const course = stateManager.get('course');\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const updates = await this._callEditWebservice(\r\n            action,\r\n            course.id,\r\n            sectionIds,\r\n            targetSectionId,\r\n            targetCmId\r\n        );\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Execute a basic course module state action.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} action the action name\r\n     * @param {array} cmIds the cm ids\r\n     * @param {number} targetSectionId optional target section id (for moving actions)\r\n     * @param {number} targetCmId optional target cm id (for moving actions)\r\n     */\r\n    async _cmBasicAction(stateManager, action, cmIds, targetSectionId, targetCmId) {\r\n        const course = stateManager.get('course');\r\n        this.cmLock(stateManager, cmIds, true);\r\n        const updates = await this._callEditWebservice(\r\n            action,\r\n            course.id,\r\n            cmIds,\r\n            targetSectionId,\r\n            targetCmId\r\n        );\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.cmLock(stateManager, cmIds, false);\r\n    }\r\n\r\n    /**\r\n     * Mutation module initialize.\r\n     *\r\n     * The reactive instance will execute this method when addMutations or setMutation is invoked.\r\n     *\r\n     * @param {StateManager} stateManager the state manager\r\n     */\r\n    init(stateManager) {\r\n        // Add a method to prepare the fields when some update is comming from the server.\r\n        stateManager.addUpdateTypes({\r\n            prepareFields: this._prepareFields,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add default values to state elements.\r\n     *\r\n     * This method is called every time a webservice returns a update state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     * @returns {Object} final fields data\r\n     */\r\n    _prepareFields(stateManager, updateName, fields) {\r\n        // Any update should unlock the element.\r\n        fields.locked = false;\r\n        return fields;\r\n    }\r\n\r\n    /**\r\n     * Hides sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     */\r\n    async sectionHide(stateManager, sectionIds) {\r\n        await this._sectionBasicAction(stateManager, 'section_hide', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Show sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     */\r\n    async sectionShow(stateManager, sectionIds) {\r\n        await this._sectionBasicAction(stateManager, 'section_show', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Show cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmShow(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_show', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Hide cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmHide(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_hide', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Stealth cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmStealth(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_stealth', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Duplicate course modules\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {number|undefined} targetSectionId the optional target sectionId\r\n     * @param {number|undefined} targetCmId the target course module id\r\n     */\r\n    async cmDuplicate(stateManager, cmIds, targetSectionId, targetCmId) {\r\n        const course = stateManager.get('course');\r\n        // Lock all target sections.\r\n        const sectionIds = new Set();\r\n        if (targetSectionId) {\r\n            sectionIds.add(targetSectionId);\r\n        } else {\r\n            cmIds.forEach((cmId) => {\r\n                const cm = stateManager.get('cm', cmId);\r\n                sectionIds.add(cm.sectionid);\r\n            });\r\n        }\r\n        this.sectionLock(stateManager, Array.from(sectionIds), true);\r\n\r\n        const updates = await this._callEditWebservice('cm_duplicate', course.id, cmIds, targetSectionId, targetCmId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n\r\n        this.sectionLock(stateManager, Array.from(sectionIds), false);\r\n    }\r\n\r\n    /**\r\n     * Move course modules to specific course location.\r\n     *\r\n     * Note that one of targetSectionId or targetCmId should be provided in order to identify the\r\n     * new location:\r\n     *  - targetCmId: the activities will be located avobe the target cm. The targetSectionId\r\n     *                value will be ignored in this case.\r\n     *  - targetSectionId: the activities will be appended to the section. In this case\r\n     *                     targetSectionId should not be present.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmids the list of cm ids to move\r\n     * @param {number} targetSectionId the target section id\r\n     * @param {number} targetCmId the target course module id\r\n     */\r\n    async cmMove(stateManager, cmids, targetSectionId, targetCmId) {\r\n        if (!targetSectionId && !targetCmId) {\r\n            throw new Error(`Mutation cmMove requires targetSectionId or targetCmId`);\r\n        }\r\n        const course = stateManager.get('course');\r\n        this.cmLock(stateManager, cmids, true);\r\n        const updates = await this._callEditWebservice('cm_move', course.id, cmids, targetSectionId, targetCmId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.cmLock(stateManager, cmids, false);\r\n    }\r\n\r\n    /**\r\n     * Move course modules to specific course location.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids to move\r\n     * @param {number} targetSectionId the target section id\r\n     */\r\n    async sectionMove(stateManager, sectionIds, targetSectionId) {\r\n        if (!targetSectionId) {\r\n            throw new Error(`Mutation sectionMove requires targetSectionId`);\r\n        }\r\n        const course = stateManager.get('course');\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const updates = await this._callEditWebservice('section_move', course.id, sectionIds, targetSectionId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Move course modules after a specific course location.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids to move\r\n     * @param {number} targetSectionId the target section id\r\n     */\r\n    async sectionMoveAfter(stateManager, sectionIds, targetSectionId) {\r\n        if (!targetSectionId) {\r\n            throw new Error(`Mutation sectionMoveAfter requires targetSectionId`);\r\n        }\r\n        const course = stateManager.get('course');\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const updates = await this._callEditWebservice('section_move_after', course.id, sectionIds, targetSectionId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Add a new section to a specific course location.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {number} targetSectionId optional the target section id\r\n     */\r\n    async addSection(stateManager, targetSectionId) {\r\n        if (!targetSectionId) {\r\n            targetSectionId = 0;\r\n        }\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('section_add', course.id, [], targetSectionId);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n    /**\r\n     * Delete sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of course modules ids\r\n     */\r\n    async sectionDelete(stateManager, sectionIds) {\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('section_delete', course.id, sectionIds);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n    /**\r\n     * Delete cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of section ids\r\n     */\r\n    async cmDelete(stateManager, cmIds) {\r\n        const course = stateManager.get('course');\r\n        this.cmLock(stateManager, cmIds, true);\r\n        const updates = await this._callEditWebservice('cm_delete', course.id, cmIds);\r\n        this.bulkReset(stateManager);\r\n        this.cmLock(stateManager, cmIds, false);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n    /**\r\n     * Mark or unmark course modules as dragging.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {bool} dragValue the new dragging value\r\n     */\r\n    cmDrag(stateManager, cmIds, dragValue) {\r\n        this.setPageItem(stateManager);\r\n        this._setElementsValue(stateManager, 'cm', cmIds, 'dragging', dragValue);\r\n    }\r\n\r\n    /**\r\n     * Mark or unmark course sections as dragging.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     * @param {bool} dragValue the new dragging value\r\n     */\r\n    sectionDrag(stateManager, sectionIds, dragValue) {\r\n        this.setPageItem(stateManager);\r\n        this._setElementsValue(stateManager, 'section', sectionIds, 'dragging', dragValue);\r\n    }\r\n\r\n    /**\r\n     * Mark or unmark course modules as complete.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {bool} complete the new completion value\r\n     */\r\n    cmCompletion(stateManager, cmIds, complete) {\r\n        const newValue = (complete) ? 1 : 0;\r\n        this._setElementsValue(stateManager, 'cm', cmIds, 'completionstate', newValue);\r\n    }\r\n\r\n    /**\r\n     * Move cms to the right: indent = 1.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmMoveRight(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_moveright', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Move cms to the left: indent = 0.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmMoveLeft(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_moveleft', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Lock or unlock course modules.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {bool} lockValue the new locked value\r\n     */\r\n    cmLock(stateManager, cmIds, lockValue) {\r\n        this._setElementsValue(stateManager, 'cm', cmIds, 'locked', lockValue);\r\n    }\r\n\r\n    /**\r\n     * Lock or unlock course sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     * @param {bool} lockValue the new locked value\r\n     */\r\n    sectionLock(stateManager, sectionIds, lockValue) {\r\n        this._setElementsValue(stateManager, 'section', sectionIds, 'locked', lockValue);\r\n    }\r\n\r\n    _setElementsValue(stateManager, name, ids, fieldName, newValue) {\r\n        stateManager.setReadOnly(false);\r\n        ids.forEach((id) => {\r\n            const element = stateManager.get(name, id);\r\n            if (element) {\r\n                element[fieldName] = newValue;\r\n            }\r\n        });\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Set the page current item.\r\n     *\r\n     * Only one element of the course state can be the page item at a time.\r\n     *\r\n     * There are several actions that can alter the page current item. For example, when the user is in an activity\r\n     * page, the page item is always the activity one. However, in a course page, when the user scrolls to an element,\r\n     * this element get the page item.\r\n     *\r\n     * If the page item is static means that it is not meant to change. This is important because\r\n     * static page items has some special logic. For example, if a cm is the static page item\r\n     * and it is inside a collapsed section, the course index will expand the section to make it visible.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {String|undefined} type the element type (section or cm). Undefined will remove the current page item.\r\n     * @param {Number|undefined} id the element id\r\n     * @param {boolean|undefined} isStatic if the page item is static\r\n     */\r\n    setPageItem(stateManager, type, id, isStatic) {\r\n        let newPageItem;\r\n        if (type !== undefined) {\r\n            newPageItem = stateManager.get(type, id);\r\n            if (!newPageItem) {\r\n                return;\r\n            }\r\n        }\r\n        stateManager.setReadOnly(false);\r\n        // Remove the current page item.\r\n        const course = stateManager.get('course');\r\n        course.pageItem = null;\r\n        // Save the new page item.\r\n        if (newPageItem) {\r\n            course.pageItem = {\r\n                id,\r\n                type,\r\n                sectionId: (type == 'section') ? newPageItem.id : newPageItem.sectionid,\r\n                isStatic,\r\n            };\r\n        }\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Unlock all course elements.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     */\r\n    unlockAll(stateManager) {\r\n        const state = stateManager.state;\r\n        stateManager.setReadOnly(false);\r\n        state.section.forEach((section) => {\r\n            section.locked = false;\r\n        });\r\n        state.cm.forEach((cm) => {\r\n            cm.locked = false;\r\n        });\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Update the course index collapsed attribute of some sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the affected section ids\r\n     * @param {boolean} collapsed the new collapsed value\r\n     */\r\n    async sectionIndexCollapsed(stateManager, sectionIds, collapsed) {\r\n        const collapsedIds = this._updateStateSectionPreference(stateManager, 'indexcollapsed', sectionIds, collapsed);\r\n        if (!collapsedIds) {\r\n            return;\r\n        }\r\n        const course = stateManager.get('course');\r\n        await this._callEditWebservice('section_index_collapsed', course.id, collapsedIds);\r\n    }\r\n\r\n    /**\r\n     * Update the course content collapsed attribute of some sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the affected section ids\r\n     * @param {boolean} collapsed the new collapsed value\r\n     */\r\n    async sectionContentCollapsed(stateManager, sectionIds, collapsed) {\r\n        const collapsedIds = this._updateStateSectionPreference(stateManager, 'contentcollapsed', sectionIds, collapsed);\r\n        if (!collapsedIds) {\r\n            return;\r\n        }\r\n        const course = stateManager.get('course');\r\n        await this._callEditWebservice('section_content_collapsed', course.id, collapsedIds);\r\n    }\r\n\r\n    /**\r\n     * Private batch update for a section preference attribute.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} preferenceName the preference name\r\n     * @param {array} sectionIds the affected section ids\r\n     * @param {boolean} preferenceValue the new preferenceValue value\r\n     * @return {Number[]|null} sections ids with the preference value true or null if no update is required\r\n     */\r\n    _updateStateSectionPreference(stateManager, preferenceName, sectionIds, preferenceValue) {\r\n        stateManager.setReadOnly(false);\r\n        const affectedSections = new Set();\r\n        // Check if we need to update preferences.\r\n        sectionIds.forEach(sectionId => {\r\n            const section = stateManager.get('section', sectionId);\r\n            if (section === undefined) {\r\n                return null;\r\n            }\r\n            const newValue = preferenceValue ?? section[preferenceName];\r\n            if (section[preferenceName] != newValue) {\r\n                section[preferenceName] = newValue;\r\n                affectedSections.add(section.id);\r\n            }\r\n        });\r\n        stateManager.setReadOnly(true);\r\n        if (affectedSections.size == 0) {\r\n            return null;\r\n        }\r\n        // Get all collapsed section ids.\r\n        const collapsedSectionIds = [];\r\n        const state = stateManager.state;\r\n        state.section.forEach(section => {\r\n            if (section[preferenceName]) {\r\n                collapsedSectionIds.push(section.id);\r\n            }\r\n        });\r\n        return collapsedSectionIds;\r\n    }\r\n\r\n    /**\r\n     * Enable/disable bulk editing.\r\n     *\r\n     * Note: reenabling the bulk will clean the current selection.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {Boolean} enabled the new bulk state.\r\n     */\r\n    bulkEnable(stateManager, enabled) {\r\n        const state = stateManager.state;\r\n        stateManager.setReadOnly(false);\r\n        state.bulk.enabled = enabled;\r\n        state.bulk.selectedType = '';\r\n        state.bulk.selection = [];\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Reset the current selection.\r\n     * @param {StateManager} stateManager the current state manager\r\n     */\r\n    bulkReset(stateManager) {\r\n        const state = stateManager.state;\r\n        stateManager.setReadOnly(false);\r\n        state.bulk.selectedType = '';\r\n        state.bulk.selection = [];\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Select a list of cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    cmSelect(stateManager, cmIds) {\r\n        this._addIdsToSelection(stateManager, 'cm', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Unselect a list of cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    cmUnselect(stateManager, cmIds) {\r\n        this._removeIdsFromSelection(stateManager, 'cm', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Select a list of sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of cm ids\r\n     */\r\n    sectionSelect(stateManager, sectionIds) {\r\n        this._addIdsToSelection(stateManager, 'section', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Unselect a list of sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of cm ids\r\n     */\r\n    sectionUnselect(stateManager, sectionIds) {\r\n        this._removeIdsFromSelection(stateManager, 'section', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Add some ids to the current bulk selection.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {String} typeName the type name (section/cm)\r\n     * @param {array} ids the list of ids\r\n     */\r\n    _addIdsToSelection(stateManager, typeName, ids) {\r\n        const bulk = stateManager.state.bulk;\r\n        if (!bulk?.enabled) {\r\n            throw new Error(`Bulk is not enabled`);\r\n        }\r\n        if (bulk?.selectedType !== \"\" && bulk?.selectedType !== typeName) {\r\n            throw new Error(`Cannot add ${typeName} to the current selection`);\r\n        }\r\n\r\n        // Stored ids are strings for compatability with HTML data attributes.\r\n        ids = ids.map(value => value.toString());\r\n\r\n        stateManager.setReadOnly(false);\r\n        bulk.selectedType = typeName;\r\n        const newSelection = new Set([...bulk.selection, ...ids]);\r\n        bulk.selection = [...newSelection];\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Remove some ids to the current bulk selection.\r\n     *\r\n     * The method resets the selection type if the current selection is empty.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {String} typeName the type name (section/cm)\r\n     * @param {array} ids the list of ids\r\n     */\r\n    _removeIdsFromSelection(stateManager, typeName, ids) {\r\n        const bulk = stateManager.state.bulk;\r\n        if (!bulk?.enabled) {\r\n            throw new Error(`Bulk is not enabled`);\r\n        }\r\n        if (bulk?.selectedType !== \"\" && bulk?.selectedType !== typeName) {\r\n            throw new Error(`Cannot remove ${typeName} from the current selection`);\r\n        }\r\n\r\n        // Stored ids are strings for compatability with HTML data attributes.\r\n        ids = ids.map(value => value.toString());\r\n\r\n        stateManager.setReadOnly(false);\r\n        const IdsToFilter = new Set(ids);\r\n        bulk.selection = bulk.selection.filter(current => !IdsToFilter.has(current));\r\n        if (bulk.selection.length === 0) {\r\n            bulk.selectedType = '';\r\n        }\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Get updated state data related to some cm ids.\r\n     *\r\n     * @method cmState\r\n     * @param {StateManager} stateManager the current state\r\n     * @param {array} cmids the list of cm ids to update\r\n     */\r\n    async cmState(stateManager, cmids) {\r\n        this.cmLock(stateManager, cmids, true);\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('cm_state', course.id, cmids);\r\n        stateManager.processUpdates(updates);\r\n        this.cmLock(stateManager, cmids, false);\r\n    }\r\n\r\n    /**\r\n     * Get updated state data related to some section ids.\r\n     *\r\n     * @method sectionState\r\n     * @param {StateManager} stateManager the current state\r\n     * @param {array} sectionIds the list of section ids to update\r\n     */\r\n    async sectionState(stateManager, sectionIds) {\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('section_state', course.id, sectionIds);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Get the full updated state data of the course.\r\n     *\r\n     * @param {StateManager} stateManager the current state\r\n     */\r\n    async courseState(stateManager) {\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('course_state', course.id);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n}\r\n"],"names":["action","courseId","ids","targetSectionId","targetCmId","args","courseid","targetsectionid","targetcmid","ajaxresult","ajax","call","methodname","JSON","parse","stateManager","sectionIds","course","get","sectionLock","updates","this","_callEditWebservice","id","bulkReset","processUpdates","cmIds","cmLock","init","addUpdateTypes","prepareFields","_prepareFields","updateName","fields","locked","_sectionBasicAction","_cmBasicAction","Set","add","forEach","cmId","cm","sectionid","Array","from","cmids","Error","cmDrag","dragValue","setPageItem","_setElementsValue","sectionDrag","cmCompletion","complete","newValue","lockValue","name","fieldName","setReadOnly","element","type","isStatic","newPageItem","undefined","pageItem","sectionId","unlockAll","state","section","collapsed","collapsedIds","_updateStateSectionPreference","preferenceName","preferenceValue","affectedSections","size","collapsedSectionIds","push","bulkEnable","enabled","bulk","selectedType","selection","cmSelect","_addIdsToSelection","cmUnselect","_removeIdsFromSelection","sectionSelect","sectionUnselect","typeName","map","value","toString","newSelection","IdsToFilter","filter","current","has","length"],"mappings":";;;;;;;;iMAuC8BA,OAAQC,SAAUC,IAAKC,gBAAiBC,kBACxDC,KAAO,CACTL,OAAAA,OACAM,SAAUL,SACVC,IAAAA,KAEAC,kBACAE,KAAKE,gBAAkBJ,iBAEvBC,aACAC,KAAKG,WAAaJ,gBAElBK,iBAAmBC,cAAKC,KAAK,CAAC,CAC9BC,WAAY,kCACZP,KAAAA,QACA,UACGQ,KAAKC,MAAML,sCAWIM,aAAcf,OAAQgB,WAAYb,gBAAiBC,kBACnEa,OAASF,aAAaG,IAAI,eAC3BC,YAAYJ,aAAcC,YAAY,SACrCI,cAAgBC,KAAKC,oBACvBtB,OACAiB,OAAOM,GACPP,WACAb,gBACAC,iBAECoB,UAAUT,cACfA,aAAaU,eAAeL,cACvBD,YAAYJ,aAAcC,YAAY,wBAW1BD,aAAcf,OAAQ0B,MAAOvB,gBAAiBC,kBACzDa,OAASF,aAAaG,IAAI,eAC3BS,OAAOZ,aAAcW,OAAO,SAC3BN,cAAgBC,KAAKC,oBACvBtB,OACAiB,OAAOM,GACPG,MACAvB,gBACAC,iBAECoB,UAAUT,cACfA,aAAaU,eAAeL,cACvBO,OAAOZ,aAAcW,OAAO,GAUrCE,KAAKb,cAEDA,aAAac,eAAe,CACxBC,cAAeT,KAAKU,iBAc5BA,eAAehB,aAAciB,WAAYC,eAErCA,OAAOC,QAAS,EACTD,yBAQOlB,aAAcC,kBACtBK,KAAKc,oBAAoBpB,aAAc,eAAgBC,8BAQ/CD,aAAcC,kBACtBK,KAAKc,oBAAoBpB,aAAc,eAAgBC,yBAQpDD,aAAcW,aACjBL,KAAKe,eAAerB,aAAc,UAAWW,oBAQ1CX,aAAcW,aACjBL,KAAKe,eAAerB,aAAc,UAAWW,uBAQvCX,aAAcW,aACpBL,KAAKe,eAAerB,aAAc,aAAcW,yBAUxCX,aAAcW,MAAOvB,gBAAiBC,kBAC9Ca,OAASF,aAAaG,IAAI,UAE1BF,WAAa,IAAIqB,IACnBlC,gBACAa,WAAWsB,IAAInC,iBAEfuB,MAAMa,SAASC,aACLC,GAAK1B,aAAaG,IAAI,KAAMsB,MAClCxB,WAAWsB,IAAIG,GAAGC,mBAGrBvB,YAAYJ,aAAc4B,MAAMC,KAAK5B,aAAa,SAEjDI,cAAgBC,KAAKC,oBAAoB,eAAgBL,OAAOM,GAAIG,MAAOvB,gBAAiBC,iBAC7FoB,UAAUT,cACfA,aAAaU,eAAeL,cAEvBD,YAAYJ,aAAc4B,MAAMC,KAAK5B,aAAa,gBAkB9CD,aAAc8B,MAAO1C,gBAAiBC,gBAC1CD,kBAAoBC,iBACf,IAAI0C,sEAER7B,OAASF,aAAaG,IAAI,eAC3BS,OAAOZ,aAAc8B,OAAO,SAC3BzB,cAAgBC,KAAKC,oBAAoB,UAAWL,OAAOM,GAAIsB,MAAO1C,gBAAiBC,iBACxFoB,UAAUT,cACfA,aAAaU,eAAeL,cACvBO,OAAOZ,aAAc8B,OAAO,qBAUnB9B,aAAcC,WAAYb,qBACnCA,sBACK,IAAI2C,6DAER7B,OAASF,aAAaG,IAAI,eAC3BC,YAAYJ,aAAcC,YAAY,SACrCI,cAAgBC,KAAKC,oBAAoB,eAAgBL,OAAOM,GAAIP,WAAYb,sBACjFqB,UAAUT,cACfA,aAAaU,eAAeL,cACvBD,YAAYJ,aAAcC,YAAY,0BAUxBD,aAAcC,WAAYb,qBACxCA,sBACK,IAAI2C,kEAER7B,OAASF,aAAaG,IAAI,eAC3BC,YAAYJ,aAAcC,YAAY,SACrCI,cAAgBC,KAAKC,oBAAoB,qBAAsBL,OAAOM,GAAIP,WAAYb,sBACvFqB,UAAUT,cACfA,aAAaU,eAAeL,cACvBD,YAAYJ,aAAcC,YAAY,oBAS9BD,aAAcZ,iBACtBA,kBACDA,gBAAkB,SAEhBc,OAASF,aAAaG,IAAI,UAC1BE,cAAgBC,KAAKC,oBAAoB,cAAeL,OAAOM,GAAI,GAAIpB,iBAC7EY,aAAaU,eAAeL,6BASZL,aAAcC,kBACxBC,OAASF,aAAaG,IAAI,UAC1BE,cAAgBC,KAAKC,oBAAoB,iBAAkBL,OAAOM,GAAIP,iBACvEQ,UAAUT,cACfA,aAAaU,eAAeL,wBAQjBL,aAAcW,aACnBT,OAASF,aAAaG,IAAI,eAC3BS,OAAOZ,aAAcW,OAAO,SAC3BN,cAAgBC,KAAKC,oBAAoB,YAAaL,OAAOM,GAAIG,YAClEF,UAAUT,mBACVY,OAAOZ,aAAcW,OAAO,GACjCX,aAAaU,eAAeL,SAUhC2B,OAAOhC,aAAcW,MAAOsB,gBACnBC,YAAYlC,mBACZmC,kBAAkBnC,aAAc,KAAMW,MAAO,WAAYsB,WAUlEG,YAAYpC,aAAcC,WAAYgC,gBAC7BC,YAAYlC,mBACZmC,kBAAkBnC,aAAc,UAAWC,WAAY,WAAYgC,WAU5EI,aAAarC,aAAcW,MAAO2B,gBACxBC,SAAYD,SAAY,EAAI,OAC7BH,kBAAkBnC,aAAc,KAAMW,MAAO,kBAAmB4B,4BAQvDvC,aAAcW,aACtBL,KAAKe,eAAerB,aAAc,eAAgBW,wBAQ3CX,aAAcW,aACrBL,KAAKe,eAAerB,aAAc,cAAeW,OAU3DC,OAAOZ,aAAcW,MAAO6B,gBACnBL,kBAAkBnC,aAAc,KAAMW,MAAO,SAAU6B,WAUhEpC,YAAYJ,aAAcC,WAAYuC,gBAC7BL,kBAAkBnC,aAAc,UAAWC,WAAY,SAAUuC,WAG1EL,kBAAkBnC,aAAcyC,KAAMtD,IAAKuD,UAAWH,UAClDvC,aAAa2C,aAAY,GACzBxD,IAAIqC,SAAShB,WACHoC,QAAU5C,aAAaG,IAAIsC,KAAMjC,IACnCoC,UACAA,QAAQF,WAAaH,aAG7BvC,aAAa2C,aAAY,GAqB7BT,YAAYlC,aAAc6C,KAAMrC,GAAIsC,cAC5BC,oBACSC,IAATH,OACAE,YAAc/C,aAAaG,IAAI0C,KAAMrC,KAChCuC,oBAIT/C,aAAa2C,aAAY,SAEnBzC,OAASF,aAAaG,IAAI,UAChCD,OAAO+C,SAAW,KAEdF,cACA7C,OAAO+C,SAAW,CACdzC,GAAAA,GACAqC,KAAAA,KACAK,UAAoB,WAARL,KAAqBE,YAAYvC,GAAKuC,YAAYpB,UAC9DmB,SAAAA,WAGR9C,aAAa2C,aAAY,GAQ7BQ,UAAUnD,oBACAoD,MAAQpD,aAAaoD,MAC3BpD,aAAa2C,aAAY,GACzBS,MAAMC,QAAQ7B,SAAS6B,UACnBA,QAAQlC,QAAS,KAErBiC,MAAM1B,GAAGF,SAASE,KACdA,GAAGP,QAAS,KAEhBnB,aAAa2C,aAAY,+BAUD3C,aAAcC,WAAYqD,iBAC5CC,aAAejD,KAAKkD,8BAA8BxD,aAAc,iBAAkBC,WAAYqD,eAC/FC,0BAGCrD,OAASF,aAAaG,IAAI,gBAC1BG,KAAKC,oBAAoB,0BAA2BL,OAAOM,GAAI+C,4CAU3CvD,aAAcC,WAAYqD,iBAC9CC,aAAejD,KAAKkD,8BAA8BxD,aAAc,mBAAoBC,WAAYqD,eACjGC,0BAGCrD,OAASF,aAAaG,IAAI,gBAC1BG,KAAKC,oBAAoB,4BAA6BL,OAAOM,GAAI+C,cAY3EC,8BAA8BxD,aAAcyD,eAAgBxD,WAAYyD,iBACpE1D,aAAa2C,aAAY,SACnBgB,iBAAmB,IAAIrC,OAE7BrB,WAAWuB,SAAQ0B,kBACTG,QAAUrD,aAAaG,IAAI,UAAW+C,mBAC5BF,IAAZK,eACO,WAELd,SAAWmB,MAAAA,gBAAAA,gBAAmBL,QAAQI,gBACxCJ,QAAQI,iBAAmBlB,WAC3Bc,QAAQI,gBAAkBlB,SAC1BoB,iBAAiBpC,IAAI8B,QAAQ7C,QAGrCR,aAAa2C,aAAY,GACI,GAAzBgB,iBAAiBC,YACV,WAGLC,oBAAsB,UACd7D,aAAaoD,MACrBC,QAAQ7B,SAAQ6B,UACdA,QAAQI,iBACRI,oBAAoBC,KAAKT,QAAQ7C,OAGlCqD,oBAWXE,WAAW/D,aAAcgE,eACfZ,MAAQpD,aAAaoD,MAC3BpD,aAAa2C,aAAY,GACzBS,MAAMa,KAAKD,QAAUA,QACrBZ,MAAMa,KAAKC,aAAe,GAC1Bd,MAAMa,KAAKE,UAAY,GACvBnE,aAAa2C,aAAY,GAO7BlC,UAAUT,oBACAoD,MAAQpD,aAAaoD,MAC3BpD,aAAa2C,aAAY,GACzBS,MAAMa,KAAKC,aAAe,GAC1Bd,MAAMa,KAAKE,UAAY,GACvBnE,aAAa2C,aAAY,GAQ7ByB,SAASpE,aAAcW,YACd0D,mBAAmBrE,aAAc,KAAMW,OAQhD2D,WAAWtE,aAAcW,YAChB4D,wBAAwBvE,aAAc,KAAMW,OAQrD6D,cAAcxE,aAAcC,iBACnBoE,mBAAmBrE,aAAc,UAAWC,YAQrDwE,gBAAgBzE,aAAcC,iBACrBsE,wBAAwBvE,aAAc,UAAWC,YAS1DoE,mBAAmBrE,aAAc0E,SAAUvF,WACjC8E,KAAOjE,aAAaoD,MAAMa,QAC3BA,MAAAA,OAAAA,KAAMD,cACD,IAAIjC,gCAEa,MAAvBkC,MAAAA,YAAAA,KAAMC,gBAAuBD,MAAAA,YAAAA,KAAMC,gBAAiBQ,eAC9C,IAAI3C,2BAAoB2C,uCAIlCvF,IAAMA,IAAIwF,KAAIC,OAASA,MAAMC,aAE7B7E,aAAa2C,aAAY,GACzBsB,KAAKC,aAAeQ,eACdI,aAAe,IAAIxD,IAAI,IAAI2C,KAAKE,aAAchF,MACpD8E,KAAKE,UAAY,IAAIW,cACrB9E,aAAa2C,aAAY,GAY7B4B,wBAAwBvE,aAAc0E,SAAUvF,WACtC8E,KAAOjE,aAAaoD,MAAMa,QAC3BA,MAAAA,OAAAA,KAAMD,cACD,IAAIjC,gCAEa,MAAvBkC,MAAAA,YAAAA,KAAMC,gBAAuBD,MAAAA,YAAAA,KAAMC,gBAAiBQ,eAC9C,IAAI3C,8BAAuB2C,yCAIrCvF,IAAMA,IAAIwF,KAAIC,OAASA,MAAMC,aAE7B7E,aAAa2C,aAAY,SACnBoC,YAAc,IAAIzD,IAAInC,KAC5B8E,KAAKE,UAAYF,KAAKE,UAAUa,QAAOC,UAAYF,YAAYG,IAAID,WACrC,IAA1BhB,KAAKE,UAAUgB,SACflB,KAAKC,aAAe,IAExBlE,aAAa2C,aAAY,iBAUf3C,aAAc8B,YACnBlB,OAAOZ,aAAc8B,OAAO,SAC3B5B,OAASF,aAAaG,IAAI,UAC1BE,cAAgBC,KAAKC,oBAAoB,WAAYL,OAAOM,GAAIsB,OACtE9B,aAAaU,eAAeL,cACvBO,OAAOZ,aAAc8B,OAAO,sBAUlB9B,aAAcC,iBACxBG,YAAYJ,aAAcC,YAAY,SACrCC,OAASF,aAAaG,IAAI,UAC1BE,cAAgBC,KAAKC,oBAAoB,gBAAiBL,OAAOM,GAAIP,YAC3ED,aAAaU,eAAeL,cACvBD,YAAYJ,aAAcC,YAAY,qBAQ7BD,oBACRE,OAASF,aAAaG,IAAI,UAC1BE,cAAgBC,KAAKC,oBAAoB,eAAgBL,OAAOM,IACtER,aAAaU,eAAeL"}