{"version":3,"file":"courseeditor.min.js","sources":["../src/courseeditor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Generic reactive module used in the course editor.\r\n *\r\n * @module     core_courseformat/courseeditor\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport DefaultMutations from 'core_courseformat/local/courseeditor/mutations';\r\nimport CourseEditor from 'core_courseformat/local/courseeditor/courseeditor';\r\nimport events from 'core_course/events';\r\n\r\n// A map with all the course editor instances.\r\nconst courseEditorMap = new Map();\r\n\r\n// Map with all the state keys the backend send us to know if the frontend cache is valid or not.\r\nconst courseStateKeyMap = new Map();\r\n\r\n/**\r\n * Trigger a state changed event.\r\n *\r\n * This function will be moved to core_course/events module\r\n * when the file is migrated to the new JS events structure proposed in MDL-70990.\r\n *\r\n * @method dispatchStateChangedEvent\r\n * @param {object} detail the full state\r\n * @param {object} target the custom event target (document if none provided)\r\n */\r\nfunction dispatchStateChangedEvent(detail, target) {\r\n    if (target === undefined) {\r\n        target = document;\r\n    }\r\n    target.dispatchEvent(new CustomEvent(events.stateChanged, {\r\n        bubbles: true,\r\n        detail: detail,\r\n    }));\r\n}\r\n\r\n/**\r\n * Setup the current view settings\r\n *\r\n * The backend cache state revision is a combination of the course->cacherev, the\r\n * user course preferences and completion state. The backend updates that number\r\n * everytime some change in the course affects the user course state.\r\n *\r\n * @param {number} courseId the course id\r\n * @param {setup} setup format, page and course settings\r\n * @param {boolean} setup.editing if the page is in edit mode\r\n * @param {boolean} setup.supportscomponents if the format supports components for content\r\n * @param {String} setup.statekey the backend cached state revision\r\n * @param {Array} setup.overriddenStrings optional overridden strings\r\n */\r\nexport const setViewFormat = (courseId, setup) => {\r\n    courseId = parseInt(courseId);\r\n    // Caches are ignored in edit mode.\r\n    if (!setup.editing) {\r\n        courseStateKeyMap.set(courseId, setup.statekey);\r\n    }\r\n    const editor = getCourseEditor(courseId);\r\n    editor.setViewFormat(setup);\r\n};\r\n\r\n/**\r\n * Get a specific course editor reactive instance.\r\n *\r\n * @param {number} courseId the course id\r\n * @returns {CourseEditor}\r\n */\r\nexport const getCourseEditor = (courseId) => {\r\n    courseId = parseInt(courseId);\r\n\r\n    if (!courseEditorMap.has(courseId)) {\r\n        courseEditorMap.set(\r\n            courseId,\r\n            new CourseEditor({\r\n                name: `CourseEditor${courseId}`,\r\n                eventName: events.stateChanged,\r\n                eventDispatch: dispatchStateChangedEvent,\r\n                // Mutations can be overridden by the format plugin using setMutations\r\n                // but we need the default one at least.\r\n                mutations: new DefaultMutations(),\r\n            })\r\n        );\r\n        courseEditorMap.get(courseId).loadCourse(courseId, courseStateKeyMap.get(courseId));\r\n    }\r\n    return courseEditorMap.get(courseId);\r\n};\r\n\r\n/**\r\n * Get the current course reactive instance.\r\n *\r\n * @returns {CourseEditor}\r\n */\r\nexport const getCurrentCourseEditor = () => getCourseEditor(M.cfg.courseId);\r\n"],"names":["courseEditorMap","Map","courseStateKeyMap","dispatchStateChangedEvent","detail","target","undefined","document","dispatchEvent","CustomEvent","events","stateChanged","bubbles","courseId","setup","parseInt","editing","set","statekey","getCourseEditor","setViewFormat","has","CourseEditor","name","eventName","eventDispatch","mutations","DefaultMutations","get","loadCourse","M","cfg"],"mappings":";;;;;;;oSA4BMA,gBAAkB,IAAIC,IAGtBC,kBAAoB,IAAID,aAYrBE,0BAA0BC,OAAQC,aACxBC,IAAXD,SACAA,OAASE,UAEbF,OAAOG,cAAc,IAAIC,YAAYC,gBAAOC,aAAc,CACtDC,SAAS,EACTR,OAAQA,iCAkBa,CAACS,SAAUC,SACpCD,SAAWE,SAASF,UAEfC,MAAME,SACPd,kBAAkBe,IAAIJ,SAAUC,MAAMI,UAE3BC,gBAAgBN,UACxBO,cAAcN,cASZK,gBAAmBN,WAC5BA,SAAWE,SAASF,UAEfb,gBAAgBqB,IAAIR,YACrBb,gBAAgBiB,IACZJ,SACA,IAAIS,sBAAa,CACbC,2BAAqBV,UACrBW,UAAWd,gBAAOC,aAClBc,cAAetB,0BAGfuB,UAAW,IAAIC,sBAGvB3B,gBAAgB4B,IAAIf,UAAUgB,WAAWhB,SAAUX,kBAAkB0B,IAAIf,YAEtEb,gBAAgB4B,IAAIf,oFAQO,IAAMM,gBAAgBW,EAAEC,IAAIlB"}