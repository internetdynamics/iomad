{"version":3,"file":"search.min.js","sources":["../src/search.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Allow the user to search for learners within the grader report.\r\n * Have to basically search twice on the dataset to avoid passing around massive csv params whilst allowing debouncing.\r\n *\r\n * @module    gradereport_grader/search\r\n * @copyright 2023 Mathew May <mathew.solutions>\r\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nimport GradebookSearchClass from 'gradereport_grader/search/search_class';\r\nimport * as Repository from 'gradereport_grader/search/repository';\r\nimport {get_strings as getStrings} from 'core/str';\r\nimport Url from 'core/url';\r\nimport {renderForPromise, replaceNodeContents} from 'core/templates';\r\n\r\n// Define our standard lookups.\r\nconst selectors = {\r\n    component: '.user-search',\r\n    courseid: '[data-region=\"courseid\"]',\r\n    resetPageButton: '[data-action=\"resetpage\"]',\r\n};\r\nconst component = document.querySelector(selectors.component);\r\nconst courseID = component.querySelector(selectors.courseid).dataset.courseid;\r\nconst bannedFilterFields = ['profileimageurlsmall', 'profileimageurl', 'id', 'link', 'matchingField', 'matchingFieldName'];\r\n\r\nexport default class UserSearch extends GradebookSearchClass {\r\n\r\n    // A map of user profile field names that is human-readable.\r\n    profilestringmap = null;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    static init() {\r\n        return new UserSearch();\r\n    }\r\n\r\n    /**\r\n     * The overall div that contains the searching widget.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    setComponentSelector() {\r\n        return '.user-search';\r\n    }\r\n\r\n    /**\r\n     * The dropdown div that contains the searching widget result space.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    setDropdownSelector() {\r\n        return '.usersearchdropdown';\r\n    }\r\n\r\n    /**\r\n     * The triggering div that contains the searching widget.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    setTriggerSelector() {\r\n        return '.usersearchwidget';\r\n    }\r\n\r\n    /**\r\n     * Build the content then replace the node.\r\n     */\r\n    async renderDropdown() {\r\n        const {html, js} = await renderForPromise('gradereport_grader/search/resultset', {\r\n            users: this.getMatchedResults().slice(0, 5),\r\n            hasusers: this.getMatchedResults().length > 0,\r\n            matches: this.getMatchedResults().length,\r\n            showing: this.getMatchedResults().slice(0, 5).length,\r\n            searchterm: this.getSearchTerm(),\r\n            selectall: this.selectAllResultsLink(),\r\n        });\r\n        replaceNodeContents(this.getHTMLElements().searchDropdown, html, js);\r\n    }\r\n\r\n    /**\r\n     * Get the data we will be searching against in this component.\r\n     *\r\n     * @returns {Promise<*>}\r\n     */\r\n    fetchDataset() {\r\n        return Repository.userFetch(courseID).then((r) => r.users);\r\n    }\r\n\r\n    /**\r\n     * Dictate to the search component how and what we want to match upon.\r\n     *\r\n     * @param {Array} filterableData\r\n     * @returns {Array} The users that match the given criteria.\r\n     */\r\n    async filterDataset(filterableData) {\r\n        return filterableData.filter((user) => Object.keys(user).some((key) => {\r\n            if (user[key] === \"\" || bannedFilterFields.includes(key)) {\r\n                return false;\r\n            }\r\n            return user[key].toString().toLowerCase().includes(this.getPreppedSearchTerm());\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Given we have a subset of the dataset, set the field that we matched upon to inform the end user.\r\n     *\r\n     * @returns {Array} The results with the matched fields inserted.\r\n     */\r\n    async filterMatchDataset() {\r\n        const stringMap = await this.getStringMap();\r\n        this.setMatchedResults(\r\n            this.getMatchedResults().map((user) => {\r\n                for (const [key, value] of Object.entries(user)) {\r\n                    const valueString = value.toString().toLowerCase();\r\n                    if (!valueString.includes(this.getPreppedSearchTerm())) {\r\n                        continue;\r\n                    }\r\n                    // Ensure we have a good string, otherwise fallback to the key.\r\n                    user.matchingFieldName = stringMap.get(key) ?? key;\r\n                    user.matchingField = valueString.replace(\r\n                        this.getPreppedSearchTerm(),\r\n                        `<span class=\"font-weight-bold\">${this.getSearchTerm()}</span>`\r\n                    );\r\n                    user.matchingField = `${user.matchingField} (${user.email})`;\r\n                    user.link = this.selectOneLink(user.id);\r\n                    break;\r\n                }\r\n                return user;\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The handler for when a user interacts with the component.\r\n     *\r\n     * @param {MouseEvent} e The triggering event that we are working with.\r\n     */\r\n    clickHandler(e) {\r\n        super.clickHandler(e);\r\n        if (e.target === this.getHTMLElements().currentViewAll && e.button === 0) {\r\n            window.location = this.selectAllResultsLink();\r\n        }\r\n        if (e.target.closest(selectors.resetPageButton)) {\r\n            window.location = e.target.closest(selectors.resetPageButton).href;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The handler for when a user presses a key within the component.\r\n     *\r\n     * @param {KeyboardEvent} e The triggering event that we are working with.\r\n     */\r\n    keyHandler(e) {\r\n        super.keyHandler(e);\r\n\r\n        if (e.target === this.getHTMLElements().currentViewAll && (e.key === 'Enter' || e.key === 'Space')) {\r\n            window.location = this.selectAllResultsLink();\r\n        }\r\n\r\n        // Switch the key presses to handle keyboard nav.\r\n        switch (e.key) {\r\n            case 'Enter':\r\n            case ' ':\r\n                if (document.activeElement === this.getHTMLElements().searchInput) {\r\n                    if (e.key === ' ') {\r\n                        break;\r\n                    } else {\r\n                        window.location = this.selectAllResultsLink();\r\n                        break;\r\n                    }\r\n                }\r\n                if (document.activeElement === this.getHTMLElements().clearSearchButton) {\r\n                    this.closeSearch(true);\r\n                    break;\r\n                }\r\n                if (e.target.closest(selectors.resetPageButton)) {\r\n                    window.location = e.target.closest(selectors.resetPageButton).href;\r\n                    break;\r\n                }\r\n                if (e.target.closest('.dropdown-item')) {\r\n                    e.preventDefault();\r\n                    window.location = e.target.closest('.dropdown-item').href;\r\n                    break;\r\n                }\r\n                break;\r\n            case 'Escape':\r\n                this.toggleDropdown();\r\n                this.searchInput.focus({preventScroll: true});\r\n                break;\r\n            case 'Tab':\r\n                // If the current focus is on clear search, then check if viewall exists then around tab to it.\r\n                if (e.target.closest(this.selectors.clearSearch)) {\r\n                    if (this.currentViewAll && !e.shiftKey) {\r\n                        e.preventDefault();\r\n                        this.currentViewAll.focus({preventScroll: true});\r\n                    } else {\r\n                        this.closeSearch();\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build up the view all link.\r\n     *\r\n     * @returns {string|*}\r\n     */\r\n    selectAllResultsLink() {\r\n        return Url.relativeUrl('/grade/report/grader/index.php', {\r\n            id: courseID,\r\n            searchvalue: this.getSearchTerm()\r\n        }, false);\r\n    }\r\n\r\n    /**\r\n     * Build up the view all link that is dedicated to a particular result.\r\n     *\r\n     * @param {Number} userID The ID of the user selected.\r\n     * @returns {string|*}\r\n     */\r\n    selectOneLink(userID) {\r\n        return Url.relativeUrl('/grade/report/grader/index.php', {\r\n            id: courseID,\r\n            searchvalue: this.getSearchTerm(),\r\n            userid: userID,\r\n            }, false);\r\n    }\r\n\r\n    /**\r\n     * Given the set of profile fields we can possibly search, fetch their strings,\r\n     * so we can report to screen readers the field that matched.\r\n     *\r\n     * @returns {Promise<void>}\r\n     */\r\n    getStringMap() {\r\n        if (!this.profilestringmap) {\r\n            const requiredStrings = [\r\n                'username',\r\n                'firstname',\r\n                'lastname',\r\n                'email',\r\n                'city',\r\n                'country',\r\n                'department',\r\n                'institution',\r\n                'idnumber',\r\n                'phone1',\r\n                'phone2',\r\n            ];\r\n            this.profilestringmap = getStrings(requiredStrings.map((key) => ({key})))\r\n                .then((stringArray) => new Map(\r\n                    requiredStrings.map((key, index) => ([key, stringArray[index]]))\r\n                ));\r\n        }\r\n        return this.profilestringmap;\r\n    }\r\n}\r\n"],"names":["selectors","courseID","document","querySelector","dataset","courseid","bannedFilterFields","UserSearch","GradebookSearchClass","constructor","setComponentSelector","setDropdownSelector","setTriggerSelector","html","js","users","this","getMatchedResults","slice","hasusers","length","matches","showing","searchterm","getSearchTerm","selectall","selectAllResultsLink","getHTMLElements","searchDropdown","fetchDataset","Repository","userFetch","then","r","filterableData","filter","user","Object","keys","some","key","includes","toString","toLowerCase","getPreppedSearchTerm","stringMap","getStringMap","setMatchedResults","map","value","entries","valueString","matchingFieldName","get","matchingField","replace","email","link","selectOneLink","id","clickHandler","e","target","currentViewAll","button","window","location","closest","href","keyHandler","activeElement","searchInput","clearSearchButton","closeSearch","preventDefault","toggleDropdown","focus","preventScroll","clearSearch","shiftKey","Url","relativeUrl","searchvalue","userID","userid","profilestringmap","requiredStrings","stringArray","Map","index"],"mappings":"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"}