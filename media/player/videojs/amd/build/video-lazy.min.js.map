{"version":3,"file":"video-lazy.min.js","sources":["../src/video-lazy.js"],"sourcesContent":["/**\r\n * @license\r\n * Video.js 7.20.3 <http://videojs.com/>\r\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\r\n * Available under Apache License Version 2.0\r\n * <https://github.com/videojs/video.js/blob/main/LICENSE>\r\n *\r\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\r\n * Available under Apache License Version 2.0\r\n * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>\r\n */\r\n\r\n (function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.videojs = factory());\r\n}(this, (function () { 'use strict';\r\n\r\n  var version$5 = \"7.20.3\";\r\n\r\n  /**\r\n   * An Object that contains lifecycle hooks as keys which point to an array\r\n   * of functions that are run when a lifecycle is triggered\r\n   *\r\n   * @private\r\n   */\r\n  var hooks_ = {};\r\n  /**\r\n   * Get a list of hooks for a specific lifecycle\r\n   *\r\n   * @param  {string} type\r\n   *         the lifecyle to get hooks from\r\n   *\r\n   * @param  {Function|Function[]} [fn]\r\n   *         Optionally add a hook (or hooks) to the lifecycle that your are getting.\r\n   *\r\n   * @return {Array}\r\n   *         an array of hooks, or an empty array if there are none.\r\n   */\r\n\r\n  var hooks = function hooks(type, fn) {\r\n    hooks_[type] = hooks_[type] || [];\r\n\r\n    if (fn) {\r\n      hooks_[type] = hooks_[type].concat(fn);\r\n    }\r\n\r\n    return hooks_[type];\r\n  };\r\n  /**\r\n   * Add a function hook to a specific videojs lifecycle.\r\n   *\r\n   * @param {string} type\r\n   *        the lifecycle to hook the function to.\r\n   *\r\n   * @param {Function|Function[]}\r\n   *        The function or array of functions to attach.\r\n   */\r\n\r\n\r\n  var hook = function hook(type, fn) {\r\n    hooks(type, fn);\r\n  };\r\n  /**\r\n   * Remove a hook from a specific videojs lifecycle.\r\n   *\r\n   * @param  {string} type\r\n   *         the lifecycle that the function hooked to\r\n   *\r\n   * @param  {Function} fn\r\n   *         The hooked function to remove\r\n   *\r\n   * @return {boolean}\r\n   *         The function that was removed or undef\r\n   */\r\n\r\n\r\n  var removeHook = function removeHook(type, fn) {\r\n    var index = hooks(type).indexOf(fn);\r\n\r\n    if (index <= -1) {\r\n      return false;\r\n    }\r\n\r\n    hooks_[type] = hooks_[type].slice();\r\n    hooks_[type].splice(index, 1);\r\n    return true;\r\n  };\r\n  /**\r\n   * Add a function hook that will only run once to a specific videojs lifecycle.\r\n   *\r\n   * @param {string} type\r\n   *        the lifecycle to hook the function to.\r\n   *\r\n   * @param {Function|Function[]}\r\n   *        The function or array of functions to attach.\r\n   */\r\n\r\n\r\n  var hookOnce = function hookOnce(type, fn) {\r\n    hooks(type, [].concat(fn).map(function (original) {\r\n      var wrapper = function wrapper() {\r\n        removeHook(type, wrapper);\r\n        return original.apply(void 0, arguments);\r\n      };\r\n\r\n      return wrapper;\r\n    }));\r\n  };\r\n\r\n  /**\r\n   * @file fullscreen-api.js\r\n   * @module fullscreen-api\r\n   * @private\r\n   */\r\n\r\n  /**\r\n   * Store the browser-specific methods for the fullscreen API.\r\n   *\r\n   * @type {Object}\r\n   * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\r\n   * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\r\n   */\r\n  var FullscreenApi = {\r\n    prefixed: true\r\n  }; // browser API methods\r\n\r\n  var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'], // WebKit\r\n  ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen'], // Mozilla\r\n  ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror', '-moz-full-screen'], // Microsoft\r\n  ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError', '-ms-fullscreen']];\r\n  var specApi = apiMap[0];\r\n  var browserApi; // determine the supported set of functions\r\n\r\n  for (var i = 0; i < apiMap.length; i++) {\r\n    // check for exitFullscreen function\r\n    if (apiMap[i][1] in document) {\r\n      browserApi = apiMap[i];\r\n      break;\r\n    }\r\n  } // map the browser API names to the spec API names\r\n\r\n\r\n  if (browserApi) {\r\n    for (var _i = 0; _i < browserApi.length; _i++) {\r\n      FullscreenApi[specApi[_i]] = browserApi[_i];\r\n    }\r\n\r\n    FullscreenApi.prefixed = browserApi[0] !== specApi[0];\r\n  }\r\n\r\n  /**\r\n   * @file create-logger.js\r\n   * @module create-logger\r\n   */\r\n  // This is the private tracking variable for the logging history.\r\n  var history = [];\r\n  /**\r\n   * Log messages to the console and history based on the type of message\r\n   *\r\n   * @private\r\n   * @param  {string} type\r\n   *         The name of the console method to use.\r\n   *\r\n   * @param  {Array} args\r\n   *         The arguments to be passed to the matching console method.\r\n   */\r\n\r\n  var LogByTypeFactory = function LogByTypeFactory(name, log) {\r\n    return function (type, level, args) {\r\n      var lvl = log.levels[level];\r\n      var lvlRegExp = new RegExp(\"^(\" + lvl + \")$\");\r\n\r\n      if (type !== 'log') {\r\n        // Add the type to the front of the message when it's not \"log\".\r\n        args.unshift(type.toUpperCase() + ':');\r\n      } // Add console prefix after adding to history.\r\n\r\n\r\n      args.unshift(name + ':'); // Add a clone of the args at this point to history.\r\n\r\n      if (history) {\r\n        history.push([].concat(args)); // only store 1000 history entries\r\n\r\n        var splice = history.length - 1000;\r\n        history.splice(0, splice > 0 ? splice : 0);\r\n      } // If there's no console then don't try to output messages, but they will\r\n      // still be stored in history.\r\n\r\n\r\n      if (!window.console) {\r\n        return;\r\n      } // Was setting these once outside of this function, but containing them\r\n      // in the function makes it easier to test cases where console doesn't exist\r\n      // when the module is executed.\r\n\r\n\r\n      var fn = window.console[type];\r\n\r\n      if (!fn && type === 'debug') {\r\n        // Certain browsers don't have support for console.debug. For those, we\r\n        // should default to the closest comparable log.\r\n        fn = window.console.info || window.console.log;\r\n      } // Bail out if there's no console or if this type is not allowed by the\r\n      // current logging level.\r\n\r\n\r\n      if (!fn || !lvl || !lvlRegExp.test(type)) {\r\n        return;\r\n      }\r\n\r\n      fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);\r\n    };\r\n  };\r\n\r\n  function createLogger$1(name) {\r\n    // This is the private tracking variable for logging level.\r\n    var level = 'info'; // the curried logByType bound to the specific log and history\r\n\r\n    var logByType;\r\n    /**\r\n     * Logs plain debug messages. Similar to `console.log`.\r\n     *\r\n     * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\r\n     * of our JSDoc template, we cannot properly document this as both a function\r\n     * and a namespace, so its function signature is documented here.\r\n     *\r\n     * #### Arguments\r\n     * ##### *args\r\n     * Mixed[]\r\n     *\r\n     * Any combination of values that could be passed to `console.log()`.\r\n     *\r\n     * #### Return Value\r\n     *\r\n     * `undefined`\r\n     *\r\n     * @namespace\r\n     * @param    {Mixed[]} args\r\n     *           One or more messages or objects that should be logged.\r\n     */\r\n\r\n    var log = function log() {\r\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args[_key] = arguments[_key];\r\n      }\r\n\r\n      logByType('log', level, args);\r\n    }; // This is the logByType helper that the logging methods below use\r\n\r\n\r\n    logByType = LogByTypeFactory(name, log);\r\n    /**\r\n     * Create a new sublogger which chains the old name to the new name.\r\n     *\r\n     * For example, doing `videojs.log.createLogger('player')` and then using that logger will log the following:\r\n     * ```js\r\n     *  mylogger('foo');\r\n     *  // > VIDEOJS: player: foo\r\n     * ```\r\n     *\r\n     * @param {string} name\r\n     *        The name to add call the new logger\r\n     * @return {Object}\r\n     */\r\n\r\n    log.createLogger = function (subname) {\r\n      return createLogger$1(name + ': ' + subname);\r\n    };\r\n    /**\r\n     * Enumeration of available logging levels, where the keys are the level names\r\n     * and the values are `|`-separated strings containing logging methods allowed\r\n     * in that logging level. These strings are used to create a regular expression\r\n     * matching the function name being called.\r\n     *\r\n     * Levels provided by Video.js are:\r\n     *\r\n     * - `off`: Matches no calls. Any value that can be cast to `false` will have\r\n     *   this effect. The most restrictive.\r\n     * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\r\n     *   `log.warn`, and `log.error`).\r\n     * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\r\n     * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\r\n     * - `warn`: Matches `log.warn` and `log.error` calls.\r\n     * - `error`: Matches only `log.error` calls.\r\n     *\r\n     * @type {Object}\r\n     */\r\n\r\n\r\n    log.levels = {\r\n      all: 'debug|log|warn|error',\r\n      off: '',\r\n      debug: 'debug|log|warn|error',\r\n      info: 'log|warn|error',\r\n      warn: 'warn|error',\r\n      error: 'error',\r\n      DEFAULT: level\r\n    };\r\n    /**\r\n     * Get or set the current logging level.\r\n     *\r\n     * If a string matching a key from {@link module:log.levels} is provided, acts\r\n     * as a setter.\r\n     *\r\n     * @param  {string} [lvl]\r\n     *         Pass a valid level to set a new logging level.\r\n     *\r\n     * @return {string}\r\n     *         The current logging level.\r\n     */\r\n\r\n    log.level = function (lvl) {\r\n      if (typeof lvl === 'string') {\r\n        if (!log.levels.hasOwnProperty(lvl)) {\r\n          throw new Error(\"\\\"\" + lvl + \"\\\" in not a valid log level\");\r\n        }\r\n\r\n        level = lvl;\r\n      }\r\n\r\n      return level;\r\n    };\r\n    /**\r\n     * Returns an array containing everything that has been logged to the history.\r\n     *\r\n     * This array is a shallow clone of the internal history record. However, its\r\n     * contents are _not_ cloned; so, mutating objects inside this array will\r\n     * mutate them in history.\r\n     *\r\n     * @return {Array}\r\n     */\r\n\r\n\r\n    log.history = function () {\r\n      return history ? [].concat(history) : [];\r\n    };\r\n    /**\r\n     * Allows you to filter the history by the given logger name\r\n     *\r\n     * @param {string} fname\r\n     *        The name to filter by\r\n     *\r\n     * @return {Array}\r\n     *         The filtered list to return\r\n     */\r\n\r\n\r\n    log.history.filter = function (fname) {\r\n      return (history || []).filter(function (historyItem) {\r\n        // if the first item in each historyItem includes `fname`, then it's a match\r\n        return new RegExp(\".*\" + fname + \".*\").test(historyItem[0]);\r\n      });\r\n    };\r\n    /**\r\n     * Clears the internal history tracking, but does not prevent further history\r\n     * tracking.\r\n     */\r\n\r\n\r\n    log.history.clear = function () {\r\n      if (history) {\r\n        history.length = 0;\r\n      }\r\n    };\r\n    /**\r\n     * Disable history tracking if it is currently enabled.\r\n     */\r\n\r\n\r\n    log.history.disable = function () {\r\n      if (history !== null) {\r\n        history.length = 0;\r\n        history = null;\r\n      }\r\n    };\r\n    /**\r\n     * Enable history tracking if it is currently disabled.\r\n     */\r\n\r\n\r\n    log.history.enable = function () {\r\n      if (history === null) {\r\n        history = [];\r\n      }\r\n    };\r\n    /**\r\n     * Logs error messages. Similar to `console.error`.\r\n     *\r\n     * @param {Mixed[]} args\r\n     *        One or more messages or objects that should be logged as an error\r\n     */\r\n\r\n\r\n    log.error = function () {\r\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n        args[_key2] = arguments[_key2];\r\n      }\r\n\r\n      return logByType('error', level, args);\r\n    };\r\n    /**\r\n     * Logs warning messages. Similar to `console.warn`.\r\n     *\r\n     * @param {Mixed[]} args\r\n     *        One or more messages or objects that should be logged as a warning.\r\n     */\r\n\r\n\r\n    log.warn = function () {\r\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\r\n        args[_key3] = arguments[_key3];\r\n      }\r\n\r\n      return logByType('warn', level, args);\r\n    };\r\n    /**\r\n     * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\r\n     * log if `console.debug` is not available\r\n     *\r\n     * @param {Mixed[]} args\r\n     *        One or more messages or objects that should be logged as debug.\r\n     */\r\n\r\n\r\n    log.debug = function () {\r\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\r\n        args[_key4] = arguments[_key4];\r\n      }\r\n\r\n      return logByType('debug', level, args);\r\n    };\r\n\r\n    return log;\r\n  }\r\n\r\n  /**\r\n   * @file log.js\r\n   * @module log\r\n   */\r\n  var log$1 = createLogger$1('VIDEOJS');\r\n  var createLogger = log$1.createLogger;\r\n\r\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\r\n\r\n  function createCommonjsModule(fn, module) {\r\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\r\n  }\r\n\r\n  var _extends_1 = createCommonjsModule(function (module) {\r\n    function _extends() {\r\n      module.exports = _extends = Object.assign || function (target) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n          var source = arguments[i];\r\n\r\n          for (var key in source) {\r\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n              target[key] = source[key];\r\n            }\r\n          }\r\n        }\r\n\r\n        return target;\r\n      };\r\n\r\n      return _extends.apply(this, arguments);\r\n    }\r\n\r\n    module.exports = _extends;\r\n  });\r\n\r\n  /**\r\n   * @file obj.js\r\n   * @module obj\r\n   */\r\n\r\n  /**\r\n   * @callback obj:EachCallback\r\n   *\r\n   * @param {Mixed} value\r\n   *        The current key for the object that is being iterated over.\r\n   *\r\n   * @param {string} key\r\n   *        The current key-value for object that is being iterated over\r\n   */\r\n\r\n  /**\r\n   * @callback obj:ReduceCallback\r\n   *\r\n   * @param {Mixed} accum\r\n   *        The value that is accumulating over the reduce loop.\r\n   *\r\n   * @param {Mixed} value\r\n   *        The current key for the object that is being iterated over.\r\n   *\r\n   * @param {string} key\r\n   *        The current key-value for object that is being iterated over\r\n   *\r\n   * @return {Mixed}\r\n   *         The new accumulated value.\r\n   */\r\n  var toString$1 = Object.prototype.toString;\r\n  /**\r\n   * Get the keys of an Object\r\n   *\r\n   * @param {Object}\r\n   *        The Object to get the keys from\r\n   *\r\n   * @return {string[]}\r\n   *         An array of the keys from the object. Returns an empty array if the\r\n   *         object passed in was invalid or had no keys.\r\n   *\r\n   * @private\r\n   */\r\n\r\n  var keys = function keys(object) {\r\n    return isObject$1(object) ? Object.keys(object) : [];\r\n  };\r\n  /**\r\n   * Array-like iteration for objects.\r\n   *\r\n   * @param {Object} object\r\n   *        The object to iterate over\r\n   *\r\n   * @param {obj:EachCallback} fn\r\n   *        The callback function which is called for each key in the object.\r\n   */\r\n\r\n\r\n  function each(object, fn) {\r\n    keys(object).forEach(function (key) {\r\n      return fn(object[key], key);\r\n    });\r\n  }\r\n  /**\r\n   * Array-like reduce for objects.\r\n   *\r\n   * @param {Object} object\r\n   *        The Object that you want to reduce.\r\n   *\r\n   * @param {Function} fn\r\n   *         A callback function which is called for each key in the object. It\r\n   *         receives the accumulated value and the per-iteration value and key\r\n   *         as arguments.\r\n   *\r\n   * @param {Mixed} [initial = 0]\r\n   *        Starting value\r\n   *\r\n   * @return {Mixed}\r\n   *         The final accumulated value.\r\n   */\r\n\r\n  function reduce(object, fn, initial) {\r\n    if (initial === void 0) {\r\n      initial = 0;\r\n    }\r\n\r\n    return keys(object).reduce(function (accum, key) {\r\n      return fn(accum, object[key], key);\r\n    }, initial);\r\n  }\r\n  /**\r\n   * Object.assign-style object shallow merge/extend.\r\n   *\r\n   * @param  {Object} target\r\n   * @param  {Object} ...sources\r\n   * @return {Object}\r\n   */\r\n\r\n  function assign(target) {\r\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n      sources[_key - 1] = arguments[_key];\r\n    }\r\n\r\n    if (Object.assign) {\r\n      return _extends_1.apply(void 0, [target].concat(sources));\r\n    }\r\n\r\n    sources.forEach(function (source) {\r\n      if (!source) {\r\n        return;\r\n      }\r\n\r\n      each(source, function (value, key) {\r\n        target[key] = value;\r\n      });\r\n    });\r\n    return target;\r\n  }\r\n  /**\r\n   * Returns whether a value is an object of any kind - including DOM nodes,\r\n   * arrays, regular expressions, etc. Not functions, though.\r\n   *\r\n   * This avoids the gotcha where using `typeof` on a `null` value\r\n   * results in `'object'`.\r\n   *\r\n   * @param  {Object} value\r\n   * @return {boolean}\r\n   */\r\n\r\n  function isObject$1(value) {\r\n    return !!value && typeof value === 'object';\r\n  }\r\n  /**\r\n   * Returns whether an object appears to be a \"plain\" object - that is, a\r\n   * direct instance of `Object`.\r\n   *\r\n   * @param  {Object} value\r\n   * @return {boolean}\r\n   */\r\n\r\n  function isPlain(value) {\r\n    return isObject$1(value) && toString$1.call(value) === '[object Object]' && value.constructor === Object;\r\n  }\r\n\r\n  /**\r\n   * @file computed-style.js\r\n   * @module computed-style\r\n   */\r\n\r\n  /**\r\n   * A safe getComputedStyle.\r\n   *\r\n   * This is needed because in Firefox, if the player is loaded in an iframe with\r\n   * `display:none`, then `getComputedStyle` returns `null`, so, we do a\r\n   * null-check to make sure that the player doesn't break in these cases.\r\n   *\r\n   * @function\r\n   * @param    {Element} el\r\n   *           The element you want the computed style of\r\n   *\r\n   * @param    {string} prop\r\n   *           The property name you want\r\n   *\r\n   * @see      https://bugzilla.mozilla.org/show_bug.cgi?id=548397\r\n   */\r\n  function computedStyle(el, prop) {\r\n    if (!el || !prop) {\r\n      return '';\r\n    }\r\n\r\n    if (typeof window.getComputedStyle === 'function') {\r\n      var computedStyleValue;\r\n\r\n      try {\r\n        computedStyleValue = window.getComputedStyle(el);\r\n      } catch (e) {\r\n        return '';\r\n      }\r\n\r\n      return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * @file browser.js\r\n   * @module browser\r\n   */\r\n  var USER_AGENT = window.navigator && window.navigator.userAgent || '';\r\n  var webkitVersionMap = /AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);\r\n  var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\r\n  /**\r\n   * Whether or not this device is an iPod.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_IPOD = /iPod/i.test(USER_AGENT);\r\n  /**\r\n   * The detected iOS version - or `null`.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {string|null}\r\n   */\r\n\r\n  var IOS_VERSION = function () {\r\n    var match = USER_AGENT.match(/OS (\\d+)_/i);\r\n\r\n    if (match && match[1]) {\r\n      return match[1];\r\n    }\r\n\r\n    return null;\r\n  }();\r\n  /**\r\n   * Whether or not this is an Android device.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_ANDROID = /Android/i.test(USER_AGENT);\r\n  /**\r\n   * The detected Android version - or `null`.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {number|string|null}\r\n   */\r\n\r\n  var ANDROID_VERSION = function () {\r\n    // This matches Android Major.Minor.Patch versions\r\n    // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\r\n    var match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\r\n\r\n    if (!match) {\r\n      return null;\r\n    }\r\n\r\n    var major = match[1] && parseFloat(match[1]);\r\n    var minor = match[2] && parseFloat(match[2]);\r\n\r\n    if (major && minor) {\r\n      return parseFloat(match[1] + '.' + match[2]);\r\n    } else if (major) {\r\n      return major;\r\n    }\r\n\r\n    return null;\r\n  }();\r\n  /**\r\n   * Whether or not this is a native Android browser.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\r\n  /**\r\n   * Whether or not this is Mozilla Firefox.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_FIREFOX = /Firefox/i.test(USER_AGENT);\r\n  /**\r\n   * Whether or not this is Microsoft Edge.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_EDGE = /Edg/i.test(USER_AGENT);\r\n  /**\r\n   * Whether or not this is Google Chrome.\r\n   *\r\n   * This will also be `true` for Chrome on iOS, which will have different support\r\n   * as it is actually Safari under the hood.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));\r\n  /**\r\n   * The detected Google Chrome version - or `null`.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {number|null}\r\n   */\r\n\r\n  var CHROME_VERSION = function () {\r\n    var match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\r\n\r\n    if (match && match[2]) {\r\n      return parseFloat(match[2]);\r\n    }\r\n\r\n    return null;\r\n  }();\r\n  /**\r\n   * The detected Internet Explorer version - or `null`.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {number|null}\r\n   */\r\n\r\n  var IE_VERSION = function () {\r\n    var result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\r\n    var version = result && parseFloat(result[1]);\r\n\r\n    if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\r\n      // IE 11 has a different user agent string than other IE versions\r\n      version = 11.0;\r\n    }\r\n\r\n    return version;\r\n  }();\r\n  /**\r\n   * Whether or not this is desktop Safari.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\r\n  /**\r\n   * Whether or not this is a Windows machine.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_WINDOWS = /Windows/i.test(USER_AGENT);\r\n  /**\r\n   * Whether or not this device is touch-enabled.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));\r\n  /**\r\n   * Whether or not this device is an iPad.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);\r\n  /**\r\n   * Whether or not this device is an iPhone.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n  // The Facebook app's UIWebView identifies as both an iPhone and iPad, so\r\n  // to identify iPhones, we need to exclude iPads.\r\n  // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\r\n\r\n  var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\r\n  /**\r\n   * Whether or not this is an iOS device.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\r\n  /**\r\n   * Whether or not this is any flavor of Safari - including iOS.\r\n   *\r\n   * @static\r\n   * @const\r\n   * @type {Boolean}\r\n   */\r\n\r\n  var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\r\n\r\n  var browser = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    IS_IPOD: IS_IPOD,\r\n    IOS_VERSION: IOS_VERSION,\r\n    IS_ANDROID: IS_ANDROID,\r\n    ANDROID_VERSION: ANDROID_VERSION,\r\n    IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,\r\n    IS_FIREFOX: IS_FIREFOX,\r\n    IS_EDGE: IS_EDGE,\r\n    IS_CHROME: IS_CHROME,\r\n    CHROME_VERSION: CHROME_VERSION,\r\n    IE_VERSION: IE_VERSION,\r\n    IS_SAFARI: IS_SAFARI,\r\n    IS_WINDOWS: IS_WINDOWS,\r\n    TOUCH_ENABLED: TOUCH_ENABLED,\r\n    IS_IPAD: IS_IPAD,\r\n    IS_IPHONE: IS_IPHONE,\r\n    IS_IOS: IS_IOS,\r\n    IS_ANY_SAFARI: IS_ANY_SAFARI\r\n  });\r\n\r\n  /**\r\n   * @file dom.js\r\n   * @module dom\r\n   */\r\n  /**\r\n   * Detect if a value is a string with any non-whitespace characters.\r\n   *\r\n   * @private\r\n   * @param  {string} str\r\n   *         The string to check\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if the string is non-blank, `false` otherwise.\r\n   *\r\n   */\r\n\r\n  function isNonBlankString(str) {\r\n    // we use str.trim as it will trim any whitespace characters\r\n    // from the front or back of non-whitespace characters. aka\r\n    // Any string that contains non-whitespace characters will\r\n    // still contain them after `trim` but whitespace only strings\r\n    // will have a length of 0, failing this check.\r\n    return typeof str === 'string' && Boolean(str.trim());\r\n  }\r\n  /**\r\n   * Throws an error if the passed string has whitespace. This is used by\r\n   * class methods to be relatively consistent with the classList API.\r\n   *\r\n   * @private\r\n   * @param  {string} str\r\n   *         The string to check for whitespace.\r\n   *\r\n   * @throws {Error}\r\n   *         Throws an error if there is whitespace in the string.\r\n   */\r\n\r\n\r\n  function throwIfWhitespace(str) {\r\n    // str.indexOf instead of regex because str.indexOf is faster performance wise.\r\n    if (str.indexOf(' ') >= 0) {\r\n      throw new Error('class has illegal whitespace characters');\r\n    }\r\n  }\r\n  /**\r\n   * Produce a regular expression for matching a className within an elements className.\r\n   *\r\n   * @private\r\n   * @param  {string} className\r\n   *         The className to generate the RegExp for.\r\n   *\r\n   * @return {RegExp}\r\n   *         The RegExp that will check for a specific `className` in an elements\r\n   *         className.\r\n   */\r\n\r\n\r\n  function classRegExp(className) {\r\n    return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\r\n  }\r\n  /**\r\n   * Whether the current DOM interface appears to be real (i.e. not simulated).\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if the DOM appears to be real, `false` otherwise.\r\n   */\r\n\r\n\r\n  function isReal() {\r\n    // Both document and window will never be undefined thanks to `global`.\r\n    return document === window.document;\r\n  }\r\n  /**\r\n   * Determines, via duck typing, whether or not a value is a DOM element.\r\n   *\r\n   * @param  {Mixed} value\r\n   *         The value to check.\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if the value is a DOM element, `false` otherwise.\r\n   */\r\n\r\n  function isEl(value) {\r\n    return isObject$1(value) && value.nodeType === 1;\r\n  }\r\n  /**\r\n   * Determines if the current DOM is embedded in an iframe.\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if the DOM is embedded in an iframe, `false`\r\n   *         otherwise.\r\n   */\r\n\r\n  function isInFrame() {\r\n    // We need a try/catch here because Safari will throw errors when attempting\r\n    // to get either `parent` or `self`\r\n    try {\r\n      return window.parent !== window.self;\r\n    } catch (x) {\r\n      return true;\r\n    }\r\n  }\r\n  /**\r\n   * Creates functions to query the DOM using a given method.\r\n   *\r\n   * @private\r\n   * @param   {string} method\r\n   *          The method to create the query with.\r\n   *\r\n   * @return  {Function}\r\n   *          The query method\r\n   */\r\n\r\n  function createQuerier(method) {\r\n    return function (selector, context) {\r\n      if (!isNonBlankString(selector)) {\r\n        return document[method](null);\r\n      }\r\n\r\n      if (isNonBlankString(context)) {\r\n        context = document.querySelector(context);\r\n      }\r\n\r\n      var ctx = isEl(context) ? context : document;\r\n      return ctx[method] && ctx[method](selector);\r\n    };\r\n  }\r\n  /**\r\n   * Creates an element and applies properties, attributes, and inserts content.\r\n   *\r\n   * @param  {string} [tagName='div']\r\n   *         Name of tag to be created.\r\n   *\r\n   * @param  {Object} [properties={}]\r\n   *         Element properties to be applied.\r\n   *\r\n   * @param  {Object} [attributes={}]\r\n   *         Element attributes to be applied.\r\n   *\r\n   * @param {module:dom~ContentDescriptor} content\r\n   *        A content descriptor object.\r\n   *\r\n   * @return {Element}\r\n   *         The element that was created.\r\n   */\r\n\r\n\r\n  function createEl(tagName, properties, attributes, content) {\r\n    if (tagName === void 0) {\r\n      tagName = 'div';\r\n    }\r\n\r\n    if (properties === void 0) {\r\n      properties = {};\r\n    }\r\n\r\n    if (attributes === void 0) {\r\n      attributes = {};\r\n    }\r\n\r\n    var el = document.createElement(tagName);\r\n    Object.getOwnPropertyNames(properties).forEach(function (propName) {\r\n      var val = properties[propName]; // See #2176\r\n      // We originally were accepting both properties and attributes in the\r\n      // same object, but that doesn't work so well.\r\n\r\n      if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\r\n        log$1.warn('Setting attributes in the second argument of createEl()\\n' + 'has been deprecated. Use the third argument instead.\\n' + (\"createEl(type, properties, attributes). Attempting to set \" + propName + \" to \" + val + \".\"));\r\n        el.setAttribute(propName, val); // Handle textContent since it's not supported everywhere and we have a\r\n        // method for it.\r\n      } else if (propName === 'textContent') {\r\n        textContent(el, val);\r\n      } else if (el[propName] !== val || propName === 'tabIndex') {\r\n        el[propName] = val;\r\n      }\r\n    });\r\n    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\r\n      el.setAttribute(attrName, attributes[attrName]);\r\n    });\r\n\r\n    if (content) {\r\n      appendContent(el, content);\r\n    }\r\n\r\n    return el;\r\n  }\r\n  /**\r\n   * Injects text into an element, replacing any existing contents entirely.\r\n   *\r\n   * @param  {Element} el\r\n   *         The element to add text content into\r\n   *\r\n   * @param  {string} text\r\n   *         The text content to add.\r\n   *\r\n   * @return {Element}\r\n   *         The element with added text content.\r\n   */\r\n\r\n  function textContent(el, text) {\r\n    if (typeof el.textContent === 'undefined') {\r\n      el.innerText = text;\r\n    } else {\r\n      el.textContent = text;\r\n    }\r\n\r\n    return el;\r\n  }\r\n  /**\r\n   * Insert an element as the first child node of another\r\n   *\r\n   * @param {Element} child\r\n   *        Element to insert\r\n   *\r\n   * @param {Element} parent\r\n   *        Element to insert child into\r\n   */\r\n\r\n  function prependTo(child, parent) {\r\n    if (parent.firstChild) {\r\n      parent.insertBefore(child, parent.firstChild);\r\n    } else {\r\n      parent.appendChild(child);\r\n    }\r\n  }\r\n  /**\r\n   * Check if an element has a class name.\r\n   *\r\n   * @param  {Element} element\r\n   *         Element to check\r\n   *\r\n   * @param  {string} classToCheck\r\n   *         Class name to check for\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if the element has a class, `false` otherwise.\r\n   *\r\n   * @throws {Error}\r\n   *         Throws an error if `classToCheck` has white space.\r\n   */\r\n\r\n  function hasClass(element, classToCheck) {\r\n    throwIfWhitespace(classToCheck);\r\n\r\n    if (element.classList) {\r\n      return element.classList.contains(classToCheck);\r\n    }\r\n\r\n    return classRegExp(classToCheck).test(element.className);\r\n  }\r\n  /**\r\n   * Add a class name to an element.\r\n   *\r\n   * @param  {Element} element\r\n   *         Element to add class name to.\r\n   *\r\n   * @param  {string} classToAdd\r\n   *         Class name to add.\r\n   *\r\n   * @return {Element}\r\n   *         The DOM element with the added class name.\r\n   */\r\n\r\n  function addClass(element, classToAdd) {\r\n    if (element.classList) {\r\n      element.classList.add(classToAdd); // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\r\n      // in the case of classList not being supported.\r\n    } else if (!hasClass(element, classToAdd)) {\r\n      element.className = (element.className + ' ' + classToAdd).trim();\r\n    }\r\n\r\n    return element;\r\n  }\r\n  /**\r\n   * Remove a class name from an element.\r\n   *\r\n   * @param  {Element} element\r\n   *         Element to remove a class name from.\r\n   *\r\n   * @param  {string} classToRemove\r\n   *         Class name to remove\r\n   *\r\n   * @return {Element}\r\n   *         The DOM element with class name removed.\r\n   */\r\n\r\n  function removeClass(element, classToRemove) {\r\n    // Protect in case the player gets disposed\r\n    if (!element) {\r\n      log$1.warn(\"removeClass was called with an element that doesn't exist\");\r\n      return null;\r\n    }\r\n\r\n    if (element.classList) {\r\n      element.classList.remove(classToRemove);\r\n    } else {\r\n      throwIfWhitespace(classToRemove);\r\n      element.className = element.className.split(/\\s+/).filter(function (c) {\r\n        return c !== classToRemove;\r\n      }).join(' ');\r\n    }\r\n\r\n    return element;\r\n  }\r\n  /**\r\n   * The callback definition for toggleClass.\r\n   *\r\n   * @callback module:dom~PredicateCallback\r\n   * @param    {Element} element\r\n   *           The DOM element of the Component.\r\n   *\r\n   * @param    {string} classToToggle\r\n   *           The `className` that wants to be toggled\r\n   *\r\n   * @return   {boolean|undefined}\r\n   *           If `true` is returned, the `classToToggle` will be added to the\r\n   *           `element`. If `false`, the `classToToggle` will be removed from\r\n   *           the `element`. If `undefined`, the callback will be ignored.\r\n   */\r\n\r\n  /**\r\n   * Adds or removes a class name to/from an element depending on an optional\r\n   * condition or the presence/absence of the class name.\r\n   *\r\n   * @param  {Element} element\r\n   *         The element to toggle a class name on.\r\n   *\r\n   * @param  {string} classToToggle\r\n   *         The class that should be toggled.\r\n   *\r\n   * @param  {boolean|module:dom~PredicateCallback} [predicate]\r\n   *         See the return value for {@link module:dom~PredicateCallback}\r\n   *\r\n   * @return {Element}\r\n   *         The element with a class that has been toggled.\r\n   */\r\n\r\n  function toggleClass(element, classToToggle, predicate) {\r\n    // This CANNOT use `classList` internally because IE11 does not support the\r\n    // second parameter to the `classList.toggle()` method! Which is fine because\r\n    // `classList` will be used by the add/remove functions.\r\n    var has = hasClass(element, classToToggle);\r\n\r\n    if (typeof predicate === 'function') {\r\n      predicate = predicate(element, classToToggle);\r\n    }\r\n\r\n    if (typeof predicate !== 'boolean') {\r\n      predicate = !has;\r\n    } // If the necessary class operation matches the current state of the\r\n    // element, no action is required.\r\n\r\n\r\n    if (predicate === has) {\r\n      return;\r\n    }\r\n\r\n    if (predicate) {\r\n      addClass(element, classToToggle);\r\n    } else {\r\n      removeClass(element, classToToggle);\r\n    }\r\n\r\n    return element;\r\n  }\r\n  /**\r\n   * Apply attributes to an HTML element.\r\n   *\r\n   * @param {Element} el\r\n   *        Element to add attributes to.\r\n   *\r\n   * @param {Object} [attributes]\r\n   *        Attributes to be applied.\r\n   */\r\n\r\n  function setAttributes(el, attributes) {\r\n    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\r\n      var attrValue = attributes[attrName];\r\n\r\n      if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\r\n        el.removeAttribute(attrName);\r\n      } else {\r\n        el.setAttribute(attrName, attrValue === true ? '' : attrValue);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Get an element's attribute values, as defined on the HTML tag.\r\n   *\r\n   * Attributes are not the same as properties. They're defined on the tag\r\n   * or with setAttribute.\r\n   *\r\n   * @param  {Element} tag\r\n   *         Element from which to get tag attributes.\r\n   *\r\n   * @return {Object}\r\n   *         All attributes of the element. Boolean attributes will be `true` or\r\n   *         `false`, others will be strings.\r\n   */\r\n\r\n  function getAttributes(tag) {\r\n    var obj = {}; // known boolean attributes\r\n    // we can check for matching boolean properties, but not all browsers\r\n    // and not all tags know about these attributes, so, we still want to check them manually\r\n\r\n    var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\r\n\r\n    if (tag && tag.attributes && tag.attributes.length > 0) {\r\n      var attrs = tag.attributes;\r\n\r\n      for (var i = attrs.length - 1; i >= 0; i--) {\r\n        var attrName = attrs[i].name;\r\n        var attrVal = attrs[i].value; // check for known booleans\r\n        // the matching element property will return a value for typeof\r\n\r\n        if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\r\n          // the value of an included boolean attribute is typically an empty\r\n          // string ('') which would equal false if we just check for a false value.\r\n          // we also don't want support bad code like autoplay='false'\r\n          attrVal = attrVal !== null ? true : false;\r\n        }\r\n\r\n        obj[attrName] = attrVal;\r\n      }\r\n    }\r\n\r\n    return obj;\r\n  }\r\n  /**\r\n   * Get the value of an element's attribute.\r\n   *\r\n   * @param {Element} el\r\n   *        A DOM element.\r\n   *\r\n   * @param {string} attribute\r\n   *        Attribute to get the value of.\r\n   *\r\n   * @return {string}\r\n   *         The value of the attribute.\r\n   */\r\n\r\n  function getAttribute(el, attribute) {\r\n    return el.getAttribute(attribute);\r\n  }\r\n  /**\r\n   * Set the value of an element's attribute.\r\n   *\r\n   * @param {Element} el\r\n   *        A DOM element.\r\n   *\r\n   * @param {string} attribute\r\n   *        Attribute to set.\r\n   *\r\n   * @param {string} value\r\n   *        Value to set the attribute to.\r\n   */\r\n\r\n  function setAttribute(el, attribute, value) {\r\n    el.setAttribute(attribute, value);\r\n  }\r\n  /**\r\n   * Remove an element's attribute.\r\n   *\r\n   * @param {Element} el\r\n   *        A DOM element.\r\n   *\r\n   * @param {string} attribute\r\n   *        Attribute to remove.\r\n   */\r\n\r\n  function removeAttribute(el, attribute) {\r\n    el.removeAttribute(attribute);\r\n  }\r\n  /**\r\n   * Attempt to block the ability to select text.\r\n   */\r\n\r\n  function blockTextSelection() {\r\n    document.body.focus();\r\n\r\n    document.onselectstart = function () {\r\n      return false;\r\n    };\r\n  }\r\n  /**\r\n   * Turn off text selection blocking.\r\n   */\r\n\r\n  function unblockTextSelection() {\r\n    document.onselectstart = function () {\r\n      return true;\r\n    };\r\n  }\r\n  /**\r\n   * Identical to the native `getBoundingClientRect` function, but ensures that\r\n   * the method is supported at all (it is in all browsers we claim to support)\r\n   * and that the element is in the DOM before continuing.\r\n   *\r\n   * This wrapper function also shims properties which are not provided by some\r\n   * older browsers (namely, IE8).\r\n   *\r\n   * Additionally, some browsers do not support adding properties to a\r\n   * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\r\n   * properties (except `x` and `y` which are not widely supported). This helps\r\n   * avoid implementations where keys are non-enumerable.\r\n   *\r\n   * @param  {Element} el\r\n   *         Element whose `ClientRect` we want to calculate.\r\n   *\r\n   * @return {Object|undefined}\r\n   *         Always returns a plain object - or `undefined` if it cannot.\r\n   */\r\n\r\n  function getBoundingClientRect(el) {\r\n    if (el && el.getBoundingClientRect && el.parentNode) {\r\n      var rect = el.getBoundingClientRect();\r\n      var result = {};\r\n      ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {\r\n        if (rect[k] !== undefined) {\r\n          result[k] = rect[k];\r\n        }\r\n      });\r\n\r\n      if (!result.height) {\r\n        result.height = parseFloat(computedStyle(el, 'height'));\r\n      }\r\n\r\n      if (!result.width) {\r\n        result.width = parseFloat(computedStyle(el, 'width'));\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }\r\n  /**\r\n   * Represents the position of a DOM element on the page.\r\n   *\r\n   * @typedef  {Object} module:dom~Position\r\n   *\r\n   * @property {number} left\r\n   *           Pixels to the left.\r\n   *\r\n   * @property {number} top\r\n   *           Pixels from the top.\r\n   */\r\n\r\n  /**\r\n   * Get the position of an element in the DOM.\r\n   *\r\n   * Uses `getBoundingClientRect` technique from John Resig.\r\n   *\r\n   * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\r\n   *\r\n   * @param  {Element} el\r\n   *         Element from which to get offset.\r\n   *\r\n   * @return {module:dom~Position}\r\n   *         The position of the element that was passed in.\r\n   */\r\n\r\n  function findPosition(el) {\r\n    if (!el || el && !el.offsetParent) {\r\n      return {\r\n        left: 0,\r\n        top: 0,\r\n        width: 0,\r\n        height: 0\r\n      };\r\n    }\r\n\r\n    var width = el.offsetWidth;\r\n    var height = el.offsetHeight;\r\n    var left = 0;\r\n    var top = 0;\r\n\r\n    while (el.offsetParent && el !== document[FullscreenApi.fullscreenElement]) {\r\n      left += el.offsetLeft;\r\n      top += el.offsetTop;\r\n      el = el.offsetParent;\r\n    }\r\n\r\n    return {\r\n      left: left,\r\n      top: top,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n  /**\r\n   * Represents x and y coordinates for a DOM element or mouse pointer.\r\n   *\r\n   * @typedef  {Object} module:dom~Coordinates\r\n   *\r\n   * @property {number} x\r\n   *           x coordinate in pixels\r\n   *\r\n   * @property {number} y\r\n   *           y coordinate in pixels\r\n   */\r\n\r\n  /**\r\n   * Get the pointer position within an element.\r\n   *\r\n   * The base on the coordinates are the bottom left of the element.\r\n   *\r\n   * @param  {Element} el\r\n   *         Element on which to get the pointer position on.\r\n   *\r\n   * @param  {EventTarget~Event} event\r\n   *         Event object.\r\n   *\r\n   * @return {module:dom~Coordinates}\r\n   *         A coordinates object corresponding to the mouse position.\r\n   *\r\n   */\r\n\r\n  function getPointerPosition(el, event) {\r\n    var translated = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n\r\n    if (IS_IOS) {\r\n      var item = el;\r\n\r\n      while (item && item.nodeName.toLowerCase() !== 'html') {\r\n        var transform = computedStyle(item, 'transform');\r\n\r\n        if (/^matrix/.test(transform)) {\r\n          var values = transform.slice(7, -1).split(/,\\s/).map(Number);\r\n          translated.x += values[4];\r\n          translated.y += values[5];\r\n        } else if (/^matrix3d/.test(transform)) {\r\n          var _values = transform.slice(9, -1).split(/,\\s/).map(Number);\r\n\r\n          translated.x += _values[12];\r\n          translated.y += _values[13];\r\n        }\r\n\r\n        item = item.parentNode;\r\n      }\r\n    }\r\n\r\n    var position = {};\r\n    var boxTarget = findPosition(event.target);\r\n    var box = findPosition(el);\r\n    var boxW = box.width;\r\n    var boxH = box.height;\r\n    var offsetY = event.offsetY - (box.top - boxTarget.top);\r\n    var offsetX = event.offsetX - (box.left - boxTarget.left);\r\n\r\n    if (event.changedTouches) {\r\n      offsetX = event.changedTouches[0].pageX - box.left;\r\n      offsetY = event.changedTouches[0].pageY + box.top;\r\n\r\n      if (IS_IOS) {\r\n        offsetX -= translated.x;\r\n        offsetY -= translated.y;\r\n      }\r\n    }\r\n\r\n    position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));\r\n    position.x = Math.max(0, Math.min(1, offsetX / boxW));\r\n    return position;\r\n  }\r\n  /**\r\n   * Determines, via duck typing, whether or not a value is a text node.\r\n   *\r\n   * @param  {Mixed} value\r\n   *         Check if this value is a text node.\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if the value is a text node, `false` otherwise.\r\n   */\r\n\r\n  function isTextNode(value) {\r\n    return isObject$1(value) && value.nodeType === 3;\r\n  }\r\n  /**\r\n   * Empties the contents of an element.\r\n   *\r\n   * @param  {Element} el\r\n   *         The element to empty children from\r\n   *\r\n   * @return {Element}\r\n   *         The element with no children\r\n   */\r\n\r\n  function emptyEl(el) {\r\n    while (el.firstChild) {\r\n      el.removeChild(el.firstChild);\r\n    }\r\n\r\n    return el;\r\n  }\r\n  /**\r\n   * This is a mixed value that describes content to be injected into the DOM\r\n   * via some method. It can be of the following types:\r\n   *\r\n   * Type       | Description\r\n   * -----------|-------------\r\n   * `string`   | The value will be normalized into a text node.\r\n   * `Element`  | The value will be accepted as-is.\r\n   * `TextNode` | The value will be accepted as-is.\r\n   * `Array`    | A one-dimensional array of strings, elements, text nodes, or functions. These functions should return a string, element, or text node (any other return value, like an array, will be ignored).\r\n   * `Function` | A function, which is expected to return a string, element, text node, or array - any of the other possible values described above. This means that a content descriptor could be a function that returns an array of functions, but those second-level functions must return strings, elements, or text nodes.\r\n   *\r\n   * @typedef {string|Element|TextNode|Array|Function} module:dom~ContentDescriptor\r\n   */\r\n\r\n  /**\r\n   * Normalizes content for eventual insertion into the DOM.\r\n   *\r\n   * This allows a wide range of content definition methods, but helps protect\r\n   * from falling into the trap of simply writing to `innerHTML`, which could\r\n   * be an XSS concern.\r\n   *\r\n   * The content for an element can be passed in multiple types and\r\n   * combinations, whose behavior is as follows:\r\n   *\r\n   * @param {module:dom~ContentDescriptor} content\r\n   *        A content descriptor value.\r\n   *\r\n   * @return {Array}\r\n   *         All of the content that was passed in, normalized to an array of\r\n   *         elements or text nodes.\r\n   */\r\n\r\n  function normalizeContent(content) {\r\n    // First, invoke content if it is a function. If it produces an array,\r\n    // that needs to happen before normalization.\r\n    if (typeof content === 'function') {\r\n      content = content();\r\n    } // Next up, normalize to an array, so one or many items can be normalized,\r\n    // filtered, and returned.\r\n\r\n\r\n    return (Array.isArray(content) ? content : [content]).map(function (value) {\r\n      // First, invoke value if it is a function to produce a new value,\r\n      // which will be subsequently normalized to a Node of some kind.\r\n      if (typeof value === 'function') {\r\n        value = value();\r\n      }\r\n\r\n      if (isEl(value) || isTextNode(value)) {\r\n        return value;\r\n      }\r\n\r\n      if (typeof value === 'string' && /\\S/.test(value)) {\r\n        return document.createTextNode(value);\r\n      }\r\n    }).filter(function (value) {\r\n      return value;\r\n    });\r\n  }\r\n  /**\r\n   * Normalizes and appends content to an element.\r\n   *\r\n   * @param  {Element} el\r\n   *         Element to append normalized content to.\r\n   *\r\n   * @param {module:dom~ContentDescriptor} content\r\n   *        A content descriptor value.\r\n   *\r\n   * @return {Element}\r\n   *         The element with appended normalized content.\r\n   */\r\n\r\n  function appendContent(el, content) {\r\n    normalizeContent(content).forEach(function (node) {\r\n      return el.appendChild(node);\r\n    });\r\n    return el;\r\n  }\r\n  /**\r\n   * Normalizes and inserts content into an element; this is identical to\r\n   * `appendContent()`, except it empties the element first.\r\n   *\r\n   * @param {Element} el\r\n   *        Element to insert normalized content into.\r\n   *\r\n   * @param {module:dom~ContentDescriptor} content\r\n   *        A content descriptor value.\r\n   *\r\n   * @return {Element}\r\n   *         The element with inserted normalized content.\r\n   */\r\n\r\n  function insertContent(el, content) {\r\n    return appendContent(emptyEl(el), content);\r\n  }\r\n  /**\r\n   * Check if an event was a single left click.\r\n   *\r\n   * @param  {EventTarget~Event} event\r\n   *         Event object.\r\n   *\r\n   * @return {boolean}\r\n   *         Will be `true` if a single left click, `false` otherwise.\r\n   */\r\n\r\n  function isSingleLeftClick(event) {\r\n    // Note: if you create something draggable, be sure to\r\n    // call it on both `mousedown` and `mousemove` event,\r\n    // otherwise `mousedown` should be enough for a button\r\n    if (event.button === undefined && event.buttons === undefined) {\r\n      // Why do we need `buttons` ?\r\n      // Because, middle mouse sometimes have this:\r\n      // e.button === 0 and e.buttons === 4\r\n      // Furthermore, we want to prevent combination click, something like\r\n      // HOLD middlemouse then left click, that would be\r\n      // e.button === 0, e.buttons === 5\r\n      // just `button` is not gonna work\r\n      // Alright, then what this block does ?\r\n      // this is for chrome `simulate mobile devices`\r\n      // I want to support this as well\r\n      return true;\r\n    }\r\n\r\n    if (event.button === 0 && event.buttons === undefined) {\r\n      // Touch screen, sometimes on some specific device, `buttons`\r\n      // doesn't have anything (safari on ios, blackberry...)\r\n      return true;\r\n    } // `mouseup` event on a single left click has\r\n    // `button` and `buttons` equal to 0\r\n\r\n\r\n    if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {\r\n      return true;\r\n    }\r\n\r\n    if (event.button !== 0 || event.buttons !== 1) {\r\n      // This is the reason we have those if else block above\r\n      // if any special case we can catch and let it slide\r\n      // we do it above, when get to here, this definitely\r\n      // is-not-left-click\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * Finds a single DOM element matching `selector` within the optional\r\n   * `context` of another DOM element (defaulting to `document`).\r\n   *\r\n   * @param  {string} selector\r\n   *         A valid CSS selector, which will be passed to `querySelector`.\r\n   *\r\n   * @param  {Element|String} [context=document]\r\n   *         A DOM element within which to query. Can also be a selector\r\n   *         string in which case the first matching element will be used\r\n   *         as context. If missing (or no element matches selector), falls\r\n   *         back to `document`.\r\n   *\r\n   * @return {Element|null}\r\n   *         The element that was found or null.\r\n   */\r\n\r\n  var $ = createQuerier('querySelector');\r\n  /**\r\n   * Finds a all DOM elements matching `selector` within the optional\r\n   * `context` of another DOM element (defaulting to `document`).\r\n   *\r\n   * @param  {string} selector\r\n   *         A valid CSS selector, which will be passed to `querySelectorAll`.\r\n   *\r\n   * @param  {Element|String} [context=document]\r\n   *         A DOM element within which to query. Can also be a selector\r\n   *         string in which case the first matching element will be used\r\n   *         as context. If missing (or no element matches selector), falls\r\n   *         back to `document`.\r\n   *\r\n   * @return {NodeList}\r\n   *         A element list of elements that were found. Will be empty if none\r\n   *         were found.\r\n   *\r\n   */\r\n\r\n  var $$ = createQuerier('querySelectorAll');\r\n\r\n  var Dom = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    isReal: isReal,\r\n    isEl: isEl,\r\n    isInFrame: isInFrame,\r\n    createEl: createEl,\r\n    textContent: textContent,\r\n    prependTo: prependTo,\r\n    hasClass: hasClass,\r\n    addClass: addClass,\r\n    removeClass: removeClass,\r\n    toggleClass: toggleClass,\r\n    setAttributes: setAttributes,\r\n    getAttributes: getAttributes,\r\n    getAttribute: getAttribute,\r\n    setAttribute: setAttribute,\r\n    removeAttribute: removeAttribute,\r\n    blockTextSelection: blockTextSelection,\r\n    unblockTextSelection: unblockTextSelection,\r\n    getBoundingClientRect: getBoundingClientRect,\r\n    findPosition: findPosition,\r\n    getPointerPosition: getPointerPosition,\r\n    isTextNode: isTextNode,\r\n    emptyEl: emptyEl,\r\n    normalizeContent: normalizeContent,\r\n    appendContent: appendContent,\r\n    insertContent: insertContent,\r\n    isSingleLeftClick: isSingleLeftClick,\r\n    $: $,\r\n    $$: $$\r\n  });\r\n\r\n  /**\r\n   * @file setup.js - Functions for setting up a player without\r\n   * user interaction based on the data-setup `attribute` of the video tag.\r\n   *\r\n   * @module setup\r\n   */\r\n  var _windowLoaded = false;\r\n  var videojs$1;\r\n  /**\r\n   * Set up any tags that have a data-setup `attribute` when the player is started.\r\n   */\r\n\r\n  var autoSetup = function autoSetup() {\r\n    if (videojs$1.options.autoSetup === false) {\r\n      return;\r\n    }\r\n\r\n    var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\r\n    var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\r\n    var divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));\r\n    var mediaEls = vids.concat(audios, divs); // Check if any media elements exist\r\n\r\n    if (mediaEls && mediaEls.length > 0) {\r\n      for (var i = 0, e = mediaEls.length; i < e; i++) {\r\n        var mediaEl = mediaEls[i]; // Check if element exists, has getAttribute func.\r\n\r\n        if (mediaEl && mediaEl.getAttribute) {\r\n          // Make sure this player hasn't already been set up.\r\n          if (mediaEl.player === undefined) {\r\n            var options = mediaEl.getAttribute('data-setup'); // Check if data-setup attr exists.\r\n            // We only auto-setup if they've added the data-setup attr.\r\n\r\n            if (options !== null) {\r\n              // Create new video.js instance.\r\n              videojs$1(mediaEl);\r\n            }\r\n          } // If getAttribute isn't defined, we need to wait for the DOM.\r\n\r\n        } else {\r\n          autoSetupTimeout(1);\r\n          break;\r\n        }\r\n      } // No videos were found, so keep looping unless page is finished loading.\r\n\r\n    } else if (!_windowLoaded) {\r\n      autoSetupTimeout(1);\r\n    }\r\n  };\r\n  /**\r\n   * Wait until the page is loaded before running autoSetup. This will be called in\r\n   * autoSetup if `hasLoaded` returns false.\r\n   *\r\n   * @param {number} wait\r\n   *        How long to wait in ms\r\n   *\r\n   * @param {module:videojs} [vjs]\r\n   *        The videojs library function\r\n   */\r\n\r\n\r\n  function autoSetupTimeout(wait, vjs) {\r\n    // Protect against breakage in non-browser environments\r\n    if (!isReal()) {\r\n      return;\r\n    }\r\n\r\n    if (vjs) {\r\n      videojs$1 = vjs;\r\n    }\r\n\r\n    window.setTimeout(autoSetup, wait);\r\n  }\r\n  /**\r\n   * Used to set the internal tracking of window loaded state to true.\r\n   *\r\n   * @private\r\n   */\r\n\r\n\r\n  function setWindowLoaded() {\r\n    _windowLoaded = true;\r\n    window.removeEventListener('load', setWindowLoaded);\r\n  }\r\n\r\n  if (isReal()) {\r\n    if (document.readyState === 'complete') {\r\n      setWindowLoaded();\r\n    } else {\r\n      /**\r\n       * Listen for the load event on window, and set _windowLoaded to true.\r\n       *\r\n       * We use a standard event listener here to avoid incrementing the GUID\r\n       * before any players are created.\r\n       *\r\n       * @listens load\r\n       */\r\n      window.addEventListener('load', setWindowLoaded);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @file stylesheet.js\r\n   * @module stylesheet\r\n   */\r\n\r\n  /**\r\n   * Create a DOM syle element given a className for it.\r\n   *\r\n   * @param {string} className\r\n   *        The className to add to the created style element.\r\n   *\r\n   * @return {Element}\r\n   *         The element that was created.\r\n   */\r\n  var createStyleElement = function createStyleElement(className) {\r\n    var style = document.createElement('style');\r\n    style.className = className;\r\n    return style;\r\n  };\r\n  /**\r\n   * Add text to a DOM element.\r\n   *\r\n   * @param {Element} el\r\n   *        The Element to add text content to.\r\n   *\r\n   * @param {string} content\r\n   *        The text to add to the element.\r\n   */\r\n\r\n  var setTextContent = function setTextContent(el, content) {\r\n    if (el.styleSheet) {\r\n      el.styleSheet.cssText = content;\r\n    } else {\r\n      el.textContent = content;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @file guid.js\r\n   * @module guid\r\n   */\r\n  // Default value for GUIDs. This allows us to reset the GUID counter in tests.\r\n  //\r\n  // The initial GUID is 3 because some users have come to rely on the first\r\n  // default player ID ending up as `vjs_video_3`.\r\n  //\r\n  // See: https://github.com/videojs/video.js/pull/6216\r\n  var _initialGuid = 3;\r\n  /**\r\n   * Unique ID for an element or function\r\n   *\r\n   * @type {Number}\r\n   */\r\n\r\n  var _guid = _initialGuid;\r\n  /**\r\n   * Get a unique auto-incrementing ID by number that has not been returned before.\r\n   *\r\n   * @return {number}\r\n   *         A new unique ID.\r\n   */\r\n\r\n  function newGUID() {\r\n    return _guid++;\r\n  }\r\n\r\n  /**\r\n   * @file dom-data.js\r\n   * @module dom-data\r\n   */\r\n  var FakeWeakMap;\r\n\r\n  if (!window.WeakMap) {\r\n    FakeWeakMap = /*#__PURE__*/function () {\r\n      function FakeWeakMap() {\r\n        this.vdata = 'vdata' + Math.floor(window.performance && window.performance.now() || Date.now());\r\n        this.data = {};\r\n      }\r\n\r\n      var _proto = FakeWeakMap.prototype;\r\n\r\n      _proto.set = function set(key, value) {\r\n        var access = key[this.vdata] || newGUID();\r\n\r\n        if (!key[this.vdata]) {\r\n          key[this.vdata] = access;\r\n        }\r\n\r\n        this.data[access] = value;\r\n        return this;\r\n      };\r\n\r\n      _proto.get = function get(key) {\r\n        var access = key[this.vdata]; // we have data, return it\r\n\r\n        if (access) {\r\n          return this.data[access];\r\n        } // we don't have data, return nothing.\r\n        // return undefined explicitly as that's the contract for this method\r\n\r\n\r\n        log$1('We have no data for this element', key);\r\n        return undefined;\r\n      };\r\n\r\n      _proto.has = function has(key) {\r\n        var access = key[this.vdata];\r\n        return access in this.data;\r\n      };\r\n\r\n      _proto[\"delete\"] = function _delete(key) {\r\n        var access = key[this.vdata];\r\n\r\n        if (access) {\r\n          delete this.data[access];\r\n          delete key[this.vdata];\r\n        }\r\n      };\r\n\r\n      return FakeWeakMap;\r\n    }();\r\n  }\r\n  /**\r\n   * Element Data Store.\r\n   *\r\n   * Allows for binding data to an element without putting it directly on the\r\n   * element. Ex. Event listeners are stored here.\r\n   * (also from jsninja.com, slightly modified and updated for closure compiler)\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  var DomData = window.WeakMap ? new WeakMap() : new FakeWeakMap();\r\n\r\n  /**\r\n   * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\r\n   * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\r\n   * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\r\n   * robust as jquery's, so there's probably some differences.\r\n   *\r\n   * @file events.js\r\n   * @module events\r\n   */\r\n  /**\r\n   * Clean up the listener cache and dispatchers\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Element to clean up\r\n   *\r\n   * @param {string} type\r\n   *        Type of event to clean up\r\n   */\r\n\r\n  function _cleanUpEvents(elem, type) {\r\n    if (!DomData.has(elem)) {\r\n      return;\r\n    }\r\n\r\n    var data = DomData.get(elem); // Remove the events of a particular type if there are none left\r\n\r\n    if (data.handlers[type].length === 0) {\r\n      delete data.handlers[type]; // data.handlers[type] = null;\r\n      // Setting to null was causing an error with data.handlers\r\n      // Remove the meta-handler from the element\r\n\r\n      if (elem.removeEventListener) {\r\n        elem.removeEventListener(type, data.dispatcher, false);\r\n      } else if (elem.detachEvent) {\r\n        elem.detachEvent('on' + type, data.dispatcher);\r\n      }\r\n    } // Remove the events object if there are no types left\r\n\r\n\r\n    if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\r\n      delete data.handlers;\r\n      delete data.dispatcher;\r\n      delete data.disabled;\r\n    } // Finally remove the element data if there is no data left\r\n\r\n\r\n    if (Object.getOwnPropertyNames(data).length === 0) {\r\n      DomData[\"delete\"](elem);\r\n    }\r\n  }\r\n  /**\r\n   * Loops through an array of event types and calls the requested method for each type.\r\n   *\r\n   * @param {Function} fn\r\n   *        The event method we want to use.\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Element or object to bind listeners to\r\n   *\r\n   * @param {string} type\r\n   *        Type of event to bind to.\r\n   *\r\n   * @param {EventTarget~EventListener} callback\r\n   *        Event listener.\r\n   */\r\n\r\n\r\n  function _handleMultipleEvents(fn, elem, types, callback) {\r\n    types.forEach(function (type) {\r\n      // Call the event method for each one of the types\r\n      fn(elem, type, callback);\r\n    });\r\n  }\r\n  /**\r\n   * Fix a native event to have standard property values\r\n   *\r\n   * @param {Object} event\r\n   *        Event object to fix.\r\n   *\r\n   * @return {Object}\r\n   *         Fixed event object.\r\n   */\r\n\r\n\r\n  function fixEvent(event) {\r\n    if (event.fixed_) {\r\n      return event;\r\n    }\r\n\r\n    function returnTrue() {\r\n      return true;\r\n    }\r\n\r\n    function returnFalse() {\r\n      return false;\r\n    } // Test if fixing up is needed\r\n    // Used to check if !event.stopPropagation instead of isPropagationStopped\r\n    // But native events return true for stopPropagation, but don't have\r\n    // other expected methods like isPropagationStopped. Seems to be a problem\r\n    // with the Javascript Ninja code. So we're just overriding all events now.\r\n\r\n\r\n    if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {\r\n      var old = event || window.event;\r\n      event = {}; // Clone the old object so that we can modify the values event = {};\r\n      // IE8 Doesn't like when you mess with native event properties\r\n      // Firefox returns false for event.hasOwnProperty('type') and other props\r\n      //  which makes copying more difficult.\r\n      // TODO: Probably best to create a whitelist of event props\r\n\r\n      for (var key in old) {\r\n        // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\r\n        // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\r\n        // and webkitMovementX/Y\r\n        // Lighthouse complains if Event.path is copied\r\n        if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY' && key !== 'path') {\r\n          // Chrome 32+ warns if you try to copy deprecated returnValue, but\r\n          // we still want to if preventDefault isn't supported (IE8).\r\n          if (!(key === 'returnValue' && old.preventDefault)) {\r\n            event[key] = old[key];\r\n          }\r\n        }\r\n      } // The event occurred on this element\r\n\r\n\r\n      if (!event.target) {\r\n        event.target = event.srcElement || document;\r\n      } // Handle which other element the event is related to\r\n\r\n\r\n      if (!event.relatedTarget) {\r\n        event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\r\n      } // Stop the default browser action\r\n\r\n\r\n      event.preventDefault = function () {\r\n        if (old.preventDefault) {\r\n          old.preventDefault();\r\n        }\r\n\r\n        event.returnValue = false;\r\n        old.returnValue = false;\r\n        event.defaultPrevented = true;\r\n      };\r\n\r\n      event.defaultPrevented = false; // Stop the event from bubbling\r\n\r\n      event.stopPropagation = function () {\r\n        if (old.stopPropagation) {\r\n          old.stopPropagation();\r\n        }\r\n\r\n        event.cancelBubble = true;\r\n        old.cancelBubble = true;\r\n        event.isPropagationStopped = returnTrue;\r\n      };\r\n\r\n      event.isPropagationStopped = returnFalse; // Stop the event from bubbling and executing other handlers\r\n\r\n      event.stopImmediatePropagation = function () {\r\n        if (old.stopImmediatePropagation) {\r\n          old.stopImmediatePropagation();\r\n        }\r\n\r\n        event.isImmediatePropagationStopped = returnTrue;\r\n        event.stopPropagation();\r\n      };\r\n\r\n      event.isImmediatePropagationStopped = returnFalse; // Handle mouse position\r\n\r\n      if (event.clientX !== null && event.clientX !== undefined) {\r\n        var doc = document.documentElement;\r\n        var body = document.body;\r\n        event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\r\n        event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\r\n      } // Handle key presses\r\n\r\n\r\n      event.which = event.charCode || event.keyCode; // Fix button for mouse clicks:\r\n      // 0 == left; 1 == middle; 2 == right\r\n\r\n      if (event.button !== null && event.button !== undefined) {\r\n        // The following is disabled because it does not pass videojs-standard\r\n        // and... yikes.\r\n\r\n        /* eslint-disable */\r\n        event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\r\n        /* eslint-enable */\r\n      }\r\n    }\r\n\r\n    event.fixed_ = true; // Returns fixed-up instance\r\n\r\n    return event;\r\n  }\r\n  /**\r\n   * Whether passive event listeners are supported\r\n   */\r\n\r\n  var _supportsPassive;\r\n\r\n  var supportsPassive = function supportsPassive() {\r\n    if (typeof _supportsPassive !== 'boolean') {\r\n      _supportsPassive = false;\r\n\r\n      try {\r\n        var opts = Object.defineProperty({}, 'passive', {\r\n          get: function get() {\r\n            _supportsPassive = true;\r\n          }\r\n        });\r\n        window.addEventListener('test', null, opts);\r\n        window.removeEventListener('test', null, opts);\r\n      } catch (e) {// disregard\r\n      }\r\n    }\r\n\r\n    return _supportsPassive;\r\n  };\r\n  /**\r\n   * Touch events Chrome expects to be passive\r\n   */\r\n\r\n\r\n  var passiveEvents = ['touchstart', 'touchmove'];\r\n  /**\r\n   * Add an event listener to element\r\n   * It stores the handler function in a separate cache object\r\n   * and adds a generic handler to the element's event,\r\n   * along with a unique id (guid) to the element.\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Element or object to bind listeners to\r\n   *\r\n   * @param {string|string[]} type\r\n   *        Type of event to bind to.\r\n   *\r\n   * @param {EventTarget~EventListener} fn\r\n   *        Event listener.\r\n   */\r\n\r\n  function on(elem, type, fn) {\r\n    if (Array.isArray(type)) {\r\n      return _handleMultipleEvents(on, elem, type, fn);\r\n    }\r\n\r\n    if (!DomData.has(elem)) {\r\n      DomData.set(elem, {});\r\n    }\r\n\r\n    var data = DomData.get(elem); // We need a place to store all our handler data\r\n\r\n    if (!data.handlers) {\r\n      data.handlers = {};\r\n    }\r\n\r\n    if (!data.handlers[type]) {\r\n      data.handlers[type] = [];\r\n    }\r\n\r\n    if (!fn.guid) {\r\n      fn.guid = newGUID();\r\n    }\r\n\r\n    data.handlers[type].push(fn);\r\n\r\n    if (!data.dispatcher) {\r\n      data.disabled = false;\r\n\r\n      data.dispatcher = function (event, hash) {\r\n        if (data.disabled) {\r\n          return;\r\n        }\r\n\r\n        event = fixEvent(event);\r\n        var handlers = data.handlers[event.type];\r\n\r\n        if (handlers) {\r\n          // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\r\n          var handlersCopy = handlers.slice(0);\r\n\r\n          for (var m = 0, n = handlersCopy.length; m < n; m++) {\r\n            if (event.isImmediatePropagationStopped()) {\r\n              break;\r\n            } else {\r\n              try {\r\n                handlersCopy[m].call(elem, event, hash);\r\n              } catch (e) {\r\n                log$1.error(e);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n    }\r\n\r\n    if (data.handlers[type].length === 1) {\r\n      if (elem.addEventListener) {\r\n        var options = false;\r\n\r\n        if (supportsPassive() && passiveEvents.indexOf(type) > -1) {\r\n          options = {\r\n            passive: true\r\n          };\r\n        }\r\n\r\n        elem.addEventListener(type, data.dispatcher, options);\r\n      } else if (elem.attachEvent) {\r\n        elem.attachEvent('on' + type, data.dispatcher);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Removes event listeners from an element\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Object to remove listeners from.\r\n   *\r\n   * @param {string|string[]} [type]\r\n   *        Type of listener to remove. Don't include to remove all events from element.\r\n   *\r\n   * @param {EventTarget~EventListener} [fn]\r\n   *        Specific listener to remove. Don't include to remove listeners for an event\r\n   *        type.\r\n   */\r\n\r\n  function off(elem, type, fn) {\r\n    // Don't want to add a cache object through getElData if not needed\r\n    if (!DomData.has(elem)) {\r\n      return;\r\n    }\r\n\r\n    var data = DomData.get(elem); // If no events exist, nothing to unbind\r\n\r\n    if (!data.handlers) {\r\n      return;\r\n    }\r\n\r\n    if (Array.isArray(type)) {\r\n      return _handleMultipleEvents(off, elem, type, fn);\r\n    } // Utility function\r\n\r\n\r\n    var removeType = function removeType(el, t) {\r\n      data.handlers[t] = [];\r\n\r\n      _cleanUpEvents(el, t);\r\n    }; // Are we removing all bound events?\r\n\r\n\r\n    if (type === undefined) {\r\n      for (var t in data.handlers) {\r\n        if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\r\n          removeType(elem, t);\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    var handlers = data.handlers[type]; // If no handlers exist, nothing to unbind\r\n\r\n    if (!handlers) {\r\n      return;\r\n    } // If no listener was provided, remove all listeners for type\r\n\r\n\r\n    if (!fn) {\r\n      removeType(elem, type);\r\n      return;\r\n    } // We're only removing a single handler\r\n\r\n\r\n    if (fn.guid) {\r\n      for (var n = 0; n < handlers.length; n++) {\r\n        if (handlers[n].guid === fn.guid) {\r\n          handlers.splice(n--, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    _cleanUpEvents(elem, type);\r\n  }\r\n  /**\r\n   * Trigger an event for an element\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Element to trigger an event on\r\n   *\r\n   * @param {EventTarget~Event|string} event\r\n   *        A string (the type) or an event object with a type attribute\r\n   *\r\n   * @param {Object} [hash]\r\n   *        data hash to pass along with the event\r\n   *\r\n   * @return {boolean|undefined}\r\n   *         Returns the opposite of `defaultPrevented` if default was\r\n   *         prevented. Otherwise, returns `undefined`\r\n   */\r\n\r\n  function trigger(elem, event, hash) {\r\n    // Fetches element data and a reference to the parent (for bubbling).\r\n    // Don't want to add a data object to cache for every parent,\r\n    // so checking hasElData first.\r\n    var elemData = DomData.has(elem) ? DomData.get(elem) : {};\r\n    var parent = elem.parentNode || elem.ownerDocument; // type = event.type || event,\r\n    // handler;\r\n    // If an event name was passed as a string, creates an event out of it\r\n\r\n    if (typeof event === 'string') {\r\n      event = {\r\n        type: event,\r\n        target: elem\r\n      };\r\n    } else if (!event.target) {\r\n      event.target = elem;\r\n    } // Normalizes the event properties.\r\n\r\n\r\n    event = fixEvent(event); // If the passed element has a dispatcher, executes the established handlers.\r\n\r\n    if (elemData.dispatcher) {\r\n      elemData.dispatcher.call(elem, event, hash);\r\n    } // Unless explicitly stopped or the event does not bubble (e.g. media events)\r\n    // recursively calls this function to bubble the event up the DOM.\r\n\r\n\r\n    if (parent && !event.isPropagationStopped() && event.bubbles === true) {\r\n      trigger.call(null, parent, event, hash); // If at the top of the DOM, triggers the default action unless disabled.\r\n    } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {\r\n      if (!DomData.has(event.target)) {\r\n        DomData.set(event.target, {});\r\n      }\r\n\r\n      var targetData = DomData.get(event.target); // Checks if the target has a default action for this event.\r\n\r\n      if (event.target[event.type]) {\r\n        // Temporarily disables event dispatching on the target as we have already executed the handler.\r\n        targetData.disabled = true; // Executes the default action.\r\n\r\n        if (typeof event.target[event.type] === 'function') {\r\n          event.target[event.type]();\r\n        } // Re-enables event dispatching.\r\n\r\n\r\n        targetData.disabled = false;\r\n      }\r\n    } // Inform the triggerer if the default was prevented by returning false\r\n\r\n\r\n    return !event.defaultPrevented;\r\n  }\r\n  /**\r\n   * Trigger a listener only once for an event.\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Element or object to bind to.\r\n   *\r\n   * @param {string|string[]} type\r\n   *        Name/type of event\r\n   *\r\n   * @param {Event~EventListener} fn\r\n   *        Event listener function\r\n   */\r\n\r\n  function one(elem, type, fn) {\r\n    if (Array.isArray(type)) {\r\n      return _handleMultipleEvents(one, elem, type, fn);\r\n    }\r\n\r\n    var func = function func() {\r\n      off(elem, type, func);\r\n      fn.apply(this, arguments);\r\n    }; // copy the guid to the new function so it can removed using the original function's ID\r\n\r\n\r\n    func.guid = fn.guid = fn.guid || newGUID();\r\n    on(elem, type, func);\r\n  }\r\n  /**\r\n   * Trigger a listener only once and then turn if off for all\r\n   * configured events\r\n   *\r\n   * @param {Element|Object} elem\r\n   *        Element or object to bind to.\r\n   *\r\n   * @param {string|string[]} type\r\n   *        Name/type of event\r\n   *\r\n   * @param {Event~EventListener} fn\r\n   *        Event listener function\r\n   */\r\n\r\n  function any(elem, type, fn) {\r\n    var func = function func() {\r\n      off(elem, type, func);\r\n      fn.apply(this, arguments);\r\n    }; // copy the guid to the new function so it can removed using the original function's ID\r\n\r\n\r\n    func.guid = fn.guid = fn.guid || newGUID(); // multiple ons, but one off for everything\r\n\r\n    on(elem, type, func);\r\n  }\r\n\r\n  var Events = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    fixEvent: fixEvent,\r\n    on: on,\r\n    off: off,\r\n    trigger: trigger,\r\n    one: one,\r\n    any: any\r\n  });\r\n\r\n  /**\r\n   * @file fn.js\r\n   * @module fn\r\n   */\r\n  var UPDATE_REFRESH_INTERVAL = 30;\r\n  /**\r\n   * Bind (a.k.a proxy or context). A simple method for changing the context of\r\n   * a function.\r\n   *\r\n   * It also stores a unique id on the function so it can be easily removed from\r\n   * events.\r\n   *\r\n   * @function\r\n   * @param    {Mixed} context\r\n   *           The object to bind as scope.\r\n   *\r\n   * @param    {Function} fn\r\n   *           The function to be bound to a scope.\r\n   *\r\n   * @param    {number} [uid]\r\n   *           An optional unique ID for the function to be set\r\n   *\r\n   * @return   {Function}\r\n   *           The new function that will be bound into the context given\r\n   */\r\n\r\n  var bind = function bind(context, fn, uid) {\r\n    // Make sure the function has a unique ID\r\n    if (!fn.guid) {\r\n      fn.guid = newGUID();\r\n    } // Create the new function that changes the context\r\n\r\n\r\n    var bound = fn.bind(context); // Allow for the ability to individualize this function\r\n    // Needed in the case where multiple objects might share the same prototype\r\n    // IF both items add an event listener with the same function, then you try to remove just one\r\n    // it will remove both because they both have the same guid.\r\n    // when using this, you need to use the bind method when you remove the listener as well.\r\n    // currently used in text tracks\r\n\r\n    bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\r\n    return bound;\r\n  };\r\n  /**\r\n   * Wraps the given function, `fn`, with a new function that only invokes `fn`\r\n   * at most once per every `wait` milliseconds.\r\n   *\r\n   * @function\r\n   * @param    {Function} fn\r\n   *           The function to be throttled.\r\n   *\r\n   * @param    {number}   wait\r\n   *           The number of milliseconds by which to throttle.\r\n   *\r\n   * @return   {Function}\r\n   */\r\n\r\n  var throttle = function throttle(fn, wait) {\r\n    var last = window.performance.now();\r\n\r\n    var throttled = function throttled() {\r\n      var now = window.performance.now();\r\n\r\n      if (now - last >= wait) {\r\n        fn.apply(void 0, arguments);\r\n        last = now;\r\n      }\r\n    };\r\n\r\n    return throttled;\r\n  };\r\n  /**\r\n   * Creates a debounced function that delays invoking `func` until after `wait`\r\n   * milliseconds have elapsed since the last time the debounced function was\r\n   * invoked.\r\n   *\r\n   * Inspired by lodash and underscore implementations.\r\n   *\r\n   * @function\r\n   * @param    {Function} func\r\n   *           The function to wrap with debounce behavior.\r\n   *\r\n   * @param    {number} wait\r\n   *           The number of milliseconds to wait after the last invocation.\r\n   *\r\n   * @param    {boolean} [immediate]\r\n   *           Whether or not to invoke the function immediately upon creation.\r\n   *\r\n   * @param    {Object} [context=window]\r\n   *           The \"context\" in which the debounced function should debounce. For\r\n   *           example, if this function should be tied to a Video.js player,\r\n   *           the player can be passed here. Alternatively, defaults to the\r\n   *           global `window` object.\r\n   *\r\n   * @return   {Function}\r\n   *           A debounced function.\r\n   */\r\n\r\n  var debounce = function debounce(func, wait, immediate, context) {\r\n    if (context === void 0) {\r\n      context = window;\r\n    }\r\n\r\n    var timeout;\r\n\r\n    var cancel = function cancel() {\r\n      context.clearTimeout(timeout);\r\n      timeout = null;\r\n    };\r\n    /* eslint-disable consistent-this */\r\n\r\n\r\n    var debounced = function debounced() {\r\n      var self = this;\r\n      var args = arguments;\r\n\r\n      var _later = function later() {\r\n        timeout = null;\r\n        _later = null;\r\n\r\n        if (!immediate) {\r\n          func.apply(self, args);\r\n        }\r\n      };\r\n\r\n      if (!timeout && immediate) {\r\n        func.apply(self, args);\r\n      }\r\n\r\n      context.clearTimeout(timeout);\r\n      timeout = context.setTimeout(_later, wait);\r\n    };\r\n    /* eslint-enable consistent-this */\r\n\r\n\r\n    debounced.cancel = cancel;\r\n    return debounced;\r\n  };\r\n\r\n  /**\r\n   * @file src/js/event-target.js\r\n   */\r\n  /**\r\n   * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\r\n   * adds shorthand functions that wrap around lengthy functions. For example:\r\n   * the `on` function is a wrapper around `addEventListener`.\r\n   *\r\n   * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\r\n   * @class EventTarget\r\n   */\r\n\r\n  var EventTarget$2 = function EventTarget() {};\r\n  /**\r\n   * A Custom DOM event.\r\n   *\r\n   * @typedef {Object} EventTarget~Event\r\n   * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\r\n   */\r\n\r\n  /**\r\n   * All event listeners should follow the following format.\r\n   *\r\n   * @callback EventTarget~EventListener\r\n   * @this {EventTarget}\r\n   *\r\n   * @param {EventTarget~Event} event\r\n   *        the event that triggered this function\r\n   *\r\n   * @param {Object} [hash]\r\n   *        hash of data sent during the event\r\n   */\r\n\r\n  /**\r\n   * An object containing event names as keys and booleans as values.\r\n   *\r\n   * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\r\n   *         will have extra functionality. See that function for more information.\r\n   *\r\n   * @property EventTarget.prototype.allowedEvents_\r\n   * @private\r\n   */\r\n\r\n\r\n  EventTarget$2.prototype.allowedEvents_ = {};\r\n  /**\r\n   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\r\n   * function that will get called when an event with a certain name gets triggered.\r\n   *\r\n   * @param {string|string[]} type\r\n   *        An event name or an array of event names.\r\n   *\r\n   * @param {EventTarget~EventListener} fn\r\n   *        The function to call with `EventTarget`s\r\n   */\r\n\r\n  EventTarget$2.prototype.on = function (type, fn) {\r\n    // Remove the addEventListener alias before calling Events.on\r\n    // so we don't get into an infinite type loop\r\n    var ael = this.addEventListener;\r\n\r\n    this.addEventListener = function () {};\r\n\r\n    on(this, type, fn);\r\n    this.addEventListener = ael;\r\n  };\r\n  /**\r\n   * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\r\n   * the standard DOM API.\r\n   *\r\n   * @function\r\n   * @see {@link EventTarget#on}\r\n   */\r\n\r\n\r\n  EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;\r\n  /**\r\n   * Removes an `event listener` for a specific event from an instance of `EventTarget`.\r\n   * This makes it so that the `event listener` will no longer get called when the\r\n   * named event happens.\r\n   *\r\n   * @param {string|string[]} type\r\n   *        An event name or an array of event names.\r\n   *\r\n   * @param {EventTarget~EventListener} fn\r\n   *        The function to remove.\r\n   */\r\n\r\n  EventTarget$2.prototype.off = function (type, fn) {\r\n    off(this, type, fn);\r\n  };\r\n  /**\r\n   * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\r\n   * the standard DOM API.\r\n   *\r\n   * @function\r\n   * @see {@link EventTarget#off}\r\n   */\r\n\r\n\r\n  EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;\r\n  /**\r\n   * This function will add an `event listener` that gets triggered only once. After the\r\n   * first trigger it will get removed. This is like adding an `event listener`\r\n   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\r\n   *\r\n   * @param {string|string[]} type\r\n   *        An event name or an array of event names.\r\n   *\r\n   * @param {EventTarget~EventListener} fn\r\n   *        The function to be called once for each event name.\r\n   */\r\n\r\n  EventTarget$2.prototype.one = function (type, fn) {\r\n    // Remove the addEventListener aliasing Events.on\r\n    // so we don't get into an infinite type loop\r\n    var ael = this.addEventListener;\r\n\r\n    this.addEventListener = function () {};\r\n\r\n    one(this, type, fn);\r\n    this.addEventListener = ael;\r\n  };\r\n\r\n  EventTarget$2.prototype.any = function (type, fn) {\r\n    // Remove the addEventListener aliasing Events.on\r\n    // so we don't get into an infinite type loop\r\n    var ael = this.addEventListener;\r\n\r\n    this.addEventListener = function () {};\r\n\r\n    any(this, type, fn);\r\n    this.addEventListener = ael;\r\n  };\r\n  /**\r\n   * This function causes an event to happen. This will then cause any `event listeners`\r\n   * that are waiting for that event, to get called. If there are no `event listeners`\r\n   * for an event then nothing will happen.\r\n   *\r\n   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\r\n   * Trigger will also call the `on` + `uppercaseEventName` function.\r\n   *\r\n   * Example:\r\n   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\r\n   * `onClick` if it exists.\r\n   *\r\n   * @param {string|EventTarget~Event|Object} event\r\n   *        The name of the event, an `Event`, or an object with a key of type set to\r\n   *        an event name.\r\n   */\r\n\r\n\r\n  EventTarget$2.prototype.trigger = function (event) {\r\n    var type = event.type || event; // deprecation\r\n    // In a future version we should default target to `this`\r\n    // similar to how we default the target to `elem` in\r\n    // `Events.trigger`. Right now the default `target` will be\r\n    // `document` due to the `Event.fixEvent` call.\r\n\r\n    if (typeof event === 'string') {\r\n      event = {\r\n        type: type\r\n      };\r\n    }\r\n\r\n    event = fixEvent(event);\r\n\r\n    if (this.allowedEvents_[type] && this['on' + type]) {\r\n      this['on' + type](event);\r\n    }\r\n\r\n    trigger(this, event);\r\n  };\r\n  /**\r\n   * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\r\n   * the standard DOM API.\r\n   *\r\n   * @function\r\n   * @see {@link EventTarget#trigger}\r\n   */\r\n\r\n\r\n  EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;\r\n  var EVENT_MAP;\r\n\r\n  EventTarget$2.prototype.queueTrigger = function (event) {\r\n    var _this = this;\r\n\r\n    // only set up EVENT_MAP if it'll be used\r\n    if (!EVENT_MAP) {\r\n      EVENT_MAP = new Map();\r\n    }\r\n\r\n    var type = event.type || event;\r\n    var map = EVENT_MAP.get(this);\r\n\r\n    if (!map) {\r\n      map = new Map();\r\n      EVENT_MAP.set(this, map);\r\n    }\r\n\r\n    var oldTimeout = map.get(type);\r\n    map[\"delete\"](type);\r\n    window.clearTimeout(oldTimeout);\r\n    var timeout = window.setTimeout(function () {\r\n      // if we cleared out all timeouts for the current target, delete its map\r\n      if (map.size === 0) {\r\n        map = null;\r\n        EVENT_MAP[\"delete\"](_this);\r\n      }\r\n\r\n      _this.trigger(event);\r\n    }, 0);\r\n    map.set(type, timeout);\r\n  };\r\n\r\n  /**\r\n   * @file mixins/evented.js\r\n   * @module evented\r\n   */\r\n\r\n  var objName = function objName(obj) {\r\n    if (typeof obj.name === 'function') {\r\n      return obj.name();\r\n    }\r\n\r\n    if (typeof obj.name === 'string') {\r\n      return obj.name;\r\n    }\r\n\r\n    if (obj.name_) {\r\n      return obj.name_;\r\n    }\r\n\r\n    if (obj.constructor && obj.constructor.name) {\r\n      return obj.constructor.name;\r\n    }\r\n\r\n    return typeof obj;\r\n  };\r\n  /**\r\n   * Returns whether or not an object has had the evented mixin applied.\r\n   *\r\n   * @param  {Object} object\r\n   *         An object to test.\r\n   *\r\n   * @return {boolean}\r\n   *         Whether or not the object appears to be evented.\r\n   */\r\n\r\n\r\n  var isEvented = function isEvented(object) {\r\n    return object instanceof EventTarget$2 || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {\r\n      return typeof object[k] === 'function';\r\n    });\r\n  };\r\n  /**\r\n   * Adds a callback to run after the evented mixin applied.\r\n   *\r\n   * @param  {Object} object\r\n   *         An object to Add\r\n   * @param  {Function} callback\r\n   *         The callback to run.\r\n   */\r\n\r\n\r\n  var addEventedCallback = function addEventedCallback(target, callback) {\r\n    if (isEvented(target)) {\r\n      callback();\r\n    } else {\r\n      if (!target.eventedCallbacks) {\r\n        target.eventedCallbacks = [];\r\n      }\r\n\r\n      target.eventedCallbacks.push(callback);\r\n    }\r\n  };\r\n  /**\r\n   * Whether a value is a valid event type - non-empty string or array.\r\n   *\r\n   * @private\r\n   * @param  {string|Array} type\r\n   *         The type value to test.\r\n   *\r\n   * @return {boolean}\r\n   *         Whether or not the type is a valid event type.\r\n   */\r\n\r\n\r\n  var isValidEventType = function isValidEventType(type) {\r\n    return (// The regex here verifies that the `type` contains at least one non-\r\n      // whitespace character.\r\n      typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length\r\n    );\r\n  };\r\n  /**\r\n   * Validates a value to determine if it is a valid event target. Throws if not.\r\n   *\r\n   * @private\r\n   * @throws {Error}\r\n   *         If the target does not appear to be a valid event target.\r\n   *\r\n   * @param  {Object} target\r\n   *         The object to test.\r\n   *\r\n   * @param  {Object} obj\r\n   *         The evented object we are validating for\r\n   *\r\n   * @param  {string} fnName\r\n   *         The name of the evented mixin function that called this.\r\n   */\r\n\r\n\r\n  var validateTarget = function validateTarget(target, obj, fnName) {\r\n    if (!target || !target.nodeName && !isEvented(target)) {\r\n      throw new Error(\"Invalid target for \" + objName(obj) + \"#\" + fnName + \"; must be a DOM node or evented object.\");\r\n    }\r\n  };\r\n  /**\r\n   * Validates a value to determine if it is a valid event target. Throws if not.\r\n   *\r\n   * @private\r\n   * @throws {Error}\r\n   *         If the type does not appear to be a valid event type.\r\n   *\r\n   * @param  {string|Array} type\r\n   *         The type to test.\r\n   *\r\n   * @param  {Object} obj\r\n  *         The evented object we are validating for\r\n   *\r\n   * @param  {string} fnName\r\n   *         The name of the evented mixin function that called this.\r\n   */\r\n\r\n\r\n  var validateEventType = function validateEventType(type, obj, fnName) {\r\n    if (!isValidEventType(type)) {\r\n      throw new Error(\"Invalid event type for \" + objName(obj) + \"#\" + fnName + \"; must be a non-empty string or array.\");\r\n    }\r\n  };\r\n  /**\r\n   * Validates a value to determine if it is a valid listener. Throws if not.\r\n   *\r\n   * @private\r\n   * @throws {Error}\r\n   *         If the listener is not a function.\r\n   *\r\n   * @param  {Function} listener\r\n   *         The listener to test.\r\n   *\r\n   * @param  {Object} obj\r\n   *         The evented object we are validating for\r\n   *\r\n   * @param  {string} fnName\r\n   *         The name of the evented mixin function that called this.\r\n   */\r\n\r\n\r\n  var validateListener = function validateListener(listener, obj, fnName) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error(\"Invalid listener for \" + objName(obj) + \"#\" + fnName + \"; must be a function.\");\r\n    }\r\n  };\r\n  /**\r\n   * Takes an array of arguments given to `on()` or `one()`, validates them, and\r\n   * normalizes them into an object.\r\n   *\r\n   * @private\r\n   * @param  {Object} self\r\n   *         The evented object on which `on()` or `one()` was called. This\r\n   *         object will be bound as the `this` value for the listener.\r\n   *\r\n   * @param  {Array} args\r\n   *         An array of arguments passed to `on()` or `one()`.\r\n   *\r\n   * @param  {string} fnName\r\n   *         The name of the evented mixin function that called this.\r\n   *\r\n   * @return {Object}\r\n   *         An object containing useful values for `on()` or `one()` calls.\r\n   */\r\n\r\n\r\n  var normalizeListenArgs = function normalizeListenArgs(self, args, fnName) {\r\n    // If the number of arguments is less than 3, the target is always the\r\n    // evented object itself.\r\n    var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\r\n    var target;\r\n    var type;\r\n    var listener;\r\n\r\n    if (isTargetingSelf) {\r\n      target = self.eventBusEl_; // Deal with cases where we got 3 arguments, but we are still listening to\r\n      // the evented object itself.\r\n\r\n      if (args.length >= 3) {\r\n        args.shift();\r\n      }\r\n\r\n      type = args[0];\r\n      listener = args[1];\r\n    } else {\r\n      target = args[0];\r\n      type = args[1];\r\n      listener = args[2];\r\n    }\r\n\r\n    validateTarget(target, self, fnName);\r\n    validateEventType(type, self, fnName);\r\n    validateListener(listener, self, fnName);\r\n    listener = bind(self, listener);\r\n    return {\r\n      isTargetingSelf: isTargetingSelf,\r\n      target: target,\r\n      type: type,\r\n      listener: listener\r\n    };\r\n  };\r\n  /**\r\n   * Adds the listener to the event type(s) on the target, normalizing for\r\n   * the type of target.\r\n   *\r\n   * @private\r\n   * @param  {Element|Object} target\r\n   *         A DOM node or evented object.\r\n   *\r\n   * @param  {string} method\r\n   *         The event binding method to use (\"on\" or \"one\").\r\n   *\r\n   * @param  {string|Array} type\r\n   *         One or more event type(s).\r\n   *\r\n   * @param  {Function} listener\r\n   *         A listener function.\r\n   */\r\n\r\n\r\n  var listen = function listen(target, method, type, listener) {\r\n    validateTarget(target, target, method);\r\n\r\n    if (target.nodeName) {\r\n      Events[method](target, type, listener);\r\n    } else {\r\n      target[method](type, listener);\r\n    }\r\n  };\r\n  /**\r\n   * Contains methods that provide event capabilities to an object which is passed\r\n   * to {@link module:evented|evented}.\r\n   *\r\n   * @mixin EventedMixin\r\n   */\r\n\r\n\r\n  var EventedMixin = {\r\n    /**\r\n     * Add a listener to an event (or events) on this object or another evented\r\n     * object.\r\n     *\r\n     * @param  {string|Array|Element|Object} targetOrType\r\n     *         If this is a string or array, it represents the event type(s)\r\n     *         that will trigger the listener.\r\n     *\r\n     *         Another evented object can be passed here instead, which will\r\n     *         cause the listener to listen for events on _that_ object.\r\n     *\r\n     *         In either case, the listener's `this` value will be bound to\r\n     *         this object.\r\n     *\r\n     * @param  {string|Array|Function} typeOrListener\r\n     *         If the first argument was a string or array, this should be the\r\n     *         listener function. Otherwise, this is a string or array of event\r\n     *         type(s).\r\n     *\r\n     * @param  {Function} [listener]\r\n     *         If the first argument was another evented object, this will be\r\n     *         the listener function.\r\n     */\r\n    on: function on() {\r\n      var _this = this;\r\n\r\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args[_key] = arguments[_key];\r\n      }\r\n\r\n      var _normalizeListenArgs = normalizeListenArgs(this, args, 'on'),\r\n          isTargetingSelf = _normalizeListenArgs.isTargetingSelf,\r\n          target = _normalizeListenArgs.target,\r\n          type = _normalizeListenArgs.type,\r\n          listener = _normalizeListenArgs.listener;\r\n\r\n      listen(target, 'on', type, listener); // If this object is listening to another evented object.\r\n\r\n      if (!isTargetingSelf) {\r\n        // If this object is disposed, remove the listener.\r\n        var removeListenerOnDispose = function removeListenerOnDispose() {\r\n          return _this.off(target, type, listener);\r\n        }; // Use the same function ID as the listener so we can remove it later it\r\n        // using the ID of the original listener.\r\n\r\n\r\n        removeListenerOnDispose.guid = listener.guid; // Add a listener to the target's dispose event as well. This ensures\r\n        // that if the target is disposed BEFORE this object, we remove the\r\n        // removal listener that was just added. Otherwise, we create a memory leak.\r\n\r\n        var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {\r\n          return _this.off('dispose', removeListenerOnDispose);\r\n        }; // Use the same function ID as the listener so we can remove it later\r\n        // it using the ID of the original listener.\r\n\r\n\r\n        removeRemoverOnTargetDispose.guid = listener.guid;\r\n        listen(this, 'on', 'dispose', removeListenerOnDispose);\r\n        listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Add a listener to an event (or events) on this object or another evented\r\n     * object. The listener will be called once per event and then removed.\r\n     *\r\n     * @param  {string|Array|Element|Object} targetOrType\r\n     *         If this is a string or array, it represents the event type(s)\r\n     *         that will trigger the listener.\r\n     *\r\n     *         Another evented object can be passed here instead, which will\r\n     *         cause the listener to listen for events on _that_ object.\r\n     *\r\n     *         In either case, the listener's `this` value will be bound to\r\n     *         this object.\r\n     *\r\n     * @param  {string|Array|Function} typeOrListener\r\n     *         If the first argument was a string or array, this should be the\r\n     *         listener function. Otherwise, this is a string or array of event\r\n     *         type(s).\r\n     *\r\n     * @param  {Function} [listener]\r\n     *         If the first argument was another evented object, this will be\r\n     *         the listener function.\r\n     */\r\n    one: function one() {\r\n      var _this2 = this;\r\n\r\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n        args[_key2] = arguments[_key2];\r\n      }\r\n\r\n      var _normalizeListenArgs2 = normalizeListenArgs(this, args, 'one'),\r\n          isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,\r\n          target = _normalizeListenArgs2.target,\r\n          type = _normalizeListenArgs2.type,\r\n          listener = _normalizeListenArgs2.listener; // Targeting this evented object.\r\n\r\n\r\n      if (isTargetingSelf) {\r\n        listen(target, 'one', type, listener); // Targeting another evented object.\r\n      } else {\r\n        // TODO: This wrapper is incorrect! It should only\r\n        //       remove the wrapper for the event type that called it.\r\n        //       Instead all listners are removed on the first trigger!\r\n        //       see https://github.com/videojs/video.js/issues/5962\r\n        var wrapper = function wrapper() {\r\n          _this2.off(target, type, wrapper);\r\n\r\n          for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\r\n            largs[_key3] = arguments[_key3];\r\n          }\r\n\r\n          listener.apply(null, largs);\r\n        }; // Use the same function ID as the listener so we can remove it later\r\n        // it using the ID of the original listener.\r\n\r\n\r\n        wrapper.guid = listener.guid;\r\n        listen(target, 'one', type, wrapper);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Add a listener to an event (or events) on this object or another evented\r\n     * object. The listener will only be called once for the first event that is triggered\r\n     * then removed.\r\n     *\r\n     * @param  {string|Array|Element|Object} targetOrType\r\n     *         If this is a string or array, it represents the event type(s)\r\n     *         that will trigger the listener.\r\n     *\r\n     *         Another evented object can be passed here instead, which will\r\n     *         cause the listener to listen for events on _that_ object.\r\n     *\r\n     *         In either case, the listener's `this` value will be bound to\r\n     *         this object.\r\n     *\r\n     * @param  {string|Array|Function} typeOrListener\r\n     *         If the first argument was a string or array, this should be the\r\n     *         listener function. Otherwise, this is a string or array of event\r\n     *         type(s).\r\n     *\r\n     * @param  {Function} [listener]\r\n     *         If the first argument was another evented object, this will be\r\n     *         the listener function.\r\n     */\r\n    any: function any() {\r\n      var _this3 = this;\r\n\r\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\r\n        args[_key4] = arguments[_key4];\r\n      }\r\n\r\n      var _normalizeListenArgs3 = normalizeListenArgs(this, args, 'any'),\r\n          isTargetingSelf = _normalizeListenArgs3.isTargetingSelf,\r\n          target = _normalizeListenArgs3.target,\r\n          type = _normalizeListenArgs3.type,\r\n          listener = _normalizeListenArgs3.listener; // Targeting this evented object.\r\n\r\n\r\n      if (isTargetingSelf) {\r\n        listen(target, 'any', type, listener); // Targeting another evented object.\r\n      } else {\r\n        var wrapper = function wrapper() {\r\n          _this3.off(target, type, wrapper);\r\n\r\n          for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\r\n            largs[_key5] = arguments[_key5];\r\n          }\r\n\r\n          listener.apply(null, largs);\r\n        }; // Use the same function ID as the listener so we can remove it later\r\n        // it using the ID of the original listener.\r\n\r\n\r\n        wrapper.guid = listener.guid;\r\n        listen(target, 'any', type, wrapper);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Removes listener(s) from event(s) on an evented object.\r\n     *\r\n     * @param  {string|Array|Element|Object} [targetOrType]\r\n     *         If this is a string or array, it represents the event type(s).\r\n     *\r\n     *         Another evented object can be passed here instead, in which case\r\n     *         ALL 3 arguments are _required_.\r\n     *\r\n     * @param  {string|Array|Function} [typeOrListener]\r\n     *         If the first argument was a string or array, this may be the\r\n     *         listener function. Otherwise, this is a string or array of event\r\n     *         type(s).\r\n     *\r\n     * @param  {Function} [listener]\r\n     *         If the first argument was another evented object, this will be\r\n     *         the listener function; otherwise, _all_ listeners bound to the\r\n     *         event type(s) will be removed.\r\n     */\r\n    off: function off$1(targetOrType, typeOrListener, listener) {\r\n      // Targeting this evented object.\r\n      if (!targetOrType || isValidEventType(targetOrType)) {\r\n        off(this.eventBusEl_, targetOrType, typeOrListener); // Targeting another evented object.\r\n      } else {\r\n        var target = targetOrType;\r\n        var type = typeOrListener; // Fail fast and in a meaningful way!\r\n\r\n        validateTarget(target, this, 'off');\r\n        validateEventType(type, this, 'off');\r\n        validateListener(listener, this, 'off'); // Ensure there's at least a guid, even if the function hasn't been used\r\n\r\n        listener = bind(this, listener); // Remove the dispose listener on this evented object, which was given\r\n        // the same guid as the event listener in on().\r\n\r\n        this.off('dispose', listener);\r\n\r\n        if (target.nodeName) {\r\n          off(target, type, listener);\r\n          off(target, 'dispose', listener);\r\n        } else if (isEvented(target)) {\r\n          target.off(type, listener);\r\n          target.off('dispose', listener);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Fire an event on this evented object, causing its listeners to be called.\r\n     *\r\n     * @param   {string|Object} event\r\n     *          An event type or an object with a type property.\r\n     *\r\n     * @param   {Object} [hash]\r\n     *          An additional object to pass along to listeners.\r\n     *\r\n     * @return {boolean}\r\n     *          Whether or not the default behavior was prevented.\r\n     */\r\n    trigger: function trigger$1(event, hash) {\r\n      validateTarget(this.eventBusEl_, this, 'trigger');\r\n      var type = event && typeof event !== 'string' ? event.type : event;\r\n\r\n      if (!isValidEventType(type)) {\r\n        var error = \"Invalid event type for \" + objName(this) + \"#trigger; \" + 'must be a non-empty string or object with a type key that has a non-empty value.';\r\n\r\n        if (event) {\r\n          (this.log || log$1).error(error);\r\n        } else {\r\n          throw new Error(error);\r\n        }\r\n      }\r\n\r\n      return trigger(this.eventBusEl_, event, hash);\r\n    }\r\n  };\r\n  /**\r\n   * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\r\n   *\r\n   * @param  {Object} target\r\n   *         The object to which to add event methods.\r\n   *\r\n   * @param  {Object} [options={}]\r\n   *         Options for customizing the mixin behavior.\r\n   *\r\n   * @param  {string} [options.eventBusKey]\r\n   *         By default, adds a `eventBusEl_` DOM element to the target object,\r\n   *         which is used as an event bus. If the target object already has a\r\n   *         DOM element that should be used, pass its key here.\r\n   *\r\n   * @return {Object}\r\n   *         The target object.\r\n   */\r\n\r\n  function evented(target, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var _options = options,\r\n        eventBusKey = _options.eventBusKey; // Set or create the eventBusEl_.\r\n\r\n    if (eventBusKey) {\r\n      if (!target[eventBusKey].nodeName) {\r\n        throw new Error(\"The eventBusKey \\\"\" + eventBusKey + \"\\\" does not refer to an element.\");\r\n      }\r\n\r\n      target.eventBusEl_ = target[eventBusKey];\r\n    } else {\r\n      target.eventBusEl_ = createEl('span', {\r\n        className: 'vjs-event-bus'\r\n      });\r\n    }\r\n\r\n    assign(target, EventedMixin);\r\n\r\n    if (target.eventedCallbacks) {\r\n      target.eventedCallbacks.forEach(function (callback) {\r\n        callback();\r\n      });\r\n    } // When any evented object is disposed, it removes all its listeners.\r\n\r\n\r\n    target.on('dispose', function () {\r\n      target.off();\r\n      [target, target.el_, target.eventBusEl_].forEach(function (val) {\r\n        if (val && DomData.has(val)) {\r\n          DomData[\"delete\"](val);\r\n        }\r\n      });\r\n      window.setTimeout(function () {\r\n        target.eventBusEl_ = null;\r\n      }, 0);\r\n    });\r\n    return target;\r\n  }\r\n\r\n  /**\r\n   * @file mixins/stateful.js\r\n   * @module stateful\r\n   */\r\n  /**\r\n   * Contains methods that provide statefulness to an object which is passed\r\n   * to {@link module:stateful}.\r\n   *\r\n   * @mixin StatefulMixin\r\n   */\r\n\r\n  var StatefulMixin = {\r\n    /**\r\n     * A hash containing arbitrary keys and values representing the state of\r\n     * the object.\r\n     *\r\n     * @type {Object}\r\n     */\r\n    state: {},\r\n\r\n    /**\r\n     * Set the state of an object by mutating its\r\n     * {@link module:stateful~StatefulMixin.state|state} object in place.\r\n     *\r\n     * @fires   module:stateful~StatefulMixin#statechanged\r\n     * @param   {Object|Function} stateUpdates\r\n     *          A new set of properties to shallow-merge into the plugin state.\r\n     *          Can be a plain object or a function returning a plain object.\r\n     *\r\n     * @return {Object|undefined}\r\n     *          An object containing changes that occurred. If no changes\r\n     *          occurred, returns `undefined`.\r\n     */\r\n    setState: function setState(stateUpdates) {\r\n      var _this = this;\r\n\r\n      // Support providing the `stateUpdates` state as a function.\r\n      if (typeof stateUpdates === 'function') {\r\n        stateUpdates = stateUpdates();\r\n      }\r\n\r\n      var changes;\r\n      each(stateUpdates, function (value, key) {\r\n        // Record the change if the value is different from what's in the\r\n        // current state.\r\n        if (_this.state[key] !== value) {\r\n          changes = changes || {};\r\n          changes[key] = {\r\n            from: _this.state[key],\r\n            to: value\r\n          };\r\n        }\r\n\r\n        _this.state[key] = value;\r\n      }); // Only trigger \"statechange\" if there were changes AND we have a trigger\r\n      // function. This allows us to not require that the target object be an\r\n      // evented object.\r\n\r\n      if (changes && isEvented(this)) {\r\n        /**\r\n         * An event triggered on an object that is both\r\n         * {@link module:stateful|stateful} and {@link module:evented|evented}\r\n         * indicating that its state has changed.\r\n         *\r\n         * @event    module:stateful~StatefulMixin#statechanged\r\n         * @type     {Object}\r\n         * @property {Object} changes\r\n         *           A hash containing the properties that were changed and\r\n         *           the values they were changed `from` and `to`.\r\n         */\r\n        this.trigger({\r\n          changes: changes,\r\n          type: 'statechanged'\r\n        });\r\n      }\r\n\r\n      return changes;\r\n    }\r\n  };\r\n  /**\r\n   * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\r\n   * object.\r\n   *\r\n   * If the target object is {@link module:evented|evented} and has a\r\n   * `handleStateChanged` method, that method will be automatically bound to the\r\n   * `statechanged` event on itself.\r\n   *\r\n   * @param   {Object} target\r\n   *          The object to be made stateful.\r\n   *\r\n   * @param   {Object} [defaultState]\r\n   *          A default set of properties to populate the newly-stateful object's\r\n   *          `state` property.\r\n   *\r\n   * @return {Object}\r\n   *          Returns the `target`.\r\n   */\r\n\r\n  function stateful(target, defaultState) {\r\n    assign(target, StatefulMixin); // This happens after the mixing-in because we need to replace the `state`\r\n    // added in that step.\r\n\r\n    target.state = assign({}, target.state, defaultState); // Auto-bind the `handleStateChanged` method of the target object if it exists.\r\n\r\n    if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\r\n      target.on('statechanged', target.handleStateChanged);\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  /**\r\n   * @file string-cases.js\r\n   * @module to-lower-case\r\n   */\r\n\r\n  /**\r\n   * Lowercase the first letter of a string.\r\n   *\r\n   * @param {string} string\r\n   *        String to be lowercased\r\n   *\r\n   * @return {string}\r\n   *         The string with a lowercased first letter\r\n   */\r\n  var toLowerCase = function toLowerCase(string) {\r\n    if (typeof string !== 'string') {\r\n      return string;\r\n    }\r\n\r\n    return string.replace(/./, function (w) {\r\n      return w.toLowerCase();\r\n    });\r\n  };\r\n  /**\r\n   * Uppercase the first letter of a string.\r\n   *\r\n   * @param {string} string\r\n   *        String to be uppercased\r\n   *\r\n   * @return {string}\r\n   *         The string with an uppercased first letter\r\n   */\r\n\r\n  var toTitleCase$1 = function toTitleCase(string) {\r\n    if (typeof string !== 'string') {\r\n      return string;\r\n    }\r\n\r\n    return string.replace(/./, function (w) {\r\n      return w.toUpperCase();\r\n    });\r\n  };\r\n  /**\r\n   * Compares the TitleCase versions of the two strings for equality.\r\n   *\r\n   * @param {string} str1\r\n   *        The first string to compare\r\n   *\r\n   * @param {string} str2\r\n   *        The second string to compare\r\n   *\r\n   * @return {boolean}\r\n   *         Whether the TitleCase versions of the strings are equal\r\n   */\r\n\r\n  var titleCaseEquals = function titleCaseEquals(str1, str2) {\r\n    return toTitleCase$1(str1) === toTitleCase$1(str2);\r\n  };\r\n\r\n  /**\r\n   * @file merge-options.js\r\n   * @module merge-options\r\n   */\r\n  /**\r\n   * Merge two objects recursively.\r\n   *\r\n   * Performs a deep merge like\r\n   * {@link https://lodash.com/docs/4.17.10#merge|lodash.merge}, but only merges\r\n   * plain objects (not arrays, elements, or anything else).\r\n   *\r\n   * Non-plain object values will be copied directly from the right-most\r\n   * argument.\r\n   *\r\n   * @static\r\n   * @param   {Object[]} sources\r\n   *          One or more objects to merge into a new object.\r\n   *\r\n   * @return {Object}\r\n   *          A new object that is the merged result of all sources.\r\n   */\r\n\r\n  function mergeOptions$3() {\r\n    var result = {};\r\n\r\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      sources[_key] = arguments[_key];\r\n    }\r\n\r\n    sources.forEach(function (source) {\r\n      if (!source) {\r\n        return;\r\n      }\r\n\r\n      each(source, function (value, key) {\r\n        if (!isPlain(value)) {\r\n          result[key] = value;\r\n          return;\r\n        }\r\n\r\n        if (!isPlain(result[key])) {\r\n          result[key] = {};\r\n        }\r\n\r\n        result[key] = mergeOptions$3(result[key], value);\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n\r\n  var MapSham = /*#__PURE__*/function () {\r\n    function MapSham() {\r\n      this.map_ = {};\r\n    }\r\n\r\n    var _proto = MapSham.prototype;\r\n\r\n    _proto.has = function has(key) {\r\n      return key in this.map_;\r\n    };\r\n\r\n    _proto[\"delete\"] = function _delete(key) {\r\n      var has = this.has(key);\r\n      delete this.map_[key];\r\n      return has;\r\n    };\r\n\r\n    _proto.set = function set(key, value) {\r\n      this.map_[key] = value;\r\n      return this;\r\n    };\r\n\r\n    _proto.forEach = function forEach(callback, thisArg) {\r\n      for (var key in this.map_) {\r\n        callback.call(thisArg, this.map_[key], key, this);\r\n      }\r\n    };\r\n\r\n    return MapSham;\r\n  }();\r\n\r\n  var Map$1 = window.Map ? window.Map : MapSham;\r\n\r\n  var SetSham = /*#__PURE__*/function () {\r\n    function SetSham() {\r\n      this.set_ = {};\r\n    }\r\n\r\n    var _proto = SetSham.prototype;\r\n\r\n    _proto.has = function has(key) {\r\n      return key in this.set_;\r\n    };\r\n\r\n    _proto[\"delete\"] = function _delete(key) {\r\n      var has = this.has(key);\r\n      delete this.set_[key];\r\n      return has;\r\n    };\r\n\r\n    _proto.add = function add(key) {\r\n      this.set_[key] = 1;\r\n      return this;\r\n    };\r\n\r\n    _proto.forEach = function forEach(callback, thisArg) {\r\n      for (var key in this.set_) {\r\n        callback.call(thisArg, key, key, this);\r\n      }\r\n    };\r\n\r\n    return SetSham;\r\n  }();\r\n\r\n  var Set$1 = window.Set ? window.Set : SetSham;\r\n\r\n  var keycode = createCommonjsModule(function (module, exports) {\r\n    // Source: http://jsfiddle.net/vWx8V/\r\n    // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\r\n\r\n    /**\r\n     * Conenience method returns corresponding value for given keyName or keyCode.\r\n     *\r\n     * @param {Mixed} keyCode {Number} or keyName {String}\r\n     * @return {Mixed}\r\n     * @api public\r\n     */\r\n    function keyCode(searchInput) {\r\n      // Keyboard Events\r\n      if (searchInput && 'object' === typeof searchInput) {\r\n        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;\r\n        if (hasKeyCode) searchInput = hasKeyCode;\r\n      } // Numbers\r\n\r\n\r\n      if ('number' === typeof searchInput) return names[searchInput]; // Everything else (cast to string)\r\n\r\n      var search = String(searchInput); // check codes\r\n\r\n      var foundNamedKey = codes[search.toLowerCase()];\r\n      if (foundNamedKey) return foundNamedKey; // check aliases\r\n\r\n      var foundNamedKey = aliases[search.toLowerCase()];\r\n      if (foundNamedKey) return foundNamedKey; // weird character?\r\n\r\n      if (search.length === 1) return search.charCodeAt(0);\r\n      return undefined;\r\n    }\r\n    /**\r\n     * Compares a keyboard event with a given keyCode or keyName.\r\n     *\r\n     * @param {Event} event Keyboard event that should be tested\r\n     * @param {Mixed} keyCode {Number} or keyName {String}\r\n     * @return {Boolean}\r\n     * @api public\r\n     */\r\n\r\n\r\n    keyCode.isEventKey = function isEventKey(event, nameOrCode) {\r\n      if (event && 'object' === typeof event) {\r\n        var keyCode = event.which || event.keyCode || event.charCode;\r\n\r\n        if (keyCode === null || keyCode === undefined) {\r\n          return false;\r\n        }\r\n\r\n        if (typeof nameOrCode === 'string') {\r\n          // check codes\r\n          var foundNamedKey = codes[nameOrCode.toLowerCase()];\r\n\r\n          if (foundNamedKey) {\r\n            return foundNamedKey === keyCode;\r\n          } // check aliases\r\n\r\n\r\n          var foundNamedKey = aliases[nameOrCode.toLowerCase()];\r\n\r\n          if (foundNamedKey) {\r\n            return foundNamedKey === keyCode;\r\n          }\r\n        } else if (typeof nameOrCode === 'number') {\r\n          return nameOrCode === keyCode;\r\n        }\r\n\r\n        return false;\r\n      }\r\n    };\r\n\r\n    exports = module.exports = keyCode;\r\n    /**\r\n     * Get by name\r\n     *\r\n     *   exports.code['enter'] // => 13\r\n     */\r\n\r\n    var codes = exports.code = exports.codes = {\r\n      'backspace': 8,\r\n      'tab': 9,\r\n      'enter': 13,\r\n      'shift': 16,\r\n      'ctrl': 17,\r\n      'alt': 18,\r\n      'pause/break': 19,\r\n      'caps lock': 20,\r\n      'esc': 27,\r\n      'space': 32,\r\n      'page up': 33,\r\n      'page down': 34,\r\n      'end': 35,\r\n      'home': 36,\r\n      'left': 37,\r\n      'up': 38,\r\n      'right': 39,\r\n      'down': 40,\r\n      'insert': 45,\r\n      'delete': 46,\r\n      'command': 91,\r\n      'left command': 91,\r\n      'right command': 93,\r\n      'numpad *': 106,\r\n      'numpad +': 107,\r\n      'numpad -': 109,\r\n      'numpad .': 110,\r\n      'numpad /': 111,\r\n      'num lock': 144,\r\n      'scroll lock': 145,\r\n      'my computer': 182,\r\n      'my calculator': 183,\r\n      ';': 186,\r\n      '=': 187,\r\n      ',': 188,\r\n      '-': 189,\r\n      '.': 190,\r\n      '/': 191,\r\n      '`': 192,\r\n      '[': 219,\r\n      '\\\\': 220,\r\n      ']': 221,\r\n      \"'\": 222\r\n    }; // Helper aliases\r\n\r\n    var aliases = exports.aliases = {\r\n      'windows': 91,\r\n      '': 16,\r\n      '': 18,\r\n      '': 17,\r\n      '': 91,\r\n      'ctl': 17,\r\n      'control': 17,\r\n      'option': 18,\r\n      'pause': 19,\r\n      'break': 19,\r\n      'caps': 20,\r\n      'return': 13,\r\n      'escape': 27,\r\n      'spc': 32,\r\n      'spacebar': 32,\r\n      'pgup': 33,\r\n      'pgdn': 34,\r\n      'ins': 45,\r\n      'del': 46,\r\n      'cmd': 91\r\n    };\r\n    /*!\r\n     * Programatically add the following\r\n     */\r\n    // lower case chars\r\n\r\n    for (i = 97; i < 123; i++) {\r\n      codes[String.fromCharCode(i)] = i - 32;\r\n    } // numbers\r\n\r\n\r\n    for (var i = 48; i < 58; i++) {\r\n      codes[i - 48] = i;\r\n    } // function keys\r\n\r\n\r\n    for (i = 1; i < 13; i++) {\r\n      codes['f' + i] = i + 111;\r\n    } // numpad keys\r\n\r\n\r\n    for (i = 0; i < 10; i++) {\r\n      codes['numpad ' + i] = i + 96;\r\n    }\r\n    /**\r\n     * Get by code\r\n     *\r\n     *   exports.name[13] // => 'Enter'\r\n     */\r\n\r\n\r\n    var names = exports.names = exports.title = {}; // title for backward compat\r\n    // Create reverse mapping\r\n\r\n    for (i in codes) {\r\n      names[codes[i]] = i;\r\n    } // Add aliases\r\n\r\n\r\n    for (var alias in aliases) {\r\n      codes[alias] = aliases[alias];\r\n    }\r\n  });\r\n  keycode.code;\r\n  keycode.codes;\r\n  keycode.aliases;\r\n  keycode.names;\r\n  keycode.title;\r\n\r\n  /**\r\n   * Player Component - Base class for all UI objects\r\n   *\r\n   * @file component.js\r\n   */\r\n  /**\r\n   * Base class for all UI Components.\r\n   * Components are UI objects which represent both a javascript object and an element\r\n   * in the DOM. They can be children of other components, and can have\r\n   * children themselves.\r\n   *\r\n   * Components can also use methods from {@link EventTarget}\r\n   */\r\n\r\n  var Component$1 = /*#__PURE__*/function () {\r\n    /**\r\n     * A callback that is called when a component is ready. Does not have any\r\n     * paramters and any callback value will be ignored.\r\n     *\r\n     * @callback Component~ReadyCallback\r\n     * @this Component\r\n     */\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of component options.\r\n     *\r\n     * @param {Object[]} [options.children]\r\n     *        An array of children objects to intialize this component with. Children objects have\r\n     *        a name property that will be used if more than one component of the same type needs to be\r\n     *        added.\r\n     *\r\n     * @param  {string} [options.className]\r\n     *         A class or space separated list of classes to add the component\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        Function that gets called when the `Component` is ready.\r\n     */\r\n    function Component(player, options, ready) {\r\n      var _this = this;\r\n\r\n      // The component might be the player itself and we can't pass `this` to super\r\n      if (!player && this.play) {\r\n        this.player_ = player = this; // eslint-disable-line\r\n      } else {\r\n        this.player_ = player;\r\n      }\r\n\r\n      this.isDisposed_ = false; // Hold the reference to the parent component via `addChild` method\r\n\r\n      this.parentComponent_ = null; // Make a copy of prototype.options_ to protect against overriding defaults\r\n\r\n      this.options_ = mergeOptions$3({}, this.options_); // Updated options with supplied options\r\n\r\n      options = this.options_ = mergeOptions$3(this.options_, options); // Get ID from options or options element if one is supplied\r\n\r\n      this.id_ = options.id || options.el && options.el.id; // If there was no ID from the options, generate one\r\n\r\n      if (!this.id_) {\r\n        // Don't require the player ID function in the case of mock players\r\n        var id = player && player.id && player.id() || 'no_player';\r\n        this.id_ = id + \"_component_\" + newGUID();\r\n      }\r\n\r\n      this.name_ = options.name || null; // Create element if one wasn't provided in options\r\n\r\n      if (options.el) {\r\n        this.el_ = options.el;\r\n      } else if (options.createEl !== false) {\r\n        this.el_ = this.createEl();\r\n      }\r\n\r\n      if (options.className && this.el_) {\r\n        options.className.split(' ').forEach(function (c) {\r\n          return _this.addClass(c);\r\n        });\r\n      } // if evented is anything except false, we want to mixin in evented\r\n\r\n\r\n      if (options.evented !== false) {\r\n        // Make this an evented object and use `el_`, if available, as its event bus\r\n        evented(this, {\r\n          eventBusKey: this.el_ ? 'el_' : null\r\n        });\r\n        this.handleLanguagechange = this.handleLanguagechange.bind(this);\r\n        this.on(this.player_, 'languagechange', this.handleLanguagechange);\r\n      }\r\n\r\n      stateful(this, this.constructor.defaultState);\r\n      this.children_ = [];\r\n      this.childIndex_ = {};\r\n      this.childNameIndex_ = {};\r\n      this.setTimeoutIds_ = new Set$1();\r\n      this.setIntervalIds_ = new Set$1();\r\n      this.rafIds_ = new Set$1();\r\n      this.namedRafs_ = new Map$1();\r\n      this.clearingTimersOnDispose_ = false; // Add any child components in options\r\n\r\n      if (options.initChildren !== false) {\r\n        this.initChildren();\r\n      } // Don't want to trigger ready here or it will go before init is actually\r\n      // finished for all children that run this constructor\r\n\r\n\r\n      this.ready(ready);\r\n\r\n      if (options.reportTouchActivity !== false) {\r\n        this.enableTouchActivity();\r\n      }\r\n    }\r\n    /**\r\n     * Dispose of the `Component` and all child components.\r\n     *\r\n     * @fires Component#dispose\r\n     *\r\n     * @param {Object} options\r\n     * @param {Element} options.originalEl element with which to replace player element\r\n     */\r\n\r\n\r\n    var _proto = Component.prototype;\r\n\r\n    _proto.dispose = function dispose(options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      // Bail out if the component has already been disposed.\r\n      if (this.isDisposed_) {\r\n        return;\r\n      }\r\n\r\n      if (this.readyQueue_) {\r\n        this.readyQueue_.length = 0;\r\n      }\r\n      /**\r\n       * Triggered when a `Component` is disposed.\r\n       *\r\n       * @event Component#dispose\r\n       * @type {EventTarget~Event}\r\n       *\r\n       * @property {boolean} [bubbles=false]\r\n       *           set to false so that the dispose event does not\r\n       *           bubble up\r\n       */\r\n\r\n\r\n      this.trigger({\r\n        type: 'dispose',\r\n        bubbles: false\r\n      });\r\n      this.isDisposed_ = true; // Dispose all children.\r\n\r\n      if (this.children_) {\r\n        for (var i = this.children_.length - 1; i >= 0; i--) {\r\n          if (this.children_[i].dispose) {\r\n            this.children_[i].dispose();\r\n          }\r\n        }\r\n      } // Delete child references\r\n\r\n\r\n      this.children_ = null;\r\n      this.childIndex_ = null;\r\n      this.childNameIndex_ = null;\r\n      this.parentComponent_ = null;\r\n\r\n      if (this.el_) {\r\n        // Remove element from DOM\r\n        if (this.el_.parentNode) {\r\n          if (options.restoreEl) {\r\n            this.el_.parentNode.replaceChild(options.restoreEl, this.el_);\r\n          } else {\r\n            this.el_.parentNode.removeChild(this.el_);\r\n          }\r\n        }\r\n\r\n        this.el_ = null;\r\n      } // remove reference to the player after disposing of the element\r\n\r\n\r\n      this.player_ = null;\r\n    }\r\n    /**\r\n     * Determine whether or not this component has been disposed.\r\n     *\r\n     * @return {boolean}\r\n     *         If the component has been disposed, will be `true`. Otherwise, `false`.\r\n     */\r\n    ;\r\n\r\n    _proto.isDisposed = function isDisposed() {\r\n      return Boolean(this.isDisposed_);\r\n    }\r\n    /**\r\n     * Return the {@link Player} that the `Component` has attached to.\r\n     *\r\n     * @return {Player}\r\n     *         The player that this `Component` has attached to.\r\n     */\r\n    ;\r\n\r\n    _proto.player = function player() {\r\n      return this.player_;\r\n    }\r\n    /**\r\n     * Deep merge of options objects with new options.\r\n     * > Note: When both `obj` and `options` contain properties whose values are objects.\r\n     *         The two properties get merged using {@link module:mergeOptions}\r\n     *\r\n     * @param {Object} obj\r\n     *        The object that contains new options.\r\n     *\r\n     * @return {Object}\r\n     *         A new object of `this.options_` and `obj` merged together.\r\n     */\r\n    ;\r\n\r\n    _proto.options = function options(obj) {\r\n      if (!obj) {\r\n        return this.options_;\r\n      }\r\n\r\n      this.options_ = mergeOptions$3(this.options_, obj);\r\n      return this.options_;\r\n    }\r\n    /**\r\n     * Get the `Component`s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The DOM element for this `Component`.\r\n     */\r\n    ;\r\n\r\n    _proto.el = function el() {\r\n      return this.el_;\r\n    }\r\n    /**\r\n     * Create the `Component`s DOM element.\r\n     *\r\n     * @param {string} [tagName]\r\n     *        Element's DOM node type. e.g. 'div'\r\n     *\r\n     * @param {Object} [properties]\r\n     *        An object of properties that should be set.\r\n     *\r\n     * @param {Object} [attributes]\r\n     *        An object of attributes that should be set.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl$1(tagName, properties, attributes) {\r\n      return createEl(tagName, properties, attributes);\r\n    }\r\n    /**\r\n     * Localize a string given the string in english.\r\n     *\r\n     * If tokens are provided, it'll try and run a simple token replacement on the provided string.\r\n     * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\r\n     *\r\n     * If a `defaultValue` is provided, it'll use that over `string`,\r\n     * if a value isn't found in provided language files.\r\n     * This is useful if you want to have a descriptive key for token replacement\r\n     * but have a succinct localized string and not require `en.json` to be included.\r\n     *\r\n     * Currently, it is used for the progress bar timing.\r\n     * ```js\r\n     * {\r\n     *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\r\n     * }\r\n     * ```\r\n     * It is then used like so:\r\n     * ```js\r\n     * this.localize('progress bar timing: currentTime={1} duration{2}',\r\n     *               [this.player_.currentTime(), this.player_.duration()],\r\n     *               '{1} of {2}');\r\n     * ```\r\n     *\r\n     * Which outputs something like: `01:23 of 24:56`.\r\n     *\r\n     *\r\n     * @param {string} string\r\n     *        The string to localize and the key to lookup in the language files.\r\n     * @param {string[]} [tokens]\r\n     *        If the current item has token replacements, provide the tokens here.\r\n     * @param {string} [defaultValue]\r\n     *        Defaults to `string`. Can be a default value to use for token replacement\r\n     *        if the lookup key is needed to be separate.\r\n     *\r\n     * @return {string}\r\n     *         The localized string or if no localization exists the english string.\r\n     */\r\n    ;\r\n\r\n    _proto.localize = function localize(string, tokens, defaultValue) {\r\n      if (defaultValue === void 0) {\r\n        defaultValue = string;\r\n      }\r\n\r\n      var code = this.player_.language && this.player_.language();\r\n      var languages = this.player_.languages && this.player_.languages();\r\n      var language = languages && languages[code];\r\n      var primaryCode = code && code.split('-')[0];\r\n      var primaryLang = languages && languages[primaryCode];\r\n      var localizedString = defaultValue;\r\n\r\n      if (language && language[string]) {\r\n        localizedString = language[string];\r\n      } else if (primaryLang && primaryLang[string]) {\r\n        localizedString = primaryLang[string];\r\n      }\r\n\r\n      if (tokens) {\r\n        localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\r\n          var value = tokens[index - 1];\r\n          var ret = value;\r\n\r\n          if (typeof value === 'undefined') {\r\n            ret = match;\r\n          }\r\n\r\n          return ret;\r\n        });\r\n      }\r\n\r\n      return localizedString;\r\n    }\r\n    /**\r\n     * Handles language change for the player in components. Should be overriden by sub-components.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.handleLanguagechange = function handleLanguagechange() {}\r\n    /**\r\n     * Return the `Component`s DOM element. This is where children get inserted.\r\n     * This will usually be the the same as the element returned in {@link Component#el}.\r\n     *\r\n     * @return {Element}\r\n     *         The content element for this `Component`.\r\n     */\r\n    ;\r\n\r\n    _proto.contentEl = function contentEl() {\r\n      return this.contentEl_ || this.el_;\r\n    }\r\n    /**\r\n     * Get this `Component`s ID\r\n     *\r\n     * @return {string}\r\n     *         The id of this `Component`\r\n     */\r\n    ;\r\n\r\n    _proto.id = function id() {\r\n      return this.id_;\r\n    }\r\n    /**\r\n     * Get the `Component`s name. The name gets used to reference the `Component`\r\n     * and is set during registration.\r\n     *\r\n     * @return {string}\r\n     *         The name of this `Component`.\r\n     */\r\n    ;\r\n\r\n    _proto.name = function name() {\r\n      return this.name_;\r\n    }\r\n    /**\r\n     * Get an array of all child components\r\n     *\r\n     * @return {Array}\r\n     *         The children\r\n     */\r\n    ;\r\n\r\n    _proto.children = function children() {\r\n      return this.children_;\r\n    }\r\n    /**\r\n     * Returns the child `Component` with the given `id`.\r\n     *\r\n     * @param {string} id\r\n     *        The id of the child `Component` to get.\r\n     *\r\n     * @return {Component|undefined}\r\n     *         The child `Component` with the given `id` or undefined.\r\n     */\r\n    ;\r\n\r\n    _proto.getChildById = function getChildById(id) {\r\n      return this.childIndex_[id];\r\n    }\r\n    /**\r\n     * Returns the child `Component` with the given `name`.\r\n     *\r\n     * @param {string} name\r\n     *        The name of the child `Component` to get.\r\n     *\r\n     * @return {Component|undefined}\r\n     *         The child `Component` with the given `name` or undefined.\r\n     */\r\n    ;\r\n\r\n    _proto.getChild = function getChild(name) {\r\n      if (!name) {\r\n        return;\r\n      }\r\n\r\n      return this.childNameIndex_[name];\r\n    }\r\n    /**\r\n     * Returns the descendant `Component` following the givent\r\n     * descendant `names`. For instance ['foo', 'bar', 'baz'] would\r\n     * try to get 'foo' on the current component, 'bar' on the 'foo'\r\n     * component and 'baz' on the 'bar' component and return undefined\r\n     * if any of those don't exist.\r\n     *\r\n     * @param {...string[]|...string} names\r\n     *        The name of the child `Component` to get.\r\n     *\r\n     * @return {Component|undefined}\r\n     *         The descendant `Component` following the given descendant\r\n     *         `names` or undefined.\r\n     */\r\n    ;\r\n\r\n    _proto.getDescendant = function getDescendant() {\r\n      for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        names[_key] = arguments[_key];\r\n      }\r\n\r\n      // flatten array argument into the main array\r\n      names = names.reduce(function (acc, n) {\r\n        return acc.concat(n);\r\n      }, []);\r\n      var currentChild = this;\r\n\r\n      for (var i = 0; i < names.length; i++) {\r\n        currentChild = currentChild.getChild(names[i]);\r\n\r\n        if (!currentChild || !currentChild.getChild) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      return currentChild;\r\n    }\r\n    /**\r\n     * Add a child `Component` inside the current `Component`.\r\n     *\r\n     *\r\n     * @param {string|Component} child\r\n     *        The name or instance of a child to add.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of options that will get passed to children of\r\n     *        the child.\r\n     *\r\n     * @param {number} [index=this.children_.length]\r\n     *        The index to attempt to add a child into.\r\n     *\r\n     * @return {Component}\r\n     *         The `Component` that gets added as a child. When using a string the\r\n     *         `Component` will get created by this process.\r\n     */\r\n    ;\r\n\r\n    _proto.addChild = function addChild(child, options, index) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      if (index === void 0) {\r\n        index = this.children_.length;\r\n      }\r\n\r\n      var component;\r\n      var componentName; // If child is a string, create component with options\r\n\r\n      if (typeof child === 'string') {\r\n        componentName = toTitleCase$1(child);\r\n        var componentClassName = options.componentClass || componentName; // Set name through options\r\n\r\n        options.name = componentName; // Create a new object & element for this controls set\r\n        // If there's no .player_, this is a player\r\n\r\n        var ComponentClass = Component.getComponent(componentClassName);\r\n\r\n        if (!ComponentClass) {\r\n          throw new Error(\"Component \" + componentClassName + \" does not exist\");\r\n        } // data stored directly on the videojs object may be\r\n        // misidentified as a component to retain\r\n        // backwards-compatibility with 4.x. check to make sure the\r\n        // component class can be instantiated.\r\n\r\n\r\n        if (typeof ComponentClass !== 'function') {\r\n          return null;\r\n        }\r\n\r\n        component = new ComponentClass(this.player_ || this, options); // child is a component instance\r\n      } else {\r\n        component = child;\r\n      }\r\n\r\n      if (component.parentComponent_) {\r\n        component.parentComponent_.removeChild(component);\r\n      }\r\n\r\n      this.children_.splice(index, 0, component);\r\n      component.parentComponent_ = this;\r\n\r\n      if (typeof component.id === 'function') {\r\n        this.childIndex_[component.id()] = component;\r\n      } // If a name wasn't used to create the component, check if we can use the\r\n      // name function of the component\r\n\r\n\r\n      componentName = componentName || component.name && toTitleCase$1(component.name());\r\n\r\n      if (componentName) {\r\n        this.childNameIndex_[componentName] = component;\r\n        this.childNameIndex_[toLowerCase(componentName)] = component;\r\n      } // Add the UI object's element to the container div (box)\r\n      // Having an element is not required\r\n\r\n\r\n      if (typeof component.el === 'function' && component.el()) {\r\n        // If inserting before a component, insert before that component's element\r\n        var refNode = null;\r\n\r\n        if (this.children_[index + 1]) {\r\n          // Most children are components, but the video tech is an HTML element\r\n          if (this.children_[index + 1].el_) {\r\n            refNode = this.children_[index + 1].el_;\r\n          } else if (isEl(this.children_[index + 1])) {\r\n            refNode = this.children_[index + 1];\r\n          }\r\n        }\r\n\r\n        this.contentEl().insertBefore(component.el(), refNode);\r\n      } // Return so it can stored on parent object if desired.\r\n\r\n\r\n      return component;\r\n    }\r\n    /**\r\n     * Remove a child `Component` from this `Component`s list of children. Also removes\r\n     * the child `Component`s element from this `Component`s element.\r\n     *\r\n     * @param {Component} component\r\n     *        The child `Component` to remove.\r\n     */\r\n    ;\r\n\r\n    _proto.removeChild = function removeChild(component) {\r\n      if (typeof component === 'string') {\r\n        component = this.getChild(component);\r\n      }\r\n\r\n      if (!component || !this.children_) {\r\n        return;\r\n      }\r\n\r\n      var childFound = false;\r\n\r\n      for (var i = this.children_.length - 1; i >= 0; i--) {\r\n        if (this.children_[i] === component) {\r\n          childFound = true;\r\n          this.children_.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!childFound) {\r\n        return;\r\n      }\r\n\r\n      component.parentComponent_ = null;\r\n      this.childIndex_[component.id()] = null;\r\n      this.childNameIndex_[toTitleCase$1(component.name())] = null;\r\n      this.childNameIndex_[toLowerCase(component.name())] = null;\r\n      var compEl = component.el();\r\n\r\n      if (compEl && compEl.parentNode === this.contentEl()) {\r\n        this.contentEl().removeChild(component.el());\r\n      }\r\n    }\r\n    /**\r\n     * Add and initialize default child `Component`s based upon options.\r\n     */\r\n    ;\r\n\r\n    _proto.initChildren = function initChildren() {\r\n      var _this2 = this;\r\n\r\n      var children = this.options_.children;\r\n\r\n      if (children) {\r\n        // `this` is `parent`\r\n        var parentOptions = this.options_;\r\n\r\n        var handleAdd = function handleAdd(child) {\r\n          var name = child.name;\r\n          var opts = child.opts; // Allow options for children to be set at the parent options\r\n          // e.g. videojs(id, { controlBar: false });\r\n          // instead of videojs(id, { children: { controlBar: false });\r\n\r\n          if (parentOptions[name] !== undefined) {\r\n            opts = parentOptions[name];\r\n          } // Allow for disabling default components\r\n          // e.g. options['children']['posterImage'] = false\r\n\r\n\r\n          if (opts === false) {\r\n            return;\r\n          } // Allow options to be passed as a simple boolean if no configuration\r\n          // is necessary.\r\n\r\n\r\n          if (opts === true) {\r\n            opts = {};\r\n          } // We also want to pass the original player options\r\n          // to each component as well so they don't need to\r\n          // reach back into the player for options later.\r\n\r\n\r\n          opts.playerOptions = _this2.options_.playerOptions; // Create and add the child component.\r\n          // Add a direct reference to the child by name on the parent instance.\r\n          // If two of the same component are used, different names should be supplied\r\n          // for each\r\n\r\n          var newChild = _this2.addChild(name, opts);\r\n\r\n          if (newChild) {\r\n            _this2[name] = newChild;\r\n          }\r\n        }; // Allow for an array of children details to passed in the options\r\n\r\n\r\n        var workingChildren;\r\n        var Tech = Component.getComponent('Tech');\r\n\r\n        if (Array.isArray(children)) {\r\n          workingChildren = children;\r\n        } else {\r\n          workingChildren = Object.keys(children);\r\n        }\r\n\r\n        workingChildren // children that are in this.options_ but also in workingChildren  would\r\n        // give us extra children we do not want. So, we want to filter them out.\r\n        .concat(Object.keys(this.options_).filter(function (child) {\r\n          return !workingChildren.some(function (wchild) {\r\n            if (typeof wchild === 'string') {\r\n              return child === wchild;\r\n            }\r\n\r\n            return child === wchild.name;\r\n          });\r\n        })).map(function (child) {\r\n          var name;\r\n          var opts;\r\n\r\n          if (typeof child === 'string') {\r\n            name = child;\r\n            opts = children[name] || _this2.options_[name] || {};\r\n          } else {\r\n            name = child.name;\r\n            opts = child;\r\n          }\r\n\r\n          return {\r\n            name: name,\r\n            opts: opts\r\n          };\r\n        }).filter(function (child) {\r\n          // we have to make sure that child.name isn't in the techOrder since\r\n          // techs are registerd as Components but can't aren't compatible\r\n          // See https://github.com/videojs/video.js/issues/2772\r\n          var c = Component.getComponent(child.opts.componentClass || toTitleCase$1(child.name));\r\n          return c && !Tech.isTech(c);\r\n        }).forEach(handleAdd);\r\n      }\r\n    }\r\n    /**\r\n     * Builds the default DOM class name. Should be overriden by sub-components.\r\n     *\r\n     * @return {string}\r\n     *         The DOM class name for this object.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      // Child classes can include a function that does:\r\n      // return 'CLASS NAME' + this._super();\r\n      return '';\r\n    }\r\n    /**\r\n     * Bind a listener to the component's ready state.\r\n     * Different from event listeners in that if the ready event has already happened\r\n     * it will trigger the function immediately.\r\n     *\r\n     * @return {Component}\r\n     *         Returns itself; method can be chained.\r\n     */\r\n    ;\r\n\r\n    _proto.ready = function ready(fn, sync) {\r\n      if (sync === void 0) {\r\n        sync = false;\r\n      }\r\n\r\n      if (!fn) {\r\n        return;\r\n      }\r\n\r\n      if (!this.isReady_) {\r\n        this.readyQueue_ = this.readyQueue_ || [];\r\n        this.readyQueue_.push(fn);\r\n        return;\r\n      }\r\n\r\n      if (sync) {\r\n        fn.call(this);\r\n      } else {\r\n        // Call the function asynchronously by default for consistency\r\n        this.setTimeout(fn, 1);\r\n      }\r\n    }\r\n    /**\r\n     * Trigger all the ready listeners for this `Component`.\r\n     *\r\n     * @fires Component#ready\r\n     */\r\n    ;\r\n\r\n    _proto.triggerReady = function triggerReady() {\r\n      this.isReady_ = true; // Ensure ready is triggered asynchronously\r\n\r\n      this.setTimeout(function () {\r\n        var readyQueue = this.readyQueue_; // Reset Ready Queue\r\n\r\n        this.readyQueue_ = [];\r\n\r\n        if (readyQueue && readyQueue.length > 0) {\r\n          readyQueue.forEach(function (fn) {\r\n            fn.call(this);\r\n          }, this);\r\n        } // Allow for using event listeners also\r\n\r\n        /**\r\n         * Triggered when a `Component` is ready.\r\n         *\r\n         * @event Component#ready\r\n         * @type {EventTarget~Event}\r\n         */\r\n\r\n\r\n        this.trigger('ready');\r\n      }, 1);\r\n    }\r\n    /**\r\n     * Find a single DOM element matching a `selector`. This can be within the `Component`s\r\n     * `contentEl()` or another custom context.\r\n     *\r\n     * @param {string} selector\r\n     *        A valid CSS selector, which will be passed to `querySelector`.\r\n     *\r\n     * @param {Element|string} [context=this.contentEl()]\r\n     *        A DOM element within which to query. Can also be a selector string in\r\n     *        which case the first matching element will get used as context. If\r\n     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\r\n     *        nothing it falls back to `document`.\r\n     *\r\n     * @return {Element|null}\r\n     *         the dom element that was found, or null\r\n     *\r\n     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\r\n     */\r\n    ;\r\n\r\n    _proto.$ = function $$1(selector, context) {\r\n      return $(selector, context || this.contentEl());\r\n    }\r\n    /**\r\n     * Finds all DOM element matching a `selector`. This can be within the `Component`s\r\n     * `contentEl()` or another custom context.\r\n     *\r\n     * @param {string} selector\r\n     *        A valid CSS selector, which will be passed to `querySelectorAll`.\r\n     *\r\n     * @param {Element|string} [context=this.contentEl()]\r\n     *        A DOM element within which to query. Can also be a selector string in\r\n     *        which case the first matching element will get used as context. If\r\n     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\r\n     *        nothing it falls back to `document`.\r\n     *\r\n     * @return {NodeList}\r\n     *         a list of dom elements that were found\r\n     *\r\n     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\r\n     */\r\n    ;\r\n\r\n    _proto.$$ = function $$$1(selector, context) {\r\n      return $$(selector, context || this.contentEl());\r\n    }\r\n    /**\r\n     * Check if a component's element has a CSS class name.\r\n     *\r\n     * @param {string} classToCheck\r\n     *        CSS class name to check.\r\n     *\r\n     * @return {boolean}\r\n     *         - True if the `Component` has the class.\r\n     *         - False if the `Component` does not have the class`\r\n     */\r\n    ;\r\n\r\n    _proto.hasClass = function hasClass$1(classToCheck) {\r\n      return hasClass(this.el_, classToCheck);\r\n    }\r\n    /**\r\n     * Add a CSS class name to the `Component`s element.\r\n     *\r\n     * @param {string} classToAdd\r\n     *        CSS class name to add\r\n     */\r\n    ;\r\n\r\n    _proto.addClass = function addClass$1(classToAdd) {\r\n      addClass(this.el_, classToAdd);\r\n    }\r\n    /**\r\n     * Remove a CSS class name from the `Component`s element.\r\n     *\r\n     * @param {string} classToRemove\r\n     *        CSS class name to remove\r\n     */\r\n    ;\r\n\r\n    _proto.removeClass = function removeClass$1(classToRemove) {\r\n      removeClass(this.el_, classToRemove);\r\n    }\r\n    /**\r\n     * Add or remove a CSS class name from the component's element.\r\n     * - `classToToggle` gets added when {@link Component#hasClass} would return false.\r\n     * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\r\n     *\r\n     * @param  {string} classToToggle\r\n     *         The class to add or remove based on (@link Component#hasClass}\r\n     *\r\n     * @param  {boolean|Dom~predicate} [predicate]\r\n     *         An {@link Dom~predicate} function or a boolean\r\n     */\r\n    ;\r\n\r\n    _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {\r\n      toggleClass(this.el_, classToToggle, predicate);\r\n    }\r\n    /**\r\n     * Show the `Component`s element if it is hidden by removing the\r\n     * 'vjs-hidden' class name from it.\r\n     */\r\n    ;\r\n\r\n    _proto.show = function show() {\r\n      this.removeClass('vjs-hidden');\r\n    }\r\n    /**\r\n     * Hide the `Component`s element if it is currently showing by adding the\r\n     * 'vjs-hidden` class name to it.\r\n     */\r\n    ;\r\n\r\n    _proto.hide = function hide() {\r\n      this.addClass('vjs-hidden');\r\n    }\r\n    /**\r\n     * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\r\n     * class name to it. Used during fadeIn/fadeOut.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.lockShowing = function lockShowing() {\r\n      this.addClass('vjs-lock-showing');\r\n    }\r\n    /**\r\n     * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\r\n     * class name from it. Used during fadeIn/fadeOut.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.unlockShowing = function unlockShowing() {\r\n      this.removeClass('vjs-lock-showing');\r\n    }\r\n    /**\r\n     * Get the value of an attribute on the `Component`s element.\r\n     *\r\n     * @param {string} attribute\r\n     *        Name of the attribute to get the value from.\r\n     *\r\n     * @return {string|null}\r\n     *         - The value of the attribute that was asked for.\r\n     *         - Can be an empty string on some browsers if the attribute does not exist\r\n     *           or has no value\r\n     *         - Most browsers will return null if the attibute does not exist or has\r\n     *           no value.\r\n     *\r\n     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\r\n     */\r\n    ;\r\n\r\n    _proto.getAttribute = function getAttribute$1(attribute) {\r\n      return getAttribute(this.el_, attribute);\r\n    }\r\n    /**\r\n     * Set the value of an attribute on the `Component`'s element\r\n     *\r\n     * @param {string} attribute\r\n     *        Name of the attribute to set.\r\n     *\r\n     * @param {string} value\r\n     *        Value to set the attribute to.\r\n     *\r\n     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\r\n     */\r\n    ;\r\n\r\n    _proto.setAttribute = function setAttribute$1(attribute, value) {\r\n      setAttribute(this.el_, attribute, value);\r\n    }\r\n    /**\r\n     * Remove an attribute from the `Component`s element.\r\n     *\r\n     * @param {string} attribute\r\n     *        Name of the attribute to remove.\r\n     *\r\n     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\r\n     */\r\n    ;\r\n\r\n    _proto.removeAttribute = function removeAttribute$1(attribute) {\r\n      removeAttribute(this.el_, attribute);\r\n    }\r\n    /**\r\n     * Get or set the width of the component based upon the CSS styles.\r\n     * See {@link Component#dimension} for more detailed information.\r\n     *\r\n     * @param {number|string} [num]\r\n     *        The width that you want to set postfixed with '%', 'px' or nothing.\r\n     *\r\n     * @param {boolean} [skipListeners]\r\n     *        Skip the componentresize event trigger\r\n     *\r\n     * @return {number|string}\r\n     *         The width when getting, zero if there is no width. Can be a string\r\n     *           postpixed with '%' or 'px'.\r\n     */\r\n    ;\r\n\r\n    _proto.width = function width(num, skipListeners) {\r\n      return this.dimension('width', num, skipListeners);\r\n    }\r\n    /**\r\n     * Get or set the height of the component based upon the CSS styles.\r\n     * See {@link Component#dimension} for more detailed information.\r\n     *\r\n     * @param {number|string} [num]\r\n     *        The height that you want to set postfixed with '%', 'px' or nothing.\r\n     *\r\n     * @param {boolean} [skipListeners]\r\n     *        Skip the componentresize event trigger\r\n     *\r\n     * @return {number|string}\r\n     *         The width when getting, zero if there is no width. Can be a string\r\n     *         postpixed with '%' or 'px'.\r\n     */\r\n    ;\r\n\r\n    _proto.height = function height(num, skipListeners) {\r\n      return this.dimension('height', num, skipListeners);\r\n    }\r\n    /**\r\n     * Set both the width and height of the `Component` element at the same time.\r\n     *\r\n     * @param  {number|string} width\r\n     *         Width to set the `Component`s element to.\r\n     *\r\n     * @param  {number|string} height\r\n     *         Height to set the `Component`s element to.\r\n     */\r\n    ;\r\n\r\n    _proto.dimensions = function dimensions(width, height) {\r\n      // Skip componentresize listeners on width for optimization\r\n      this.width(width, true);\r\n      this.height(height);\r\n    }\r\n    /**\r\n     * Get or set width or height of the `Component` element. This is the shared code\r\n     * for the {@link Component#width} and {@link Component#height}.\r\n     *\r\n     * Things to know:\r\n     * - If the width or height in an number this will return the number postfixed with 'px'.\r\n     * - If the width/height is a percent this will return the percent postfixed with '%'\r\n     * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\r\n     *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\r\n     *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\r\n     *   for more information\r\n     * - If you want the computed style of the component, use {@link Component#currentWidth}\r\n     *   and {@link {Component#currentHeight}\r\n     *\r\n     * @fires Component#componentresize\r\n     *\r\n     * @param {string} widthOrHeight\r\n     8        'width' or 'height'\r\n     *\r\n     * @param  {number|string} [num]\r\n     8         New dimension\r\n     *\r\n     * @param  {boolean} [skipListeners]\r\n     *         Skip componentresize event trigger\r\n     *\r\n     * @return {number}\r\n     *         The dimension when getting or 0 if unset\r\n     */\r\n    ;\r\n\r\n    _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {\r\n      if (num !== undefined) {\r\n        // Set to zero if null or literally NaN (NaN !== NaN)\r\n        if (num === null || num !== num) {\r\n          num = 0;\r\n        } // Check if using css width/height (% or px) and adjust\r\n\r\n\r\n        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\r\n          this.el_.style[widthOrHeight] = num;\r\n        } else if (num === 'auto') {\r\n          this.el_.style[widthOrHeight] = '';\r\n        } else {\r\n          this.el_.style[widthOrHeight] = num + 'px';\r\n        } // skipListeners allows us to avoid triggering the resize event when setting both width and height\r\n\r\n\r\n        if (!skipListeners) {\r\n          /**\r\n           * Triggered when a component is resized.\r\n           *\r\n           * @event Component#componentresize\r\n           * @type {EventTarget~Event}\r\n           */\r\n          this.trigger('componentresize');\r\n        }\r\n\r\n        return;\r\n      } // Not setting a value, so getting it\r\n      // Make sure element exists\r\n\r\n\r\n      if (!this.el_) {\r\n        return 0;\r\n      } // Get dimension value from style\r\n\r\n\r\n      var val = this.el_.style[widthOrHeight];\r\n      var pxIndex = val.indexOf('px');\r\n\r\n      if (pxIndex !== -1) {\r\n        // Return the pixel value with no 'px'\r\n        return parseInt(val.slice(0, pxIndex), 10);\r\n      } // No px so using % or no style was set, so falling back to offsetWidth/height\r\n      // If component has display:none, offset will return 0\r\n      // TODO: handle display:none and no dimension style using px\r\n\r\n\r\n      return parseInt(this.el_['offset' + toTitleCase$1(widthOrHeight)], 10);\r\n    }\r\n    /**\r\n     * Get the computed width or the height of the component's element.\r\n     *\r\n     * Uses `window.getComputedStyle`.\r\n     *\r\n     * @param {string} widthOrHeight\r\n     *        A string containing 'width' or 'height'. Whichever one you want to get.\r\n     *\r\n     * @return {number}\r\n     *         The dimension that gets asked for or 0 if nothing was set\r\n     *         for that dimension.\r\n     */\r\n    ;\r\n\r\n    _proto.currentDimension = function currentDimension(widthOrHeight) {\r\n      var computedWidthOrHeight = 0;\r\n\r\n      if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\r\n        throw new Error('currentDimension only accepts width or height value');\r\n      }\r\n\r\n      computedWidthOrHeight = computedStyle(this.el_, widthOrHeight); // remove 'px' from variable and parse as integer\r\n\r\n      computedWidthOrHeight = parseFloat(computedWidthOrHeight); // if the computed value is still 0, it's possible that the browser is lying\r\n      // and we want to check the offset values.\r\n      // This code also runs wherever getComputedStyle doesn't exist.\r\n\r\n      if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {\r\n        var rule = \"offset\" + toTitleCase$1(widthOrHeight);\r\n        computedWidthOrHeight = this.el_[rule];\r\n      }\r\n\r\n      return computedWidthOrHeight;\r\n    }\r\n    /**\r\n     * An object that contains width and height values of the `Component`s\r\n     * computed style. Uses `window.getComputedStyle`.\r\n     *\r\n     * @typedef {Object} Component~DimensionObject\r\n     *\r\n     * @property {number} width\r\n     *           The width of the `Component`s computed style.\r\n     *\r\n     * @property {number} height\r\n     *           The height of the `Component`s computed style.\r\n     */\r\n\r\n    /**\r\n     * Get an object that contains computed width and height values of the\r\n     * component's element.\r\n     *\r\n     * Uses `window.getComputedStyle`.\r\n     *\r\n     * @return {Component~DimensionObject}\r\n     *         The computed dimensions of the component's element.\r\n     */\r\n    ;\r\n\r\n    _proto.currentDimensions = function currentDimensions() {\r\n      return {\r\n        width: this.currentDimension('width'),\r\n        height: this.currentDimension('height')\r\n      };\r\n    }\r\n    /**\r\n     * Get the computed width of the component's element.\r\n     *\r\n     * Uses `window.getComputedStyle`.\r\n     *\r\n     * @return {number}\r\n     *         The computed width of the component's element.\r\n     */\r\n    ;\r\n\r\n    _proto.currentWidth = function currentWidth() {\r\n      return this.currentDimension('width');\r\n    }\r\n    /**\r\n     * Get the computed height of the component's element.\r\n     *\r\n     * Uses `window.getComputedStyle`.\r\n     *\r\n     * @return {number}\r\n     *         The computed height of the component's element.\r\n     */\r\n    ;\r\n\r\n    _proto.currentHeight = function currentHeight() {\r\n      return this.currentDimension('height');\r\n    }\r\n    /**\r\n     * Set the focus to this component\r\n     */\r\n    ;\r\n\r\n    _proto.focus = function focus() {\r\n      this.el_.focus();\r\n    }\r\n    /**\r\n     * Remove the focus from this component\r\n     */\r\n    ;\r\n\r\n    _proto.blur = function blur() {\r\n      this.el_.blur();\r\n    }\r\n    /**\r\n     * When this Component receives a `keydown` event which it does not process,\r\n     *  it passes the event to the Player for handling.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      if (this.player_) {\r\n        // We only stop propagation here because we want unhandled events to fall\r\n        // back to the browser. Exclude Tab for focus trapping.\r\n        if (!keycode.isEventKey(event, 'Tab')) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        this.player_.handleKeyDown(event);\r\n      }\r\n    }\r\n    /**\r\n     * Many components used to have a `handleKeyPress` method, which was poorly\r\n     * named because it listened to a `keydown` event. This method name now\r\n     * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`\r\n     * will not see their method calls stop working.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to be called.\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyPress = function handleKeyPress(event) {\r\n      this.handleKeyDown(event);\r\n    }\r\n    /**\r\n     * Emit a 'tap' events when touch event support gets detected. This gets used to\r\n     * support toggling the controls through a tap on the video. They get enabled\r\n     * because every sub-component would have extra overhead otherwise.\r\n     *\r\n     * @private\r\n     * @fires Component#tap\r\n     * @listens Component#touchstart\r\n     * @listens Component#touchmove\r\n     * @listens Component#touchleave\r\n     * @listens Component#touchcancel\r\n     * @listens Component#touchend\r\n      */\r\n    ;\r\n\r\n    _proto.emitTapEvents = function emitTapEvents() {\r\n      // Track the start time so we can determine how long the touch lasted\r\n      var touchStart = 0;\r\n      var firstTouch = null; // Maximum movement allowed during a touch event to still be considered a tap\r\n      // Other popular libs use anywhere from 2 (hammer.js) to 15,\r\n      // so 10 seems like a nice, round number.\r\n\r\n      var tapMovementThreshold = 10; // The maximum length a touch can be while still being considered a tap\r\n\r\n      var touchTimeThreshold = 200;\r\n      var couldBeTap;\r\n      this.on('touchstart', function (event) {\r\n        // If more than one finger, don't consider treating this as a click\r\n        if (event.touches.length === 1) {\r\n          // Copy pageX/pageY from the object\r\n          firstTouch = {\r\n            pageX: event.touches[0].pageX,\r\n            pageY: event.touches[0].pageY\r\n          }; // Record start time so we can detect a tap vs. \"touch and hold\"\r\n\r\n          touchStart = window.performance.now(); // Reset couldBeTap tracking\r\n\r\n          couldBeTap = true;\r\n        }\r\n      });\r\n      this.on('touchmove', function (event) {\r\n        // If more than one finger, don't consider treating this as a click\r\n        if (event.touches.length > 1) {\r\n          couldBeTap = false;\r\n        } else if (firstTouch) {\r\n          // Some devices will throw touchmoves for all but the slightest of taps.\r\n          // So, if we moved only a small distance, this could still be a tap\r\n          var xdiff = event.touches[0].pageX - firstTouch.pageX;\r\n          var ydiff = event.touches[0].pageY - firstTouch.pageY;\r\n          var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\r\n\r\n          if (touchDistance > tapMovementThreshold) {\r\n            couldBeTap = false;\r\n          }\r\n        }\r\n      });\r\n\r\n      var noTap = function noTap() {\r\n        couldBeTap = false;\r\n      }; // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\r\n\r\n\r\n      this.on('touchleave', noTap);\r\n      this.on('touchcancel', noTap); // When the touch ends, measure how long it took and trigger the appropriate\r\n      // event\r\n\r\n      this.on('touchend', function (event) {\r\n        firstTouch = null; // Proceed only if the touchmove/leave/cancel event didn't happen\r\n\r\n        if (couldBeTap === true) {\r\n          // Measure how long the touch lasted\r\n          var touchTime = window.performance.now() - touchStart; // Make sure the touch was less than the threshold to be considered a tap\r\n\r\n          if (touchTime < touchTimeThreshold) {\r\n            // Don't let browser turn this into a click\r\n            event.preventDefault();\r\n            /**\r\n             * Triggered when a `Component` is tapped.\r\n             *\r\n             * @event Component#tap\r\n             * @type {EventTarget~Event}\r\n             */\r\n\r\n            this.trigger('tap'); // It may be good to copy the touchend event object and change the\r\n            // type to tap, if the other event properties aren't exact after\r\n            // Events.fixEvent runs (e.g. event.target)\r\n          }\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * This function reports user activity whenever touch events happen. This can get\r\n     * turned off by any sub-components that wants touch events to act another way.\r\n     *\r\n     * Report user touch activity when touch events occur. User activity gets used to\r\n     * determine when controls should show/hide. It is simple when it comes to mouse\r\n     * events, because any mouse event should show the controls. So we capture mouse\r\n     * events that bubble up to the player and report activity when that happens.\r\n     * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\r\n     * controls. So touch events can't help us at the player level either.\r\n     *\r\n     * User activity gets checked asynchronously. So what could happen is a tap event\r\n     * on the video turns the controls off. Then the `touchend` event bubbles up to\r\n     * the player. Which, if it reported user activity, would turn the controls right\r\n     * back on. We also don't want to completely block touch events from bubbling up.\r\n     * Furthermore a `touchmove` event and anything other than a tap, should not turn\r\n     * controls back on.\r\n     *\r\n     * @listens Component#touchstart\r\n     * @listens Component#touchmove\r\n     * @listens Component#touchend\r\n     * @listens Component#touchcancel\r\n     */\r\n    ;\r\n\r\n    _proto.enableTouchActivity = function enableTouchActivity() {\r\n      // Don't continue if the root player doesn't support reporting user activity\r\n      if (!this.player() || !this.player().reportUserActivity) {\r\n        return;\r\n      } // listener for reporting that the user is active\r\n\r\n\r\n      var report = bind(this.player(), this.player().reportUserActivity);\r\n      var touchHolding;\r\n      this.on('touchstart', function () {\r\n        report(); // For as long as the they are touching the device or have their mouse down,\r\n        // we consider them active even if they're not moving their finger or mouse.\r\n        // So we want to continue to update that they are active\r\n\r\n        this.clearInterval(touchHolding); // report at the same interval as activityCheck\r\n\r\n        touchHolding = this.setInterval(report, 250);\r\n      });\r\n\r\n      var touchEnd = function touchEnd(event) {\r\n        report(); // stop the interval that maintains activity if the touch is holding\r\n\r\n        this.clearInterval(touchHolding);\r\n      };\r\n\r\n      this.on('touchmove', report);\r\n      this.on('touchend', touchEnd);\r\n      this.on('touchcancel', touchEnd);\r\n    }\r\n    /**\r\n     * A callback that has no parameters and is bound into `Component`s context.\r\n     *\r\n     * @callback Component~GenericCallback\r\n     * @this Component\r\n     */\r\n\r\n    /**\r\n     * Creates a function that runs after an `x` millisecond timeout. This function is a\r\n     * wrapper around `window.setTimeout`. There are a few reasons to use this one\r\n     * instead though:\r\n     * 1. It gets cleared via  {@link Component#clearTimeout} when\r\n     *    {@link Component#dispose} gets called.\r\n     * 2. The function callback will gets turned into a {@link Component~GenericCallback}\r\n     *\r\n     * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\r\n     *         will cause its dispose listener not to get cleaned up! Please use\r\n     *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\r\n     *\r\n     * @param {Component~GenericCallback} fn\r\n     *        The function that will be run after `timeout`.\r\n     *\r\n     * @param {number} timeout\r\n     *        Timeout in milliseconds to delay before executing the specified function.\r\n     *\r\n     * @return {number}\r\n     *         Returns a timeout ID that gets used to identify the timeout. It can also\r\n     *         get used in {@link Component#clearTimeout} to clear the timeout that\r\n     *         was set.\r\n     *\r\n     * @listens Component#dispose\r\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\r\n     */\r\n    ;\r\n\r\n    _proto.setTimeout = function setTimeout(fn, timeout) {\r\n      var _this3 = this;\r\n\r\n      // declare as variables so they are properly available in timeout function\r\n      // eslint-disable-next-line\r\n      var timeoutId;\r\n      fn = bind(this, fn);\r\n      this.clearTimersOnDispose_();\r\n      timeoutId = window.setTimeout(function () {\r\n        if (_this3.setTimeoutIds_.has(timeoutId)) {\r\n          _this3.setTimeoutIds_[\"delete\"](timeoutId);\r\n        }\r\n\r\n        fn();\r\n      }, timeout);\r\n      this.setTimeoutIds_.add(timeoutId);\r\n      return timeoutId;\r\n    }\r\n    /**\r\n     * Clears a timeout that gets created via `window.setTimeout` or\r\n     * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\r\n     * use this function instead of `window.clearTimout`. If you don't your dispose\r\n     * listener will not get cleaned up until {@link Component#dispose}!\r\n     *\r\n     * @param {number} timeoutId\r\n     *        The id of the timeout to clear. The return value of\r\n     *        {@link Component#setTimeout} or `window.setTimeout`.\r\n     *\r\n     * @return {number}\r\n     *         Returns the timeout id that was cleared.\r\n     *\r\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\r\n     */\r\n    ;\r\n\r\n    _proto.clearTimeout = function clearTimeout(timeoutId) {\r\n      if (this.setTimeoutIds_.has(timeoutId)) {\r\n        this.setTimeoutIds_[\"delete\"](timeoutId);\r\n        window.clearTimeout(timeoutId);\r\n      }\r\n\r\n      return timeoutId;\r\n    }\r\n    /**\r\n     * Creates a function that gets run every `x` milliseconds. This function is a wrapper\r\n     * around `window.setInterval`. There are a few reasons to use this one instead though.\r\n     * 1. It gets cleared via  {@link Component#clearInterval} when\r\n     *    {@link Component#dispose} gets called.\r\n     * 2. The function callback will be a {@link Component~GenericCallback}\r\n     *\r\n     * @param {Component~GenericCallback} fn\r\n     *        The function to run every `x` seconds.\r\n     *\r\n     * @param {number} interval\r\n     *        Execute the specified function every `x` milliseconds.\r\n     *\r\n     * @return {number}\r\n     *         Returns an id that can be used to identify the interval. It can also be be used in\r\n     *         {@link Component#clearInterval} to clear the interval.\r\n     *\r\n     * @listens Component#dispose\r\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\r\n     */\r\n    ;\r\n\r\n    _proto.setInterval = function setInterval(fn, interval) {\r\n      fn = bind(this, fn);\r\n      this.clearTimersOnDispose_();\r\n      var intervalId = window.setInterval(fn, interval);\r\n      this.setIntervalIds_.add(intervalId);\r\n      return intervalId;\r\n    }\r\n    /**\r\n     * Clears an interval that gets created via `window.setInterval` or\r\n     * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\r\n     * use this function instead of `window.clearInterval`. If you don't your dispose\r\n     * listener will not get cleaned up until {@link Component#dispose}!\r\n     *\r\n     * @param {number} intervalId\r\n     *        The id of the interval to clear. The return value of\r\n     *        {@link Component#setInterval} or `window.setInterval`.\r\n     *\r\n     * @return {number}\r\n     *         Returns the interval id that was cleared.\r\n     *\r\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\r\n     */\r\n    ;\r\n\r\n    _proto.clearInterval = function clearInterval(intervalId) {\r\n      if (this.setIntervalIds_.has(intervalId)) {\r\n        this.setIntervalIds_[\"delete\"](intervalId);\r\n        window.clearInterval(intervalId);\r\n      }\r\n\r\n      return intervalId;\r\n    }\r\n    /**\r\n     * Queues up a callback to be passed to requestAnimationFrame (rAF), but\r\n     * with a few extra bonuses:\r\n     *\r\n     * - Supports browsers that do not support rAF by falling back to\r\n     *   {@link Component#setTimeout}.\r\n     *\r\n     * - The callback is turned into a {@link Component~GenericCallback} (i.e.\r\n     *   bound to the component).\r\n     *\r\n     * - Automatic cancellation of the rAF callback is handled if the component\r\n     *   is disposed before it is called.\r\n     *\r\n     * @param  {Component~GenericCallback} fn\r\n     *         A function that will be bound to this component and executed just\r\n     *         before the browser's next repaint.\r\n     *\r\n     * @return {number}\r\n     *         Returns an rAF ID that gets used to identify the timeout. It can\r\n     *         also be used in {@link Component#cancelAnimationFrame} to cancel\r\n     *         the animation frame callback.\r\n     *\r\n     * @listens Component#dispose\r\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\r\n     */\r\n    ;\r\n\r\n    _proto.requestAnimationFrame = function requestAnimationFrame(fn) {\r\n      var _this4 = this;\r\n\r\n      // Fall back to using a timer.\r\n      if (!this.supportsRaf_) {\r\n        return this.setTimeout(fn, 1000 / 60);\r\n      }\r\n\r\n      this.clearTimersOnDispose_(); // declare as variables so they are properly available in rAF function\r\n      // eslint-disable-next-line\r\n\r\n      var id;\r\n      fn = bind(this, fn);\r\n      id = window.requestAnimationFrame(function () {\r\n        if (_this4.rafIds_.has(id)) {\r\n          _this4.rafIds_[\"delete\"](id);\r\n        }\r\n\r\n        fn();\r\n      });\r\n      this.rafIds_.add(id);\r\n      return id;\r\n    }\r\n    /**\r\n     * Request an animation frame, but only one named animation\r\n     * frame will be queued. Another will never be added until\r\n     * the previous one finishes.\r\n     *\r\n     * @param {string} name\r\n     *        The name to give this requestAnimationFrame\r\n     *\r\n     * @param  {Component~GenericCallback} fn\r\n     *         A function that will be bound to this component and executed just\r\n     *         before the browser's next repaint.\r\n     */\r\n    ;\r\n\r\n    _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn) {\r\n      var _this5 = this;\r\n\r\n      if (this.namedRafs_.has(name)) {\r\n        return;\r\n      }\r\n\r\n      this.clearTimersOnDispose_();\r\n      fn = bind(this, fn);\r\n      var id = this.requestAnimationFrame(function () {\r\n        fn();\r\n\r\n        if (_this5.namedRafs_.has(name)) {\r\n          _this5.namedRafs_[\"delete\"](name);\r\n        }\r\n      });\r\n      this.namedRafs_.set(name, id);\r\n      return name;\r\n    }\r\n    /**\r\n     * Cancels a current named animation frame if it exists.\r\n     *\r\n     * @param {string} name\r\n     *        The name of the requestAnimationFrame to cancel.\r\n     */\r\n    ;\r\n\r\n    _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {\r\n      if (!this.namedRafs_.has(name)) {\r\n        return;\r\n      }\r\n\r\n      this.cancelAnimationFrame(this.namedRafs_.get(name));\r\n      this.namedRafs_[\"delete\"](name);\r\n    }\r\n    /**\r\n     * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\r\n     * (rAF).\r\n     *\r\n     * If you queue an rAF callback via {@link Component#requestAnimationFrame},\r\n     * use this function instead of `window.cancelAnimationFrame`. If you don't,\r\n     * your dispose listener will not get cleaned up until {@link Component#dispose}!\r\n     *\r\n     * @param {number} id\r\n     *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\r\n     *\r\n     * @return {number}\r\n     *         Returns the rAF ID that was cleared.\r\n     *\r\n     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\r\n     */\r\n    ;\r\n\r\n    _proto.cancelAnimationFrame = function cancelAnimationFrame(id) {\r\n      // Fall back to using a timer.\r\n      if (!this.supportsRaf_) {\r\n        return this.clearTimeout(id);\r\n      }\r\n\r\n      if (this.rafIds_.has(id)) {\r\n        this.rafIds_[\"delete\"](id);\r\n        window.cancelAnimationFrame(id);\r\n      }\r\n\r\n      return id;\r\n    }\r\n    /**\r\n     * A function to setup `requestAnimationFrame`, `setTimeout`,\r\n     * and `setInterval`, clearing on dispose.\r\n     *\r\n     * > Previously each timer added and removed dispose listeners on it's own.\r\n     * For better performance it was decided to batch them all, and use `Set`s\r\n     * to track outstanding timer ids.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {\r\n      var _this6 = this;\r\n\r\n      if (this.clearingTimersOnDispose_) {\r\n        return;\r\n      }\r\n\r\n      this.clearingTimersOnDispose_ = true;\r\n      this.one('dispose', function () {\r\n        [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(function (_ref) {\r\n          var idName = _ref[0],\r\n              cancelName = _ref[1];\r\n\r\n          // for a `Set` key will actually be the value again\r\n          // so forEach((val, val) =>` but for maps we want to use\r\n          // the key.\r\n          _this6[idName].forEach(function (val, key) {\r\n            return _this6[cancelName](key);\r\n          });\r\n        });\r\n        _this6.clearingTimersOnDispose_ = false;\r\n      });\r\n    }\r\n    /**\r\n     * Register a `Component` with `videojs` given the name and the component.\r\n     *\r\n     * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\r\n     *         should be registered using {@link Tech.registerTech} or\r\n     *         {@link videojs:videojs.registerTech}.\r\n     *\r\n     * > NOTE: This function can also be seen on videojs as\r\n     *         {@link videojs:videojs.registerComponent}.\r\n     *\r\n     * @param {string} name\r\n     *        The name of the `Component` to register.\r\n     *\r\n     * @param {Component} ComponentToRegister\r\n     *        The `Component` class to register.\r\n     *\r\n     * @return {Component}\r\n     *         The `Component` that was registered.\r\n     */\r\n    ;\r\n\r\n    Component.registerComponent = function registerComponent(name, ComponentToRegister) {\r\n      if (typeof name !== 'string' || !name) {\r\n        throw new Error(\"Illegal component name, \\\"\" + name + \"\\\"; must be a non-empty string.\");\r\n      }\r\n\r\n      var Tech = Component.getComponent('Tech'); // We need to make sure this check is only done if Tech has been registered.\r\n\r\n      var isTech = Tech && Tech.isTech(ComponentToRegister);\r\n      var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);\r\n\r\n      if (isTech || !isComp) {\r\n        var reason;\r\n\r\n        if (isTech) {\r\n          reason = 'techs must be registered using Tech.registerTech()';\r\n        } else {\r\n          reason = 'must be a Component subclass';\r\n        }\r\n\r\n        throw new Error(\"Illegal component, \\\"\" + name + \"\\\"; \" + reason + \".\");\r\n      }\r\n\r\n      name = toTitleCase$1(name);\r\n\r\n      if (!Component.components_) {\r\n        Component.components_ = {};\r\n      }\r\n\r\n      var Player = Component.getComponent('Player');\r\n\r\n      if (name === 'Player' && Player && Player.players) {\r\n        var players = Player.players;\r\n        var playerNames = Object.keys(players); // If we have players that were disposed, then their name will still be\r\n        // in Players.players. So, we must loop through and verify that the value\r\n        // for each item is not null. This allows registration of the Player component\r\n        // after all players have been disposed or before any were created.\r\n\r\n        if (players && playerNames.length > 0 && playerNames.map(function (pname) {\r\n          return players[pname];\r\n        }).every(Boolean)) {\r\n          throw new Error('Can not register Player component after player has been created.');\r\n        }\r\n      }\r\n\r\n      Component.components_[name] = ComponentToRegister;\r\n      Component.components_[toLowerCase(name)] = ComponentToRegister;\r\n      return ComponentToRegister;\r\n    }\r\n    /**\r\n     * Get a `Component` based on the name it was registered with.\r\n     *\r\n     * @param {string} name\r\n     *        The Name of the component to get.\r\n     *\r\n     * @return {Component}\r\n     *         The `Component` that got registered under the given name.\r\n     */\r\n    ;\r\n\r\n    Component.getComponent = function getComponent(name) {\r\n      if (!name || !Component.components_) {\r\n        return;\r\n      }\r\n\r\n      return Component.components_[name];\r\n    };\r\n\r\n    return Component;\r\n  }();\r\n  /**\r\n   * Whether or not this component supports `requestAnimationFrame`.\r\n   *\r\n   * This is exposed primarily for testing purposes.\r\n   *\r\n   * @private\r\n   * @type {Boolean}\r\n   */\r\n\r\n\r\n  Component$1.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';\r\n  Component$1.registerComponent('Component', Component$1);\r\n\r\n  function _assertThisInitialized(self) {\r\n    if (self === void 0) {\r\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n    }\r\n\r\n    return self;\r\n  }\r\n\r\n  var assertThisInitialized = _assertThisInitialized;\r\n\r\n  function _inheritsLoose(subClass, superClass) {\r\n    subClass.prototype = Object.create(superClass.prototype);\r\n    subClass.prototype.constructor = subClass;\r\n    subClass.__proto__ = superClass;\r\n  }\r\n\r\n  var inheritsLoose = _inheritsLoose;\r\n\r\n  /**\r\n   * @file time-ranges.js\r\n   * @module time-ranges\r\n   */\r\n\r\n  /**\r\n   * Returns the time for the specified index at the start or end\r\n   * of a TimeRange object.\r\n   *\r\n   * @typedef    {Function} TimeRangeIndex\r\n   *\r\n   * @param      {number} [index=0]\r\n   *             The range number to return the time for.\r\n   *\r\n   * @return     {number}\r\n   *             The time offset at the specified index.\r\n   *\r\n   * @deprecated The index argument must be provided.\r\n   *             In the future, leaving it out will throw an error.\r\n   */\r\n\r\n  /**\r\n   * An object that contains ranges of time.\r\n   *\r\n   * @typedef  {Object} TimeRange\r\n   *\r\n   * @property {number} length\r\n   *           The number of time ranges represented by this object.\r\n   *\r\n   * @property {module:time-ranges~TimeRangeIndex} start\r\n   *           Returns the time offset at which a specified time range begins.\r\n   *\r\n   * @property {module:time-ranges~TimeRangeIndex} end\r\n   *           Returns the time offset at which a specified time range ends.\r\n   *\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\r\n   */\r\n\r\n  /**\r\n   * Check if any of the time ranges are over the maximum index.\r\n   *\r\n   * @private\r\n   * @param   {string} fnName\r\n   *          The function name to use for logging\r\n   *\r\n   * @param   {number} index\r\n   *          The index to check\r\n   *\r\n   * @param   {number} maxIndex\r\n   *          The maximum possible index\r\n   *\r\n   * @throws  {Error} if the timeRanges provided are over the maxIndex\r\n   */\r\n  function rangeCheck(fnName, index, maxIndex) {\r\n    if (typeof index !== 'number' || index < 0 || index > maxIndex) {\r\n      throw new Error(\"Failed to execute '\" + fnName + \"' on 'TimeRanges': The index provided (\" + index + \") is non-numeric or out of bounds (0-\" + maxIndex + \").\");\r\n    }\r\n  }\r\n  /**\r\n   * Get the time for the specified index at the start or end\r\n   * of a TimeRange object.\r\n   *\r\n   * @private\r\n   * @param      {string} fnName\r\n   *             The function name to use for logging\r\n   *\r\n   * @param      {string} valueIndex\r\n   *             The property that should be used to get the time. should be\r\n   *             'start' or 'end'\r\n   *\r\n   * @param      {Array} ranges\r\n   *             An array of time ranges\r\n   *\r\n   * @param      {Array} [rangeIndex=0]\r\n   *             The index to start the search at\r\n   *\r\n   * @return     {number}\r\n   *             The time that offset at the specified index.\r\n   *\r\n   * @deprecated rangeIndex must be set to a value, in the future this will throw an error.\r\n   * @throws     {Error} if rangeIndex is more than the length of ranges\r\n   */\r\n\r\n\r\n  function getRange(fnName, valueIndex, ranges, rangeIndex) {\r\n    rangeCheck(fnName, rangeIndex, ranges.length - 1);\r\n    return ranges[rangeIndex][valueIndex];\r\n  }\r\n  /**\r\n   * Create a time range object given ranges of time.\r\n   *\r\n   * @private\r\n   * @param   {Array} [ranges]\r\n   *          An array of time ranges.\r\n   */\r\n\r\n\r\n  function createTimeRangesObj(ranges) {\r\n    var timeRangesObj;\r\n\r\n    if (ranges === undefined || ranges.length === 0) {\r\n      timeRangesObj = {\r\n        length: 0,\r\n        start: function start() {\r\n          throw new Error('This TimeRanges object is empty');\r\n        },\r\n        end: function end() {\r\n          throw new Error('This TimeRanges object is empty');\r\n        }\r\n      };\r\n    } else {\r\n      timeRangesObj = {\r\n        length: ranges.length,\r\n        start: getRange.bind(null, 'start', 0, ranges),\r\n        end: getRange.bind(null, 'end', 1, ranges)\r\n      };\r\n    }\r\n\r\n    if (window.Symbol && window.Symbol.iterator) {\r\n      timeRangesObj[window.Symbol.iterator] = function () {\r\n        return (ranges || []).values();\r\n      };\r\n    }\r\n\r\n    return timeRangesObj;\r\n  }\r\n  /**\r\n   * Create a `TimeRange` object which mimics an\r\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges|HTML5 TimeRanges instance}.\r\n   *\r\n   * @param {number|Array[]} start\r\n   *        The start of a single range (a number) or an array of ranges (an\r\n   *        array of arrays of two numbers each).\r\n   *\r\n   * @param {number} end\r\n   *        The end of a single range. Cannot be used with the array form of\r\n   *        the `start` argument.\r\n   */\r\n\r\n\r\n  function createTimeRanges(start, end) {\r\n    if (Array.isArray(start)) {\r\n      return createTimeRangesObj(start);\r\n    } else if (start === undefined || end === undefined) {\r\n      return createTimeRangesObj();\r\n    }\r\n\r\n    return createTimeRangesObj([[start, end]]);\r\n  }\r\n\r\n  /**\r\n   * @file buffer.js\r\n   * @module buffer\r\n   */\r\n  /**\r\n   * Compute the percentage of the media that has been buffered.\r\n   *\r\n   * @param {TimeRange} buffered\r\n   *        The current `TimeRange` object representing buffered time ranges\r\n   *\r\n   * @param {number} duration\r\n   *        Total duration of the media\r\n   *\r\n   * @return {number}\r\n   *         Percent buffered of the total duration in decimal form.\r\n   */\r\n\r\n  function bufferedPercent(buffered, duration) {\r\n    var bufferedDuration = 0;\r\n    var start;\r\n    var end;\r\n\r\n    if (!duration) {\r\n      return 0;\r\n    }\r\n\r\n    if (!buffered || !buffered.length) {\r\n      buffered = createTimeRanges(0, 0);\r\n    }\r\n\r\n    for (var i = 0; i < buffered.length; i++) {\r\n      start = buffered.start(i);\r\n      end = buffered.end(i); // buffered end can be bigger than duration by a very small fraction\r\n\r\n      if (end > duration) {\r\n        end = duration;\r\n      }\r\n\r\n      bufferedDuration += end - start;\r\n    }\r\n\r\n    return bufferedDuration / duration;\r\n  }\r\n\r\n  /**\r\n   * @file media-error.js\r\n   */\r\n  /**\r\n   * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\r\n   *\r\n   * @param {number|string|Object|MediaError} value\r\n   *        This can be of multiple types:\r\n   *        - number: should be a standard error code\r\n   *        - string: an error message (the code will be 0)\r\n   *        - Object: arbitrary properties\r\n   *        - `MediaError` (native): used to populate a video.js `MediaError` object\r\n   *        - `MediaError` (video.js): will return itself if it's already a\r\n   *          video.js `MediaError` object.\r\n   *\r\n   * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\r\n   * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\r\n   *\r\n   * @class MediaError\r\n   */\r\n\r\n  function MediaError(value) {\r\n    // Allow redundant calls to this constructor to avoid having `instanceof`\r\n    // checks peppered around the code.\r\n    if (value instanceof MediaError) {\r\n      return value;\r\n    }\r\n\r\n    if (typeof value === 'number') {\r\n      this.code = value;\r\n    } else if (typeof value === 'string') {\r\n      // default code is zero, so this is a custom error\r\n      this.message = value;\r\n    } else if (isObject$1(value)) {\r\n      // We assign the `code` property manually because native `MediaError` objects\r\n      // do not expose it as an own/enumerable property of the object.\r\n      if (typeof value.code === 'number') {\r\n        this.code = value.code;\r\n      }\r\n\r\n      assign(this, value);\r\n    }\r\n\r\n    if (!this.message) {\r\n      this.message = MediaError.defaultMessages[this.code] || '';\r\n    }\r\n  }\r\n  /**\r\n   * The error code that refers two one of the defined `MediaError` types\r\n   *\r\n   * @type {Number}\r\n   */\r\n\r\n\r\n  MediaError.prototype.code = 0;\r\n  /**\r\n   * An optional message that to show with the error. Message is not part of the HTML5\r\n   * video spec but allows for more informative custom errors.\r\n   *\r\n   * @type {String}\r\n   */\r\n\r\n  MediaError.prototype.message = '';\r\n  /**\r\n   * An optional status code that can be set by plugins to allow even more detail about\r\n   * the error. For example a plugin might provide a specific HTTP status code and an\r\n   * error message for that code. Then when the plugin gets that error this class will\r\n   * know how to display an error message for it. This allows a custom message to show\r\n   * up on the `Player` error overlay.\r\n   *\r\n   * @type {Array}\r\n   */\r\n\r\n  MediaError.prototype.status = null;\r\n  /**\r\n   * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\r\n   * specification listed under {@link MediaError} for more information.\r\n   *\r\n   * @enum {array}\r\n   * @readonly\r\n   * @property {string} 0 - MEDIA_ERR_CUSTOM\r\n   * @property {string} 1 - MEDIA_ERR_ABORTED\r\n   * @property {string} 2 - MEDIA_ERR_NETWORK\r\n   * @property {string} 3 - MEDIA_ERR_DECODE\r\n   * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\r\n   * @property {string} 5 - MEDIA_ERR_ENCRYPTED\r\n   */\r\n\r\n  MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\r\n  /**\r\n   * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\r\n   *\r\n   * @type {Array}\r\n   * @constant\r\n   */\r\n\r\n  MediaError.defaultMessages = {\r\n    1: 'You aborted the media playback',\r\n    2: 'A network error caused the media download to fail part-way.',\r\n    3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\r\n    4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\r\n    5: 'The media is encrypted and we do not have the keys to decrypt it.'\r\n  }; // Add types as properties on MediaError\r\n  // e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\r\n\r\n  for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\r\n    MediaError[MediaError.errorTypes[errNum]] = errNum; // values should be accessible on both the class and instance\r\n\r\n    MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\r\n  } // jsdocs for instance/static members added above\r\n\r\n  var tuple = SafeParseTuple;\r\n\r\n  function SafeParseTuple(obj, reviver) {\r\n    var json;\r\n    var error = null;\r\n\r\n    try {\r\n      json = JSON.parse(obj, reviver);\r\n    } catch (err) {\r\n      error = err;\r\n    }\r\n\r\n    return [error, json];\r\n  }\r\n\r\n  /**\r\n   * Returns whether an object is `Promise`-like (i.e. has a `then` method).\r\n   *\r\n   * @param  {Object}  value\r\n   *         An object that may or may not be `Promise`-like.\r\n   *\r\n   * @return {boolean}\r\n   *         Whether or not the object is `Promise`-like.\r\n   */\r\n  function isPromise(value) {\r\n    return value !== undefined && value !== null && typeof value.then === 'function';\r\n  }\r\n  /**\r\n   * Silence a Promise-like object.\r\n   *\r\n   * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\r\n   * play promise\" rejection error messages.\r\n   *\r\n   * @param  {Object} value\r\n   *         An object that may or may not be `Promise`-like.\r\n   */\r\n\r\n  function silencePromise(value) {\r\n    if (isPromise(value)) {\r\n      value.then(null, function (e) {});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @file text-track-list-converter.js Utilities for capturing text track state and\r\n   * re-creating tracks based on a capture.\r\n   *\r\n   * @module text-track-list-converter\r\n   */\r\n\r\n  /**\r\n   * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\r\n   * represents the {@link TextTrack}'s state.\r\n   *\r\n   * @param {TextTrack} track\r\n   *        The text track to query.\r\n   *\r\n   * @return {Object}\r\n   *         A serializable javascript representation of the TextTrack.\r\n   * @private\r\n   */\r\n  var trackToJson_ = function trackToJson_(track) {\r\n    var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\r\n      if (track[prop]) {\r\n        acc[prop] = track[prop];\r\n      }\r\n\r\n      return acc;\r\n    }, {\r\n      cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\r\n        return {\r\n          startTime: cue.startTime,\r\n          endTime: cue.endTime,\r\n          text: cue.text,\r\n          id: cue.id\r\n        };\r\n      })\r\n    });\r\n    return ret;\r\n  };\r\n  /**\r\n   * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\r\n   * state of all {@link TextTrack}s currently configured. The return array is compatible with\r\n   * {@link text-track-list-converter:jsonToTextTracks}.\r\n   *\r\n   * @param {Tech} tech\r\n   *        The tech object to query\r\n   *\r\n   * @return {Array}\r\n   *         A serializable javascript representation of the {@link Tech}s\r\n   *         {@link TextTrackList}.\r\n   */\r\n\r\n\r\n  var textTracksToJson = function textTracksToJson(tech) {\r\n    var trackEls = tech.$$('track');\r\n    var trackObjs = Array.prototype.map.call(trackEls, function (t) {\r\n      return t.track;\r\n    });\r\n    var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\r\n      var json = trackToJson_(trackEl.track);\r\n\r\n      if (trackEl.src) {\r\n        json.src = trackEl.src;\r\n      }\r\n\r\n      return json;\r\n    });\r\n    return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\r\n      return trackObjs.indexOf(track) === -1;\r\n    }).map(trackToJson_));\r\n  };\r\n  /**\r\n   * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\r\n   * object {@link TextTrack} representations.\r\n   *\r\n   * @param {Array} json\r\n   *        An array of `TextTrack` representation objects, like those that would be\r\n   *        produced by `textTracksToJson`.\r\n   *\r\n   * @param {Tech} tech\r\n   *        The `Tech` to create the `TextTrack`s on.\r\n   */\r\n\r\n\r\n  var jsonToTextTracks = function jsonToTextTracks(json, tech) {\r\n    json.forEach(function (track) {\r\n      var addedTrack = tech.addRemoteTextTrack(track).track;\r\n\r\n      if (!track.src && track.cues) {\r\n        track.cues.forEach(function (cue) {\r\n          return addedTrack.addCue(cue);\r\n        });\r\n      }\r\n    });\r\n    return tech.textTracks();\r\n  };\r\n\r\n  var textTrackConverter = {\r\n    textTracksToJson: textTracksToJson,\r\n    jsonToTextTracks: jsonToTextTracks,\r\n    trackToJson_: trackToJson_\r\n  };\r\n\r\n  var MODAL_CLASS_NAME = 'vjs-modal-dialog';\r\n  /**\r\n   * The `ModalDialog` displays over the video and its controls, which blocks\r\n   * interaction with the player until it is closed.\r\n   *\r\n   * Modal dialogs include a \"Close\" button and will close when that button\r\n   * is activated - or when ESC is pressed anywhere.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var ModalDialog = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(ModalDialog, _Component);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Mixed} [options.content=undefined]\r\n     *        Provide customized content for this modal.\r\n     *\r\n     * @param {string} [options.description]\r\n     *        A text description for the modal, primarily for accessibility.\r\n     *\r\n     * @param {boolean} [options.fillAlways=false]\r\n     *        Normally, modals are automatically filled only the first time\r\n     *        they open. This tells the modal to refresh its content\r\n     *        every time it opens.\r\n     *\r\n     * @param {string} [options.label]\r\n     *        A text label for the modal, primarily for accessibility.\r\n     *\r\n     * @param {boolean} [options.pauseOnOpen=true]\r\n     *        If `true`, playback will will be paused if playing when\r\n     *        the modal opens, and resumed when it closes.\r\n     *\r\n     * @param {boolean} [options.temporary=true]\r\n     *        If `true`, the modal can only be opened once; it will be\r\n     *        disposed as soon as it's closed.\r\n     *\r\n     * @param {boolean} [options.uncloseable=false]\r\n     *        If `true`, the user will not be able to close the modal\r\n     *        through the UI in the normal ways. Programmatic closing is\r\n     *        still possible.\r\n     */\r\n    function ModalDialog(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n\r\n      _this.handleKeyDown_ = function (e) {\r\n        return _this.handleKeyDown(e);\r\n      };\r\n\r\n      _this.close_ = function (e) {\r\n        return _this.close(e);\r\n      };\r\n\r\n      _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;\r\n\r\n      _this.closeable(!_this.options_.uncloseable);\r\n\r\n      _this.content(_this.options_.content); // Make sure the contentEl is defined AFTER any children are initialized\r\n      // because we only want the contents of the modal in the contentEl\r\n      // (not the UI elements like the close button).\r\n\r\n\r\n      _this.contentEl_ = createEl('div', {\r\n        className: MODAL_CLASS_NAME + \"-content\"\r\n      }, {\r\n        role: 'document'\r\n      });\r\n      _this.descEl_ = createEl('p', {\r\n        className: MODAL_CLASS_NAME + \"-description vjs-control-text\",\r\n        id: _this.el().getAttribute('aria-describedby')\r\n      });\r\n      textContent(_this.descEl_, _this.description());\r\n\r\n      _this.el_.appendChild(_this.descEl_);\r\n\r\n      _this.el_.appendChild(_this.contentEl_);\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `ModalDialog`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The DOM element that gets created.\r\n     */\r\n\r\n\r\n    var _proto = ModalDialog.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: this.buildCSSClass(),\r\n        tabIndex: -1\r\n      }, {\r\n        'aria-describedby': this.id() + \"_description\",\r\n        'aria-hidden': 'true',\r\n        'aria-label': this.label(),\r\n        'role': 'dialog'\r\n      });\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.contentEl_ = null;\r\n      this.descEl_ = null;\r\n      this.previouslyActiveEl_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    ;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return MODAL_CLASS_NAME + \" vjs-hidden \" + _Component.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Returns the label string for this modal. Primarily used for accessibility.\r\n     *\r\n     * @return {string}\r\n     *         the localized or raw label of this modal.\r\n     */\r\n    ;\r\n\r\n    _proto.label = function label() {\r\n      return this.localize(this.options_.label || 'Modal Window');\r\n    }\r\n    /**\r\n     * Returns the description string for this modal. Primarily used for\r\n     * accessibility.\r\n     *\r\n     * @return {string}\r\n     *         The localized or raw description of this modal.\r\n     */\r\n    ;\r\n\r\n    _proto.description = function description() {\r\n      var desc = this.options_.description || this.localize('This is a modal window.'); // Append a universal closeability message if the modal is closeable.\r\n\r\n      if (this.closeable()) {\r\n        desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\r\n      }\r\n\r\n      return desc;\r\n    }\r\n    /**\r\n     * Opens the modal.\r\n     *\r\n     * @fires ModalDialog#beforemodalopen\r\n     * @fires ModalDialog#modalopen\r\n     */\r\n    ;\r\n\r\n    _proto.open = function open() {\r\n      if (!this.opened_) {\r\n        var player = this.player();\r\n        /**\r\n          * Fired just before a `ModalDialog` is opened.\r\n          *\r\n          * @event ModalDialog#beforemodalopen\r\n          * @type {EventTarget~Event}\r\n          */\r\n\r\n        this.trigger('beforemodalopen');\r\n        this.opened_ = true; // Fill content if the modal has never opened before and\r\n        // never been filled.\r\n\r\n        if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\r\n          this.fill();\r\n        } // If the player was playing, pause it and take note of its previously\r\n        // playing state.\r\n\r\n\r\n        this.wasPlaying_ = !player.paused();\r\n\r\n        if (this.options_.pauseOnOpen && this.wasPlaying_) {\r\n          player.pause();\r\n        }\r\n\r\n        this.on('keydown', this.handleKeyDown_); // Hide controls and note if they were enabled.\r\n\r\n        this.hadControls_ = player.controls();\r\n        player.controls(false);\r\n        this.show();\r\n        this.conditionalFocus_();\r\n        this.el().setAttribute('aria-hidden', 'false');\r\n        /**\r\n          * Fired just after a `ModalDialog` is opened.\r\n          *\r\n          * @event ModalDialog#modalopen\r\n          * @type {EventTarget~Event}\r\n          */\r\n\r\n        this.trigger('modalopen');\r\n        this.hasBeenOpened_ = true;\r\n      }\r\n    }\r\n    /**\r\n     * If the `ModalDialog` is currently open or closed.\r\n     *\r\n     * @param  {boolean} [value]\r\n     *         If given, it will open (`true`) or close (`false`) the modal.\r\n     *\r\n     * @return {boolean}\r\n     *         the current open state of the modaldialog\r\n     */\r\n    ;\r\n\r\n    _proto.opened = function opened(value) {\r\n      if (typeof value === 'boolean') {\r\n        this[value ? 'open' : 'close']();\r\n      }\r\n\r\n      return this.opened_;\r\n    }\r\n    /**\r\n     * Closes the modal, does nothing if the `ModalDialog` is\r\n     * not open.\r\n     *\r\n     * @fires ModalDialog#beforemodalclose\r\n     * @fires ModalDialog#modalclose\r\n     */\r\n    ;\r\n\r\n    _proto.close = function close() {\r\n      if (!this.opened_) {\r\n        return;\r\n      }\r\n\r\n      var player = this.player();\r\n      /**\r\n        * Fired just before a `ModalDialog` is closed.\r\n        *\r\n        * @event ModalDialog#beforemodalclose\r\n        * @type {EventTarget~Event}\r\n        */\r\n\r\n      this.trigger('beforemodalclose');\r\n      this.opened_ = false;\r\n\r\n      if (this.wasPlaying_ && this.options_.pauseOnOpen) {\r\n        player.play();\r\n      }\r\n\r\n      this.off('keydown', this.handleKeyDown_);\r\n\r\n      if (this.hadControls_) {\r\n        player.controls(true);\r\n      }\r\n\r\n      this.hide();\r\n      this.el().setAttribute('aria-hidden', 'true');\r\n      /**\r\n        * Fired just after a `ModalDialog` is closed.\r\n        *\r\n        * @event ModalDialog#modalclose\r\n        * @type {EventTarget~Event}\r\n        */\r\n\r\n      this.trigger('modalclose');\r\n      this.conditionalBlur_();\r\n\r\n      if (this.options_.temporary) {\r\n        this.dispose();\r\n      }\r\n    }\r\n    /**\r\n     * Check to see if the `ModalDialog` is closeable via the UI.\r\n     *\r\n     * @param  {boolean} [value]\r\n     *         If given as a boolean, it will set the `closeable` option.\r\n     *\r\n     * @return {boolean}\r\n     *         Returns the final value of the closable option.\r\n     */\r\n    ;\r\n\r\n    _proto.closeable = function closeable(value) {\r\n      if (typeof value === 'boolean') {\r\n        var closeable = this.closeable_ = !!value;\r\n        var close = this.getChild('closeButton'); // If this is being made closeable and has no close button, add one.\r\n\r\n        if (closeable && !close) {\r\n          // The close button should be a child of the modal - not its\r\n          // content element, so temporarily change the content element.\r\n          var temp = this.contentEl_;\r\n          this.contentEl_ = this.el_;\r\n          close = this.addChild('closeButton', {\r\n            controlText: 'Close Modal Dialog'\r\n          });\r\n          this.contentEl_ = temp;\r\n          this.on(close, 'close', this.close_);\r\n        } // If this is being made uncloseable and has a close button, remove it.\r\n\r\n\r\n        if (!closeable && close) {\r\n          this.off(close, 'close', this.close_);\r\n          this.removeChild(close);\r\n          close.dispose();\r\n        }\r\n      }\r\n\r\n      return this.closeable_;\r\n    }\r\n    /**\r\n     * Fill the modal's content element with the modal's \"content\" option.\r\n     * The content element will be emptied before this change takes place.\r\n     */\r\n    ;\r\n\r\n    _proto.fill = function fill() {\r\n      this.fillWith(this.content());\r\n    }\r\n    /**\r\n     * Fill the modal's content element with arbitrary content.\r\n     * The content element will be emptied before this change takes place.\r\n     *\r\n     * @fires ModalDialog#beforemodalfill\r\n     * @fires ModalDialog#modalfill\r\n     *\r\n     * @param {Mixed} [content]\r\n     *        The same rules apply to this as apply to the `content` option.\r\n     */\r\n    ;\r\n\r\n    _proto.fillWith = function fillWith(content) {\r\n      var contentEl = this.contentEl();\r\n      var parentEl = contentEl.parentNode;\r\n      var nextSiblingEl = contentEl.nextSibling;\r\n      /**\r\n        * Fired just before a `ModalDialog` is filled with content.\r\n        *\r\n        * @event ModalDialog#beforemodalfill\r\n        * @type {EventTarget~Event}\r\n        */\r\n\r\n      this.trigger('beforemodalfill');\r\n      this.hasBeenFilled_ = true; // Detach the content element from the DOM before performing\r\n      // manipulation to avoid modifying the live DOM multiple times.\r\n\r\n      parentEl.removeChild(contentEl);\r\n      this.empty();\r\n      insertContent(contentEl, content);\r\n      /**\r\n       * Fired just after a `ModalDialog` is filled with content.\r\n       *\r\n       * @event ModalDialog#modalfill\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('modalfill'); // Re-inject the re-filled content element.\r\n\r\n      if (nextSiblingEl) {\r\n        parentEl.insertBefore(contentEl, nextSiblingEl);\r\n      } else {\r\n        parentEl.appendChild(contentEl);\r\n      } // make sure that the close button is last in the dialog DOM\r\n\r\n\r\n      var closeButton = this.getChild('closeButton');\r\n\r\n      if (closeButton) {\r\n        parentEl.appendChild(closeButton.el_);\r\n      }\r\n    }\r\n    /**\r\n     * Empties the content element. This happens anytime the modal is filled.\r\n     *\r\n     * @fires ModalDialog#beforemodalempty\r\n     * @fires ModalDialog#modalempty\r\n     */\r\n    ;\r\n\r\n    _proto.empty = function empty() {\r\n      /**\r\n      * Fired just before a `ModalDialog` is emptied.\r\n      *\r\n      * @event ModalDialog#beforemodalempty\r\n      * @type {EventTarget~Event}\r\n      */\r\n      this.trigger('beforemodalempty');\r\n      emptyEl(this.contentEl());\r\n      /**\r\n      * Fired just after a `ModalDialog` is emptied.\r\n      *\r\n      * @event ModalDialog#modalempty\r\n      * @type {EventTarget~Event}\r\n      */\r\n\r\n      this.trigger('modalempty');\r\n    }\r\n    /**\r\n     * Gets or sets the modal content, which gets normalized before being\r\n     * rendered into the DOM.\r\n     *\r\n     * This does not update the DOM or fill the modal, but it is called during\r\n     * that process.\r\n     *\r\n     * @param  {Mixed} [value]\r\n     *         If defined, sets the internal content value to be used on the\r\n     *         next call(s) to `fill`. This value is normalized before being\r\n     *         inserted. To \"clear\" the internal content value, pass `null`.\r\n     *\r\n     * @return {Mixed}\r\n     *         The current content of the modal dialog\r\n     */\r\n    ;\r\n\r\n    _proto.content = function content(value) {\r\n      if (typeof value !== 'undefined') {\r\n        this.content_ = value;\r\n      }\r\n\r\n      return this.content_;\r\n    }\r\n    /**\r\n     * conditionally focus the modal dialog if focus was previously on the player.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.conditionalFocus_ = function conditionalFocus_() {\r\n      var activeEl = document.activeElement;\r\n      var playerEl = this.player_.el_;\r\n      this.previouslyActiveEl_ = null;\r\n\r\n      if (playerEl.contains(activeEl) || playerEl === activeEl) {\r\n        this.previouslyActiveEl_ = activeEl;\r\n        this.focus();\r\n      }\r\n    }\r\n    /**\r\n     * conditionally blur the element and refocus the last focused element\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.conditionalBlur_ = function conditionalBlur_() {\r\n      if (this.previouslyActiveEl_) {\r\n        this.previouslyActiveEl_.focus();\r\n        this.previouslyActiveEl_ = null;\r\n      }\r\n    }\r\n    /**\r\n     * Keydown handler. Attached when modal is focused.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Do not allow keydowns to reach out of the modal dialog.\r\n      event.stopPropagation();\r\n\r\n      if (keycode.isEventKey(event, 'Escape') && this.closeable()) {\r\n        event.preventDefault();\r\n        this.close();\r\n        return;\r\n      } // exit early if it isn't a tab key\r\n\r\n\r\n      if (!keycode.isEventKey(event, 'Tab')) {\r\n        return;\r\n      }\r\n\r\n      var focusableEls = this.focusableEls_();\r\n      var activeEl = this.el_.querySelector(':focus');\r\n      var focusIndex;\r\n\r\n      for (var i = 0; i < focusableEls.length; i++) {\r\n        if (activeEl === focusableEls[i]) {\r\n          focusIndex = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (document.activeElement === this.el_) {\r\n        focusIndex = 0;\r\n      }\r\n\r\n      if (event.shiftKey && focusIndex === 0) {\r\n        focusableEls[focusableEls.length - 1].focus();\r\n        event.preventDefault();\r\n      } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\r\n        focusableEls[0].focus();\r\n        event.preventDefault();\r\n      }\r\n    }\r\n    /**\r\n     * get all focusable elements\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.focusableEls_ = function focusableEls_() {\r\n      var allChildren = this.el_.querySelectorAll('*');\r\n      return Array.prototype.filter.call(allChildren, function (child) {\r\n        return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\r\n      });\r\n    };\r\n\r\n    return ModalDialog;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for `ModalDialog` default options.\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  ModalDialog.prototype.options_ = {\r\n    pauseOnOpen: true,\r\n    temporary: true\r\n  };\r\n  Component$1.registerComponent('ModalDialog', ModalDialog);\r\n\r\n  /**\r\n   * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\r\n   * {@link VideoTrackList}\r\n   *\r\n   * @extends EventTarget\r\n   */\r\n\r\n  var TrackList = /*#__PURE__*/function (_EventTarget) {\r\n    inheritsLoose(TrackList, _EventTarget);\r\n\r\n    /**\r\n     * Create an instance of this class\r\n     *\r\n     * @param {Track[]} tracks\r\n     *        A list of tracks to initialize the list with.\r\n     *\r\n     * @abstract\r\n     */\r\n    function TrackList(tracks) {\r\n      var _this;\r\n\r\n      if (tracks === void 0) {\r\n        tracks = [];\r\n      }\r\n\r\n      _this = _EventTarget.call(this) || this;\r\n      _this.tracks_ = [];\r\n      /**\r\n       * @memberof TrackList\r\n       * @member {number} length\r\n       *         The current number of `Track`s in the this Trackist.\r\n       * @instance\r\n       */\r\n\r\n      Object.defineProperty(assertThisInitialized(_this), 'length', {\r\n        get: function get() {\r\n          return this.tracks_.length;\r\n        }\r\n      });\r\n\r\n      for (var i = 0; i < tracks.length; i++) {\r\n        _this.addTrack(tracks[i]);\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Add a {@link Track} to the `TrackList`\r\n     *\r\n     * @param {Track} track\r\n     *        The audio, video, or text track to add to the list.\r\n     *\r\n     * @fires TrackList#addtrack\r\n     */\r\n\r\n\r\n    var _proto = TrackList.prototype;\r\n\r\n    _proto.addTrack = function addTrack(track) {\r\n      var _this2 = this;\r\n\r\n      var index = this.tracks_.length;\r\n\r\n      if (!('' + index in this)) {\r\n        Object.defineProperty(this, index, {\r\n          get: function get() {\r\n            return this.tracks_[index];\r\n          }\r\n        });\r\n      } // Do not add duplicate tracks\r\n\r\n\r\n      if (this.tracks_.indexOf(track) === -1) {\r\n        this.tracks_.push(track);\r\n        /**\r\n         * Triggered when a track is added to a track list.\r\n         *\r\n         * @event TrackList#addtrack\r\n         * @type {EventTarget~Event}\r\n         * @property {Track} track\r\n         *           A reference to track that was added.\r\n         */\r\n\r\n        this.trigger({\r\n          track: track,\r\n          type: 'addtrack',\r\n          target: this\r\n        });\r\n      }\r\n      /**\r\n       * Triggered when a track label is changed.\r\n       *\r\n       * @event TrackList#addtrack\r\n       * @type {EventTarget~Event}\r\n       * @property {Track} track\r\n       *           A reference to track that was added.\r\n       */\r\n\r\n\r\n      track.labelchange_ = function () {\r\n        _this2.trigger({\r\n          track: track,\r\n          type: 'labelchange',\r\n          target: _this2\r\n        });\r\n      };\r\n\r\n      if (isEvented(track)) {\r\n        track.addEventListener('labelchange', track.labelchange_);\r\n      }\r\n    }\r\n    /**\r\n     * Remove a {@link Track} from the `TrackList`\r\n     *\r\n     * @param {Track} rtrack\r\n     *        The audio, video, or text track to remove from the list.\r\n     *\r\n     * @fires TrackList#removetrack\r\n     */\r\n    ;\r\n\r\n    _proto.removeTrack = function removeTrack(rtrack) {\r\n      var track;\r\n\r\n      for (var i = 0, l = this.length; i < l; i++) {\r\n        if (this[i] === rtrack) {\r\n          track = this[i];\r\n\r\n          if (track.off) {\r\n            track.off();\r\n          }\r\n\r\n          this.tracks_.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!track) {\r\n        return;\r\n      }\r\n      /**\r\n       * Triggered when a track is removed from track list.\r\n       *\r\n       * @event TrackList#removetrack\r\n       * @type {EventTarget~Event}\r\n       * @property {Track} track\r\n       *           A reference to track that was removed.\r\n       */\r\n\r\n\r\n      this.trigger({\r\n        track: track,\r\n        type: 'removetrack',\r\n        target: this\r\n      });\r\n    }\r\n    /**\r\n     * Get a Track from the TrackList by a tracks id\r\n     *\r\n     * @param {string} id - the id of the track to get\r\n     * @method getTrackById\r\n     * @return {Track}\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.getTrackById = function getTrackById(id) {\r\n      var result = null;\r\n\r\n      for (var i = 0, l = this.length; i < l; i++) {\r\n        var track = this[i];\r\n\r\n        if (track.id === id) {\r\n          result = track;\r\n          break;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    return TrackList;\r\n  }(EventTarget$2);\r\n  /**\r\n   * Triggered when a different track is selected/enabled.\r\n   *\r\n   * @event TrackList#change\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Events that can be called with on + eventName. See {@link EventHandler}.\r\n   *\r\n   * @property {Object} TrackList#allowedEvents_\r\n   * @private\r\n   */\r\n\r\n\r\n  TrackList.prototype.allowedEvents_ = {\r\n    change: 'change',\r\n    addtrack: 'addtrack',\r\n    removetrack: 'removetrack',\r\n    labelchange: 'labelchange'\r\n  }; // emulate attribute EventHandler support to allow for feature detection\r\n\r\n  for (var event in TrackList.prototype.allowedEvents_) {\r\n    TrackList.prototype['on' + event] = null;\r\n  }\r\n\r\n  /**\r\n   * Anywhere we call this function we diverge from the spec\r\n   * as we only support one enabled audiotrack at a time\r\n   *\r\n   * @param {AudioTrackList} list\r\n   *        list to work on\r\n   *\r\n   * @param {AudioTrack} track\r\n   *        The track to skip\r\n   *\r\n   * @private\r\n   */\r\n\r\n  var disableOthers$1 = function disableOthers(list, track) {\r\n    for (var i = 0; i < list.length; i++) {\r\n      if (!Object.keys(list[i]).length || track.id === list[i].id) {\r\n        continue;\r\n      } // another audio track is enabled, disable it\r\n\r\n\r\n      list[i].enabled = false;\r\n    }\r\n  };\r\n  /**\r\n   * The current list of {@link AudioTrack} for a media file.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\r\n   * @extends TrackList\r\n   */\r\n\r\n\r\n  var AudioTrackList = /*#__PURE__*/function (_TrackList) {\r\n    inheritsLoose(AudioTrackList, _TrackList);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {AudioTrack[]} [tracks=[]]\r\n     *        A list of `AudioTrack` to instantiate the list with.\r\n     */\r\n    function AudioTrackList(tracks) {\r\n      var _this;\r\n\r\n      if (tracks === void 0) {\r\n        tracks = [];\r\n      }\r\n\r\n      // make sure only 1 track is enabled\r\n      // sorted from last index to first index\r\n      for (var i = tracks.length - 1; i >= 0; i--) {\r\n        if (tracks[i].enabled) {\r\n          disableOthers$1(tracks, tracks[i]);\r\n          break;\r\n        }\r\n      }\r\n\r\n      _this = _TrackList.call(this, tracks) || this;\r\n      _this.changing_ = false;\r\n      return _this;\r\n    }\r\n    /**\r\n     * Add an {@link AudioTrack} to the `AudioTrackList`.\r\n     *\r\n     * @param {AudioTrack} track\r\n     *        The AudioTrack to add to the list\r\n     *\r\n     * @fires TrackList#addtrack\r\n     */\r\n\r\n\r\n    var _proto = AudioTrackList.prototype;\r\n\r\n    _proto.addTrack = function addTrack(track) {\r\n      var _this2 = this;\r\n\r\n      if (track.enabled) {\r\n        disableOthers$1(this, track);\r\n      }\r\n\r\n      _TrackList.prototype.addTrack.call(this, track); // native tracks don't have this\r\n\r\n\r\n      if (!track.addEventListener) {\r\n        return;\r\n      }\r\n\r\n      track.enabledChange_ = function () {\r\n        // when we are disabling other tracks (since we don't support\r\n        // more than one track at a time) we will set changing_\r\n        // to true so that we don't trigger additional change events\r\n        if (_this2.changing_) {\r\n          return;\r\n        }\r\n\r\n        _this2.changing_ = true;\r\n        disableOthers$1(_this2, track);\r\n        _this2.changing_ = false;\r\n\r\n        _this2.trigger('change');\r\n      };\r\n      /**\r\n       * @listens AudioTrack#enabledchange\r\n       * @fires TrackList#change\r\n       */\r\n\r\n\r\n      track.addEventListener('enabledchange', track.enabledChange_);\r\n    };\r\n\r\n    _proto.removeTrack = function removeTrack(rtrack) {\r\n      _TrackList.prototype.removeTrack.call(this, rtrack);\r\n\r\n      if (rtrack.removeEventListener && rtrack.enabledChange_) {\r\n        rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);\r\n        rtrack.enabledChange_ = null;\r\n      }\r\n    };\r\n\r\n    return AudioTrackList;\r\n  }(TrackList);\r\n\r\n  /**\r\n   * Un-select all other {@link VideoTrack}s that are selected.\r\n   *\r\n   * @param {VideoTrackList} list\r\n   *        list to work on\r\n   *\r\n   * @param {VideoTrack} track\r\n   *        The track to skip\r\n   *\r\n   * @private\r\n   */\r\n\r\n  var disableOthers = function disableOthers(list, track) {\r\n    for (var i = 0; i < list.length; i++) {\r\n      if (!Object.keys(list[i]).length || track.id === list[i].id) {\r\n        continue;\r\n      } // another video track is enabled, disable it\r\n\r\n\r\n      list[i].selected = false;\r\n    }\r\n  };\r\n  /**\r\n   * The current list of {@link VideoTrack} for a video.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\r\n   * @extends TrackList\r\n   */\r\n\r\n\r\n  var VideoTrackList = /*#__PURE__*/function (_TrackList) {\r\n    inheritsLoose(VideoTrackList, _TrackList);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {VideoTrack[]} [tracks=[]]\r\n     *        A list of `VideoTrack` to instantiate the list with.\r\n     */\r\n    function VideoTrackList(tracks) {\r\n      var _this;\r\n\r\n      if (tracks === void 0) {\r\n        tracks = [];\r\n      }\r\n\r\n      // make sure only 1 track is enabled\r\n      // sorted from last index to first index\r\n      for (var i = tracks.length - 1; i >= 0; i--) {\r\n        if (tracks[i].selected) {\r\n          disableOthers(tracks, tracks[i]);\r\n          break;\r\n        }\r\n      }\r\n\r\n      _this = _TrackList.call(this, tracks) || this;\r\n      _this.changing_ = false;\r\n      /**\r\n       * @member {number} VideoTrackList#selectedIndex\r\n       *         The current index of the selected {@link VideoTrack`}.\r\n       */\r\n\r\n      Object.defineProperty(assertThisInitialized(_this), 'selectedIndex', {\r\n        get: function get() {\r\n          for (var _i = 0; _i < this.length; _i++) {\r\n            if (this[_i].selected) {\r\n              return _i;\r\n            }\r\n          }\r\n\r\n          return -1;\r\n        },\r\n        set: function set() {}\r\n      });\r\n      return _this;\r\n    }\r\n    /**\r\n     * Add a {@link VideoTrack} to the `VideoTrackList`.\r\n     *\r\n     * @param {VideoTrack} track\r\n     *        The VideoTrack to add to the list\r\n     *\r\n     * @fires TrackList#addtrack\r\n     */\r\n\r\n\r\n    var _proto = VideoTrackList.prototype;\r\n\r\n    _proto.addTrack = function addTrack(track) {\r\n      var _this2 = this;\r\n\r\n      if (track.selected) {\r\n        disableOthers(this, track);\r\n      }\r\n\r\n      _TrackList.prototype.addTrack.call(this, track); // native tracks don't have this\r\n\r\n\r\n      if (!track.addEventListener) {\r\n        return;\r\n      }\r\n\r\n      track.selectedChange_ = function () {\r\n        if (_this2.changing_) {\r\n          return;\r\n        }\r\n\r\n        _this2.changing_ = true;\r\n        disableOthers(_this2, track);\r\n        _this2.changing_ = false;\r\n\r\n        _this2.trigger('change');\r\n      };\r\n      /**\r\n       * @listens VideoTrack#selectedchange\r\n       * @fires TrackList#change\r\n       */\r\n\r\n\r\n      track.addEventListener('selectedchange', track.selectedChange_);\r\n    };\r\n\r\n    _proto.removeTrack = function removeTrack(rtrack) {\r\n      _TrackList.prototype.removeTrack.call(this, rtrack);\r\n\r\n      if (rtrack.removeEventListener && rtrack.selectedChange_) {\r\n        rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);\r\n        rtrack.selectedChange_ = null;\r\n      }\r\n    };\r\n\r\n    return VideoTrackList;\r\n  }(TrackList);\r\n\r\n  /**\r\n   * The current list of {@link TextTrack} for a media file.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\r\n   * @extends TrackList\r\n   */\r\n\r\n  var TextTrackList = /*#__PURE__*/function (_TrackList) {\r\n    inheritsLoose(TextTrackList, _TrackList);\r\n\r\n    function TextTrackList() {\r\n      return _TrackList.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = TextTrackList.prototype;\r\n\r\n    /**\r\n     * Add a {@link TextTrack} to the `TextTrackList`\r\n     *\r\n     * @param {TextTrack} track\r\n     *        The text track to add to the list.\r\n     *\r\n     * @fires TrackList#addtrack\r\n     */\r\n    _proto.addTrack = function addTrack(track) {\r\n      var _this = this;\r\n\r\n      _TrackList.prototype.addTrack.call(this, track);\r\n\r\n      if (!this.queueChange_) {\r\n        this.queueChange_ = function () {\r\n          return _this.queueTrigger('change');\r\n        };\r\n      }\r\n\r\n      if (!this.triggerSelectedlanguagechange) {\r\n        this.triggerSelectedlanguagechange_ = function () {\r\n          return _this.trigger('selectedlanguagechange');\r\n        };\r\n      }\r\n      /**\r\n       * @listens TextTrack#modechange\r\n       * @fires TrackList#change\r\n       */\r\n\r\n\r\n      track.addEventListener('modechange', this.queueChange_);\r\n      var nonLanguageTextTrackKind = ['metadata', 'chapters'];\r\n\r\n      if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\r\n        track.addEventListener('modechange', this.triggerSelectedlanguagechange_);\r\n      }\r\n    };\r\n\r\n    _proto.removeTrack = function removeTrack(rtrack) {\r\n      _TrackList.prototype.removeTrack.call(this, rtrack); // manually remove the event handlers we added\r\n\r\n\r\n      if (rtrack.removeEventListener) {\r\n        if (this.queueChange_) {\r\n          rtrack.removeEventListener('modechange', this.queueChange_);\r\n        }\r\n\r\n        if (this.selectedlanguagechange_) {\r\n          rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);\r\n        }\r\n      }\r\n    };\r\n\r\n    return TextTrackList;\r\n  }(TrackList);\r\n\r\n  /**\r\n   * @file html-track-element-list.js\r\n   */\r\n\r\n  /**\r\n   * The current list of {@link HtmlTrackElement}s.\r\n   */\r\n  var HtmlTrackElementList = /*#__PURE__*/function () {\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {HtmlTrackElement[]} [tracks=[]]\r\n     *        A list of `HtmlTrackElement` to instantiate the list with.\r\n     */\r\n    function HtmlTrackElementList(trackElements) {\r\n      if (trackElements === void 0) {\r\n        trackElements = [];\r\n      }\r\n\r\n      this.trackElements_ = [];\r\n      /**\r\n       * @memberof HtmlTrackElementList\r\n       * @member {number} length\r\n       *         The current number of `Track`s in the this Trackist.\r\n       * @instance\r\n       */\r\n\r\n      Object.defineProperty(this, 'length', {\r\n        get: function get() {\r\n          return this.trackElements_.length;\r\n        }\r\n      });\r\n\r\n      for (var i = 0, length = trackElements.length; i < length; i++) {\r\n        this.addTrackElement_(trackElements[i]);\r\n      }\r\n    }\r\n    /**\r\n     * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\r\n     *\r\n     * @param {HtmlTrackElement} trackElement\r\n     *        The track element to add to the list.\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var _proto = HtmlTrackElementList.prototype;\r\n\r\n    _proto.addTrackElement_ = function addTrackElement_(trackElement) {\r\n      var index = this.trackElements_.length;\r\n\r\n      if (!('' + index in this)) {\r\n        Object.defineProperty(this, index, {\r\n          get: function get() {\r\n            return this.trackElements_[index];\r\n          }\r\n        });\r\n      } // Do not add duplicate elements\r\n\r\n\r\n      if (this.trackElements_.indexOf(trackElement) === -1) {\r\n        this.trackElements_.push(trackElement);\r\n      }\r\n    }\r\n    /**\r\n     * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\r\n     * {@link TextTrack}.\r\n     *\r\n     * @param {TextTrack} track\r\n     *        The track associated with a track element.\r\n     *\r\n     * @return {HtmlTrackElement|undefined}\r\n     *         The track element that was found or undefined.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\r\n      var trackElement_;\r\n\r\n      for (var i = 0, length = this.trackElements_.length; i < length; i++) {\r\n        if (track === this.trackElements_[i].track) {\r\n          trackElement_ = this.trackElements_[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      return trackElement_;\r\n    }\r\n    /**\r\n     * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\r\n     *\r\n     * @param {HtmlTrackElement} trackElement\r\n     *        The track element to remove from the list.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {\r\n      for (var i = 0, length = this.trackElements_.length; i < length; i++) {\r\n        if (trackElement === this.trackElements_[i]) {\r\n          if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {\r\n            this.trackElements_[i].track.off();\r\n          }\r\n\r\n          if (typeof this.trackElements_[i].off === 'function') {\r\n            this.trackElements_[i].off();\r\n          }\r\n\r\n          this.trackElements_.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    return HtmlTrackElementList;\r\n  }();\r\n\r\n  /**\r\n   * @file text-track-cue-list.js\r\n   */\r\n\r\n  /**\r\n   * @typedef {Object} TextTrackCueList~TextTrackCue\r\n   *\r\n   * @property {string} id\r\n   *           The unique id for this text track cue\r\n   *\r\n   * @property {number} startTime\r\n   *           The start time for this text track cue\r\n   *\r\n   * @property {number} endTime\r\n   *           The end time for this text track cue\r\n   *\r\n   * @property {boolean} pauseOnExit\r\n   *           Pause when the end time is reached if true.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\r\n   */\r\n\r\n  /**\r\n   * A List of TextTrackCues.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\r\n   */\r\n  var TextTrackCueList = /*#__PURE__*/function () {\r\n    /**\r\n     * Create an instance of this class..\r\n     *\r\n     * @param {Array} cues\r\n     *        A list of cues to be initialized with\r\n     */\r\n    function TextTrackCueList(cues) {\r\n      TextTrackCueList.prototype.setCues_.call(this, cues);\r\n      /**\r\n       * @memberof TextTrackCueList\r\n       * @member {number} length\r\n       *         The current number of `TextTrackCue`s in the TextTrackCueList.\r\n       * @instance\r\n       */\r\n\r\n      Object.defineProperty(this, 'length', {\r\n        get: function get() {\r\n          return this.length_;\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * A setter for cues in this list. Creates getters\r\n     * an an index for the cues.\r\n     *\r\n     * @param {Array} cues\r\n     *        An array of cues to set\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var _proto = TextTrackCueList.prototype;\r\n\r\n    _proto.setCues_ = function setCues_(cues) {\r\n      var oldLength = this.length || 0;\r\n      var i = 0;\r\n      var l = cues.length;\r\n      this.cues_ = cues;\r\n      this.length_ = cues.length;\r\n\r\n      var defineProp = function defineProp(index) {\r\n        if (!('' + index in this)) {\r\n          Object.defineProperty(this, '' + index, {\r\n            get: function get() {\r\n              return this.cues_[index];\r\n            }\r\n          });\r\n        }\r\n      };\r\n\r\n      if (oldLength < l) {\r\n        i = oldLength;\r\n\r\n        for (; i < l; i++) {\r\n          defineProp.call(this, i);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\r\n     *\r\n     * @param {string} id\r\n     *        The id of the cue that should be searched for.\r\n     *\r\n     * @return {TextTrackCueList~TextTrackCue|null}\r\n     *         A single cue or null if none was found.\r\n     */\r\n    ;\r\n\r\n    _proto.getCueById = function getCueById(id) {\r\n      var result = null;\r\n\r\n      for (var i = 0, l = this.length; i < l; i++) {\r\n        var cue = this[i];\r\n\r\n        if (cue.id === id) {\r\n          result = cue;\r\n          break;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    return TextTrackCueList;\r\n  }();\r\n\r\n  /**\r\n   * @file track-kinds.js\r\n   */\r\n\r\n  /**\r\n   * All possible `VideoTrackKind`s\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\r\n   * @typedef VideoTrack~Kind\r\n   * @enum\r\n   */\r\n  var VideoTrackKind = {\r\n    alternative: 'alternative',\r\n    captions: 'captions',\r\n    main: 'main',\r\n    sign: 'sign',\r\n    subtitles: 'subtitles',\r\n    commentary: 'commentary'\r\n  };\r\n  /**\r\n   * All possible `AudioTrackKind`s\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\r\n   * @typedef AudioTrack~Kind\r\n   * @enum\r\n   */\r\n\r\n  var AudioTrackKind = {\r\n    'alternative': 'alternative',\r\n    'descriptions': 'descriptions',\r\n    'main': 'main',\r\n    'main-desc': 'main-desc',\r\n    'translation': 'translation',\r\n    'commentary': 'commentary'\r\n  };\r\n  /**\r\n   * All possible `TextTrackKind`s\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\r\n   * @typedef TextTrack~Kind\r\n   * @enum\r\n   */\r\n\r\n  var TextTrackKind = {\r\n    subtitles: 'subtitles',\r\n    captions: 'captions',\r\n    descriptions: 'descriptions',\r\n    chapters: 'chapters',\r\n    metadata: 'metadata'\r\n  };\r\n  /**\r\n   * All possible `TextTrackMode`s\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\r\n   * @typedef TextTrack~Mode\r\n   * @enum\r\n   */\r\n\r\n  var TextTrackMode = {\r\n    disabled: 'disabled',\r\n    hidden: 'hidden',\r\n    showing: 'showing'\r\n  };\r\n\r\n  /**\r\n   * A Track class that contains all of the common functionality for {@link AudioTrack},\r\n   * {@link VideoTrack}, and {@link TextTrack}.\r\n   *\r\n   * > Note: This class should not be used directly\r\n   *\r\n   * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\r\n   * @extends EventTarget\r\n   * @abstract\r\n   */\r\n\r\n  var Track = /*#__PURE__*/function (_EventTarget) {\r\n    inheritsLoose(Track, _EventTarget);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        Object of option names and values\r\n     *\r\n     * @param {string} [options.kind='']\r\n     *        A valid kind for the track type you are creating.\r\n     *\r\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\r\n     *        A unique id for this AudioTrack.\r\n     *\r\n     * @param {string} [options.label='']\r\n     *        The menu label for this track.\r\n     *\r\n     * @param {string} [options.language='']\r\n     *        A valid two character language code.\r\n     *\r\n     * @abstract\r\n     */\r\n    function Track(options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _EventTarget.call(this) || this;\r\n      var trackProps = {\r\n        id: options.id || 'vjs_track_' + newGUID(),\r\n        kind: options.kind || '',\r\n        language: options.language || ''\r\n      };\r\n      var label = options.label || '';\r\n      /**\r\n       * @memberof Track\r\n       * @member {string} id\r\n       *         The id of this track. Cannot be changed after creation.\r\n       * @instance\r\n       *\r\n       * @readonly\r\n       */\r\n\r\n      /**\r\n       * @memberof Track\r\n       * @member {string} kind\r\n       *         The kind of track that this is. Cannot be changed after creation.\r\n       * @instance\r\n       *\r\n       * @readonly\r\n       */\r\n\r\n      /**\r\n       * @memberof Track\r\n       * @member {string} language\r\n       *         The two letter language code for this track. Cannot be changed after\r\n       *         creation.\r\n       * @instance\r\n       *\r\n       * @readonly\r\n       */\r\n\r\n      var _loop = function _loop(key) {\r\n        Object.defineProperty(assertThisInitialized(_this), key, {\r\n          get: function get() {\r\n            return trackProps[key];\r\n          },\r\n          set: function set() {}\r\n        });\r\n      };\r\n\r\n      for (var key in trackProps) {\r\n        _loop(key);\r\n      }\r\n      /**\r\n       * @memberof Track\r\n       * @member {string} label\r\n       *         The label of this track. Cannot be changed after creation.\r\n       * @instance\r\n       *\r\n       * @fires Track#labelchange\r\n       */\r\n\r\n\r\n      Object.defineProperty(assertThisInitialized(_this), 'label', {\r\n        get: function get() {\r\n          return label;\r\n        },\r\n        set: function set(newLabel) {\r\n          if (newLabel !== label) {\r\n            label = newLabel;\r\n            /**\r\n             * An event that fires when label changes on this track.\r\n             *\r\n             * > Note: This is not part of the spec!\r\n             *\r\n             * @event Track#labelchange\r\n             * @type {EventTarget~Event}\r\n             */\r\n\r\n            this.trigger('labelchange');\r\n          }\r\n        }\r\n      });\r\n      return _this;\r\n    }\r\n\r\n    return Track;\r\n  }(EventTarget$2);\r\n\r\n  /**\r\n   * @file url.js\r\n   * @module url\r\n   */\r\n\r\n  /**\r\n   * @typedef {Object} url:URLObject\r\n   *\r\n   * @property {string} protocol\r\n   *           The protocol of the url that was parsed.\r\n   *\r\n   * @property {string} hostname\r\n   *           The hostname of the url that was parsed.\r\n   *\r\n   * @property {string} port\r\n   *           The port of the url that was parsed.\r\n   *\r\n   * @property {string} pathname\r\n   *           The pathname of the url that was parsed.\r\n   *\r\n   * @property {string} search\r\n   *           The search query of the url that was parsed.\r\n   *\r\n   * @property {string} hash\r\n   *           The hash of the url that was parsed.\r\n   *\r\n   * @property {string} host\r\n   *           The host of the url that was parsed.\r\n   */\r\n\r\n  /**\r\n   * Resolve and parse the elements of a URL.\r\n   *\r\n   * @function\r\n   * @param    {String} url\r\n   *           The url to parse\r\n   *\r\n   * @return   {url:URLObject}\r\n   *           An object of url details\r\n   */\r\n  var parseUrl = function parseUrl(url) {\r\n    // This entire method can be replace with URL once we are able to drop IE11\r\n    var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host']; // add the url to an anchor and let the browser parse the URL\r\n\r\n    var a = document.createElement('a');\r\n    a.href = url; // Copy the specific URL properties to a new object\r\n    // This is also needed for IE because the anchor loses its\r\n    // properties when it's removed from the dom\r\n\r\n    var details = {};\r\n\r\n    for (var i = 0; i < props.length; i++) {\r\n      details[props[i]] = a[props[i]];\r\n    } // IE adds the port to the host property unlike everyone else. If\r\n    // a port identifier is added for standard ports, strip it.\r\n\r\n\r\n    if (details.protocol === 'http:') {\r\n      details.host = details.host.replace(/:80$/, '');\r\n    }\r\n\r\n    if (details.protocol === 'https:') {\r\n      details.host = details.host.replace(/:443$/, '');\r\n    }\r\n\r\n    if (!details.protocol) {\r\n      details.protocol = window.location.protocol;\r\n    }\r\n    /* istanbul ignore if */\r\n\r\n\r\n    if (!details.host) {\r\n      details.host = window.location.host;\r\n    }\r\n\r\n    return details;\r\n  };\r\n  /**\r\n   * Get absolute version of relative URL. Used to tell Flash the correct URL.\r\n   *\r\n   * @function\r\n   * @param    {string} url\r\n   *           URL to make absolute\r\n   *\r\n   * @return   {string}\r\n   *           Absolute URL\r\n   *\r\n   * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\r\n   */\r\n\r\n  var getAbsoluteURL = function getAbsoluteURL(url) {\r\n    // Check if absolute URL\r\n    if (!url.match(/^https?:\\/\\//)) {\r\n      // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\r\n      // add the url to an anchor and let the browser parse the URL\r\n      var a = document.createElement('a');\r\n      a.href = url;\r\n      url = a.href;\r\n    }\r\n\r\n    return url;\r\n  };\r\n  /**\r\n   * Returns the extension of the passed file name. It will return an empty string\r\n   * if passed an invalid path.\r\n   *\r\n   * @function\r\n   * @param    {string} path\r\n   *           The fileName path like '/path/to/file.mp4'\r\n   *\r\n   * @return  {string}\r\n   *           The extension in lower case or an empty string if no\r\n   *           extension could be found.\r\n   */\r\n\r\n  var getFileExtension = function getFileExtension(path) {\r\n    if (typeof path === 'string') {\r\n      var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\r\n      var pathParts = splitPathRe.exec(path);\r\n\r\n      if (pathParts) {\r\n        return pathParts.pop().toLowerCase();\r\n      }\r\n    }\r\n\r\n    return '';\r\n  };\r\n  /**\r\n   * Returns whether the url passed is a cross domain request or not.\r\n   *\r\n   * @function\r\n   * @param    {string} url\r\n   *           The url to check.\r\n   *\r\n   * @param    {Object} [winLoc]\r\n   *           the domain to check the url against, defaults to window.location\r\n   *\r\n   * @param    {string} [winLoc.protocol]\r\n   *           The window location protocol defaults to window.location.protocol\r\n   *\r\n   * @param    {string} [winLoc.host]\r\n   *           The window location host defaults to window.location.host\r\n   *\r\n   * @return   {boolean}\r\n   *           Whether it is a cross domain request or not.\r\n   */\r\n\r\n  var isCrossOrigin = function isCrossOrigin(url, winLoc) {\r\n    if (winLoc === void 0) {\r\n      winLoc = window.location;\r\n    }\r\n\r\n    var urlInfo = parseUrl(url); // IE8 protocol relative urls will return ':' for protocol\r\n\r\n    var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol; // Check if url is for another domain/origin\r\n    // IE8 doesn't know location.origin, so we won't rely on it here\r\n\r\n    var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\r\n    return crossOrigin;\r\n  };\r\n\r\n  var Url = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    parseUrl: parseUrl,\r\n    getAbsoluteURL: getAbsoluteURL,\r\n    getFileExtension: getFileExtension,\r\n    isCrossOrigin: isCrossOrigin\r\n  });\r\n\r\n  var win;\r\n\r\n  if (typeof window !== \"undefined\") {\r\n    win = window;\r\n  } else if (typeof commonjsGlobal !== \"undefined\") {\r\n    win = commonjsGlobal;\r\n  } else if (typeof self !== \"undefined\") {\r\n    win = self;\r\n  } else {\r\n    win = {};\r\n  }\r\n\r\n  var window_1 = win;\r\n\r\n  var isFunction_1 = isFunction;\r\n  var toString = Object.prototype.toString;\r\n\r\n  function isFunction(fn) {\r\n    if (!fn) {\r\n      return false;\r\n    }\r\n\r\n    var string = toString.call(fn);\r\n    return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && ( // IE8 and below\r\n    fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);\r\n  }\r\n\r\n  var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {\r\n    if (decodeResponseBody === void 0) {\r\n      decodeResponseBody = false;\r\n    }\r\n\r\n    return function (err, response, responseBody) {\r\n      // if the XHR failed, return that error\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      } // if the HTTP status code is 4xx or 5xx, the request also failed\r\n\r\n\r\n      if (response.statusCode >= 400 && response.statusCode <= 599) {\r\n        var cause = responseBody;\r\n\r\n        if (decodeResponseBody) {\r\n          if (window_1.TextDecoder) {\r\n            var charset = getCharset(response.headers && response.headers['content-type']);\r\n\r\n            try {\r\n              cause = new TextDecoder(charset).decode(responseBody);\r\n            } catch (e) {}\r\n          } else {\r\n            cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));\r\n          }\r\n        }\r\n\r\n        callback({\r\n          cause: cause\r\n        });\r\n        return;\r\n      } // otherwise, request succeeded\r\n\r\n\r\n      callback(null, responseBody);\r\n    };\r\n  };\r\n\r\n  function getCharset(contentTypeHeader) {\r\n    if (contentTypeHeader === void 0) {\r\n      contentTypeHeader = '';\r\n    }\r\n\r\n    return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {\r\n      var _contentType$split = contentType.split('='),\r\n          type = _contentType$split[0],\r\n          value = _contentType$split[1];\r\n\r\n      if (type.trim() === 'charset') {\r\n        return value.trim();\r\n      }\r\n\r\n      return charset;\r\n    }, 'utf-8');\r\n  }\r\n\r\n  var httpHandler = httpResponseHandler;\r\n\r\n  createXHR.httpHandler = httpHandler;\r\n  /**\r\n   * @license\r\n   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>\r\n   * Copyright (c) 2014 David Bjrklund\r\n   * Available under the MIT license\r\n   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>\r\n   */\r\n\r\n  var parseHeaders = function parseHeaders(headers) {\r\n    var result = {};\r\n\r\n    if (!headers) {\r\n      return result;\r\n    }\r\n\r\n    headers.trim().split('\\n').forEach(function (row) {\r\n      var index = row.indexOf(':');\r\n      var key = row.slice(0, index).trim().toLowerCase();\r\n      var value = row.slice(index + 1).trim();\r\n\r\n      if (typeof result[key] === 'undefined') {\r\n        result[key] = value;\r\n      } else if (Array.isArray(result[key])) {\r\n        result[key].push(value);\r\n      } else {\r\n        result[key] = [result[key], value];\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n\r\n  var lib = createXHR; // Allow use of default import syntax in TypeScript\r\n\r\n  var default_1 = createXHR;\r\n  createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop$1;\r\n  createXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window_1.XDomainRequest;\r\n  forEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\r\n    createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\r\n      options = initParams(uri, options, callback);\r\n      options.method = method.toUpperCase();\r\n      return _createXHR(options);\r\n    };\r\n  });\r\n\r\n  function forEachArray(array, iterator) {\r\n    for (var i = 0; i < array.length; i++) {\r\n      iterator(array[i]);\r\n    }\r\n  }\r\n\r\n  function isEmpty(obj) {\r\n    for (var i in obj) {\r\n      if (obj.hasOwnProperty(i)) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function initParams(uri, options, callback) {\r\n    var params = uri;\r\n\r\n    if (isFunction_1(options)) {\r\n      callback = options;\r\n\r\n      if (typeof uri === \"string\") {\r\n        params = {\r\n          uri: uri\r\n        };\r\n      }\r\n    } else {\r\n      params = _extends_1({}, options, {\r\n        uri: uri\r\n      });\r\n    }\r\n\r\n    params.callback = callback;\r\n    return params;\r\n  }\r\n\r\n  function createXHR(uri, options, callback) {\r\n    options = initParams(uri, options, callback);\r\n    return _createXHR(options);\r\n  }\r\n\r\n  function _createXHR(options) {\r\n    if (typeof options.callback === \"undefined\") {\r\n      throw new Error(\"callback argument missing\");\r\n    }\r\n\r\n    var called = false;\r\n\r\n    var callback = function cbOnce(err, response, body) {\r\n      if (!called) {\r\n        called = true;\r\n        options.callback(err, response, body);\r\n      }\r\n    };\r\n\r\n    function readystatechange() {\r\n      if (xhr.readyState === 4) {\r\n        setTimeout(loadFunc, 0);\r\n      }\r\n    }\r\n\r\n    function getBody() {\r\n      // Chrome with requestType=blob throws errors arround when even testing access to responseText\r\n      var body = undefined;\r\n\r\n      if (xhr.response) {\r\n        body = xhr.response;\r\n      } else {\r\n        body = xhr.responseText || getXml(xhr);\r\n      }\r\n\r\n      if (isJson) {\r\n        try {\r\n          body = JSON.parse(body);\r\n        } catch (e) {}\r\n      }\r\n\r\n      return body;\r\n    }\r\n\r\n    function errorFunc(evt) {\r\n      clearTimeout(timeoutTimer);\r\n\r\n      if (!(evt instanceof Error)) {\r\n        evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\r\n      }\r\n\r\n      evt.statusCode = 0;\r\n      return callback(evt, failureResponse);\r\n    } // will load the data & process the response in a special response object\r\n\r\n\r\n    function loadFunc() {\r\n      if (aborted) return;\r\n      var status;\r\n      clearTimeout(timeoutTimer);\r\n\r\n      if (options.useXDR && xhr.status === undefined) {\r\n        //IE8 CORS GET successful response doesn't have a status field, but body is fine\r\n        status = 200;\r\n      } else {\r\n        status = xhr.status === 1223 ? 204 : xhr.status;\r\n      }\r\n\r\n      var response = failureResponse;\r\n      var err = null;\r\n\r\n      if (status !== 0) {\r\n        response = {\r\n          body: getBody(),\r\n          statusCode: status,\r\n          method: method,\r\n          headers: {},\r\n          url: uri,\r\n          rawRequest: xhr\r\n        };\r\n\r\n        if (xhr.getAllResponseHeaders) {\r\n          //remember xhr can in fact be XDR for CORS in IE\r\n          response.headers = parseHeaders(xhr.getAllResponseHeaders());\r\n        }\r\n      } else {\r\n        err = new Error(\"Internal XMLHttpRequest Error\");\r\n      }\r\n\r\n      return callback(err, response, response.body);\r\n    }\r\n\r\n    var xhr = options.xhr || null;\r\n\r\n    if (!xhr) {\r\n      if (options.cors || options.useXDR) {\r\n        xhr = new createXHR.XDomainRequest();\r\n      } else {\r\n        xhr = new createXHR.XMLHttpRequest();\r\n      }\r\n    }\r\n\r\n    var key;\r\n    var aborted;\r\n    var uri = xhr.url = options.uri || options.url;\r\n    var method = xhr.method = options.method || \"GET\";\r\n    var body = options.body || options.data;\r\n    var headers = xhr.headers = options.headers || {};\r\n    var sync = !!options.sync;\r\n    var isJson = false;\r\n    var timeoutTimer;\r\n    var failureResponse = {\r\n      body: undefined,\r\n      headers: {},\r\n      statusCode: 0,\r\n      method: method,\r\n      url: uri,\r\n      rawRequest: xhr\r\n    };\r\n\r\n    if (\"json\" in options && options.json !== false) {\r\n      isJson = true;\r\n      headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\r\n\r\n      if (method !== \"GET\" && method !== \"HEAD\") {\r\n        headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\r\n\r\n        body = JSON.stringify(options.json === true ? body : options.json);\r\n      }\r\n    }\r\n\r\n    xhr.onreadystatechange = readystatechange;\r\n    xhr.onload = loadFunc;\r\n    xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.\r\n\r\n    xhr.onprogress = function () {// IE must die\r\n    };\r\n\r\n    xhr.onabort = function () {\r\n      aborted = true;\r\n    };\r\n\r\n    xhr.ontimeout = errorFunc;\r\n    xhr.open(method, uri, !sync, options.username, options.password); //has to be after open\r\n\r\n    if (!sync) {\r\n      xhr.withCredentials = !!options.withCredentials;\r\n    } // Cannot set timeout with sync request\r\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\r\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\r\n\r\n\r\n    if (!sync && options.timeout > 0) {\r\n      timeoutTimer = setTimeout(function () {\r\n        if (aborted) return;\r\n        aborted = true; //IE9 may still call readystatechange\r\n\r\n        xhr.abort(\"timeout\");\r\n        var e = new Error(\"XMLHttpRequest timeout\");\r\n        e.code = \"ETIMEDOUT\";\r\n        errorFunc(e);\r\n      }, options.timeout);\r\n    }\r\n\r\n    if (xhr.setRequestHeader) {\r\n      for (key in headers) {\r\n        if (headers.hasOwnProperty(key)) {\r\n          xhr.setRequestHeader(key, headers[key]);\r\n        }\r\n      }\r\n    } else if (options.headers && !isEmpty(options.headers)) {\r\n      throw new Error(\"Headers cannot be set on an XDomainRequest object\");\r\n    }\r\n\r\n    if (\"responseType\" in options) {\r\n      xhr.responseType = options.responseType;\r\n    }\r\n\r\n    if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\r\n      options.beforeSend(xhr);\r\n    } // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\r\n    // XMLHttpRequest spec says to pass null as body to indicate no body\r\n    // See https://github.com/naugtur/xhr/issues/100.\r\n\r\n\r\n    xhr.send(body || null);\r\n    return xhr;\r\n  }\r\n\r\n  function getXml(xhr) {\r\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\r\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\r\n    try {\r\n      if (xhr.responseType === \"document\") {\r\n        return xhr.responseXML;\r\n      }\r\n\r\n      var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\r\n\r\n      if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\r\n        return xhr.responseXML;\r\n      }\r\n    } catch (e) {}\r\n\r\n    return null;\r\n  }\r\n\r\n  function noop$1() {}\r\n  lib[\"default\"] = default_1;\r\n\r\n  /**\r\n   * Takes a webvtt file contents and parses it into cues\r\n   *\r\n   * @param {string} srcContent\r\n   *        webVTT file contents\r\n   *\r\n   * @param {TextTrack} track\r\n   *        TextTrack to add cues to. Cues come from the srcContent.\r\n   *\r\n   * @private\r\n   */\r\n\r\n  var parseCues = function parseCues(srcContent, track) {\r\n    var parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());\r\n    var errors = [];\r\n\r\n    parser.oncue = function (cue) {\r\n      track.addCue(cue);\r\n    };\r\n\r\n    parser.onparsingerror = function (error) {\r\n      errors.push(error);\r\n    };\r\n\r\n    parser.onflush = function () {\r\n      track.trigger({\r\n        type: 'loadeddata',\r\n        target: track\r\n      });\r\n    };\r\n\r\n    parser.parse(srcContent);\r\n\r\n    if (errors.length > 0) {\r\n      if (window.console && window.console.groupCollapsed) {\r\n        window.console.groupCollapsed(\"Text Track parsing errors for \" + track.src);\r\n      }\r\n\r\n      errors.forEach(function (error) {\r\n        return log$1.error(error);\r\n      });\r\n\r\n      if (window.console && window.console.groupEnd) {\r\n        window.console.groupEnd();\r\n      }\r\n    }\r\n\r\n    parser.flush();\r\n  };\r\n  /**\r\n   * Load a `TextTrack` from a specified url.\r\n   *\r\n   * @param {string} src\r\n   *        Url to load track from.\r\n   *\r\n   * @param {TextTrack} track\r\n   *        Track to add cues to. Comes from the content at the end of `url`.\r\n   *\r\n   * @private\r\n   */\r\n\r\n\r\n  var loadTrack = function loadTrack(src, track) {\r\n    var opts = {\r\n      uri: src\r\n    };\r\n    var crossOrigin = isCrossOrigin(src);\r\n\r\n    if (crossOrigin) {\r\n      opts.cors = crossOrigin;\r\n    }\r\n\r\n    var withCredentials = track.tech_.crossOrigin() === 'use-credentials';\r\n\r\n    if (withCredentials) {\r\n      opts.withCredentials = withCredentials;\r\n    }\r\n\r\n    lib(opts, bind(this, function (err, response, responseBody) {\r\n      if (err) {\r\n        return log$1.error(err, response);\r\n      }\r\n\r\n      track.loaded_ = true; // Make sure that vttjs has loaded, otherwise, wait till it finished loading\r\n      // NOTE: this is only used for the alt/video.novtt.js build\r\n\r\n      if (typeof window.WebVTT !== 'function') {\r\n        if (track.tech_) {\r\n          // to prevent use before define eslint error, we define loadHandler\r\n          // as a let here\r\n          track.tech_.any(['vttjsloaded', 'vttjserror'], function (event) {\r\n            if (event.type === 'vttjserror') {\r\n              log$1.error(\"vttjs failed to load, stopping trying to process \" + track.src);\r\n              return;\r\n            }\r\n\r\n            return parseCues(responseBody, track);\r\n          });\r\n        }\r\n      } else {\r\n        parseCues(responseBody, track);\r\n      }\r\n    }));\r\n  };\r\n  /**\r\n   * A representation of a single `TextTrack`.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\r\n   * @extends Track\r\n   */\r\n\r\n\r\n  var TextTrack = /*#__PURE__*/function (_Track) {\r\n    inheritsLoose(TextTrack, _Track);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Object} options={}\r\n     *        Object of option names and values\r\n     *\r\n     * @param {Tech} options.tech\r\n     *        A reference to the tech that owns this TextTrack.\r\n     *\r\n     * @param {TextTrack~Kind} [options.kind='subtitles']\r\n     *        A valid text track kind.\r\n     *\r\n     * @param {TextTrack~Mode} [options.mode='disabled']\r\n     *        A valid text track mode.\r\n     *\r\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\r\n     *        A unique id for this TextTrack.\r\n     *\r\n     * @param {string} [options.label='']\r\n     *        The menu label for this track.\r\n     *\r\n     * @param {string} [options.language='']\r\n     *        A valid two character language code.\r\n     *\r\n     * @param {string} [options.srclang='']\r\n     *        A valid two character language code. An alternative, but deprioritized\r\n     *        version of `options.language`\r\n     *\r\n     * @param {string} [options.src]\r\n     *        A url to TextTrack cues.\r\n     *\r\n     * @param {boolean} [options.default]\r\n     *        If this track should default to on or off.\r\n     */\r\n    function TextTrack(options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      if (!options.tech) {\r\n        throw new Error('A tech was not provided.');\r\n      }\r\n\r\n      var settings = mergeOptions$3(options, {\r\n        kind: TextTrackKind[options.kind] || 'subtitles',\r\n        language: options.language || options.srclang || ''\r\n      });\r\n      var mode = TextTrackMode[settings.mode] || 'disabled';\r\n      var default_ = settings[\"default\"];\r\n\r\n      if (settings.kind === 'metadata' || settings.kind === 'chapters') {\r\n        mode = 'hidden';\r\n      }\r\n\r\n      _this = _Track.call(this, settings) || this;\r\n      _this.tech_ = settings.tech;\r\n      _this.cues_ = [];\r\n      _this.activeCues_ = [];\r\n      _this.preload_ = _this.tech_.preloadTextTracks !== false;\r\n      var cues = new TextTrackCueList(_this.cues_);\r\n      var activeCues = new TextTrackCueList(_this.activeCues_);\r\n      var changed = false;\r\n      _this.timeupdateHandler = bind(assertThisInitialized(_this), function (event) {\r\n        if (event === void 0) {\r\n          event = {};\r\n        }\r\n\r\n        if (this.tech_.isDisposed()) {\r\n          return;\r\n        }\r\n\r\n        if (!this.tech_.isReady_) {\r\n          if (event.type !== 'timeupdate') {\r\n            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\r\n          }\r\n\r\n          return;\r\n        } // Accessing this.activeCues for the side-effects of updating itself\r\n        // due to its nature as a getter function. Do not remove or cues will\r\n        // stop updating!\r\n        // Use the setter to prevent deletion from uglify (pure_getters rule)\r\n\r\n\r\n        this.activeCues = this.activeCues;\r\n\r\n        if (changed) {\r\n          this.trigger('cuechange');\r\n          changed = false;\r\n        }\r\n\r\n        if (event.type !== 'timeupdate') {\r\n          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\r\n        }\r\n      });\r\n\r\n      var disposeHandler = function disposeHandler() {\r\n        _this.stopTracking();\r\n      };\r\n\r\n      _this.tech_.one('dispose', disposeHandler);\r\n\r\n      if (mode !== 'disabled') {\r\n        _this.startTracking();\r\n      }\r\n\r\n      Object.defineProperties(assertThisInitialized(_this), {\r\n        /**\r\n         * @memberof TextTrack\r\n         * @member {boolean} default\r\n         *         If this track was set to be on or off by default. Cannot be changed after\r\n         *         creation.\r\n         * @instance\r\n         *\r\n         * @readonly\r\n         */\r\n        \"default\": {\r\n          get: function get() {\r\n            return default_;\r\n          },\r\n          set: function set() {}\r\n        },\r\n\r\n        /**\r\n         * @memberof TextTrack\r\n         * @member {string} mode\r\n         *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\r\n         *         not be set if setting to an invalid mode.\r\n         * @instance\r\n         *\r\n         * @fires TextTrack#modechange\r\n         */\r\n        mode: {\r\n          get: function get() {\r\n            return mode;\r\n          },\r\n          set: function set(newMode) {\r\n            if (!TextTrackMode[newMode]) {\r\n              return;\r\n            }\r\n\r\n            if (mode === newMode) {\r\n              return;\r\n            }\r\n\r\n            mode = newMode;\r\n\r\n            if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {\r\n              // On-demand load.\r\n              loadTrack(this.src, this);\r\n            }\r\n\r\n            this.stopTracking();\r\n\r\n            if (mode !== 'disabled') {\r\n              this.startTracking();\r\n            }\r\n            /**\r\n             * An event that fires when mode changes on this track. This allows\r\n             * the TextTrackList that holds this track to act accordingly.\r\n             *\r\n             * > Note: This is not part of the spec!\r\n             *\r\n             * @event TextTrack#modechange\r\n             * @type {EventTarget~Event}\r\n             */\r\n\r\n\r\n            this.trigger('modechange');\r\n          }\r\n        },\r\n\r\n        /**\r\n         * @memberof TextTrack\r\n         * @member {TextTrackCueList} cues\r\n         *         The text track cue list for this TextTrack.\r\n         * @instance\r\n         */\r\n        cues: {\r\n          get: function get() {\r\n            if (!this.loaded_) {\r\n              return null;\r\n            }\r\n\r\n            return cues;\r\n          },\r\n          set: function set() {}\r\n        },\r\n\r\n        /**\r\n         * @memberof TextTrack\r\n         * @member {TextTrackCueList} activeCues\r\n         *         The list text track cues that are currently active for this TextTrack.\r\n         * @instance\r\n         */\r\n        activeCues: {\r\n          get: function get() {\r\n            if (!this.loaded_) {\r\n              return null;\r\n            } // nothing to do\r\n\r\n\r\n            if (this.cues.length === 0) {\r\n              return activeCues;\r\n            }\r\n\r\n            var ct = this.tech_.currentTime();\r\n            var active = [];\r\n\r\n            for (var i = 0, l = this.cues.length; i < l; i++) {\r\n              var cue = this.cues[i];\r\n\r\n              if (cue.startTime <= ct && cue.endTime >= ct) {\r\n                active.push(cue);\r\n              } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\r\n                active.push(cue);\r\n              }\r\n            }\r\n\r\n            changed = false;\r\n\r\n            if (active.length !== this.activeCues_.length) {\r\n              changed = true;\r\n            } else {\r\n              for (var _i = 0; _i < active.length; _i++) {\r\n                if (this.activeCues_.indexOf(active[_i]) === -1) {\r\n                  changed = true;\r\n                }\r\n              }\r\n            }\r\n\r\n            this.activeCues_ = active;\r\n            activeCues.setCues_(this.activeCues_);\r\n            return activeCues;\r\n          },\r\n          // /!\\ Keep this setter empty (see the timeupdate handler above)\r\n          set: function set() {}\r\n        }\r\n      });\r\n\r\n      if (settings.src) {\r\n        _this.src = settings.src;\r\n\r\n        if (!_this.preload_) {\r\n          // Tracks will load on-demand.\r\n          // Act like we're loaded for other purposes.\r\n          _this.loaded_ = true;\r\n        }\r\n\r\n        if (_this.preload_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {\r\n          loadTrack(_this.src, assertThisInitialized(_this));\r\n        }\r\n      } else {\r\n        _this.loaded_ = true;\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = TextTrack.prototype;\r\n\r\n    _proto.startTracking = function startTracking() {\r\n      // More precise cues based on requestVideoFrameCallback with a requestAnimationFram fallback\r\n      this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler); // Also listen to timeupdate in case rVFC/rAF stops (window in background, audio in video el)\r\n\r\n      this.tech_.on('timeupdate', this.timeupdateHandler);\r\n    };\r\n\r\n    _proto.stopTracking = function stopTracking() {\r\n      if (this.rvf_) {\r\n        this.tech_.cancelVideoFrameCallback(this.rvf_);\r\n        this.rvf_ = undefined;\r\n      }\r\n\r\n      this.tech_.off('timeupdate', this.timeupdateHandler);\r\n    }\r\n    /**\r\n     * Add a cue to the internal list of cues.\r\n     *\r\n     * @param {TextTrack~Cue} cue\r\n     *        The cue to add to our internal list\r\n     */\r\n    ;\r\n\r\n    _proto.addCue = function addCue(originalCue) {\r\n      var cue = originalCue;\r\n\r\n      if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {\r\n        cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\r\n\r\n        for (var prop in originalCue) {\r\n          if (!(prop in cue)) {\r\n            cue[prop] = originalCue[prop];\r\n          }\r\n        } // make sure that `id` is copied over\r\n\r\n\r\n        cue.id = originalCue.id;\r\n        cue.originalCue_ = originalCue;\r\n      }\r\n\r\n      var tracks = this.tech_.textTracks();\r\n\r\n      for (var i = 0; i < tracks.length; i++) {\r\n        if (tracks[i] !== this) {\r\n          tracks[i].removeCue(cue);\r\n        }\r\n      }\r\n\r\n      this.cues_.push(cue);\r\n      this.cues.setCues_(this.cues_);\r\n    }\r\n    /**\r\n     * Remove a cue from our internal list\r\n     *\r\n     * @param {TextTrack~Cue} removeCue\r\n     *        The cue to remove from our internal list\r\n     */\r\n    ;\r\n\r\n    _proto.removeCue = function removeCue(_removeCue) {\r\n      var i = this.cues_.length;\r\n\r\n      while (i--) {\r\n        var cue = this.cues_[i];\r\n\r\n        if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {\r\n          this.cues_.splice(i, 1);\r\n          this.cues.setCues_(this.cues_);\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    return TextTrack;\r\n  }(Track);\r\n  /**\r\n   * cuechange - One or more cues in the track have become active or stopped being active.\r\n   */\r\n\r\n\r\n  TextTrack.prototype.allowedEvents_ = {\r\n    cuechange: 'cuechange'\r\n  };\r\n\r\n  /**\r\n   * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\r\n   * only one `AudioTrack` in the list will be enabled at a time.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\r\n   * @extends Track\r\n   */\r\n\r\n  var AudioTrack = /*#__PURE__*/function (_Track) {\r\n    inheritsLoose(AudioTrack, _Track);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        Object of option names and values\r\n     *\r\n     * @param {AudioTrack~Kind} [options.kind='']\r\n     *        A valid audio track kind\r\n     *\r\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\r\n     *        A unique id for this AudioTrack.\r\n     *\r\n     * @param {string} [options.label='']\r\n     *        The menu label for this track.\r\n     *\r\n     * @param {string} [options.language='']\r\n     *        A valid two character language code.\r\n     *\r\n     * @param {boolean} [options.enabled]\r\n     *        If this track is the one that is currently playing. If this track is part of\r\n     *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\r\n     */\r\n    function AudioTrack(options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var settings = mergeOptions$3(options, {\r\n        kind: AudioTrackKind[options.kind] || ''\r\n      });\r\n      _this = _Track.call(this, settings) || this;\r\n      var enabled = false;\r\n      /**\r\n       * @memberof AudioTrack\r\n       * @member {boolean} enabled\r\n       *         If this `AudioTrack` is enabled or not. When setting this will\r\n       *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\r\n       * @instance\r\n       *\r\n       * @fires VideoTrack#selectedchange\r\n       */\r\n\r\n      Object.defineProperty(assertThisInitialized(_this), 'enabled', {\r\n        get: function get() {\r\n          return enabled;\r\n        },\r\n        set: function set(newEnabled) {\r\n          // an invalid or unchanged value\r\n          if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\r\n            return;\r\n          }\r\n\r\n          enabled = newEnabled;\r\n          /**\r\n           * An event that fires when enabled changes on this track. This allows\r\n           * the AudioTrackList that holds this track to act accordingly.\r\n           *\r\n           * > Note: This is not part of the spec! Native tracks will do\r\n           *         this internally without an event.\r\n           *\r\n           * @event AudioTrack#enabledchange\r\n           * @type {EventTarget~Event}\r\n           */\r\n\r\n          this.trigger('enabledchange');\r\n        }\r\n      }); // if the user sets this track to selected then\r\n      // set selected to that true value otherwise\r\n      // we keep it false\r\n\r\n      if (settings.enabled) {\r\n        _this.enabled = settings.enabled;\r\n      }\r\n\r\n      _this.loaded_ = true;\r\n      return _this;\r\n    }\r\n\r\n    return AudioTrack;\r\n  }(Track);\r\n\r\n  /**\r\n   * A representation of a single `VideoTrack`.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\r\n   * @extends Track\r\n   */\r\n\r\n  var VideoTrack = /*#__PURE__*/function (_Track) {\r\n    inheritsLoose(VideoTrack, _Track);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        Object of option names and values\r\n     *\r\n     * @param {string} [options.kind='']\r\n     *        A valid {@link VideoTrack~Kind}\r\n     *\r\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\r\n     *        A unique id for this AudioTrack.\r\n     *\r\n     * @param {string} [options.label='']\r\n     *        The menu label for this track.\r\n     *\r\n     * @param {string} [options.language='']\r\n     *        A valid two character language code.\r\n     *\r\n     * @param {boolean} [options.selected]\r\n     *        If this track is the one that is currently playing.\r\n     */\r\n    function VideoTrack(options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var settings = mergeOptions$3(options, {\r\n        kind: VideoTrackKind[options.kind] || ''\r\n      });\r\n      _this = _Track.call(this, settings) || this;\r\n      var selected = false;\r\n      /**\r\n       * @memberof VideoTrack\r\n       * @member {boolean} selected\r\n       *         If this `VideoTrack` is selected or not. When setting this will\r\n       *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\r\n       * @instance\r\n       *\r\n       * @fires VideoTrack#selectedchange\r\n       */\r\n\r\n      Object.defineProperty(assertThisInitialized(_this), 'selected', {\r\n        get: function get() {\r\n          return selected;\r\n        },\r\n        set: function set(newSelected) {\r\n          // an invalid or unchanged value\r\n          if (typeof newSelected !== 'boolean' || newSelected === selected) {\r\n            return;\r\n          }\r\n\r\n          selected = newSelected;\r\n          /**\r\n           * An event that fires when selected changes on this track. This allows\r\n           * the VideoTrackList that holds this track to act accordingly.\r\n           *\r\n           * > Note: This is not part of the spec! Native tracks will do\r\n           *         this internally without an event.\r\n           *\r\n           * @event VideoTrack#selectedchange\r\n           * @type {EventTarget~Event}\r\n           */\r\n\r\n          this.trigger('selectedchange');\r\n        }\r\n      }); // if the user sets this track to selected then\r\n      // set selected to that true value otherwise\r\n      // we keep it false\r\n\r\n      if (settings.selected) {\r\n        _this.selected = settings.selected;\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    return VideoTrack;\r\n  }(Track);\r\n\r\n  /**\r\n   * @memberof HTMLTrackElement\r\n   * @typedef {HTMLTrackElement~ReadyState}\r\n   * @enum {number}\r\n   */\r\n\r\n  var NONE = 0;\r\n  var LOADING = 1;\r\n  var LOADED = 2;\r\n  var ERROR = 3;\r\n  /**\r\n   * A single track represented in the DOM.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\r\n   * @extends EventTarget\r\n   */\r\n\r\n  var HTMLTrackElement = /*#__PURE__*/function (_EventTarget) {\r\n    inheritsLoose(HTMLTrackElement, _EventTarget);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Object} options={}\r\n     *        Object of option names and values\r\n     *\r\n     * @param {Tech} options.tech\r\n     *        A reference to the tech that owns this HTMLTrackElement.\r\n     *\r\n     * @param {TextTrack~Kind} [options.kind='subtitles']\r\n     *        A valid text track kind.\r\n     *\r\n     * @param {TextTrack~Mode} [options.mode='disabled']\r\n     *        A valid text track mode.\r\n     *\r\n     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\r\n     *        A unique id for this TextTrack.\r\n     *\r\n     * @param {string} [options.label='']\r\n     *        The menu label for this track.\r\n     *\r\n     * @param {string} [options.language='']\r\n     *        A valid two character language code.\r\n     *\r\n     * @param {string} [options.srclang='']\r\n     *        A valid two character language code. An alternative, but deprioritized\r\n     *        version of `options.language`\r\n     *\r\n     * @param {string} [options.src]\r\n     *        A url to TextTrack cues.\r\n     *\r\n     * @param {boolean} [options.default]\r\n     *        If this track should default to on or off.\r\n     */\r\n    function HTMLTrackElement(options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _EventTarget.call(this) || this;\r\n      var readyState;\r\n      var track = new TextTrack(options);\r\n      _this.kind = track.kind;\r\n      _this.src = track.src;\r\n      _this.srclang = track.language;\r\n      _this.label = track.label;\r\n      _this[\"default\"] = track[\"default\"];\r\n      Object.defineProperties(assertThisInitialized(_this), {\r\n        /**\r\n         * @memberof HTMLTrackElement\r\n         * @member {HTMLTrackElement~ReadyState} readyState\r\n         *         The current ready state of the track element.\r\n         * @instance\r\n         */\r\n        readyState: {\r\n          get: function get() {\r\n            return readyState;\r\n          }\r\n        },\r\n\r\n        /**\r\n         * @memberof HTMLTrackElement\r\n         * @member {TextTrack} track\r\n         *         The underlying TextTrack object.\r\n         * @instance\r\n         *\r\n         */\r\n        track: {\r\n          get: function get() {\r\n            return track;\r\n          }\r\n        }\r\n      });\r\n      readyState = NONE;\r\n      /**\r\n       * @listens TextTrack#loadeddata\r\n       * @fires HTMLTrackElement#load\r\n       */\r\n\r\n      track.addEventListener('loadeddata', function () {\r\n        readyState = LOADED;\r\n\r\n        _this.trigger({\r\n          type: 'load',\r\n          target: assertThisInitialized(_this)\r\n        });\r\n      });\r\n      return _this;\r\n    }\r\n\r\n    return HTMLTrackElement;\r\n  }(EventTarget$2);\r\n\r\n  HTMLTrackElement.prototype.allowedEvents_ = {\r\n    load: 'load'\r\n  };\r\n  HTMLTrackElement.NONE = NONE;\r\n  HTMLTrackElement.LOADING = LOADING;\r\n  HTMLTrackElement.LOADED = LOADED;\r\n  HTMLTrackElement.ERROR = ERROR;\r\n\r\n  /*\r\n   * This file contains all track properties that are used in\r\n   * player.js, tech.js, html5.js and possibly other techs in the future.\r\n   */\r\n\r\n  var NORMAL = {\r\n    audio: {\r\n      ListClass: AudioTrackList,\r\n      TrackClass: AudioTrack,\r\n      capitalName: 'Audio'\r\n    },\r\n    video: {\r\n      ListClass: VideoTrackList,\r\n      TrackClass: VideoTrack,\r\n      capitalName: 'Video'\r\n    },\r\n    text: {\r\n      ListClass: TextTrackList,\r\n      TrackClass: TextTrack,\r\n      capitalName: 'Text'\r\n    }\r\n  };\r\n  Object.keys(NORMAL).forEach(function (type) {\r\n    NORMAL[type].getterName = type + \"Tracks\";\r\n    NORMAL[type].privateName = type + \"Tracks_\";\r\n  });\r\n  var REMOTE = {\r\n    remoteText: {\r\n      ListClass: TextTrackList,\r\n      TrackClass: TextTrack,\r\n      capitalName: 'RemoteText',\r\n      getterName: 'remoteTextTracks',\r\n      privateName: 'remoteTextTracks_'\r\n    },\r\n    remoteTextEl: {\r\n      ListClass: HtmlTrackElementList,\r\n      TrackClass: HTMLTrackElement,\r\n      capitalName: 'RemoteTextTrackEls',\r\n      getterName: 'remoteTextTrackEls',\r\n      privateName: 'remoteTextTrackEls_'\r\n    }\r\n  };\r\n\r\n  var ALL = _extends_1({}, NORMAL, REMOTE);\r\n\r\n  REMOTE.names = Object.keys(REMOTE);\r\n  NORMAL.names = Object.keys(NORMAL);\r\n  ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\r\n\r\n  var minDoc = {};\r\n\r\n  var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : {};\r\n  var doccy;\r\n\r\n  if (typeof document !== 'undefined') {\r\n    doccy = document;\r\n  } else {\r\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\r\n\r\n    if (!doccy) {\r\n      doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\r\n    }\r\n  }\r\n\r\n  var document_1 = doccy;\r\n\r\n  /**\r\n   * Copyright 2013 vtt.js Contributors\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *   http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n\r\n  /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\r\n\r\n  /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\r\n\r\n  var _objCreate = Object.create || function () {\r\n    function F() {}\r\n\r\n    return function (o) {\r\n      if (arguments.length !== 1) {\r\n        throw new Error('Object.create shim only accepts one parameter.');\r\n      }\r\n\r\n      F.prototype = o;\r\n      return new F();\r\n    };\r\n  }(); // Creates a new ParserError object from an errorData object. The errorData\r\n  // object should have default code and message properties. The default message\r\n  // property can be overriden by passing in a message parameter.\r\n  // See ParsingError.Errors below for acceptable errors.\r\n\r\n\r\n  function ParsingError(errorData, message) {\r\n    this.name = \"ParsingError\";\r\n    this.code = errorData.code;\r\n    this.message = message || errorData.message;\r\n  }\r\n\r\n  ParsingError.prototype = _objCreate(Error.prototype);\r\n  ParsingError.prototype.constructor = ParsingError; // ParsingError metadata for acceptable ParsingErrors.\r\n\r\n  ParsingError.Errors = {\r\n    BadSignature: {\r\n      code: 0,\r\n      message: \"Malformed WebVTT signature.\"\r\n    },\r\n    BadTimeStamp: {\r\n      code: 1,\r\n      message: \"Malformed time stamp.\"\r\n    }\r\n  }; // Try to parse input as a time stamp.\r\n\r\n  function parseTimeStamp(input) {\r\n    function computeSeconds(h, m, s, f) {\r\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\r\n    }\r\n\r\n    var m = input.match(/^(\\d+):(\\d{1,2})(:\\d{1,2})?\\.(\\d{3})/);\r\n\r\n    if (!m) {\r\n      return null;\r\n    }\r\n\r\n    if (m[3]) {\r\n      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\r\n      return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\r\n    } else if (m[1] > 59) {\r\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\r\n      // First position is hours as it's over 59.\r\n      return computeSeconds(m[1], m[2], 0, m[4]);\r\n    } else {\r\n      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\r\n      return computeSeconds(0, m[1], m[2], m[4]);\r\n    }\r\n  } // A settings object holds key/value pairs and will ignore anything but the first\r\n  // assignment to a specific key.\r\n\r\n\r\n  function Settings() {\r\n    this.values = _objCreate(null);\r\n  }\r\n\r\n  Settings.prototype = {\r\n    // Only accept the first assignment to any key.\r\n    set: function set(k, v) {\r\n      if (!this.get(k) && v !== \"\") {\r\n        this.values[k] = v;\r\n      }\r\n    },\r\n    // Return the value for a key, or a default value.\r\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\r\n    // a number of possible default values as properties where 'defaultKey' is\r\n    // the key of the property that will be chosen; otherwise it's assumed to be\r\n    // a single value.\r\n    get: function get(k, dflt, defaultKey) {\r\n      if (defaultKey) {\r\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\r\n      }\r\n\r\n      return this.has(k) ? this.values[k] : dflt;\r\n    },\r\n    // Check whether we have a value for a key.\r\n    has: function has(k) {\r\n      return k in this.values;\r\n    },\r\n    // Accept a setting if its one of the given alternatives.\r\n    alt: function alt(k, v, a) {\r\n      for (var n = 0; n < a.length; ++n) {\r\n        if (v === a[n]) {\r\n          this.set(k, v);\r\n          break;\r\n        }\r\n      }\r\n    },\r\n    // Accept a setting if its a valid (signed) integer.\r\n    integer: function integer(k, v) {\r\n      if (/^-?\\d+$/.test(v)) {\r\n        // integer\r\n        this.set(k, parseInt(v, 10));\r\n      }\r\n    },\r\n    // Accept a setting if its a valid percentage.\r\n    percent: function percent(k, v) {\r\n\r\n      if (v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\r\n        v = parseFloat(v);\r\n\r\n        if (v >= 0 && v <= 100) {\r\n          this.set(k, v);\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }; // Helper function to parse input into groups separated by 'groupDelim', and\r\n  // interprete each group as a key/value pair separated by 'keyValueDelim'.\r\n\r\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\r\n    var groups = groupDelim ? input.split(groupDelim) : [input];\r\n\r\n    for (var i in groups) {\r\n      if (typeof groups[i] !== \"string\") {\r\n        continue;\r\n      }\r\n\r\n      var kv = groups[i].split(keyValueDelim);\r\n\r\n      if (kv.length !== 2) {\r\n        continue;\r\n      }\r\n\r\n      var k = kv[0].trim();\r\n      var v = kv[1].trim();\r\n      callback(k, v);\r\n    }\r\n  }\r\n\r\n  function parseCue(input, cue, regionList) {\r\n    // Remember the original input if we need to throw an error.\r\n    var oInput = input; // 4.1 WebVTT timestamp\r\n\r\n    function consumeTimeStamp() {\r\n      var ts = parseTimeStamp(input);\r\n\r\n      if (ts === null) {\r\n        throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed timestamp: \" + oInput);\r\n      } // Remove time stamp from input.\r\n\r\n\r\n      input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\r\n      return ts;\r\n    } // 4.4.2 WebVTT cue settings\r\n\r\n\r\n    function consumeCueSettings(input, cue) {\r\n      var settings = new Settings();\r\n      parseOptions(input, function (k, v) {\r\n        switch (k) {\r\n          case \"region\":\r\n            // Find the last region we parsed with the same region id.\r\n            for (var i = regionList.length - 1; i >= 0; i--) {\r\n              if (regionList[i].id === v) {\r\n                settings.set(k, regionList[i].region);\r\n                break;\r\n              }\r\n            }\r\n\r\n            break;\r\n\r\n          case \"vertical\":\r\n            settings.alt(k, v, [\"rl\", \"lr\"]);\r\n            break;\r\n\r\n          case \"line\":\r\n            var vals = v.split(\",\"),\r\n                vals0 = vals[0];\r\n            settings.integer(k, vals0);\r\n            settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\r\n            settings.alt(k, vals0, [\"auto\"]);\r\n\r\n            if (vals.length === 2) {\r\n              settings.alt(\"lineAlign\", vals[1], [\"start\", \"center\", \"end\"]);\r\n            }\r\n\r\n            break;\r\n\r\n          case \"position\":\r\n            vals = v.split(\",\");\r\n            settings.percent(k, vals[0]);\r\n\r\n            if (vals.length === 2) {\r\n              settings.alt(\"positionAlign\", vals[1], [\"start\", \"center\", \"end\"]);\r\n            }\r\n\r\n            break;\r\n\r\n          case \"size\":\r\n            settings.percent(k, v);\r\n            break;\r\n\r\n          case \"align\":\r\n            settings.alt(k, v, [\"start\", \"center\", \"end\", \"left\", \"right\"]);\r\n            break;\r\n        }\r\n      }, /:/, /\\s/); // Apply default values for any missing fields.\r\n\r\n      cue.region = settings.get(\"region\", null);\r\n      cue.vertical = settings.get(\"vertical\", \"\");\r\n\r\n      try {\r\n        cue.line = settings.get(\"line\", \"auto\");\r\n      } catch (e) {}\r\n\r\n      cue.lineAlign = settings.get(\"lineAlign\", \"start\");\r\n      cue.snapToLines = settings.get(\"snapToLines\", true);\r\n      cue.size = settings.get(\"size\", 100); // Safari still uses the old middle value and won't accept center\r\n\r\n      try {\r\n        cue.align = settings.get(\"align\", \"center\");\r\n      } catch (e) {\r\n        cue.align = settings.get(\"align\", \"middle\");\r\n      }\r\n\r\n      try {\r\n        cue.position = settings.get(\"position\", \"auto\");\r\n      } catch (e) {\r\n        cue.position = settings.get(\"position\", {\r\n          start: 0,\r\n          left: 0,\r\n          center: 50,\r\n          middle: 50,\r\n          end: 100,\r\n          right: 100\r\n        }, cue.align);\r\n      }\r\n\r\n      cue.positionAlign = settings.get(\"positionAlign\", {\r\n        start: \"start\",\r\n        left: \"start\",\r\n        center: \"center\",\r\n        middle: \"center\",\r\n        end: \"end\",\r\n        right: \"end\"\r\n      }, cue.align);\r\n    }\r\n\r\n    function skipWhitespace() {\r\n      input = input.replace(/^\\s+/, \"\");\r\n    } // 4.1 WebVTT cue timings.\r\n\r\n\r\n    skipWhitespace();\r\n    cue.startTime = consumeTimeStamp(); // (1) collect cue start time\r\n\r\n    skipWhitespace();\r\n\r\n    if (input.substr(0, 3) !== \"-->\") {\r\n      // (3) next characters must match \"-->\"\r\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\r\n    }\r\n\r\n    input = input.substr(3);\r\n    skipWhitespace();\r\n    cue.endTime = consumeTimeStamp(); // (5) collect cue end time\r\n    // 4.1 WebVTT cue settings list.\r\n\r\n    skipWhitespace();\r\n    consumeCueSettings(input, cue);\r\n  } // When evaluating this file as part of a Webpack bundle for server\r\n  // side rendering, `document` is an empty object.\r\n\r\n\r\n  var TEXTAREA_ELEMENT = document_1.createElement && document_1.createElement(\"textarea\");\r\n  var TAG_NAME = {\r\n    c: \"span\",\r\n    i: \"i\",\r\n    b: \"b\",\r\n    u: \"u\",\r\n    ruby: \"ruby\",\r\n    rt: \"rt\",\r\n    v: \"span\",\r\n    lang: \"span\"\r\n  }; // 5.1 default text color\r\n  // 5.2 default text background color is equivalent to text color with bg_ prefix\r\n\r\n  var DEFAULT_COLOR_CLASS = {\r\n    white: 'rgba(255,255,255,1)',\r\n    lime: 'rgba(0,255,0,1)',\r\n    cyan: 'rgba(0,255,255,1)',\r\n    red: 'rgba(255,0,0,1)',\r\n    yellow: 'rgba(255,255,0,1)',\r\n    magenta: 'rgba(255,0,255,1)',\r\n    blue: 'rgba(0,0,255,1)',\r\n    black: 'rgba(0,0,0,1)'\r\n  };\r\n  var TAG_ANNOTATION = {\r\n    v: \"title\",\r\n    lang: \"lang\"\r\n  };\r\n  var NEEDS_PARENT = {\r\n    rt: \"ruby\"\r\n  }; // Parse content into a document fragment.\r\n\r\n  function parseContent(window, input) {\r\n    function nextToken() {\r\n      // Check for end-of-string.\r\n      if (!input) {\r\n        return null;\r\n      } // Consume 'n' characters from the input.\r\n\r\n\r\n      function consume(result) {\r\n        input = input.substr(result.length);\r\n        return result;\r\n      }\r\n\r\n      var m = input.match(/^([^<]*)(<[^>]*>?)?/); // If there is some text before the next tag, return it, otherwise return\r\n      // the tag.\r\n\r\n      return consume(m[1] ? m[1] : m[2]);\r\n    }\r\n\r\n    function unescape(s) {\r\n      TEXTAREA_ELEMENT.innerHTML = s;\r\n      s = TEXTAREA_ELEMENT.textContent;\r\n      TEXTAREA_ELEMENT.textContent = \"\";\r\n      return s;\r\n    }\r\n\r\n    function shouldAdd(current, element) {\r\n      return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;\r\n    } // Create an element for this tag.\r\n\r\n\r\n    function createElement(type, annotation) {\r\n      var tagName = TAG_NAME[type];\r\n\r\n      if (!tagName) {\r\n        return null;\r\n      }\r\n\r\n      var element = window.document.createElement(tagName);\r\n      var name = TAG_ANNOTATION[type];\r\n\r\n      if (name && annotation) {\r\n        element[name] = annotation.trim();\r\n      }\r\n\r\n      return element;\r\n    }\r\n\r\n    var rootDiv = window.document.createElement(\"div\"),\r\n        current = rootDiv,\r\n        t,\r\n        tagStack = [];\r\n\r\n    while ((t = nextToken()) !== null) {\r\n      if (t[0] === '<') {\r\n        if (t[1] === \"/\") {\r\n          // If the closing tag matches, move back up to the parent node.\r\n          if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\r\n            tagStack.pop();\r\n            current = current.parentNode;\r\n          } // Otherwise just ignore the end tag.\r\n\r\n\r\n          continue;\r\n        }\r\n\r\n        var ts = parseTimeStamp(t.substr(1, t.length - 2));\r\n        var node;\r\n\r\n        if (ts) {\r\n          // Timestamps are lead nodes as well.\r\n          node = window.document.createProcessingInstruction(\"timestamp\", ts);\r\n          current.appendChild(node);\r\n          continue;\r\n        }\r\n\r\n        var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/); // If we can't parse the tag, skip to the next tag.\r\n\r\n        if (!m) {\r\n          continue;\r\n        } // Try to construct an element, and ignore the tag if we couldn't.\r\n\r\n\r\n        node = createElement(m[1], m[3]);\r\n\r\n        if (!node) {\r\n          continue;\r\n        } // Determine if the tag should be added based on the context of where it\r\n        // is placed in the cuetext.\r\n\r\n\r\n        if (!shouldAdd(current, node)) {\r\n          continue;\r\n        } // Set the class list (as a list of classes, separated by space).\r\n\r\n\r\n        if (m[2]) {\r\n          var classes = m[2].split('.');\r\n          classes.forEach(function (cl) {\r\n            var bgColor = /^bg_/.test(cl); // slice out `bg_` if it's a background color\r\n\r\n            var colorName = bgColor ? cl.slice(3) : cl;\r\n\r\n            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {\r\n              var propName = bgColor ? 'background-color' : 'color';\r\n              var propValue = DEFAULT_COLOR_CLASS[colorName];\r\n              node.style[propName] = propValue;\r\n            }\r\n          });\r\n          node.className = classes.join(' ');\r\n        } // Append the node to the current node, and enter the scope of the new\r\n        // node.\r\n\r\n\r\n        tagStack.push(m[1]);\r\n        current.appendChild(node);\r\n        current = node;\r\n        continue;\r\n      } // Text nodes are leaf nodes.\r\n\r\n\r\n      current.appendChild(window.document.createTextNode(unescape(t)));\r\n    }\r\n\r\n    return rootDiv;\r\n  } // This is a list of all the Unicode characters that have a strong\r\n  // right-to-left category. What this means is that these characters are\r\n  // written right-to-left for sure. It was generated by pulling all the strong\r\n  // right-to-left characters out of the Unicode data table. That table can\r\n  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\r\n\r\n\r\n  var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\r\n\r\n  function isStrongRTLChar(charCode) {\r\n    for (var i = 0; i < strongRTLRanges.length; i++) {\r\n      var currentRange = strongRTLRanges[i];\r\n\r\n      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function determineBidi(cueDiv) {\r\n    var nodeStack = [],\r\n        text = \"\",\r\n        charCode;\r\n\r\n    if (!cueDiv || !cueDiv.childNodes) {\r\n      return \"ltr\";\r\n    }\r\n\r\n    function pushNodes(nodeStack, node) {\r\n      for (var i = node.childNodes.length - 1; i >= 0; i--) {\r\n        nodeStack.push(node.childNodes[i]);\r\n      }\r\n    }\r\n\r\n    function nextTextNode(nodeStack) {\r\n      if (!nodeStack || !nodeStack.length) {\r\n        return null;\r\n      }\r\n\r\n      var node = nodeStack.pop(),\r\n          text = node.textContent || node.innerText;\r\n\r\n      if (text) {\r\n        // TODO: This should match all unicode type B characters (paragraph\r\n        // separator characters). See issue #115.\r\n        var m = text.match(/^.*(\\n|\\r)/);\r\n\r\n        if (m) {\r\n          nodeStack.length = 0;\r\n          return m[0];\r\n        }\r\n\r\n        return text;\r\n      }\r\n\r\n      if (node.tagName === \"ruby\") {\r\n        return nextTextNode(nodeStack);\r\n      }\r\n\r\n      if (node.childNodes) {\r\n        pushNodes(nodeStack, node);\r\n        return nextTextNode(nodeStack);\r\n      }\r\n    }\r\n\r\n    pushNodes(nodeStack, cueDiv);\r\n\r\n    while (text = nextTextNode(nodeStack)) {\r\n      for (var i = 0; i < text.length; i++) {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (isStrongRTLChar(charCode)) {\r\n          return \"rtl\";\r\n        }\r\n      }\r\n    }\r\n\r\n    return \"ltr\";\r\n  }\r\n\r\n  function computeLinePos(cue) {\r\n    if (typeof cue.line === \"number\" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {\r\n      return cue.line;\r\n    }\r\n\r\n    if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {\r\n      return -1;\r\n    }\r\n\r\n    var track = cue.track,\r\n        trackList = track.textTrackList,\r\n        count = 0;\r\n\r\n    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\r\n      if (trackList[i].mode === \"showing\") {\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return ++count * -1;\r\n  }\r\n\r\n  function StyleBox() {} // Apply styles to a div. If there is no div passed then it defaults to the\r\n  // div on 'this'.\r\n\r\n\r\n  StyleBox.prototype.applyStyles = function (styles, div) {\r\n    div = div || this.div;\r\n\r\n    for (var prop in styles) {\r\n      if (styles.hasOwnProperty(prop)) {\r\n        div.style[prop] = styles[prop];\r\n      }\r\n    }\r\n  };\r\n\r\n  StyleBox.prototype.formatStyle = function (val, unit) {\r\n    return val === 0 ? 0 : val + unit;\r\n  }; // Constructs the computed display state of the cue (a div). Places the div\r\n  // into the overlay which should be a block level element (usually a div).\r\n\r\n\r\n  function CueStyleBox(window, cue, styleOptions) {\r\n    StyleBox.call(this);\r\n    this.cue = cue; // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\r\n    // have inline positioning and will function as the cue background box.\r\n\r\n    this.cueDiv = parseContent(window, cue.text);\r\n    var styles = {\r\n      color: \"rgba(255, 255, 255, 1)\",\r\n      backgroundColor: \"rgba(0, 0, 0, 0.8)\",\r\n      position: \"relative\",\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0,\r\n      display: \"inline\",\r\n      writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\r\n      unicodeBidi: \"plaintext\"\r\n    };\r\n    this.applyStyles(styles, this.cueDiv); // Create an absolutely positioned div that will be used to position the cue\r\n    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\r\n    // mirrors of them except middle instead of center on Safari.\r\n\r\n    this.div = window.document.createElement(\"div\");\r\n    styles = {\r\n      direction: determineBidi(this.cueDiv),\r\n      writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\r\n      unicodeBidi: \"plaintext\",\r\n      textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\r\n      font: styleOptions.font,\r\n      whiteSpace: \"pre-line\",\r\n      position: \"absolute\"\r\n    };\r\n    this.applyStyles(styles);\r\n    this.div.appendChild(this.cueDiv); // Calculate the distance from the reference edge of the viewport to the text\r\n    // position of the cue box. The reference edge will be resolved later when\r\n    // the box orientation styles are applied.\r\n\r\n    var textPos = 0;\r\n\r\n    switch (cue.positionAlign) {\r\n      case \"start\":\r\n        textPos = cue.position;\r\n        break;\r\n\r\n      case \"center\":\r\n        textPos = cue.position - cue.size / 2;\r\n        break;\r\n\r\n      case \"end\":\r\n        textPos = cue.position - cue.size;\r\n        break;\r\n    } // Horizontal box orientation; textPos is the distance from the left edge of the\r\n    // area to the left edge of the box and cue.size is the distance extending to\r\n    // the right from there.\r\n\r\n\r\n    if (cue.vertical === \"\") {\r\n      this.applyStyles({\r\n        left: this.formatStyle(textPos, \"%\"),\r\n        width: this.formatStyle(cue.size, \"%\")\r\n      }); // Vertical box orientation; textPos is the distance from the top edge of the\r\n      // area to the top edge of the box and cue.size is the height extending\r\n      // downwards from there.\r\n    } else {\r\n      this.applyStyles({\r\n        top: this.formatStyle(textPos, \"%\"),\r\n        height: this.formatStyle(cue.size, \"%\")\r\n      });\r\n    }\r\n\r\n    this.move = function (box) {\r\n      this.applyStyles({\r\n        top: this.formatStyle(box.top, \"px\"),\r\n        bottom: this.formatStyle(box.bottom, \"px\"),\r\n        left: this.formatStyle(box.left, \"px\"),\r\n        right: this.formatStyle(box.right, \"px\"),\r\n        height: this.formatStyle(box.height, \"px\"),\r\n        width: this.formatStyle(box.width, \"px\")\r\n      });\r\n    };\r\n  }\r\n\r\n  CueStyleBox.prototype = _objCreate(StyleBox.prototype);\r\n  CueStyleBox.prototype.constructor = CueStyleBox; // Represents the co-ordinates of an Element in a way that we can easily\r\n  // compute things with such as if it overlaps or intersects with another Element.\r\n  // Can initialize it with either a StyleBox or another BoxPosition.\r\n\r\n  function BoxPosition(obj) {\r\n    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\r\n    // was passed in and we need to copy the results of 'getBoundingClientRect'\r\n    // as the object returned is readonly. All co-ordinate values are in reference\r\n    // to the viewport origin (top left).\r\n    var lh, height, width, top;\r\n\r\n    if (obj.div) {\r\n      height = obj.div.offsetHeight;\r\n      width = obj.div.offsetWidth;\r\n      top = obj.div.offsetTop;\r\n      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();\r\n      obj = obj.div.getBoundingClientRect(); // In certain cases the outter div will be slightly larger then the sum of\r\n      // the inner div's lines. This could be due to bold text, etc, on some platforms.\r\n      // In this case we should get the average line height and use that. This will\r\n      // result in the desired behaviour.\r\n\r\n      lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;\r\n    }\r\n\r\n    this.left = obj.left;\r\n    this.right = obj.right;\r\n    this.top = obj.top || top;\r\n    this.height = obj.height || height;\r\n    this.bottom = obj.bottom || top + (obj.height || height);\r\n    this.width = obj.width || width;\r\n    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\r\n  } // Move the box along a particular axis. Optionally pass in an amount to move\r\n  // the box. If no amount is passed then the default is the line height of the\r\n  // box.\r\n\r\n\r\n  BoxPosition.prototype.move = function (axis, toMove) {\r\n    toMove = toMove !== undefined ? toMove : this.lineHeight;\r\n\r\n    switch (axis) {\r\n      case \"+x\":\r\n        this.left += toMove;\r\n        this.right += toMove;\r\n        break;\r\n\r\n      case \"-x\":\r\n        this.left -= toMove;\r\n        this.right -= toMove;\r\n        break;\r\n\r\n      case \"+y\":\r\n        this.top += toMove;\r\n        this.bottom += toMove;\r\n        break;\r\n\r\n      case \"-y\":\r\n        this.top -= toMove;\r\n        this.bottom -= toMove;\r\n        break;\r\n    }\r\n  }; // Check if this box overlaps another box, b2.\r\n\r\n\r\n  BoxPosition.prototype.overlaps = function (b2) {\r\n    return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;\r\n  }; // Check if this box overlaps any other boxes in boxes.\r\n\r\n\r\n  BoxPosition.prototype.overlapsAny = function (boxes) {\r\n    for (var i = 0; i < boxes.length; i++) {\r\n      if (this.overlaps(boxes[i])) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }; // Check if this box is within another box.\r\n\r\n\r\n  BoxPosition.prototype.within = function (container) {\r\n    return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;\r\n  }; // Check if this box is entirely within the container or it is overlapping\r\n  // on the edge opposite of the axis direction passed. For example, if \"+x\" is\r\n  // passed and the box is overlapping on the left edge of the container, then\r\n  // return true.\r\n\r\n\r\n  BoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {\r\n    switch (axis) {\r\n      case \"+x\":\r\n        return this.left < container.left;\r\n\r\n      case \"-x\":\r\n        return this.right > container.right;\r\n\r\n      case \"+y\":\r\n        return this.top < container.top;\r\n\r\n      case \"-y\":\r\n        return this.bottom > container.bottom;\r\n    }\r\n  }; // Find the percentage of the area that this box is overlapping with another\r\n  // box.\r\n\r\n\r\n  BoxPosition.prototype.intersectPercentage = function (b2) {\r\n    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\r\n        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\r\n        intersectArea = x * y;\r\n    return intersectArea / (this.height * this.width);\r\n  }; // Convert the positions from this box to CSS compatible positions using\r\n  // the reference container's positions. This has to be done because this\r\n  // box's positions are in reference to the viewport origin, whereas, CSS\r\n  // values are in referecne to their respective edges.\r\n\r\n\r\n  BoxPosition.prototype.toCSSCompatValues = function (reference) {\r\n    return {\r\n      top: this.top - reference.top,\r\n      bottom: reference.bottom - this.bottom,\r\n      left: this.left - reference.left,\r\n      right: reference.right - this.right,\r\n      height: this.height,\r\n      width: this.width\r\n    };\r\n  }; // Get an object that represents the box's position without anything extra.\r\n  // Can pass a StyleBox, HTMLElement, or another BoxPositon.\r\n\r\n\r\n  BoxPosition.getSimpleBoxPosition = function (obj) {\r\n    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\r\n    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\r\n    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\r\n    obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;\r\n    var ret = {\r\n      left: obj.left,\r\n      right: obj.right,\r\n      top: obj.top || top,\r\n      height: obj.height || height,\r\n      bottom: obj.bottom || top + (obj.height || height),\r\n      width: obj.width || width\r\n    };\r\n    return ret;\r\n  }; // Move a StyleBox to its specified, or next best, position. The containerBox\r\n  // is the box that contains the StyleBox, such as a div. boxPositions are\r\n  // a list of other boxes that the styleBox can't overlap with.\r\n\r\n\r\n  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\r\n    // Find the best position for a cue box, b, on the video. The axis parameter\r\n    // is a list of axis, the order of which, it will move the box along. For example:\r\n    // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\r\n    // direction. If it doesn't find a good position for it there it will then move\r\n    // it along the x axis in the negative direction.\r\n    function findBestPosition(b, axis) {\r\n      var bestPosition,\r\n          specifiedPosition = new BoxPosition(b),\r\n          percentage = 1; // Highest possible so the first thing we get is better.\r\n\r\n      for (var i = 0; i < axis.length; i++) {\r\n        while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {\r\n          b.move(axis[i]);\r\n        } // We found a spot where we aren't overlapping anything. This is our\r\n        // best position.\r\n\r\n\r\n        if (b.within(containerBox)) {\r\n          return b;\r\n        }\r\n\r\n        var p = b.intersectPercentage(containerBox); // If we're outside the container box less then we were on our last try\r\n        // then remember this position as the best position.\r\n\r\n        if (percentage > p) {\r\n          bestPosition = new BoxPosition(b);\r\n          percentage = p;\r\n        } // Reset the box position to the specified position.\r\n\r\n\r\n        b = new BoxPosition(specifiedPosition);\r\n      }\r\n\r\n      return bestPosition || specifiedPosition;\r\n    }\r\n\r\n    var boxPosition = new BoxPosition(styleBox),\r\n        cue = styleBox.cue,\r\n        linePos = computeLinePos(cue),\r\n        axis = []; // If we have a line number to align the cue to.\r\n\r\n    if (cue.snapToLines) {\r\n      var size;\r\n\r\n      switch (cue.vertical) {\r\n        case \"\":\r\n          axis = [\"+y\", \"-y\"];\r\n          size = \"height\";\r\n          break;\r\n\r\n        case \"rl\":\r\n          axis = [\"+x\", \"-x\"];\r\n          size = \"width\";\r\n          break;\r\n\r\n        case \"lr\":\r\n          axis = [\"-x\", \"+x\"];\r\n          size = \"width\";\r\n          break;\r\n      }\r\n\r\n      var step = boxPosition.lineHeight,\r\n          position = step * Math.round(linePos),\r\n          maxPosition = containerBox[size] + step,\r\n          initialAxis = axis[0]; // If the specified intial position is greater then the max position then\r\n      // clamp the box to the amount of steps it would take for the box to\r\n      // reach the max position.\r\n\r\n      if (Math.abs(position) > maxPosition) {\r\n        position = position < 0 ? -1 : 1;\r\n        position *= Math.ceil(maxPosition / step) * step;\r\n      } // If computed line position returns negative then line numbers are\r\n      // relative to the bottom of the video instead of the top. Therefore, we\r\n      // need to increase our initial position by the length or width of the\r\n      // video, depending on the writing direction, and reverse our axis directions.\r\n\r\n\r\n      if (linePos < 0) {\r\n        position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\r\n        axis = axis.reverse();\r\n      } // Move the box to the specified position. This may not be its best\r\n      // position.\r\n\r\n\r\n      boxPosition.move(initialAxis, position);\r\n    } else {\r\n      // If we have a percentage line value for the cue.\r\n      var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;\r\n\r\n      switch (cue.lineAlign) {\r\n        case \"center\":\r\n          linePos -= calculatedPercentage / 2;\r\n          break;\r\n\r\n        case \"end\":\r\n          linePos -= calculatedPercentage;\r\n          break;\r\n      } // Apply initial line position to the cue box.\r\n\r\n\r\n      switch (cue.vertical) {\r\n        case \"\":\r\n          styleBox.applyStyles({\r\n            top: styleBox.formatStyle(linePos, \"%\")\r\n          });\r\n          break;\r\n\r\n        case \"rl\":\r\n          styleBox.applyStyles({\r\n            left: styleBox.formatStyle(linePos, \"%\")\r\n          });\r\n          break;\r\n\r\n        case \"lr\":\r\n          styleBox.applyStyles({\r\n            right: styleBox.formatStyle(linePos, \"%\")\r\n          });\r\n          break;\r\n      }\r\n\r\n      axis = [\"+y\", \"-x\", \"+x\", \"-y\"]; // Get the box position again after we've applied the specified positioning\r\n      // to it.\r\n\r\n      boxPosition = new BoxPosition(styleBox);\r\n    }\r\n\r\n    var bestPosition = findBestPosition(boxPosition, axis);\r\n    styleBox.move(bestPosition.toCSSCompatValues(containerBox));\r\n  }\r\n\r\n  function WebVTT$1() {// Nothing\r\n  } // Helper to allow strings to be decoded instead of the default binary utf8 data.\r\n\r\n\r\n  WebVTT$1.StringDecoder = function () {\r\n    return {\r\n      decode: function decode(data) {\r\n        if (!data) {\r\n          return \"\";\r\n        }\r\n\r\n        if (typeof data !== \"string\") {\r\n          throw new Error(\"Error - expected string data.\");\r\n        }\r\n\r\n        return decodeURIComponent(encodeURIComponent(data));\r\n      }\r\n    };\r\n  };\r\n\r\n  WebVTT$1.convertCueToDOMTree = function (window, cuetext) {\r\n    if (!window || !cuetext) {\r\n      return null;\r\n    }\r\n\r\n    return parseContent(window, cuetext);\r\n  };\r\n\r\n  var FONT_SIZE_PERCENT = 0.05;\r\n  var FONT_STYLE = \"sans-serif\";\r\n  var CUE_BACKGROUND_PADDING = \"1.5%\"; // Runs the processing model over the cues and regions passed to it.\r\n  // @param overlay A block level element (usually a div) that the computed cues\r\n  //                and regions will be placed into.\r\n\r\n  WebVTT$1.processCues = function (window, cues, overlay) {\r\n    if (!window || !cues || !overlay) {\r\n      return null;\r\n    } // Remove all previous children.\r\n\r\n\r\n    while (overlay.firstChild) {\r\n      overlay.removeChild(overlay.firstChild);\r\n    }\r\n\r\n    var paddedOverlay = window.document.createElement(\"div\");\r\n    paddedOverlay.style.position = \"absolute\";\r\n    paddedOverlay.style.left = \"0\";\r\n    paddedOverlay.style.right = \"0\";\r\n    paddedOverlay.style.top = \"0\";\r\n    paddedOverlay.style.bottom = \"0\";\r\n    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\r\n    overlay.appendChild(paddedOverlay); // Determine if we need to compute the display states of the cues. This could\r\n    // be the case if a cue's state has been changed since the last computation or\r\n    // if it has not been computed yet.\r\n\r\n    function shouldCompute(cues) {\r\n      for (var i = 0; i < cues.length; i++) {\r\n        if (cues[i].hasBeenReset || !cues[i].displayState) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    } // We don't need to recompute the cues' display states. Just reuse them.\r\n\r\n\r\n    if (!shouldCompute(cues)) {\r\n      for (var i = 0; i < cues.length; i++) {\r\n        paddedOverlay.appendChild(cues[i].displayState);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    var boxPositions = [],\r\n        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\r\n        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\r\n    var styleOptions = {\r\n      font: fontSize + \"px \" + FONT_STYLE\r\n    };\r\n\r\n    (function () {\r\n      var styleBox, cue;\r\n\r\n      for (var i = 0; i < cues.length; i++) {\r\n        cue = cues[i]; // Compute the intial position and styles of the cue div.\r\n\r\n        styleBox = new CueStyleBox(window, cue, styleOptions);\r\n        paddedOverlay.appendChild(styleBox.div); // Move the cue div to it's correct line position.\r\n\r\n        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions); // Remember the computed div so that we don't have to recompute it later\r\n        // if we don't have too.\r\n\r\n        cue.displayState = styleBox.div;\r\n        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\r\n      }\r\n    })();\r\n  };\r\n\r\n  WebVTT$1.Parser = function (window, vttjs, decoder) {\r\n    if (!decoder) {\r\n      decoder = vttjs;\r\n      vttjs = {};\r\n    }\r\n\r\n    if (!vttjs) {\r\n      vttjs = {};\r\n    }\r\n\r\n    this.window = window;\r\n    this.vttjs = vttjs;\r\n    this.state = \"INITIAL\";\r\n    this.buffer = \"\";\r\n    this.decoder = decoder || new TextDecoder(\"utf8\");\r\n    this.regionList = [];\r\n  };\r\n\r\n  WebVTT$1.Parser.prototype = {\r\n    // If the error is a ParsingError then report it to the consumer if\r\n    // possible. If it's not a ParsingError then throw it like normal.\r\n    reportOrThrowError: function reportOrThrowError(e) {\r\n      if (e instanceof ParsingError) {\r\n        this.onparsingerror && this.onparsingerror(e);\r\n      } else {\r\n        throw e;\r\n      }\r\n    },\r\n    parse: function parse(data) {\r\n      var self = this; // If there is no data then we won't decode it, but will just try to parse\r\n      // whatever is in buffer already. This may occur in circumstances, for\r\n      // example when flush() is called.\r\n\r\n      if (data) {\r\n        // Try to decode the data that we received.\r\n        self.buffer += self.decoder.decode(data, {\r\n          stream: true\r\n        });\r\n      }\r\n\r\n      function collectNextLine() {\r\n        var buffer = self.buffer;\r\n        var pos = 0;\r\n\r\n        while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\r\n          ++pos;\r\n        }\r\n\r\n        var line = buffer.substr(0, pos); // Advance the buffer early in case we fail below.\r\n\r\n        if (buffer[pos] === '\\r') {\r\n          ++pos;\r\n        }\r\n\r\n        if (buffer[pos] === '\\n') {\r\n          ++pos;\r\n        }\r\n\r\n        self.buffer = buffer.substr(pos);\r\n        return line;\r\n      } // 3.4 WebVTT region and WebVTT region settings syntax\r\n\r\n\r\n      function parseRegion(input) {\r\n        var settings = new Settings();\r\n        parseOptions(input, function (k, v) {\r\n          switch (k) {\r\n            case \"id\":\r\n              settings.set(k, v);\r\n              break;\r\n\r\n            case \"width\":\r\n              settings.percent(k, v);\r\n              break;\r\n\r\n            case \"lines\":\r\n              settings.integer(k, v);\r\n              break;\r\n\r\n            case \"regionanchor\":\r\n            case \"viewportanchor\":\r\n              var xy = v.split(',');\r\n\r\n              if (xy.length !== 2) {\r\n                break;\r\n              } // We have to make sure both x and y parse, so use a temporary\r\n              // settings object here.\r\n\r\n\r\n              var anchor = new Settings();\r\n              anchor.percent(\"x\", xy[0]);\r\n              anchor.percent(\"y\", xy[1]);\r\n\r\n              if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\r\n                break;\r\n              }\r\n\r\n              settings.set(k + \"X\", anchor.get(\"x\"));\r\n              settings.set(k + \"Y\", anchor.get(\"y\"));\r\n              break;\r\n\r\n            case \"scroll\":\r\n              settings.alt(k, v, [\"up\"]);\r\n              break;\r\n          }\r\n        }, /=/, /\\s/); // Create the region, using default values for any values that were not\r\n        // specified.\r\n\r\n        if (settings.has(\"id\")) {\r\n          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\r\n          region.width = settings.get(\"width\", 100);\r\n          region.lines = settings.get(\"lines\", 3);\r\n          region.regionAnchorX = settings.get(\"regionanchorX\", 0);\r\n          region.regionAnchorY = settings.get(\"regionanchorY\", 100);\r\n          region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\r\n          region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\r\n          region.scroll = settings.get(\"scroll\", \"\"); // Register the region.\r\n\r\n          self.onregion && self.onregion(region); // Remember the VTTRegion for later in case we parse any VTTCues that\r\n          // reference it.\r\n\r\n          self.regionList.push({\r\n            id: settings.get(\"id\"),\r\n            region: region\r\n          });\r\n        }\r\n      } // draft-pantos-http-live-streaming-20\r\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\r\n      // 3.5 WebVTT\r\n\r\n\r\n      function parseTimestampMap(input) {\r\n        var settings = new Settings();\r\n        parseOptions(input, function (k, v) {\r\n          switch (k) {\r\n            case \"MPEGT\":\r\n              settings.integer(k + 'S', v);\r\n              break;\r\n\r\n            case \"LOCA\":\r\n              settings.set(k + 'L', parseTimeStamp(v));\r\n              break;\r\n          }\r\n        }, /[^\\d]:/, /,/);\r\n        self.ontimestampmap && self.ontimestampmap({\r\n          \"MPEGTS\": settings.get(\"MPEGTS\"),\r\n          \"LOCAL\": settings.get(\"LOCAL\")\r\n        });\r\n      } // 3.2 WebVTT metadata header syntax\r\n\r\n\r\n      function parseHeader(input) {\r\n        if (input.match(/X-TIMESTAMP-MAP/)) {\r\n          // This line contains HLS X-TIMESTAMP-MAP metadata\r\n          parseOptions(input, function (k, v) {\r\n            switch (k) {\r\n              case \"X-TIMESTAMP-MAP\":\r\n                parseTimestampMap(v);\r\n                break;\r\n            }\r\n          }, /=/);\r\n        } else {\r\n          parseOptions(input, function (k, v) {\r\n            switch (k) {\r\n              case \"Region\":\r\n                // 3.3 WebVTT region metadata header syntax\r\n                parseRegion(v);\r\n                break;\r\n            }\r\n          }, /:/);\r\n        }\r\n      } // 5.1 WebVTT file parsing.\r\n\r\n\r\n      try {\r\n        var line;\r\n\r\n        if (self.state === \"INITIAL\") {\r\n          // We can't start parsing until we have the first line.\r\n          if (!/\\r\\n|\\n/.test(self.buffer)) {\r\n            return this;\r\n          }\r\n\r\n          line = collectNextLine();\r\n          var m = line.match(/^WEBVTT([ \\t].*)?$/);\r\n\r\n          if (!m || !m[0]) {\r\n            throw new ParsingError(ParsingError.Errors.BadSignature);\r\n          }\r\n\r\n          self.state = \"HEADER\";\r\n        }\r\n\r\n        var alreadyCollectedLine = false;\r\n\r\n        while (self.buffer) {\r\n          // We can't parse a line until we have the full line.\r\n          if (!/\\r\\n|\\n/.test(self.buffer)) {\r\n            return this;\r\n          }\r\n\r\n          if (!alreadyCollectedLine) {\r\n            line = collectNextLine();\r\n          } else {\r\n            alreadyCollectedLine = false;\r\n          }\r\n\r\n          switch (self.state) {\r\n            case \"HEADER\":\r\n              // 13-18 - Allow a header (metadata) under the WEBVTT line.\r\n              if (/:/.test(line)) {\r\n                parseHeader(line);\r\n              } else if (!line) {\r\n                // An empty line terminates the header and starts the body (cues).\r\n                self.state = \"ID\";\r\n              }\r\n\r\n              continue;\r\n\r\n            case \"NOTE\":\r\n              // Ignore NOTE blocks.\r\n              if (!line) {\r\n                self.state = \"ID\";\r\n              }\r\n\r\n              continue;\r\n\r\n            case \"ID\":\r\n              // Check for the start of NOTE blocks.\r\n              if (/^NOTE($|[ \\t])/.test(line)) {\r\n                self.state = \"NOTE\";\r\n                break;\r\n              } // 19-29 - Allow any number of line terminators, then initialize new cue values.\r\n\r\n\r\n              if (!line) {\r\n                continue;\r\n              }\r\n\r\n              self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\"); // Safari still uses the old middle value and won't accept center\r\n\r\n              try {\r\n                self.cue.align = \"center\";\r\n              } catch (e) {\r\n                self.cue.align = \"middle\";\r\n              }\r\n\r\n              self.state = \"CUE\"; // 30-39 - Check if self line contains an optional identifier or timing data.\r\n\r\n              if (line.indexOf(\"-->\") === -1) {\r\n                self.cue.id = line;\r\n                continue;\r\n              }\r\n\r\n            // Process line as start of a cue.\r\n\r\n            /*falls through*/\r\n\r\n            case \"CUE\":\r\n              // 40 - Collect cue timings and settings.\r\n              try {\r\n                parseCue(line, self.cue, self.regionList);\r\n              } catch (e) {\r\n                self.reportOrThrowError(e); // In case of an error ignore rest of the cue.\r\n\r\n                self.cue = null;\r\n                self.state = \"BADCUE\";\r\n                continue;\r\n              }\r\n\r\n              self.state = \"CUETEXT\";\r\n              continue;\r\n\r\n            case \"CUETEXT\":\r\n              var hasSubstring = line.indexOf(\"-->\") !== -1; // 34 - If we have an empty line then report the cue.\r\n              // 35 - If we have the special substring '-->' then report the cue,\r\n              // but do not collect the line as we need to process the current\r\n              // one as a new cue.\r\n\r\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\r\n                // We are done parsing self cue.\r\n                self.oncue && self.oncue(self.cue);\r\n                self.cue = null;\r\n                self.state = \"ID\";\r\n                continue;\r\n              }\r\n\r\n              if (self.cue.text) {\r\n                self.cue.text += \"\\n\";\r\n              }\r\n\r\n              self.cue.text += line.replace(/\\u2028/g, '\\n').replace(/u2029/g, '\\n');\r\n              continue;\r\n\r\n            case \"BADCUE\":\r\n              // BADCUE\r\n              // 54-62 - Collect and discard the remaining cue.\r\n              if (!line) {\r\n                self.state = \"ID\";\r\n              }\r\n\r\n              continue;\r\n          }\r\n        }\r\n      } catch (e) {\r\n        self.reportOrThrowError(e); // If we are currently parsing a cue, report what we have.\r\n\r\n        if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\r\n          self.oncue(self.cue);\r\n        }\r\n\r\n        self.cue = null; // Enter BADWEBVTT state if header was not parsed correctly otherwise\r\n        // another exception occurred so enter BADCUE state.\r\n\r\n        self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\r\n      }\r\n\r\n      return this;\r\n    },\r\n    flush: function flush() {\r\n      var self = this;\r\n\r\n      try {\r\n        // Finish decoding the stream.\r\n        self.buffer += self.decoder.decode(); // Synthesize the end of the current cue or region.\r\n\r\n        if (self.cue || self.state === \"HEADER\") {\r\n          self.buffer += \"\\n\\n\";\r\n          self.parse();\r\n        } // If we've flushed, parsed, and we're still on the INITIAL state then\r\n        // that means we don't have enough of the stream to parse the first\r\n        // line.\r\n\r\n\r\n        if (self.state === \"INITIAL\") {\r\n          throw new ParsingError(ParsingError.Errors.BadSignature);\r\n        }\r\n      } catch (e) {\r\n        self.reportOrThrowError(e);\r\n      }\r\n\r\n      self.onflush && self.onflush();\r\n      return this;\r\n    }\r\n  };\r\n  var vtt = WebVTT$1;\r\n\r\n  /**\r\n   * Copyright 2013 vtt.js Contributors\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *   http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n  var autoKeyword = \"auto\";\r\n  var directionSetting = {\r\n    \"\": 1,\r\n    \"lr\": 1,\r\n    \"rl\": 1\r\n  };\r\n  var alignSetting = {\r\n    \"start\": 1,\r\n    \"center\": 1,\r\n    \"end\": 1,\r\n    \"left\": 1,\r\n    \"right\": 1,\r\n    \"auto\": 1,\r\n    \"line-left\": 1,\r\n    \"line-right\": 1\r\n  };\r\n\r\n  function findDirectionSetting(value) {\r\n    if (typeof value !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    var dir = directionSetting[value.toLowerCase()];\r\n    return dir ? value.toLowerCase() : false;\r\n  }\r\n\r\n  function findAlignSetting(value) {\r\n    if (typeof value !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    var align = alignSetting[value.toLowerCase()];\r\n    return align ? value.toLowerCase() : false;\r\n  }\r\n\r\n  function VTTCue(startTime, endTime, text) {\r\n    /**\r\n     * Shim implementation specific properties. These properties are not in\r\n     * the spec.\r\n     */\r\n    // Lets us know when the VTTCue's data has changed in such a way that we need\r\n    // to recompute its display state. This lets us compute its display state\r\n    // lazily.\r\n    this.hasBeenReset = false;\r\n    /**\r\n     * VTTCue and TextTrackCue properties\r\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\r\n     */\r\n\r\n    var _id = \"\";\r\n    var _pauseOnExit = false;\r\n    var _startTime = startTime;\r\n    var _endTime = endTime;\r\n    var _text = text;\r\n    var _region = null;\r\n    var _vertical = \"\";\r\n    var _snapToLines = true;\r\n    var _line = \"auto\";\r\n    var _lineAlign = \"start\";\r\n    var _position = \"auto\";\r\n    var _positionAlign = \"auto\";\r\n    var _size = 100;\r\n    var _align = \"center\";\r\n    Object.defineProperties(this, {\r\n      \"id\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _id;\r\n        },\r\n        set: function set(value) {\r\n          _id = \"\" + value;\r\n        }\r\n      },\r\n      \"pauseOnExit\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _pauseOnExit;\r\n        },\r\n        set: function set(value) {\r\n          _pauseOnExit = !!value;\r\n        }\r\n      },\r\n      \"startTime\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _startTime;\r\n        },\r\n        set: function set(value) {\r\n          if (typeof value !== \"number\") {\r\n            throw new TypeError(\"Start time must be set to a number.\");\r\n          }\r\n\r\n          _startTime = value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"endTime\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _endTime;\r\n        },\r\n        set: function set(value) {\r\n          if (typeof value !== \"number\") {\r\n            throw new TypeError(\"End time must be set to a number.\");\r\n          }\r\n\r\n          _endTime = value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"text\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _text;\r\n        },\r\n        set: function set(value) {\r\n          _text = \"\" + value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"region\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _region;\r\n        },\r\n        set: function set(value) {\r\n          _region = value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"vertical\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _vertical;\r\n        },\r\n        set: function set(value) {\r\n          var setting = findDirectionSetting(value); // Have to check for false because the setting an be an empty string.\r\n\r\n          if (setting === false) {\r\n            throw new SyntaxError(\"Vertical: an invalid or illegal direction string was specified.\");\r\n          }\r\n\r\n          _vertical = setting;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"snapToLines\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _snapToLines;\r\n        },\r\n        set: function set(value) {\r\n          _snapToLines = !!value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"line\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _line;\r\n        },\r\n        set: function set(value) {\r\n          if (typeof value !== \"number\" && value !== autoKeyword) {\r\n            throw new SyntaxError(\"Line: an invalid number or illegal string was specified.\");\r\n          }\r\n\r\n          _line = value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"lineAlign\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _lineAlign;\r\n        },\r\n        set: function set(value) {\r\n          var setting = findAlignSetting(value);\r\n\r\n          if (!setting) {\r\n            console.warn(\"lineAlign: an invalid or illegal string was specified.\");\r\n          } else {\r\n            _lineAlign = setting;\r\n            this.hasBeenReset = true;\r\n          }\r\n        }\r\n      },\r\n      \"position\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _position;\r\n        },\r\n        set: function set(value) {\r\n          if (value < 0 || value > 100) {\r\n            throw new Error(\"Position must be between 0 and 100.\");\r\n          }\r\n\r\n          _position = value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"positionAlign\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _positionAlign;\r\n        },\r\n        set: function set(value) {\r\n          var setting = findAlignSetting(value);\r\n\r\n          if (!setting) {\r\n            console.warn(\"positionAlign: an invalid or illegal string was specified.\");\r\n          } else {\r\n            _positionAlign = setting;\r\n            this.hasBeenReset = true;\r\n          }\r\n        }\r\n      },\r\n      \"size\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _size;\r\n        },\r\n        set: function set(value) {\r\n          if (value < 0 || value > 100) {\r\n            throw new Error(\"Size must be between 0 and 100.\");\r\n          }\r\n\r\n          _size = value;\r\n          this.hasBeenReset = true;\r\n        }\r\n      },\r\n      \"align\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _align;\r\n        },\r\n        set: function set(value) {\r\n          var setting = findAlignSetting(value);\r\n\r\n          if (!setting) {\r\n            throw new SyntaxError(\"align: an invalid or illegal alignment string was specified.\");\r\n          }\r\n\r\n          _align = setting;\r\n          this.hasBeenReset = true;\r\n        }\r\n      }\r\n    });\r\n    /**\r\n     * Other <track> spec defined properties\r\n     */\r\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\r\n\r\n    this.displayState = undefined;\r\n  }\r\n  /**\r\n   * VTTCue methods\r\n   */\r\n\r\n\r\n  VTTCue.prototype.getCueAsHTML = function () {\r\n    // Assume WebVTT.convertCueToDOMTree is on the global.\r\n    return WebVTT.convertCueToDOMTree(window, this.text);\r\n  };\r\n\r\n  var vttcue = VTTCue;\r\n\r\n  /**\r\n   * Copyright 2013 vtt.js Contributors\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *   http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n  var scrollSetting = {\r\n    \"\": true,\r\n    \"up\": true\r\n  };\r\n\r\n  function findScrollSetting(value) {\r\n    if (typeof value !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    var scroll = scrollSetting[value.toLowerCase()];\r\n    return scroll ? value.toLowerCase() : false;\r\n  }\r\n\r\n  function isValidPercentValue(value) {\r\n    return typeof value === \"number\" && value >= 0 && value <= 100;\r\n  } // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\r\n\r\n\r\n  function VTTRegion() {\r\n    var _width = 100;\r\n    var _lines = 3;\r\n    var _regionAnchorX = 0;\r\n    var _regionAnchorY = 100;\r\n    var _viewportAnchorX = 0;\r\n    var _viewportAnchorY = 100;\r\n    var _scroll = \"\";\r\n    Object.defineProperties(this, {\r\n      \"width\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _width;\r\n        },\r\n        set: function set(value) {\r\n          if (!isValidPercentValue(value)) {\r\n            throw new Error(\"Width must be between 0 and 100.\");\r\n          }\r\n\r\n          _width = value;\r\n        }\r\n      },\r\n      \"lines\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _lines;\r\n        },\r\n        set: function set(value) {\r\n          if (typeof value !== \"number\") {\r\n            throw new TypeError(\"Lines must be set to a number.\");\r\n          }\r\n\r\n          _lines = value;\r\n        }\r\n      },\r\n      \"regionAnchorY\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _regionAnchorY;\r\n        },\r\n        set: function set(value) {\r\n          if (!isValidPercentValue(value)) {\r\n            throw new Error(\"RegionAnchorX must be between 0 and 100.\");\r\n          }\r\n\r\n          _regionAnchorY = value;\r\n        }\r\n      },\r\n      \"regionAnchorX\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _regionAnchorX;\r\n        },\r\n        set: function set(value) {\r\n          if (!isValidPercentValue(value)) {\r\n            throw new Error(\"RegionAnchorY must be between 0 and 100.\");\r\n          }\r\n\r\n          _regionAnchorX = value;\r\n        }\r\n      },\r\n      \"viewportAnchorY\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _viewportAnchorY;\r\n        },\r\n        set: function set(value) {\r\n          if (!isValidPercentValue(value)) {\r\n            throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\r\n          }\r\n\r\n          _viewportAnchorY = value;\r\n        }\r\n      },\r\n      \"viewportAnchorX\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _viewportAnchorX;\r\n        },\r\n        set: function set(value) {\r\n          if (!isValidPercentValue(value)) {\r\n            throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\r\n          }\r\n\r\n          _viewportAnchorX = value;\r\n        }\r\n      },\r\n      \"scroll\": {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return _scroll;\r\n        },\r\n        set: function set(value) {\r\n          var setting = findScrollSetting(value); // Have to check for false as an empty string is a legal value.\r\n\r\n          if (setting === false) {\r\n            console.warn(\"Scroll: an invalid or illegal string was specified.\");\r\n          } else {\r\n            _scroll = setting;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  var vttregion = VTTRegion;\r\n\r\n  var browserIndex = createCommonjsModule(function (module) {\r\n    /**\r\n     * Copyright 2013 vtt.js Contributors\r\n     *\r\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n     * you may not use this file except in compliance with the License.\r\n     * You may obtain a copy of the License at\r\n     *\r\n     *   http://www.apache.org/licenses/LICENSE-2.0\r\n     *\r\n     * Unless required by applicable law or agreed to in writing, software\r\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n     * See the License for the specific language governing permissions and\r\n     * limitations under the License.\r\n     */\r\n    // Default exports for Node. Export the extended versions of VTTCue and\r\n    // VTTRegion in Node since we likely want the capability to convert back and\r\n    // forth between JSON. If we don't then it's not that big of a deal since we're\r\n    // off browser.\r\n    var vttjs = module.exports = {\r\n      WebVTT: vtt,\r\n      VTTCue: vttcue,\r\n      VTTRegion: vttregion\r\n    };\r\n    window_1.vttjs = vttjs;\r\n    window_1.WebVTT = vttjs.WebVTT;\r\n    var cueShim = vttjs.VTTCue;\r\n    var regionShim = vttjs.VTTRegion;\r\n    var nativeVTTCue = window_1.VTTCue;\r\n    var nativeVTTRegion = window_1.VTTRegion;\r\n\r\n    vttjs.shim = function () {\r\n      window_1.VTTCue = cueShim;\r\n      window_1.VTTRegion = regionShim;\r\n    };\r\n\r\n    vttjs.restore = function () {\r\n      window_1.VTTCue = nativeVTTCue;\r\n      window_1.VTTRegion = nativeVTTRegion;\r\n    };\r\n\r\n    if (!window_1.VTTCue) {\r\n      vttjs.shim();\r\n    }\r\n  });\r\n  browserIndex.WebVTT;\r\n  browserIndex.VTTCue;\r\n  browserIndex.VTTRegion;\r\n\r\n  /**\r\n   * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\r\n   * that just contains the src url alone.\r\n   * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\r\n     * `var SourceString = 'http://example.com/some-video.mp4';`\r\n   *\r\n   * @typedef {Object|string} Tech~SourceObject\r\n   *\r\n   * @property {string} src\r\n   *           The url to the source\r\n   *\r\n   * @property {string} type\r\n   *           The mime type of the source\r\n   */\r\n\r\n  /**\r\n   * A function used by {@link Tech} to create a new {@link TextTrack}.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Tech} self\r\n   *        An instance of the Tech class.\r\n   *\r\n   * @param {string} kind\r\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\r\n   *\r\n   * @param {string} [label]\r\n   *        Label to identify the text track\r\n   *\r\n   * @param {string} [language]\r\n   *        Two letter language abbreviation\r\n   *\r\n   * @param {Object} [options={}]\r\n   *        An object with additional text track options\r\n   *\r\n   * @return {TextTrack}\r\n   *          The text track that was created.\r\n   */\r\n\r\n  function createTrackHelper(self, kind, label, language, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var tracks = self.textTracks();\r\n    options.kind = kind;\r\n\r\n    if (label) {\r\n      options.label = label;\r\n    }\r\n\r\n    if (language) {\r\n      options.language = language;\r\n    }\r\n\r\n    options.tech = self;\r\n    var track = new ALL.text.TrackClass(options);\r\n    tracks.addTrack(track);\r\n    return track;\r\n  }\r\n  /**\r\n   * This is the base class for media playback technology controllers, such as\r\n   * {@link HTML5}\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n\r\n  var Tech = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(Tech, _Component);\r\n\r\n    /**\r\n    * Create an instance of this Tech.\r\n    *\r\n    * @param {Object} [options]\r\n    *        The key/value store of player options.\r\n    *\r\n    * @param {Component~ReadyCallback} ready\r\n    *        Callback function to call when the `HTML5` Tech is ready.\r\n    */\r\n    function Tech(options, ready) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      if (ready === void 0) {\r\n        ready = function ready() {};\r\n      }\r\n\r\n      // we don't want the tech to report user activity automatically.\r\n      // This is done manually in addControlsListeners\r\n      options.reportTouchActivity = false;\r\n      _this = _Component.call(this, null, options, ready) || this;\r\n\r\n      _this.onDurationChange_ = function (e) {\r\n        return _this.onDurationChange(e);\r\n      };\r\n\r\n      _this.trackProgress_ = function (e) {\r\n        return _this.trackProgress(e);\r\n      };\r\n\r\n      _this.trackCurrentTime_ = function (e) {\r\n        return _this.trackCurrentTime(e);\r\n      };\r\n\r\n      _this.stopTrackingCurrentTime_ = function (e) {\r\n        return _this.stopTrackingCurrentTime(e);\r\n      };\r\n\r\n      _this.disposeSourceHandler_ = function (e) {\r\n        return _this.disposeSourceHandler(e);\r\n      };\r\n\r\n      _this.queuedHanders_ = new Set(); // keep track of whether the current source has played at all to\r\n      // implement a very limited played()\r\n\r\n      _this.hasStarted_ = false;\r\n\r\n      _this.on('playing', function () {\r\n        this.hasStarted_ = true;\r\n      });\r\n\r\n      _this.on('loadstart', function () {\r\n        this.hasStarted_ = false;\r\n      });\r\n\r\n      ALL.names.forEach(function (name) {\r\n        var props = ALL[name];\r\n\r\n        if (options && options[props.getterName]) {\r\n          _this[props.privateName] = options[props.getterName];\r\n        }\r\n      }); // Manually track progress in cases where the browser/tech doesn't report it.\r\n\r\n      if (!_this.featuresProgressEvents) {\r\n        _this.manualProgressOn();\r\n      } // Manually track timeupdates in cases where the browser/tech doesn't report it.\r\n\r\n\r\n      if (!_this.featuresTimeupdateEvents) {\r\n        _this.manualTimeUpdatesOn();\r\n      }\r\n\r\n      ['Text', 'Audio', 'Video'].forEach(function (track) {\r\n        if (options[\"native\" + track + \"Tracks\"] === false) {\r\n          _this[\"featuresNative\" + track + \"Tracks\"] = false;\r\n        }\r\n      });\r\n\r\n      if (options.nativeCaptions === false || options.nativeTextTracks === false) {\r\n        _this.featuresNativeTextTracks = false;\r\n      } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\r\n        _this.featuresNativeTextTracks = true;\r\n      }\r\n\r\n      if (!_this.featuresNativeTextTracks) {\r\n        _this.emulateTextTracks();\r\n      }\r\n\r\n      _this.preloadTextTracks = options.preloadTextTracks !== false;\r\n      _this.autoRemoteTextTracks_ = new ALL.text.ListClass();\r\n\r\n      _this.initTrackListeners(); // Turn on component tap events only if not using native controls\r\n\r\n\r\n      if (!options.nativeControlsForTouch) {\r\n        _this.emitTapEvents();\r\n      }\r\n\r\n      if (_this.constructor) {\r\n        _this.name_ = _this.constructor.name || 'Unknown Tech';\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * A special function to trigger source set in a way that will allow player\r\n     * to re-trigger if the player or tech are not ready yet.\r\n     *\r\n     * @fires Tech#sourceset\r\n     * @param {string} src The source string at the time of the source changing.\r\n     */\r\n\r\n\r\n    var _proto = Tech.prototype;\r\n\r\n    _proto.triggerSourceset = function triggerSourceset(src) {\r\n      var _this2 = this;\r\n\r\n      if (!this.isReady_) {\r\n        // on initial ready we have to trigger source set\r\n        // 1ms after ready so that player can watch for it.\r\n        this.one('ready', function () {\r\n          return _this2.setTimeout(function () {\r\n            return _this2.triggerSourceset(src);\r\n          }, 1);\r\n        });\r\n      }\r\n      /**\r\n       * Fired when the source is set on the tech causing the media element\r\n       * to reload.\r\n       *\r\n       * @see {@link Player#event:sourceset}\r\n       * @event Tech#sourceset\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n\r\n      this.trigger({\r\n        src: src,\r\n        type: 'sourceset'\r\n      });\r\n    }\r\n    /* Fallbacks for unsupported event types\r\n    ================================================================================ */\r\n\r\n    /**\r\n     * Polyfill the `progress` event for browsers that don't support it natively.\r\n     *\r\n     * @see {@link Tech#trackProgress}\r\n     */\r\n    ;\r\n\r\n    _proto.manualProgressOn = function manualProgressOn() {\r\n      this.on('durationchange', this.onDurationChange_);\r\n      this.manualProgress = true; // Trigger progress watching when a source begins loading\r\n\r\n      this.one('ready', this.trackProgress_);\r\n    }\r\n    /**\r\n     * Turn off the polyfill for `progress` events that was created in\r\n     * {@link Tech#manualProgressOn}\r\n     */\r\n    ;\r\n\r\n    _proto.manualProgressOff = function manualProgressOff() {\r\n      this.manualProgress = false;\r\n      this.stopTrackingProgress();\r\n      this.off('durationchange', this.onDurationChange_);\r\n    }\r\n    /**\r\n     * This is used to trigger a `progress` event when the buffered percent changes. It\r\n     * sets an interval function that will be called every 500 milliseconds to check if the\r\n     * buffer end percent has changed.\r\n     *\r\n     * > This function is called by {@link Tech#manualProgressOn}\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `ready` event that caused this to run.\r\n     *\r\n     * @listens Tech#ready\r\n     * @fires Tech#progress\r\n     */\r\n    ;\r\n\r\n    _proto.trackProgress = function trackProgress(event) {\r\n      this.stopTrackingProgress();\r\n      this.progressInterval = this.setInterval(bind(this, function () {\r\n        // Don't trigger unless buffered amount is greater than last time\r\n        var numBufferedPercent = this.bufferedPercent();\r\n\r\n        if (this.bufferedPercent_ !== numBufferedPercent) {\r\n          /**\r\n           * See {@link Player#progress}\r\n           *\r\n           * @event Tech#progress\r\n           * @type {EventTarget~Event}\r\n           */\r\n          this.trigger('progress');\r\n        }\r\n\r\n        this.bufferedPercent_ = numBufferedPercent;\r\n\r\n        if (numBufferedPercent === 1) {\r\n          this.stopTrackingProgress();\r\n        }\r\n      }), 500);\r\n    }\r\n    /**\r\n     * Update our internal duration on a `durationchange` event by calling\r\n     * {@link Tech#duration}.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `durationchange` event that caused this to run.\r\n     *\r\n     * @listens Tech#durationchange\r\n     */\r\n    ;\r\n\r\n    _proto.onDurationChange = function onDurationChange(event) {\r\n      this.duration_ = this.duration();\r\n    }\r\n    /**\r\n     * Get and create a `TimeRange` object for buffering.\r\n     *\r\n     * @return {TimeRange}\r\n     *         The time range object that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.buffered = function buffered() {\r\n      return createTimeRanges(0, 0);\r\n    }\r\n    /**\r\n     * Get the percentage of the current video that is currently buffered.\r\n     *\r\n     * @return {number}\r\n     *         A number from 0 to 1 that represents the decimal percentage of the\r\n     *         video that is buffered.\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.bufferedPercent = function bufferedPercent$1() {\r\n      return bufferedPercent(this.buffered(), this.duration_);\r\n    }\r\n    /**\r\n     * Turn off the polyfill for `progress` events that was created in\r\n     * {@link Tech#manualProgressOn}\r\n     * Stop manually tracking progress events by clearing the interval that was set in\r\n     * {@link Tech#trackProgress}.\r\n     */\r\n    ;\r\n\r\n    _proto.stopTrackingProgress = function stopTrackingProgress() {\r\n      this.clearInterval(this.progressInterval);\r\n    }\r\n    /**\r\n     * Polyfill the `timeupdate` event for browsers that don't support it.\r\n     *\r\n     * @see {@link Tech#trackCurrentTime}\r\n     */\r\n    ;\r\n\r\n    _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\r\n      this.manualTimeUpdates = true;\r\n      this.on('play', this.trackCurrentTime_);\r\n      this.on('pause', this.stopTrackingCurrentTime_);\r\n    }\r\n    /**\r\n     * Turn off the polyfill for `timeupdate` events that was created in\r\n     * {@link Tech#manualTimeUpdatesOn}\r\n     */\r\n    ;\r\n\r\n    _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\r\n      this.manualTimeUpdates = false;\r\n      this.stopTrackingCurrentTime();\r\n      this.off('play', this.trackCurrentTime_);\r\n      this.off('pause', this.stopTrackingCurrentTime_);\r\n    }\r\n    /**\r\n     * Sets up an interval function to track current time and trigger `timeupdate` every\r\n     * 250 milliseconds.\r\n     *\r\n     * @listens Tech#play\r\n     * @triggers Tech#timeupdate\r\n     */\r\n    ;\r\n\r\n    _proto.trackCurrentTime = function trackCurrentTime() {\r\n      if (this.currentTimeInterval) {\r\n        this.stopTrackingCurrentTime();\r\n      }\r\n\r\n      this.currentTimeInterval = this.setInterval(function () {\r\n        /**\r\n         * Triggered at an interval of 250ms to indicated that time is passing in the video.\r\n         *\r\n         * @event Tech#timeupdate\r\n         * @type {EventTarget~Event}\r\n         */\r\n        this.trigger({\r\n          type: 'timeupdate',\r\n          target: this,\r\n          manuallyTriggered: true\r\n        }); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\r\n      }, 250);\r\n    }\r\n    /**\r\n     * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\r\n     * `timeupdate` event is no longer triggered.\r\n     *\r\n     * @listens {Tech#pause}\r\n     */\r\n    ;\r\n\r\n    _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\r\n      this.clearInterval(this.currentTimeInterval); // #1002 - if the video ends right before the next timeupdate would happen,\r\n      // the progress bar won't make it all the way to the end\r\n\r\n      this.trigger({\r\n        type: 'timeupdate',\r\n        target: this,\r\n        manuallyTriggered: true\r\n      });\r\n    }\r\n    /**\r\n     * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\r\n     * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\r\n     *\r\n     * @fires Component#dispose\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      // clear out all tracks because we can't reuse them between techs\r\n      this.clearTracks(NORMAL.names); // Turn off any manual progress or timeupdate tracking\r\n\r\n      if (this.manualProgress) {\r\n        this.manualProgressOff();\r\n      }\r\n\r\n      if (this.manualTimeUpdates) {\r\n        this.manualTimeUpdatesOff();\r\n      }\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Clear out a single `TrackList` or an array of `TrackLists` given their names.\r\n     *\r\n     * > Note: Techs without source handlers should call this between sources for `video`\r\n     *         & `audio` tracks. You don't want to use them between tracks!\r\n     *\r\n     * @param {string[]|string} types\r\n     *        TrackList names to clear, valid names are `video`, `audio`, and\r\n     *        `text`.\r\n     */\r\n    ;\r\n\r\n    _proto.clearTracks = function clearTracks(types) {\r\n      var _this3 = this;\r\n\r\n      types = [].concat(types); // clear out all tracks because we can't reuse them between techs\r\n\r\n      types.forEach(function (type) {\r\n        var list = _this3[type + \"Tracks\"]() || [];\r\n        var i = list.length;\r\n\r\n        while (i--) {\r\n          var track = list[i];\r\n\r\n          if (type === 'text') {\r\n            _this3.removeRemoteTextTrack(track);\r\n          }\r\n\r\n          list.removeTrack(track);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Remove any TextTracks added via addRemoteTextTrack that are\r\n     * flagged for automatic garbage collection\r\n     */\r\n    ;\r\n\r\n    _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {\r\n      var list = this.autoRemoteTextTracks_ || [];\r\n      var i = list.length;\r\n\r\n      while (i--) {\r\n        var track = list[i];\r\n        this.removeRemoteTextTrack(track);\r\n      }\r\n    }\r\n    /**\r\n     * Reset the tech, which will removes all sources and reset the internal readyState.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.reset = function reset() {}\r\n    /**\r\n     * Get the value of `crossOrigin` from the tech.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @see {Html5#crossOrigin}\r\n     */\r\n    ;\r\n\r\n    _proto.crossOrigin = function crossOrigin() {}\r\n    /**\r\n     * Set the value of `crossOrigin` on the tech.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @param {string} crossOrigin the crossOrigin value\r\n     * @see {Html5#setCrossOrigin}\r\n     */\r\n    ;\r\n\r\n    _proto.setCrossOrigin = function setCrossOrigin() {}\r\n    /**\r\n     * Get or set an error on the Tech.\r\n     *\r\n     * @param {MediaError} [err]\r\n     *        Error to set on the Tech\r\n     *\r\n     * @return {MediaError|null}\r\n     *         The current error object on the tech, or null if there isn't one.\r\n     */\r\n    ;\r\n\r\n    _proto.error = function error(err) {\r\n      if (err !== undefined) {\r\n        this.error_ = new MediaError(err);\r\n        this.trigger('error');\r\n      }\r\n\r\n      return this.error_;\r\n    }\r\n    /**\r\n     * Returns the `TimeRange`s that have been played through for the current source.\r\n     *\r\n     * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\r\n     *         It only checks whether the source has played at all or not.\r\n     *\r\n     * @return {TimeRange}\r\n     *         - A single time range if this video has played\r\n     *         - An empty set of ranges if not.\r\n     */\r\n    ;\r\n\r\n    _proto.played = function played() {\r\n      if (this.hasStarted_) {\r\n        return createTimeRanges(0, 0);\r\n      }\r\n\r\n      return createTimeRanges();\r\n    }\r\n    /**\r\n     * Start playback\r\n     *\r\n     * @abstract\r\n     *\r\n     * @see {Html5#play}\r\n     */\r\n    ;\r\n\r\n    _proto.play = function play() {}\r\n    /**\r\n     * Set whether we are scrubbing or not\r\n     *\r\n     * @abstract\r\n     *\r\n     * @see {Html5#setScrubbing}\r\n     */\r\n    ;\r\n\r\n    _proto.setScrubbing = function setScrubbing() {}\r\n    /**\r\n     * Get whether we are scrubbing or not\r\n     *\r\n     * @abstract\r\n     *\r\n     * @see {Html5#scrubbing}\r\n     */\r\n    ;\r\n\r\n    _proto.scrubbing = function scrubbing() {}\r\n    /**\r\n     * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\r\n     * previously called.\r\n     *\r\n     * @fires Tech#timeupdate\r\n     */\r\n    ;\r\n\r\n    _proto.setCurrentTime = function setCurrentTime() {\r\n      // improve the accuracy of manual timeupdates\r\n      if (this.manualTimeUpdates) {\r\n        /**\r\n         * A manual `timeupdate` event.\r\n         *\r\n         * @event Tech#timeupdate\r\n         * @type {EventTarget~Event}\r\n         */\r\n        this.trigger({\r\n          type: 'timeupdate',\r\n          target: this,\r\n          manuallyTriggered: true\r\n        });\r\n      }\r\n    }\r\n    /**\r\n     * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\r\n     * {@link TextTrackList} events.\r\n     *\r\n     * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\r\n     *\r\n     * @fires Tech#audiotrackchange\r\n     * @fires Tech#videotrackchange\r\n     * @fires Tech#texttrackchange\r\n     */\r\n    ;\r\n\r\n    _proto.initTrackListeners = function initTrackListeners() {\r\n      var _this4 = this;\r\n\r\n      /**\r\n        * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\r\n        *\r\n        * @event Tech#audiotrackchange\r\n        * @type {EventTarget~Event}\r\n        */\r\n\r\n      /**\r\n        * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\r\n        *\r\n        * @event Tech#videotrackchange\r\n        * @type {EventTarget~Event}\r\n        */\r\n\r\n      /**\r\n        * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\r\n        *\r\n        * @event Tech#texttrackchange\r\n        * @type {EventTarget~Event}\r\n        */\r\n      NORMAL.names.forEach(function (name) {\r\n        var props = NORMAL[name];\r\n\r\n        var trackListChanges = function trackListChanges() {\r\n          _this4.trigger(name + \"trackchange\");\r\n        };\r\n\r\n        var tracks = _this4[props.getterName]();\r\n\r\n        tracks.addEventListener('removetrack', trackListChanges);\r\n        tracks.addEventListener('addtrack', trackListChanges);\r\n\r\n        _this4.on('dispose', function () {\r\n          tracks.removeEventListener('removetrack', trackListChanges);\r\n          tracks.removeEventListener('addtrack', trackListChanges);\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Emulate TextTracks using vtt.js if necessary\r\n     *\r\n     * @fires Tech#vttjsloaded\r\n     * @fires Tech#vttjserror\r\n     */\r\n    ;\r\n\r\n    _proto.addWebVttScript_ = function addWebVttScript_() {\r\n      var _this5 = this;\r\n\r\n      if (window.WebVTT) {\r\n        return;\r\n      } // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\r\n      // signals that the Tech is ready at which point Tech.el_ is part of the DOM\r\n      // before inserting the WebVTT script\r\n\r\n\r\n      if (document.body.contains(this.el())) {\r\n        // load via require if available and vtt.js script location was not passed in\r\n        // as an option. novtt builds will turn the above require call into an empty object\r\n        // which will cause this if check to always fail.\r\n        if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {\r\n          this.trigger('vttjsloaded');\r\n          return;\r\n        } // load vtt.js via the script location option or the cdn of no location was\r\n        // passed in\r\n\r\n\r\n        var script = document.createElement('script');\r\n        script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';\r\n\r\n        script.onload = function () {\r\n          /**\r\n           * Fired when vtt.js is loaded.\r\n           *\r\n           * @event Tech#vttjsloaded\r\n           * @type {EventTarget~Event}\r\n           */\r\n          _this5.trigger('vttjsloaded');\r\n        };\r\n\r\n        script.onerror = function () {\r\n          /**\r\n           * Fired when vtt.js was not loaded due to an error\r\n           *\r\n           * @event Tech#vttjsloaded\r\n           * @type {EventTarget~Event}\r\n           */\r\n          _this5.trigger('vttjserror');\r\n        };\r\n\r\n        this.on('dispose', function () {\r\n          script.onload = null;\r\n          script.onerror = null;\r\n        }); // but have not loaded yet and we set it to true before the inject so that\r\n        // we don't overwrite the injected window.WebVTT if it loads right away\r\n\r\n        window.WebVTT = true;\r\n        this.el().parentNode.appendChild(script);\r\n      } else {\r\n        this.ready(this.addWebVttScript_);\r\n      }\r\n    }\r\n    /**\r\n     * Emulate texttracks\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.emulateTextTracks = function emulateTextTracks() {\r\n      var _this6 = this;\r\n\r\n      var tracks = this.textTracks();\r\n      var remoteTracks = this.remoteTextTracks();\r\n\r\n      var handleAddTrack = function handleAddTrack(e) {\r\n        return tracks.addTrack(e.track);\r\n      };\r\n\r\n      var handleRemoveTrack = function handleRemoveTrack(e) {\r\n        return tracks.removeTrack(e.track);\r\n      };\r\n\r\n      remoteTracks.on('addtrack', handleAddTrack);\r\n      remoteTracks.on('removetrack', handleRemoveTrack);\r\n      this.addWebVttScript_();\r\n\r\n      var updateDisplay = function updateDisplay() {\r\n        return _this6.trigger('texttrackchange');\r\n      };\r\n\r\n      var textTracksChanges = function textTracksChanges() {\r\n        updateDisplay();\r\n\r\n        for (var i = 0; i < tracks.length; i++) {\r\n          var track = tracks[i];\r\n          track.removeEventListener('cuechange', updateDisplay);\r\n\r\n          if (track.mode === 'showing') {\r\n            track.addEventListener('cuechange', updateDisplay);\r\n          }\r\n        }\r\n      };\r\n\r\n      textTracksChanges();\r\n      tracks.addEventListener('change', textTracksChanges);\r\n      tracks.addEventListener('addtrack', textTracksChanges);\r\n      tracks.addEventListener('removetrack', textTracksChanges);\r\n      this.on('dispose', function () {\r\n        remoteTracks.off('addtrack', handleAddTrack);\r\n        remoteTracks.off('removetrack', handleRemoveTrack);\r\n        tracks.removeEventListener('change', textTracksChanges);\r\n        tracks.removeEventListener('addtrack', textTracksChanges);\r\n        tracks.removeEventListener('removetrack', textTracksChanges);\r\n\r\n        for (var i = 0; i < tracks.length; i++) {\r\n          var track = tracks[i];\r\n          track.removeEventListener('cuechange', updateDisplay);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Create and returns a remote {@link TextTrack} object.\r\n     *\r\n     * @param {string} kind\r\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\r\n     *\r\n     * @param {string} [label]\r\n     *        Label to identify the text track\r\n     *\r\n     * @param {string} [language]\r\n     *        Two letter language abbreviation\r\n     *\r\n     * @return {TextTrack}\r\n     *         The TextTrack that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.addTextTrack = function addTextTrack(kind, label, language) {\r\n      if (!kind) {\r\n        throw new Error('TextTrack kind is required but was not provided');\r\n      }\r\n\r\n      return createTrackHelper(this, kind, label, language);\r\n    }\r\n    /**\r\n     * Create an emulated TextTrack for use by addRemoteTextTrack\r\n     *\r\n     * This is intended to be overridden by classes that inherit from\r\n     * Tech in order to create native or custom TextTracks.\r\n     *\r\n     * @param {Object} options\r\n     *        The object should contain the options to initialize the TextTrack with.\r\n     *\r\n     * @param {string} [options.kind]\r\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\r\n     *\r\n     * @param {string} [options.label].\r\n     *        Label to identify the text track\r\n     *\r\n     * @param {string} [options.language]\r\n     *        Two letter language abbreviation.\r\n     *\r\n     * @return {HTMLTrackElement}\r\n     *         The track element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {\r\n      var track = mergeOptions$3(options, {\r\n        tech: this\r\n      });\r\n      return new REMOTE.remoteTextEl.TrackClass(track);\r\n    }\r\n    /**\r\n     * Creates a remote text track object and returns an html track element.\r\n     *\r\n     * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\r\n     *\r\n     * @param {Object} options\r\n     *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\r\n     *\r\n     * @param {boolean} [manualCleanup=true]\r\n     *        - When false: the TextTrack will be automatically removed from the video\r\n     *          element whenever the source changes\r\n     *        - When True: The TextTrack will have to be cleaned up manually\r\n     *\r\n     * @return {HTMLTrackElement}\r\n     *         An Html Track Element.\r\n     *\r\n     * @deprecated The default functionality for this function will be equivalent\r\n     *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\r\n     *             also be removed.\r\n     */\r\n    ;\r\n\r\n    _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\r\n      var _this7 = this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var htmlTrackElement = this.createRemoteTextTrack(options);\r\n\r\n      if (manualCleanup !== true && manualCleanup !== false) {\r\n        // deprecation warning\r\n        log$1.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');\r\n        manualCleanup = true;\r\n      } // store HTMLTrackElement and TextTrack to remote list\r\n\r\n\r\n      this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\r\n      this.remoteTextTracks().addTrack(htmlTrackElement.track);\r\n\r\n      if (manualCleanup !== true) {\r\n        // create the TextTrackList if it doesn't exist\r\n        this.ready(function () {\r\n          return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);\r\n        });\r\n      }\r\n\r\n      return htmlTrackElement;\r\n    }\r\n    /**\r\n     * Remove a remote text track from the remote `TextTrackList`.\r\n     *\r\n     * @param {TextTrack} track\r\n     *        `TextTrack` to remove from the `TextTrackList`\r\n     */\r\n    ;\r\n\r\n    _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\r\n      var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track); // remove HTMLTrackElement and TextTrack from remote list\r\n\r\n      this.remoteTextTrackEls().removeTrackElement_(trackElement);\r\n      this.remoteTextTracks().removeTrack(track);\r\n      this.autoRemoteTextTracks_.removeTrack(track);\r\n    }\r\n    /**\r\n     * Gets available media playback quality metrics as specified by the W3C's Media\r\n     * Playback Quality API.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\r\n     *\r\n     * @return {Object}\r\n     *         An object with supported media playback quality metrics\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\r\n      return {};\r\n    }\r\n    /**\r\n     * Attempt to create a floating video window always on top of other windows\r\n     * so that users may continue consuming media while they interact with other\r\n     * content sites, or applications on their device.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\r\n     *\r\n     * @return {Promise|undefined}\r\n     *         A promise with a Picture-in-Picture window if the browser supports\r\n     *         Promises (or one was passed in as an option). It returns undefined\r\n     *         otherwise.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.requestPictureInPicture = function requestPictureInPicture() {\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (PromiseClass) {\r\n        return PromiseClass.reject();\r\n      }\r\n    }\r\n    /**\r\n     * A method to check for the value of the 'disablePictureInPicture' <video> property.\r\n     * Defaults to true, as it should be considered disabled if the tech does not support pip\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.disablePictureInPicture = function disablePictureInPicture() {\r\n      return true;\r\n    }\r\n    /**\r\n     * A method to set or unset the 'disablePictureInPicture' <video> property.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {}\r\n    /**\r\n     * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame\r\n     *\r\n     * @param {function} cb\r\n     * @return {number} request id\r\n     */\r\n    ;\r\n\r\n    _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {\r\n      var _this8 = this;\r\n\r\n      var id = newGUID();\r\n\r\n      if (!this.isReady_ || this.paused()) {\r\n        this.queuedHanders_.add(id);\r\n        this.one('playing', function () {\r\n          if (_this8.queuedHanders_.has(id)) {\r\n            _this8.queuedHanders_[\"delete\"](id);\r\n\r\n            cb();\r\n          }\r\n        });\r\n      } else {\r\n        this.requestNamedAnimationFrame(id, cb);\r\n      }\r\n\r\n      return id;\r\n    }\r\n    /**\r\n     * A fallback implementation of cancelVideoFrameCallback\r\n     *\r\n     * @param {number} id id of callback to be cancelled\r\n     */\r\n    ;\r\n\r\n    _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {\r\n      if (this.queuedHanders_.has(id)) {\r\n        this.queuedHanders_[\"delete\"](id);\r\n      } else {\r\n        this.cancelNamedAnimationFrame(id);\r\n      }\r\n    }\r\n    /**\r\n     * A method to set a poster from a `Tech`.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.setPoster = function setPoster() {}\r\n    /**\r\n     * A method to check for the presence of the 'playsinline' <video> attribute.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.playsinline = function playsinline() {}\r\n    /**\r\n     * A method to set or unset the 'playsinline' <video> attribute.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.setPlaysinline = function setPlaysinline() {}\r\n    /**\r\n     * Attempt to force override of native audio tracks.\r\n     *\r\n     * @param {boolean} override - If set to true native audio will be overridden,\r\n     * otherwise native audio will potentially be used.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {}\r\n    /**\r\n     * Attempt to force override of native video tracks.\r\n     *\r\n     * @param {boolean} override - If set to true native video will be overridden,\r\n     * otherwise native video will potentially be used.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {}\r\n    /*\r\n     * Check if the tech can support the given mime-type.\r\n     *\r\n     * The base tech does not support any type, but source handlers might\r\n     * overwrite this.\r\n     *\r\n     * @param  {string} type\r\n     *         The mimetype to check for support\r\n     *\r\n     * @return {string}\r\n     *         'probably', 'maybe', or empty string\r\n     *\r\n     * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.canPlayType = function canPlayType() {\r\n      return '';\r\n    }\r\n    /**\r\n     * Check if the type is supported by this tech.\r\n     *\r\n     * The base tech does not support any type, but source handlers might\r\n     * overwrite this.\r\n     *\r\n     * @param {string} type\r\n     *        The media type to check\r\n     * @return {string} Returns the native video element's response\r\n     */\r\n    ;\r\n\r\n    Tech.canPlayType = function canPlayType() {\r\n      return '';\r\n    }\r\n    /**\r\n     * Check if the tech can support the given source\r\n     *\r\n     * @param {Object} srcObj\r\n     *        The source object\r\n     * @param {Object} options\r\n     *        The options passed to the tech\r\n     * @return {string} 'probably', 'maybe', or '' (empty string)\r\n     */\r\n    ;\r\n\r\n    Tech.canPlaySource = function canPlaySource(srcObj, options) {\r\n      return Tech.canPlayType(srcObj.type);\r\n    }\r\n    /*\r\n     * Return whether the argument is a Tech or not.\r\n     * Can be passed either a Class like `Html5` or a instance like `player.tech_`\r\n     *\r\n     * @param {Object} component\r\n     *        The item to check\r\n     *\r\n     * @return {boolean}\r\n     *         Whether it is a tech or not\r\n     *         - True if it is a tech\r\n     *         - False if it is not\r\n     */\r\n    ;\r\n\r\n    Tech.isTech = function isTech(component) {\r\n      return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\r\n    }\r\n    /**\r\n     * Registers a `Tech` into a shared list for videojs.\r\n     *\r\n     * @param {string} name\r\n     *        Name of the `Tech` to register.\r\n     *\r\n     * @param {Object} tech\r\n     *        The `Tech` class to register.\r\n     */\r\n    ;\r\n\r\n    Tech.registerTech = function registerTech(name, tech) {\r\n      if (!Tech.techs_) {\r\n        Tech.techs_ = {};\r\n      }\r\n\r\n      if (!Tech.isTech(tech)) {\r\n        throw new Error(\"Tech \" + name + \" must be a Tech\");\r\n      }\r\n\r\n      if (!Tech.canPlayType) {\r\n        throw new Error('Techs must have a static canPlayType method on them');\r\n      }\r\n\r\n      if (!Tech.canPlaySource) {\r\n        throw new Error('Techs must have a static canPlaySource method on them');\r\n      }\r\n\r\n      name = toTitleCase$1(name);\r\n      Tech.techs_[name] = tech;\r\n      Tech.techs_[toLowerCase(name)] = tech;\r\n\r\n      if (name !== 'Tech') {\r\n        // camel case the techName for use in techOrder\r\n        Tech.defaultTechOrder_.push(name);\r\n      }\r\n\r\n      return tech;\r\n    }\r\n    /**\r\n     * Get a `Tech` from the shared list by name.\r\n     *\r\n     * @param {string} name\r\n     *        `camelCase` or `TitleCase` name of the Tech to get\r\n     *\r\n     * @return {Tech|undefined}\r\n     *         The `Tech` or undefined if there was no tech with the name requested.\r\n     */\r\n    ;\r\n\r\n    Tech.getTech = function getTech(name) {\r\n      if (!name) {\r\n        return;\r\n      }\r\n\r\n      if (Tech.techs_ && Tech.techs_[name]) {\r\n        return Tech.techs_[name];\r\n      }\r\n\r\n      name = toTitleCase$1(name);\r\n\r\n      if (window && window.videojs && window.videojs[name]) {\r\n        log$1.warn(\"The \" + name + \" tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)\");\r\n        return window.videojs[name];\r\n      }\r\n    };\r\n\r\n    return Tech;\r\n  }(Component$1);\r\n  /**\r\n   * Get the {@link VideoTrackList}\r\n   *\r\n   * @returns {VideoTrackList}\r\n   * @method Tech.prototype.videoTracks\r\n   */\r\n\r\n  /**\r\n   * Get the {@link AudioTrackList}\r\n   *\r\n   * @returns {AudioTrackList}\r\n   * @method Tech.prototype.audioTracks\r\n   */\r\n\r\n  /**\r\n   * Get the {@link TextTrackList}\r\n   *\r\n   * @returns {TextTrackList}\r\n   * @method Tech.prototype.textTracks\r\n   */\r\n\r\n  /**\r\n   * Get the remote element {@link TextTrackList}\r\n   *\r\n   * @returns {TextTrackList}\r\n   * @method Tech.prototype.remoteTextTracks\r\n   */\r\n\r\n  /**\r\n   * Get the remote element {@link HtmlTrackElementList}\r\n   *\r\n   * @returns {HtmlTrackElementList}\r\n   * @method Tech.prototype.remoteTextTrackEls\r\n   */\r\n\r\n\r\n  ALL.names.forEach(function (name) {\r\n    var props = ALL[name];\r\n\r\n    Tech.prototype[props.getterName] = function () {\r\n      this[props.privateName] = this[props.privateName] || new props.ListClass();\r\n      return this[props.privateName];\r\n    };\r\n  });\r\n  /**\r\n   * List of associated text tracks\r\n   *\r\n   * @type {TextTrackList}\r\n   * @private\r\n   * @property Tech#textTracks_\r\n   */\r\n\r\n  /**\r\n   * List of associated audio tracks.\r\n   *\r\n   * @type {AudioTrackList}\r\n   * @private\r\n   * @property Tech#audioTracks_\r\n   */\r\n\r\n  /**\r\n   * List of associated video tracks.\r\n   *\r\n   * @type {VideoTrackList}\r\n   * @private\r\n   * @property Tech#videoTracks_\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports volume control.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresVolumeControl = true;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports muting volume.\r\n   *\r\n   * @type {bolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresMuteControl = true;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports fullscreen resize control.\r\n   * Resizing plugins using request fullscreen reloads the plugin\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresFullscreenResize = false;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports changing the speed at which the video\r\n   * plays. Examples:\r\n   *   - Set player to play 2x (twice) as fast\r\n   *   - Set player to play 0.5x (half) as fast\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresPlaybackRate = false;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports the `progress` event. This is currently\r\n   * not triggered by video-js-swf. This will be used to determine if\r\n   * {@link Tech#manualProgressOn} should be called.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresProgressEvents = false;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports the `sourceset` event.\r\n   *\r\n   * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\r\n   * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\r\n   * a new source.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresSourceset = false;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports the `timeupdate` event. This is currently\r\n   * not triggered by video-js-swf. This will be used to determine if\r\n   * {@link Tech#manualTimeUpdates} should be called.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresTimeupdateEvents = false;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports the native `TextTrack`s.\r\n   * This will help us integrate with native `TextTrack`s if the browser supports them.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresNativeTextTracks = false;\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports `requestVideoFrameCallback`.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Tech.prototype.featuresVideoFrameCallback = false;\r\n  /**\r\n   * A functional mixin for techs that want to use the Source Handler pattern.\r\n   * Source handlers are scripts for handling specific formats.\r\n   * The source handler pattern is used for adaptive formats (HLS, DASH) that\r\n   * manually load video data and feed it into a Source Buffer (Media Source Extensions)\r\n   * Example: `Tech.withSourceHandlers.call(MyTech);`\r\n   *\r\n   * @param {Tech} _Tech\r\n   *        The tech to add source handler functions to.\r\n   *\r\n   * @mixes Tech~SourceHandlerAdditions\r\n   */\r\n\r\n  Tech.withSourceHandlers = function (_Tech) {\r\n    /**\r\n     * Register a source handler\r\n     *\r\n     * @param {Function} handler\r\n     *        The source handler class\r\n     *\r\n     * @param {number} [index]\r\n     *        Register it at the following index\r\n     */\r\n    _Tech.registerSourceHandler = function (handler, index) {\r\n      var handlers = _Tech.sourceHandlers;\r\n\r\n      if (!handlers) {\r\n        handlers = _Tech.sourceHandlers = [];\r\n      }\r\n\r\n      if (index === undefined) {\r\n        // add to the end of the list\r\n        index = handlers.length;\r\n      }\r\n\r\n      handlers.splice(index, 0, handler);\r\n    };\r\n    /**\r\n     * Check if the tech can support the given type. Also checks the\r\n     * Techs sourceHandlers.\r\n     *\r\n     * @param {string} type\r\n     *         The mimetype to check.\r\n     *\r\n     * @return {string}\r\n     *         'probably', 'maybe', or '' (empty string)\r\n     */\r\n\r\n\r\n    _Tech.canPlayType = function (type) {\r\n      var handlers = _Tech.sourceHandlers || [];\r\n      var can;\r\n\r\n      for (var i = 0; i < handlers.length; i++) {\r\n        can = handlers[i].canPlayType(type);\r\n\r\n        if (can) {\r\n          return can;\r\n        }\r\n      }\r\n\r\n      return '';\r\n    };\r\n    /**\r\n     * Returns the first source handler that supports the source.\r\n     *\r\n     * TODO: Answer question: should 'probably' be prioritized over 'maybe'\r\n     *\r\n     * @param {Tech~SourceObject} source\r\n     *        The source object\r\n     *\r\n     * @param {Object} options\r\n     *        The options passed to the tech\r\n     *\r\n     * @return {SourceHandler|null}\r\n     *          The first source handler that supports the source or null if\r\n     *          no SourceHandler supports the source\r\n     */\r\n\r\n\r\n    _Tech.selectSourceHandler = function (source, options) {\r\n      var handlers = _Tech.sourceHandlers || [];\r\n      var can;\r\n\r\n      for (var i = 0; i < handlers.length; i++) {\r\n        can = handlers[i].canHandleSource(source, options);\r\n\r\n        if (can) {\r\n          return handlers[i];\r\n        }\r\n      }\r\n\r\n      return null;\r\n    };\r\n    /**\r\n     * Check if the tech can support the given source.\r\n     *\r\n     * @param {Tech~SourceObject} srcObj\r\n     *        The source object\r\n     *\r\n     * @param {Object} options\r\n     *        The options passed to the tech\r\n     *\r\n     * @return {string}\r\n     *         'probably', 'maybe', or '' (empty string)\r\n     */\r\n\r\n\r\n    _Tech.canPlaySource = function (srcObj, options) {\r\n      var sh = _Tech.selectSourceHandler(srcObj, options);\r\n\r\n      if (sh) {\r\n        return sh.canHandleSource(srcObj, options);\r\n      }\r\n\r\n      return '';\r\n    };\r\n    /**\r\n     * When using a source handler, prefer its implementation of\r\n     * any function normally provided by the tech.\r\n     */\r\n\r\n\r\n    var deferrable = ['seekable', 'seeking', 'duration'];\r\n    /**\r\n     * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\r\n     * function if it exists, with a fallback to the Techs seekable function.\r\n     *\r\n     * @method _Tech.seekable\r\n     */\r\n\r\n    /**\r\n     * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\r\n     * function if it exists, otherwise it will fallback to the techs duration function.\r\n     *\r\n     * @method _Tech.duration\r\n     */\r\n\r\n    deferrable.forEach(function (fnName) {\r\n      var originalFn = this[fnName];\r\n\r\n      if (typeof originalFn !== 'function') {\r\n        return;\r\n      }\r\n\r\n      this[fnName] = function () {\r\n        if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\r\n          return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\r\n        }\r\n\r\n        return originalFn.apply(this, arguments);\r\n      };\r\n    }, _Tech.prototype);\r\n    /**\r\n     * Create a function for setting the source using a source object\r\n     * and source handlers.\r\n     * Should never be called unless a source handler was found.\r\n     *\r\n     * @param {Tech~SourceObject} source\r\n     *        A source object with src and type keys\r\n     */\r\n\r\n    _Tech.prototype.setSource = function (source) {\r\n      var sh = _Tech.selectSourceHandler(source, this.options_);\r\n\r\n      if (!sh) {\r\n        // Fall back to a native source hander when unsupported sources are\r\n        // deliberately set\r\n        if (_Tech.nativeSourceHandler) {\r\n          sh = _Tech.nativeSourceHandler;\r\n        } else {\r\n          log$1.error('No source handler found for the current source.');\r\n        }\r\n      } // Dispose any existing source handler\r\n\r\n\r\n      this.disposeSourceHandler();\r\n      this.off('dispose', this.disposeSourceHandler_);\r\n\r\n      if (sh !== _Tech.nativeSourceHandler) {\r\n        this.currentSource_ = source;\r\n      }\r\n\r\n      this.sourceHandler_ = sh.handleSource(source, this, this.options_);\r\n      this.one('dispose', this.disposeSourceHandler_);\r\n    };\r\n    /**\r\n     * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\r\n     *\r\n     * @listens Tech#dispose\r\n     */\r\n\r\n\r\n    _Tech.prototype.disposeSourceHandler = function () {\r\n      // if we have a source and get another one\r\n      // then we are loading something new\r\n      // than clear all of our current tracks\r\n      if (this.currentSource_) {\r\n        this.clearTracks(['audio', 'video']);\r\n        this.currentSource_ = null;\r\n      } // always clean up auto-text tracks\r\n\r\n\r\n      this.cleanupAutoTextTracks();\r\n\r\n      if (this.sourceHandler_) {\r\n        if (this.sourceHandler_.dispose) {\r\n          this.sourceHandler_.dispose();\r\n        }\r\n\r\n        this.sourceHandler_ = null;\r\n      }\r\n    };\r\n  }; // The base Tech class needs to be registered as a Component. It is the only\r\n  // Tech that can be registered as a Component.\r\n\r\n\r\n  Component$1.registerComponent('Tech', Tech);\r\n  Tech.registerTech('Tech', Tech);\r\n  /**\r\n   * A list of techs that should be added to techOrder on Players\r\n   *\r\n   * @private\r\n   */\r\n\r\n  Tech.defaultTechOrder_ = [];\r\n\r\n  /**\r\n   * @file middleware.js\r\n   * @module middleware\r\n   */\r\n  var middlewares = {};\r\n  var middlewareInstances = {};\r\n  var TERMINATOR = {};\r\n  /**\r\n   * A middleware object is a plain JavaScript object that has methods that\r\n   * match the {@link Tech} methods found in the lists of allowed\r\n   * {@link module:middleware.allowedGetters|getters},\r\n   * {@link module:middleware.allowedSetters|setters}, and\r\n   * {@link module:middleware.allowedMediators|mediators}.\r\n   *\r\n   * @typedef {Object} MiddlewareObject\r\n   */\r\n\r\n  /**\r\n   * A middleware factory function that should return a\r\n   * {@link module:middleware~MiddlewareObject|MiddlewareObject}.\r\n   *\r\n   * This factory will be called for each player when needed, with the player\r\n   * passed in as an argument.\r\n   *\r\n   * @callback MiddlewareFactory\r\n   * @param {Player} player\r\n   *        A Video.js player.\r\n   */\r\n\r\n  /**\r\n   * Define a middleware that the player should use by way of a factory function\r\n   * that returns a middleware object.\r\n   *\r\n   * @param  {string} type\r\n   *         The MIME type to match or `\"*\"` for all MIME types.\r\n   *\r\n   * @param  {MiddlewareFactory} middleware\r\n   *         A middleware factory function that will be executed for\r\n   *         matching types.\r\n   */\r\n\r\n  function use(type, middleware) {\r\n    middlewares[type] = middlewares[type] || [];\r\n    middlewares[type].push(middleware);\r\n  }\r\n  /**\r\n   * Asynchronously sets a source using middleware by recursing through any\r\n   * matching middlewares and calling `setSource` on each, passing along the\r\n   * previous returned value each time.\r\n   *\r\n   * @param  {Player} player\r\n   *         A {@link Player} instance.\r\n   *\r\n   * @param  {Tech~SourceObject} src\r\n   *         A source object.\r\n   *\r\n   * @param  {Function}\r\n   *         The next middleware to run.\r\n   */\r\n\r\n  function setSource(player, src, next) {\r\n    player.setTimeout(function () {\r\n      return setSourceHelper(src, middlewares[src.type], next, player);\r\n    }, 1);\r\n  }\r\n  /**\r\n   * When the tech is set, passes the tech to each middleware's `setTech` method.\r\n   *\r\n   * @param {Object[]} middleware\r\n   *        An array of middleware instances.\r\n   *\r\n   * @param {Tech} tech\r\n   *        A Video.js tech.\r\n   */\r\n\r\n  function setTech(middleware, tech) {\r\n    middleware.forEach(function (mw) {\r\n      return mw.setTech && mw.setTech(tech);\r\n    });\r\n  }\r\n  /**\r\n   * Calls a getter on the tech first, through each middleware\r\n   * from right to left to the player.\r\n   *\r\n   * @param  {Object[]} middleware\r\n   *         An array of middleware instances.\r\n   *\r\n   * @param  {Tech} tech\r\n   *         The current tech.\r\n   *\r\n   * @param  {string} method\r\n   *         A method name.\r\n   *\r\n   * @return {Mixed}\r\n   *         The final value from the tech after middleware has intercepted it.\r\n   */\r\n\r\n  function get(middleware, tech, method) {\r\n    return middleware.reduceRight(middlewareIterator(method), tech[method]());\r\n  }\r\n  /**\r\n   * Takes the argument given to the player and calls the setter method on each\r\n   * middleware from left to right to the tech.\r\n   *\r\n   * @param  {Object[]} middleware\r\n   *         An array of middleware instances.\r\n   *\r\n   * @param  {Tech} tech\r\n   *         The current tech.\r\n   *\r\n   * @param  {string} method\r\n   *         A method name.\r\n   *\r\n   * @param  {Mixed} arg\r\n   *         The value to set on the tech.\r\n   *\r\n   * @return {Mixed}\r\n   *         The return value of the `method` of the `tech`.\r\n   */\r\n\r\n  function set(middleware, tech, method, arg) {\r\n    return tech[method](middleware.reduce(middlewareIterator(method), arg));\r\n  }\r\n  /**\r\n   * Takes the argument given to the player and calls the `call` version of the\r\n   * method on each middleware from left to right.\r\n   *\r\n   * Then, call the passed in method on the tech and return the result unchanged\r\n   * back to the player, through middleware, this time from right to left.\r\n   *\r\n   * @param  {Object[]} middleware\r\n   *         An array of middleware instances.\r\n   *\r\n   * @param  {Tech} tech\r\n   *         The current tech.\r\n   *\r\n   * @param  {string} method\r\n   *         A method name.\r\n   *\r\n   * @param  {Mixed} arg\r\n   *         The value to set on the tech.\r\n   *\r\n   * @return {Mixed}\r\n   *         The return value of the `method` of the `tech`, regardless of the\r\n   *         return values of middlewares.\r\n   */\r\n\r\n  function mediate(middleware, tech, method, arg) {\r\n    if (arg === void 0) {\r\n      arg = null;\r\n    }\r\n\r\n    var callMethod = 'call' + toTitleCase$1(method);\r\n    var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\r\n    var terminated = middlewareValue === TERMINATOR; // deprecated. The `null` return value should instead return TERMINATOR to\r\n    // prevent confusion if a techs method actually returns null.\r\n\r\n    var returnValue = terminated ? null : tech[method](middlewareValue);\r\n    executeRight(middleware, method, returnValue, terminated);\r\n    return returnValue;\r\n  }\r\n  /**\r\n   * Enumeration of allowed getters where the keys are method names.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var allowedGetters = {\r\n    buffered: 1,\r\n    currentTime: 1,\r\n    duration: 1,\r\n    muted: 1,\r\n    played: 1,\r\n    paused: 1,\r\n    seekable: 1,\r\n    volume: 1,\r\n    ended: 1\r\n  };\r\n  /**\r\n   * Enumeration of allowed setters where the keys are method names.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var allowedSetters = {\r\n    setCurrentTime: 1,\r\n    setMuted: 1,\r\n    setVolume: 1\r\n  };\r\n  /**\r\n   * Enumeration of allowed mediators where the keys are method names.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var allowedMediators = {\r\n    play: 1,\r\n    pause: 1\r\n  };\r\n\r\n  function middlewareIterator(method) {\r\n    return function (value, mw) {\r\n      // if the previous middleware terminated, pass along the termination\r\n      if (value === TERMINATOR) {\r\n        return TERMINATOR;\r\n      }\r\n\r\n      if (mw[method]) {\r\n        return mw[method](value);\r\n      }\r\n\r\n      return value;\r\n    };\r\n  }\r\n\r\n  function executeRight(mws, method, value, terminated) {\r\n    for (var i = mws.length - 1; i >= 0; i--) {\r\n      var mw = mws[i];\r\n\r\n      if (mw[method]) {\r\n        mw[method](terminated, value);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Clear the middleware cache for a player.\r\n   *\r\n   * @param  {Player} player\r\n   *         A {@link Player} instance.\r\n   */\r\n\r\n\r\n  function clearCacheForPlayer(player) {\r\n    middlewareInstances[player.id()] = null;\r\n  }\r\n  /**\r\n   * {\r\n   *  [playerId]: [[mwFactory, mwInstance], ...]\r\n   * }\r\n   *\r\n   * @private\r\n   */\r\n\r\n  function getOrCreateFactory(player, mwFactory) {\r\n    var mws = middlewareInstances[player.id()];\r\n    var mw = null;\r\n\r\n    if (mws === undefined || mws === null) {\r\n      mw = mwFactory(player);\r\n      middlewareInstances[player.id()] = [[mwFactory, mw]];\r\n      return mw;\r\n    }\r\n\r\n    for (var i = 0; i < mws.length; i++) {\r\n      var _mws$i = mws[i],\r\n          mwf = _mws$i[0],\r\n          mwi = _mws$i[1];\r\n\r\n      if (mwf !== mwFactory) {\r\n        continue;\r\n      }\r\n\r\n      mw = mwi;\r\n    }\r\n\r\n    if (mw === null) {\r\n      mw = mwFactory(player);\r\n      mws.push([mwFactory, mw]);\r\n    }\r\n\r\n    return mw;\r\n  }\r\n\r\n  function setSourceHelper(src, middleware, next, player, acc, lastRun) {\r\n    if (src === void 0) {\r\n      src = {};\r\n    }\r\n\r\n    if (middleware === void 0) {\r\n      middleware = [];\r\n    }\r\n\r\n    if (acc === void 0) {\r\n      acc = [];\r\n    }\r\n\r\n    if (lastRun === void 0) {\r\n      lastRun = false;\r\n    }\r\n\r\n    var _middleware = middleware,\r\n        mwFactory = _middleware[0],\r\n        mwrest = _middleware.slice(1); // if mwFactory is a string, then we're at a fork in the road\r\n\r\n\r\n    if (typeof mwFactory === 'string') {\r\n      setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun); // if we have an mwFactory, call it with the player to get the mw,\r\n      // then call the mw's setSource method\r\n    } else if (mwFactory) {\r\n      var mw = getOrCreateFactory(player, mwFactory); // if setSource isn't present, implicitly select this middleware\r\n\r\n      if (!mw.setSource) {\r\n        acc.push(mw);\r\n        return setSourceHelper(src, mwrest, next, player, acc, lastRun);\r\n      }\r\n\r\n      mw.setSource(assign({}, src), function (err, _src) {\r\n        // something happened, try the next middleware on the current level\r\n        // make sure to use the old src\r\n        if (err) {\r\n          return setSourceHelper(src, mwrest, next, player, acc, lastRun);\r\n        } // we've succeeded, now we need to go deeper\r\n\r\n\r\n        acc.push(mw); // if it's the same type, continue down the current chain\r\n        // otherwise, we want to go down the new chain\r\n\r\n        setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\r\n      });\r\n    } else if (mwrest.length) {\r\n      setSourceHelper(src, mwrest, next, player, acc, lastRun);\r\n    } else if (lastRun) {\r\n      next(src, acc);\r\n    } else {\r\n      setSourceHelper(src, middlewares['*'], next, player, acc, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mimetypes\r\n   *\r\n   * @see https://www.iana.org/assignments/media-types/media-types.xhtml\r\n   * @typedef Mimetypes~Kind\r\n   * @enum\r\n   */\r\n\r\n  var MimetypesKind = {\r\n    opus: 'video/ogg',\r\n    ogv: 'video/ogg',\r\n    mp4: 'video/mp4',\r\n    mov: 'video/mp4',\r\n    m4v: 'video/mp4',\r\n    mkv: 'video/x-matroska',\r\n    m4a: 'audio/mp4',\r\n    mp3: 'audio/mpeg',\r\n    aac: 'audio/aac',\r\n    caf: 'audio/x-caf',\r\n    flac: 'audio/flac',\r\n    oga: 'audio/ogg',\r\n    wav: 'audio/wav',\r\n    m3u8: 'application/x-mpegURL',\r\n    mpd: 'application/dash+xml',\r\n    jpg: 'image/jpeg',\r\n    jpeg: 'image/jpeg',\r\n    gif: 'image/gif',\r\n    png: 'image/png',\r\n    svg: 'image/svg+xml',\r\n    webp: 'image/webp'\r\n  };\r\n  /**\r\n   * Get the mimetype of a given src url if possible\r\n   *\r\n   * @param {string} src\r\n   *        The url to the src\r\n   *\r\n   * @return {string}\r\n   *         return the mimetype if it was known or empty string otherwise\r\n   */\r\n\r\n  var getMimetype = function getMimetype(src) {\r\n    if (src === void 0) {\r\n      src = '';\r\n    }\r\n\r\n    var ext = getFileExtension(src);\r\n    var mimetype = MimetypesKind[ext.toLowerCase()];\r\n    return mimetype || '';\r\n  };\r\n  /**\r\n   * Find the mime type of a given source string if possible. Uses the player\r\n   * source cache.\r\n   *\r\n   * @param {Player} player\r\n   *        The player object\r\n   *\r\n   * @param {string} src\r\n   *        The source string\r\n   *\r\n   * @return {string}\r\n   *         The type that was found\r\n   */\r\n\r\n  var findMimetype = function findMimetype(player, src) {\r\n    if (!src) {\r\n      return '';\r\n    } // 1. check for the type in the `source` cache\r\n\r\n\r\n    if (player.cache_.source.src === src && player.cache_.source.type) {\r\n      return player.cache_.source.type;\r\n    } // 2. see if we have this source in our `currentSources` cache\r\n\r\n\r\n    var matchingSources = player.cache_.sources.filter(function (s) {\r\n      return s.src === src;\r\n    });\r\n\r\n    if (matchingSources.length) {\r\n      return matchingSources[0].type;\r\n    } // 3. look for the src url in source elements and use the type there\r\n\r\n\r\n    var sources = player.$$('source');\r\n\r\n    for (var i = 0; i < sources.length; i++) {\r\n      var s = sources[i];\r\n\r\n      if (s.type && s.src && s.src === src) {\r\n        return s.type;\r\n      }\r\n    } // 4. finally fallback to our list of mime types based on src url extension\r\n\r\n\r\n    return getMimetype(src);\r\n  };\r\n\r\n  /**\r\n   * @module filter-source\r\n   */\r\n  /**\r\n   * Filter out single bad source objects or multiple source objects in an\r\n   * array. Also flattens nested source object arrays into a 1 dimensional\r\n   * array of source objects.\r\n   *\r\n   * @param {Tech~SourceObject|Tech~SourceObject[]} src\r\n   *        The src object to filter\r\n   *\r\n   * @return {Tech~SourceObject[]}\r\n   *         An array of sourceobjects containing only valid sources\r\n   *\r\n   * @private\r\n   */\r\n\r\n  var filterSource = function filterSource(src) {\r\n    // traverse array\r\n    if (Array.isArray(src)) {\r\n      var newsrc = [];\r\n      src.forEach(function (srcobj) {\r\n        srcobj = filterSource(srcobj);\r\n\r\n        if (Array.isArray(srcobj)) {\r\n          newsrc = newsrc.concat(srcobj);\r\n        } else if (isObject$1(srcobj)) {\r\n          newsrc.push(srcobj);\r\n        }\r\n      });\r\n      src = newsrc;\r\n    } else if (typeof src === 'string' && src.trim()) {\r\n      // convert string into object\r\n      src = [fixSource({\r\n        src: src\r\n      })];\r\n    } else if (isObject$1(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\r\n      // src is already valid\r\n      src = [fixSource(src)];\r\n    } else {\r\n      // invalid source, turn it into an empty array\r\n      src = [];\r\n    }\r\n\r\n    return src;\r\n  };\r\n  /**\r\n   * Checks src mimetype, adding it when possible\r\n   *\r\n   * @param {Tech~SourceObject} src\r\n   *        The src object to check\r\n   * @return {Tech~SourceObject}\r\n   *        src Object with known type\r\n   */\r\n\r\n\r\n  function fixSource(src) {\r\n    if (!src.type) {\r\n      var mimetype = getMimetype(src.src);\r\n\r\n      if (mimetype) {\r\n        src.type = mimetype;\r\n      }\r\n    }\r\n\r\n    return src;\r\n  }\r\n\r\n  /**\r\n   * The `MediaLoader` is the `Component` that decides which playback technology to load\r\n   * when a player is initialized.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var MediaLoader = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(MediaLoader, _Component);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should attach to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        The function that is run when this component is ready.\r\n     */\r\n    function MediaLoader(player, options, ready) {\r\n      var _this;\r\n\r\n      // MediaLoader has no element\r\n      var options_ = mergeOptions$3({\r\n        createEl: false\r\n      }, options);\r\n      _this = _Component.call(this, player, options_, ready) || this; // If there are no sources when the player is initialized,\r\n      // load the first supported playback technology.\r\n\r\n      if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\r\n        for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\r\n          var techName = toTitleCase$1(j[i]);\r\n          var tech = Tech.getTech(techName); // Support old behavior of techs being registered as components.\r\n          // Remove once that deprecated behavior is removed.\r\n\r\n          if (!techName) {\r\n            tech = Component$1.getComponent(techName);\r\n          } // Check if the browser supports this technology\r\n\r\n\r\n          if (tech && tech.isSupported()) {\r\n            player.loadTech_(techName);\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        // Loop through playback technologies (e.g. HTML5) and check for support.\r\n        // Then load the best source.\r\n        // A few assumptions here:\r\n        //   All playback technologies respect preload false.\r\n        player.src(options.playerOptions.sources);\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    return MediaLoader;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('MediaLoader', MediaLoader);\r\n\r\n  /**\r\n   * Component which is clickable or keyboard actionable, but is not a\r\n   * native HTML button.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var ClickableComponent = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(ClickableComponent, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param  {Player} player\r\n     *         The `Player` that this class should be attached to.\r\n     *\r\n     * @param  {Object} [options]\r\n     *         The key/value store of component options.\r\n     *\r\n     * @param  {function} [options.clickHandler]\r\n     *         The function to call when the button is clicked / activated\r\n     *\r\n     * @param  {string} [options.controlText]\r\n     *         The text to set on the button\r\n     *\r\n     * @param  {string} [options.className]\r\n     *         A class or space separated list of classes to add the component\r\n     *\r\n     */\r\n    function ClickableComponent(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n\r\n      if (_this.options_.controlText) {\r\n        _this.controlText(_this.options_.controlText);\r\n      }\r\n\r\n      _this.handleMouseOver_ = function (e) {\r\n        return _this.handleMouseOver(e);\r\n      };\r\n\r\n      _this.handleMouseOut_ = function (e) {\r\n        return _this.handleMouseOut(e);\r\n      };\r\n\r\n      _this.handleClick_ = function (e) {\r\n        return _this.handleClick(e);\r\n      };\r\n\r\n      _this.handleKeyDown_ = function (e) {\r\n        return _this.handleKeyDown(e);\r\n      };\r\n\r\n      _this.emitTapEvents();\r\n\r\n      _this.enable();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `ClickableComponent`s DOM element.\r\n     *\r\n     * @param {string} [tag=div]\r\n     *        The element's node type.\r\n     *\r\n     * @param {Object} [props={}]\r\n     *        An object of properties that should be set on the element.\r\n     *\r\n     * @param {Object} [attributes={}]\r\n     *        An object of attributes that should be set on the element.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n\r\n\r\n    var _proto = ClickableComponent.prototype;\r\n\r\n    _proto.createEl = function createEl$1(tag, props, attributes) {\r\n      if (tag === void 0) {\r\n        tag = 'div';\r\n      }\r\n\r\n      if (props === void 0) {\r\n        props = {};\r\n      }\r\n\r\n      if (attributes === void 0) {\r\n        attributes = {};\r\n      }\r\n\r\n      props = assign({\r\n        className: this.buildCSSClass(),\r\n        tabIndex: 0\r\n      }, props);\r\n\r\n      if (tag === 'button') {\r\n        log$1.error(\"Creating a ClickableComponent with an HTML element of \" + tag + \" is not supported; use a Button instead.\");\r\n      } // Add ARIA attributes for clickable element which is not a native HTML button\r\n\r\n\r\n      attributes = assign({\r\n        role: 'button'\r\n      }, attributes);\r\n      this.tabIndex_ = props.tabIndex;\r\n      var el = createEl(tag, props, attributes);\r\n      el.appendChild(createEl('span', {\r\n        className: 'vjs-icon-placeholder'\r\n      }, {\r\n        'aria-hidden': true\r\n      }));\r\n      this.createControlTextEl(el);\r\n      return el;\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      // remove controlTextEl_ on dispose\r\n      this.controlTextEl_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Create a control text element on this `ClickableComponent`\r\n     *\r\n     * @param {Element} [el]\r\n     *        Parent element for the control text.\r\n     *\r\n     * @return {Element}\r\n     *         The control text element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createControlTextEl = function createControlTextEl(el) {\r\n      this.controlTextEl_ = createEl('span', {\r\n        className: 'vjs-control-text'\r\n      }, {\r\n        // let the screen reader user know that the text of the element may change\r\n        'aria-live': 'polite'\r\n      });\r\n\r\n      if (el) {\r\n        el.appendChild(this.controlTextEl_);\r\n      }\r\n\r\n      this.controlText(this.controlText_, el);\r\n      return this.controlTextEl_;\r\n    }\r\n    /**\r\n     * Get or set the localize text to use for the controls on the `ClickableComponent`.\r\n     *\r\n     * @param {string} [text]\r\n     *        Control text for element.\r\n     *\r\n     * @param {Element} [el=this.el()]\r\n     *        Element to set the title on.\r\n     *\r\n     * @return {string}\r\n     *         - The control text when getting\r\n     */\r\n    ;\r\n\r\n    _proto.controlText = function controlText(text, el) {\r\n      if (el === void 0) {\r\n        el = this.el();\r\n      }\r\n\r\n      if (text === undefined) {\r\n        return this.controlText_ || 'Need Text';\r\n      }\r\n\r\n      var localizedText = this.localize(text);\r\n      this.controlText_ = text;\r\n      textContent(this.controlTextEl_, localizedText);\r\n\r\n      if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {\r\n        // Set title attribute if only an icon is shown\r\n        el.setAttribute('title', localizedText);\r\n      }\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    ;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-control vjs-button \" + _Component.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Enable this `ClickableComponent`\r\n     */\r\n    ;\r\n\r\n    _proto.enable = function enable() {\r\n      if (!this.enabled_) {\r\n        this.enabled_ = true;\r\n        this.removeClass('vjs-disabled');\r\n        this.el_.setAttribute('aria-disabled', 'false');\r\n\r\n        if (typeof this.tabIndex_ !== 'undefined') {\r\n          this.el_.setAttribute('tabIndex', this.tabIndex_);\r\n        }\r\n\r\n        this.on(['tap', 'click'], this.handleClick_);\r\n        this.on('keydown', this.handleKeyDown_);\r\n      }\r\n    }\r\n    /**\r\n     * Disable this `ClickableComponent`\r\n     */\r\n    ;\r\n\r\n    _proto.disable = function disable() {\r\n      this.enabled_ = false;\r\n      this.addClass('vjs-disabled');\r\n      this.el_.setAttribute('aria-disabled', 'true');\r\n\r\n      if (typeof this.tabIndex_ !== 'undefined') {\r\n        this.el_.removeAttribute('tabIndex');\r\n      }\r\n\r\n      this.off('mouseover', this.handleMouseOver_);\r\n      this.off('mouseout', this.handleMouseOut_);\r\n      this.off(['tap', 'click'], this.handleClick_);\r\n      this.off('keydown', this.handleKeyDown_);\r\n    }\r\n    /**\r\n     * Handles language change in ClickableComponent for the player in components\r\n     *\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.handleLanguagechange = function handleLanguagechange() {\r\n      this.controlText(this.controlText_);\r\n    }\r\n    /**\r\n     * Event handler that is called when a `ClickableComponent` receives a\r\n     * `click` or `tap` event.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `tap` or `click` event that caused this function to be called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      if (this.options_.clickHandler) {\r\n        this.options_.clickHandler.call(this, arguments);\r\n      }\r\n    }\r\n    /**\r\n     * Event handler that is called when a `ClickableComponent` receives a\r\n     * `keydown` event.\r\n     *\r\n     * By default, if the key is Space or Enter, it will trigger a `click` event.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Support Space or Enter key operation to fire a click event. Also,\r\n      // prevent the event from propagating through the DOM and triggering\r\n      // Player hotkeys.\r\n      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.trigger('click');\r\n      } else {\r\n        // Pass keypress handling up for unsupported keys\r\n        _Component.prototype.handleKeyDown.call(this, event);\r\n      }\r\n    };\r\n\r\n    return ClickableComponent;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('ClickableComponent', ClickableComponent);\r\n\r\n  /**\r\n   * A `ClickableComponent` that handles showing the poster image for the player.\r\n   *\r\n   * @extends ClickableComponent\r\n   */\r\n\r\n  var PosterImage = /*#__PURE__*/function (_ClickableComponent) {\r\n    inheritsLoose(PosterImage, _ClickableComponent);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should attach to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function PosterImage(player, options) {\r\n      var _this;\r\n\r\n      _this = _ClickableComponent.call(this, player, options) || this;\r\n\r\n      _this.update();\r\n\r\n      _this.update_ = function (e) {\r\n        return _this.update(e);\r\n      };\r\n\r\n      player.on('posterchange', _this.update_);\r\n      return _this;\r\n    }\r\n    /**\r\n     * Clean up and dispose of the `PosterImage`.\r\n     */\r\n\r\n\r\n    var _proto = PosterImage.prototype;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.player().off('posterchange', this.update_);\r\n\r\n      _ClickableComponent.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Create the `PosterImage`s DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var el = createEl('div', {\r\n        className: 'vjs-poster',\r\n        // Don't want poster to be tabbable.\r\n        tabIndex: -1\r\n      });\r\n      return el;\r\n    }\r\n    /**\r\n     * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\r\n     *\r\n     * @listens Player#posterchange\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `Player#posterchange` event that triggered this function.\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(event) {\r\n      var url = this.player().poster();\r\n      this.setSrc(url); // If there's no poster source we should display:none on this component\r\n      // so it's not still clickable or right-clickable\r\n\r\n      if (url) {\r\n        this.show();\r\n      } else {\r\n        this.hide();\r\n      }\r\n    }\r\n    /**\r\n     * Set the source of the `PosterImage` depending on the display method.\r\n     *\r\n     * @param {string} url\r\n     *        The URL to the source for the `PosterImage`.\r\n     */\r\n    ;\r\n\r\n    _proto.setSrc = function setSrc(url) {\r\n      var backgroundImage = ''; // Any falsy value should stay as an empty string, otherwise\r\n      // this will throw an extra error\r\n\r\n      if (url) {\r\n        backgroundImage = \"url(\\\"\" + url + \"\\\")\";\r\n      }\r\n\r\n      this.el_.style.backgroundImage = backgroundImage;\r\n    }\r\n    /**\r\n     * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\r\n     * {@link ClickableComponent#handleClick} for instances where this will be triggered.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     * @listens keydown\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     +        The `click`, `tap` or `keydown` event that caused this function to be called.\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      // We don't want a click to trigger playback when controls are disabled\r\n      if (!this.player_.controls()) {\r\n        return;\r\n      }\r\n\r\n      var sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;\r\n\r\n      if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where\r\n      // calling .focus() on the video element causes the video to go black,\r\n      // so we avoid it in that specific case\r\n      !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {\r\n        this.player_.tech(true).focus();\r\n      }\r\n\r\n      if (this.player_.paused()) {\r\n        silencePromise(this.player_.play());\r\n      } else {\r\n        this.player_.pause();\r\n      }\r\n    };\r\n\r\n    return PosterImage;\r\n  }(ClickableComponent);\r\n\r\n  Component$1.registerComponent('PosterImage', PosterImage);\r\n\r\n  var darkGray = '#222';\r\n  var lightGray = '#ccc';\r\n  var fontMap = {\r\n    monospace: 'monospace',\r\n    sansSerif: 'sans-serif',\r\n    serif: 'serif',\r\n    monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\r\n    monospaceSerif: '\"Courier New\", monospace',\r\n    proportionalSansSerif: 'sans-serif',\r\n    proportionalSerif: 'serif',\r\n    casual: '\"Comic Sans MS\", Impact, fantasy',\r\n    script: '\"Monotype Corsiva\", cursive',\r\n    smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\r\n  };\r\n  /**\r\n   * Construct an rgba color from a given hex color code.\r\n   *\r\n   * @param {number} color\r\n   *        Hex number for color, like #f0e or #f604e2.\r\n   *\r\n   * @param {number} opacity\r\n   *        Value for opacity, 0.0 - 1.0.\r\n   *\r\n   * @return {string}\r\n   *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\r\n   */\r\n\r\n  function constructColor(color, opacity) {\r\n    var hex;\r\n\r\n    if (color.length === 4) {\r\n      // color looks like \"#f0e\"\r\n      hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\r\n    } else if (color.length === 7) {\r\n      // color looks like \"#f604e2\"\r\n      hex = color.slice(1);\r\n    } else {\r\n      throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\r\n    }\r\n\r\n    return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\r\n  }\r\n  /**\r\n   * Try to update the style of a DOM element. Some style changes will throw an error,\r\n   * particularly in IE8. Those should be noops.\r\n   *\r\n   * @param {Element} el\r\n   *        The DOM element to be styled.\r\n   *\r\n   * @param {string} style\r\n   *        The CSS property on the element that should be styled.\r\n   *\r\n   * @param {string} rule\r\n   *        The style rule that should be applied to the property.\r\n   *\r\n   * @private\r\n   */\r\n\r\n  function tryUpdateStyle(el, style, rule) {\r\n    try {\r\n      el.style[style] = rule;\r\n    } catch (e) {\r\n      // Satisfies linter.\r\n      return;\r\n    }\r\n  }\r\n  /**\r\n   * The component for displaying text track cues.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n\r\n  var TextTrackDisplay = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(TextTrackDisplay, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        The function to call when `TextTrackDisplay` is ready.\r\n     */\r\n    function TextTrackDisplay(player, options, ready) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options, ready) || this;\r\n\r\n      var updateDisplayHandler = function updateDisplayHandler(e) {\r\n        return _this.updateDisplay(e);\r\n      };\r\n\r\n      player.on('loadstart', function (e) {\r\n        return _this.toggleDisplay(e);\r\n      });\r\n      player.on('texttrackchange', updateDisplayHandler);\r\n      player.on('loadedmetadata', function (e) {\r\n        return _this.preselectTrack(e);\r\n      }); // This used to be called during player init, but was causing an error\r\n      // if a track should show by default and the display hadn't loaded yet.\r\n      // Should probably be moved to an external track loader when we support\r\n      // tracks that don't need a display.\r\n\r\n      player.ready(bind(assertThisInitialized(_this), function () {\r\n        if (player.tech_ && player.tech_.featuresNativeTextTracks) {\r\n          this.hide();\r\n          return;\r\n        }\r\n\r\n        player.on('fullscreenchange', updateDisplayHandler);\r\n        player.on('playerresize', updateDisplayHandler);\r\n        window.addEventListener('orientationchange', updateDisplayHandler);\r\n        player.on('dispose', function () {\r\n          return window.removeEventListener('orientationchange', updateDisplayHandler);\r\n        });\r\n        var tracks = this.options_.playerOptions.tracks || [];\r\n\r\n        for (var i = 0; i < tracks.length; i++) {\r\n          this.player_.addRemoteTextTrack(tracks[i], true);\r\n        }\r\n\r\n        this.preselectTrack();\r\n      }));\r\n      return _this;\r\n    }\r\n    /**\r\n    * Preselect a track following this precedence:\r\n    * - matches the previously selected {@link TextTrack}'s language and kind\r\n    * - matches the previously selected {@link TextTrack}'s language only\r\n    * - is the first default captions track\r\n    * - is the first default descriptions track\r\n    *\r\n    * @listens Player#loadstart\r\n    */\r\n\r\n\r\n    var _proto = TextTrackDisplay.prototype;\r\n\r\n    _proto.preselectTrack = function preselectTrack() {\r\n      var modes = {\r\n        captions: 1,\r\n        subtitles: 1\r\n      };\r\n      var trackList = this.player_.textTracks();\r\n      var userPref = this.player_.cache_.selectedLanguage;\r\n      var firstDesc;\r\n      var firstCaptions;\r\n      var preferredTrack;\r\n\r\n      for (var i = 0; i < trackList.length; i++) {\r\n        var track = trackList[i];\r\n\r\n        if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {\r\n          // Always choose the track that matches both language and kind\r\n          if (track.kind === userPref.kind) {\r\n            preferredTrack = track; // or choose the first track that matches language\r\n          } else if (!preferredTrack) {\r\n            preferredTrack = track;\r\n          } // clear everything if offTextTrackMenuItem was clicked\r\n\r\n        } else if (userPref && !userPref.enabled) {\r\n          preferredTrack = null;\r\n          firstDesc = null;\r\n          firstCaptions = null;\r\n        } else if (track[\"default\"]) {\r\n          if (track.kind === 'descriptions' && !firstDesc) {\r\n            firstDesc = track;\r\n          } else if (track.kind in modes && !firstCaptions) {\r\n            firstCaptions = track;\r\n          }\r\n        }\r\n      } // The preferredTrack matches the user preference and takes\r\n      // precedence over all the other tracks.\r\n      // So, display the preferredTrack before the first default track\r\n      // and the subtitles/captions track before the descriptions track\r\n\r\n\r\n      if (preferredTrack) {\r\n        preferredTrack.mode = 'showing';\r\n      } else if (firstCaptions) {\r\n        firstCaptions.mode = 'showing';\r\n      } else if (firstDesc) {\r\n        firstDesc.mode = 'showing';\r\n      }\r\n    }\r\n    /**\r\n     * Turn display of {@link TextTrack}'s from the current state into the other state.\r\n     * There are only two states:\r\n     * - 'shown'\r\n     * - 'hidden'\r\n     *\r\n     * @listens Player#loadstart\r\n     */\r\n    ;\r\n\r\n    _proto.toggleDisplay = function toggleDisplay() {\r\n      if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\r\n        this.hide();\r\n      } else {\r\n        this.show();\r\n      }\r\n    }\r\n    /**\r\n     * Create the {@link Component}'s DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-text-track-display'\r\n      }, {\r\n        'translate': 'yes',\r\n        'aria-live': 'off',\r\n        'aria-atomic': 'true'\r\n      });\r\n    }\r\n    /**\r\n     * Clear all displayed {@link TextTrack}s.\r\n     */\r\n    ;\r\n\r\n    _proto.clearDisplay = function clearDisplay() {\r\n      if (typeof window.WebVTT === 'function') {\r\n        window.WebVTT.processCues(window, [], this.el_);\r\n      }\r\n    }\r\n    /**\r\n     * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\r\n     * a {@link Player#fullscreenchange} is fired.\r\n     *\r\n     * @listens Player#texttrackchange\r\n     * @listens Player#fullscreenchange\r\n     */\r\n    ;\r\n\r\n    _proto.updateDisplay = function updateDisplay() {\r\n      var tracks = this.player_.textTracks();\r\n      var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;\r\n      this.clearDisplay();\r\n\r\n      if (allowMultipleShowingTracks) {\r\n        var showingTracks = [];\r\n\r\n        for (var _i = 0; _i < tracks.length; ++_i) {\r\n          var track = tracks[_i];\r\n\r\n          if (track.mode !== 'showing') {\r\n            continue;\r\n          }\r\n\r\n          showingTracks.push(track);\r\n        }\r\n\r\n        this.updateForTrack(showingTracks);\r\n        return;\r\n      } //  Track display prioritization model: if multiple tracks are 'showing',\r\n      //  display the first 'subtitles' or 'captions' track which is 'showing',\r\n      //  otherwise display the first 'descriptions' track which is 'showing'\r\n\r\n\r\n      var descriptionsTrack = null;\r\n      var captionsSubtitlesTrack = null;\r\n      var i = tracks.length;\r\n\r\n      while (i--) {\r\n        var _track = tracks[i];\r\n\r\n        if (_track.mode === 'showing') {\r\n          if (_track.kind === 'descriptions') {\r\n            descriptionsTrack = _track;\r\n          } else {\r\n            captionsSubtitlesTrack = _track;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (captionsSubtitlesTrack) {\r\n        if (this.getAttribute('aria-live') !== 'off') {\r\n          this.setAttribute('aria-live', 'off');\r\n        }\r\n\r\n        this.updateForTrack(captionsSubtitlesTrack);\r\n      } else if (descriptionsTrack) {\r\n        if (this.getAttribute('aria-live') !== 'assertive') {\r\n          this.setAttribute('aria-live', 'assertive');\r\n        }\r\n\r\n        this.updateForTrack(descriptionsTrack);\r\n      }\r\n    }\r\n    /**\r\n     * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.\r\n     *\r\n     * @param {TextTrack} track\r\n     *        Text track object containing active cues to style.\r\n     */\r\n    ;\r\n\r\n    _proto.updateDisplayState = function updateDisplayState(track) {\r\n      var overrides = this.player_.textTrackSettings.getValues();\r\n      var cues = track.activeCues;\r\n      var i = cues.length;\r\n\r\n      while (i--) {\r\n        var cue = cues[i];\r\n\r\n        if (!cue) {\r\n          continue;\r\n        }\r\n\r\n        var cueDiv = cue.displayState;\r\n\r\n        if (overrides.color) {\r\n          cueDiv.firstChild.style.color = overrides.color;\r\n        }\r\n\r\n        if (overrides.textOpacity) {\r\n          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\r\n        }\r\n\r\n        if (overrides.backgroundColor) {\r\n          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\r\n        }\r\n\r\n        if (overrides.backgroundOpacity) {\r\n          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\r\n        }\r\n\r\n        if (overrides.windowColor) {\r\n          if (overrides.windowOpacity) {\r\n            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\r\n          } else {\r\n            cueDiv.style.backgroundColor = overrides.windowColor;\r\n          }\r\n        }\r\n\r\n        if (overrides.edgeStyle) {\r\n          if (overrides.edgeStyle === 'dropshadow') {\r\n            cueDiv.firstChild.style.textShadow = \"2px 2px 3px \" + darkGray + \", 2px 2px 4px \" + darkGray + \", 2px 2px 5px \" + darkGray;\r\n          } else if (overrides.edgeStyle === 'raised') {\r\n            cueDiv.firstChild.style.textShadow = \"1px 1px \" + darkGray + \", 2px 2px \" + darkGray + \", 3px 3px \" + darkGray;\r\n          } else if (overrides.edgeStyle === 'depressed') {\r\n            cueDiv.firstChild.style.textShadow = \"1px 1px \" + lightGray + \", 0 1px \" + lightGray + \", -1px -1px \" + darkGray + \", 0 -1px \" + darkGray;\r\n          } else if (overrides.edgeStyle === 'uniform') {\r\n            cueDiv.firstChild.style.textShadow = \"0 0 4px \" + darkGray + \", 0 0 4px \" + darkGray + \", 0 0 4px \" + darkGray + \", 0 0 4px \" + darkGray;\r\n          }\r\n        }\r\n\r\n        if (overrides.fontPercent && overrides.fontPercent !== 1) {\r\n          var fontSize = window.parseFloat(cueDiv.style.fontSize);\r\n          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\r\n          cueDiv.style.height = 'auto';\r\n          cueDiv.style.top = 'auto';\r\n        }\r\n\r\n        if (overrides.fontFamily && overrides.fontFamily !== 'default') {\r\n          if (overrides.fontFamily === 'small-caps') {\r\n            cueDiv.firstChild.style.fontVariant = 'small-caps';\r\n          } else {\r\n            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.\r\n     *\r\n     * @param {TextTrack|TextTrack[]} tracks\r\n     *        Text track object or text track array to be added to the list.\r\n     */\r\n    ;\r\n\r\n    _proto.updateForTrack = function updateForTrack(tracks) {\r\n      if (!Array.isArray(tracks)) {\r\n        tracks = [tracks];\r\n      }\r\n\r\n      if (typeof window.WebVTT !== 'function' || tracks.every(function (track) {\r\n        return !track.activeCues;\r\n      })) {\r\n        return;\r\n      }\r\n\r\n      var cues = []; // push all active track cues\r\n\r\n      for (var i = 0; i < tracks.length; ++i) {\r\n        var track = tracks[i];\r\n\r\n        for (var j = 0; j < track.activeCues.length; ++j) {\r\n          cues.push(track.activeCues[j]);\r\n        }\r\n      } // removes all cues before it processes new ones\r\n\r\n\r\n      window.WebVTT.processCues(window, cues, this.el_); // add unique class to each language text track & add settings styling if necessary\r\n\r\n      for (var _i2 = 0; _i2 < tracks.length; ++_i2) {\r\n        var _track2 = tracks[_i2];\r\n\r\n        for (var _j = 0; _j < _track2.activeCues.length; ++_j) {\r\n          var cueEl = _track2.activeCues[_j].displayState;\r\n          addClass(cueEl, 'vjs-text-track-cue');\r\n          addClass(cueEl, 'vjs-text-track-cue-' + (_track2.language ? _track2.language : _i2));\r\n\r\n          if (_track2.language) {\r\n            setAttribute(cueEl, 'lang', _track2.language);\r\n          }\r\n        }\r\n\r\n        if (this.player_.textTrackSettings) {\r\n          this.updateDisplayState(_track2);\r\n        }\r\n      }\r\n    };\r\n\r\n    return TextTrackDisplay;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('TextTrackDisplay', TextTrackDisplay);\r\n\r\n  /**\r\n   * A loading spinner for use during waiting/loading events.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var LoadingSpinner = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(LoadingSpinner, _Component);\r\n\r\n    function LoadingSpinner() {\r\n      return _Component.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = LoadingSpinner.prototype;\r\n\r\n    /**\r\n     * Create the `LoadingSpinner`s DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         The dom element that gets created.\r\n     */\r\n    _proto.createEl = function createEl$1() {\r\n      var isAudio = this.player_.isAudio();\r\n      var playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\r\n      var controlText = createEl('span', {\r\n        className: 'vjs-control-text',\r\n        textContent: this.localize('{1} is loading.', [playerType])\r\n      });\r\n\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-loading-spinner',\r\n        dir: 'ltr'\r\n      });\r\n\r\n      el.appendChild(controlText);\r\n      return el;\r\n    };\r\n\r\n    return LoadingSpinner;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('LoadingSpinner', LoadingSpinner);\r\n\r\n  /**\r\n   * Base class for all buttons.\r\n   *\r\n   * @extends ClickableComponent\r\n   */\r\n\r\n  var Button = /*#__PURE__*/function (_ClickableComponent) {\r\n    inheritsLoose(Button, _ClickableComponent);\r\n\r\n    function Button() {\r\n      return _ClickableComponent.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = Button.prototype;\r\n\r\n    /**\r\n     * Create the `Button`s DOM element.\r\n     *\r\n     * @param {string} [tag=\"button\"]\r\n     *        The element's node type. This argument is IGNORED: no matter what\r\n     *        is passed, it will always create a `button` element.\r\n     *\r\n     * @param {Object} [props={}]\r\n     *        An object of properties that should be set on the element.\r\n     *\r\n     * @param {Object} [attributes={}]\r\n     *        An object of attributes that should be set on the element.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n    _proto.createEl = function createEl$1(tag, props, attributes) {\r\n      if (props === void 0) {\r\n        props = {};\r\n      }\r\n\r\n      if (attributes === void 0) {\r\n        attributes = {};\r\n      }\r\n\r\n      tag = 'button';\r\n      props = assign({\r\n        className: this.buildCSSClass()\r\n      }, props); // Add attributes for button element\r\n\r\n      attributes = assign({\r\n        // Necessary since the default button type is \"submit\"\r\n        type: 'button'\r\n      }, attributes);\r\n\r\n      var el = createEl(tag, props, attributes);\r\n\r\n      el.appendChild(createEl('span', {\r\n        className: 'vjs-icon-placeholder'\r\n      }, {\r\n        'aria-hidden': true\r\n      }));\r\n      this.createControlTextEl(el);\r\n      return el;\r\n    }\r\n    /**\r\n     * Add a child `Component` inside of this `Button`.\r\n     *\r\n     * @param {string|Component} child\r\n     *        The name or instance of a child to add.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of options that will get passed to children of\r\n     *        the child.\r\n     *\r\n     * @return {Component}\r\n     *         The `Component` that gets added as a child. When using a string the\r\n     *         `Component` will get created by this process.\r\n     *\r\n     * @deprecated since version 5\r\n     */\r\n    ;\r\n\r\n    _proto.addChild = function addChild(child, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var className = this.constructor.name;\r\n      log$1.warn(\"Adding an actionable (user controllable) child to a Button (\" + className + \") is not supported; use a ClickableComponent instead.\"); // Avoid the error message generated by ClickableComponent's addChild method\r\n\r\n      return Component$1.prototype.addChild.call(this, child, options);\r\n    }\r\n    /**\r\n     * Enable the `Button` element so that it can be activated or clicked. Use this with\r\n     * {@link Button#disable}.\r\n     */\r\n    ;\r\n\r\n    _proto.enable = function enable() {\r\n      _ClickableComponent.prototype.enable.call(this);\r\n\r\n      this.el_.removeAttribute('disabled');\r\n    }\r\n    /**\r\n     * Disable the `Button` element so that it cannot be activated or clicked. Use this with\r\n     * {@link Button#enable}.\r\n     */\r\n    ;\r\n\r\n    _proto.disable = function disable() {\r\n      _ClickableComponent.prototype.disable.call(this);\r\n\r\n      this.el_.setAttribute('disabled', 'disabled');\r\n    }\r\n    /**\r\n     * This gets called when a `Button` has focus and `keydown` is triggered via a key\r\n     * press.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to get called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Ignore Space or Enter key operation, which is handled by the browser for\r\n      // a button - though not for its super class, ClickableComponent. Also,\r\n      // prevent the event from propagating through the DOM and triggering Player\r\n      // hotkeys. We do not preventDefault here because we _want_ the browser to\r\n      // handle it.\r\n      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\r\n        event.stopPropagation();\r\n        return;\r\n      } // Pass keypress handling up for unsupported keys\r\n\r\n\r\n      _ClickableComponent.prototype.handleKeyDown.call(this, event);\r\n    };\r\n\r\n    return Button;\r\n  }(ClickableComponent);\r\n\r\n  Component$1.registerComponent('Button', Button);\r\n\r\n  /**\r\n   * The initial play button that shows before the video has played. The hiding of the\r\n   * `BigPlayButton` get done via CSS and `Player` states.\r\n   *\r\n   * @extends Button\r\n   */\r\n\r\n  var BigPlayButton = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(BigPlayButton, _Button);\r\n\r\n    function BigPlayButton(player, options) {\r\n      var _this;\r\n\r\n      _this = _Button.call(this, player, options) || this;\r\n      _this.mouseused_ = false;\r\n\r\n      _this.on('mousedown', function (e) {\r\n        return _this.handleMouseDown(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\r\n     */\r\n\r\n\r\n    var _proto = BigPlayButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return 'vjs-big-play-button';\r\n    }\r\n    /**\r\n     * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\r\n     * for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      var playPromise = this.player_.play(); // exit early if clicked via the mouse\r\n\r\n      if (this.mouseused_ && event.clientX && event.clientY) {\r\n        var sourceIsEncrypted = this.player_.usingPlugin('eme') && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;\r\n        silencePromise(playPromise);\r\n\r\n        if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where\r\n        // calling .focus() on the video element causes the video to go black,\r\n        // so we avoid it in that specific case\r\n        !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {\r\n          this.player_.tech(true).focus();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      var cb = this.player_.getChild('controlBar');\r\n      var playToggle = cb && cb.getChild('playToggle');\r\n\r\n      if (!playToggle) {\r\n        this.player_.tech(true).focus();\r\n        return;\r\n      }\r\n\r\n      var playFocus = function playFocus() {\r\n        return playToggle.focus();\r\n      };\r\n\r\n      if (isPromise(playPromise)) {\r\n        playPromise.then(playFocus, function () {});\r\n      } else {\r\n        this.setTimeout(playFocus, 1);\r\n      }\r\n    };\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      this.mouseused_ = false;\r\n\r\n      _Button.prototype.handleKeyDown.call(this, event);\r\n    };\r\n\r\n    _proto.handleMouseDown = function handleMouseDown(event) {\r\n      this.mouseused_ = true;\r\n    };\r\n\r\n    return BigPlayButton;\r\n  }(Button);\r\n  /**\r\n   * The text that should display over the `BigPlayButton`s controls. Added to for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  BigPlayButton.prototype.controlText_ = 'Play Video';\r\n  Component$1.registerComponent('BigPlayButton', BigPlayButton);\r\n\r\n  /**\r\n   * The `CloseButton` is a `{@link Button}` that fires a `close` event when\r\n   * it gets clicked.\r\n   *\r\n   * @extends Button\r\n   */\r\n\r\n  var CloseButton = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(CloseButton, _Button);\r\n\r\n    /**\r\n    * Creates an instance of the this class.\r\n    *\r\n    * @param  {Player} player\r\n    *         The `Player` that this class should be attached to.\r\n    *\r\n    * @param  {Object} [options]\r\n    *         The key/value store of player options.\r\n    */\r\n    function CloseButton(player, options) {\r\n      var _this;\r\n\r\n      _this = _Button.call(this, player, options) || this;\r\n\r\n      _this.controlText(options && options.controlText || _this.localize('Close'));\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n    * Builds the default DOM `className`.\r\n    *\r\n    * @return {string}\r\n    *         The DOM `className` for this object.\r\n    */\r\n\r\n\r\n    var _proto = CloseButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-close-button \" + _Button.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * This gets called when a `CloseButton` gets clicked. See\r\n     * {@link ClickableComponent#handleClick} for more information on when\r\n     * this will be triggered\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     * @fires CloseButton#close\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      /**\r\n       * Triggered when the a `CloseButton` is clicked.\r\n       *\r\n       * @event CloseButton#close\r\n       * @type {EventTarget~Event}\r\n       *\r\n       * @property {boolean} [bubbles=false]\r\n       *           set to false so that the close event does not\r\n       *           bubble up to parents if there is no listener\r\n       */\r\n      this.trigger({\r\n        type: 'close',\r\n        bubbles: false\r\n      });\r\n    }\r\n    /**\r\n     * Event handler that is called when a `CloseButton` receives a\r\n     * `keydown` event.\r\n     *\r\n     * By default, if the key is Esc, it will trigger a `click` event.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Esc button will trigger `click` event\r\n      if (keycode.isEventKey(event, 'Esc')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.trigger('click');\r\n      } else {\r\n        // Pass keypress handling up for unsupported keys\r\n        _Button.prototype.handleKeyDown.call(this, event);\r\n      }\r\n    };\r\n\r\n    return CloseButton;\r\n  }(Button);\r\n\r\n  Component$1.registerComponent('CloseButton', CloseButton);\r\n\r\n  /**\r\n   * Button to toggle between play and pause.\r\n   *\r\n   * @extends Button\r\n   */\r\n\r\n  var PlayToggle = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(PlayToggle, _Button);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     */\r\n    function PlayToggle(player, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _Button.call(this, player, options) || this; // show or hide replay icon\r\n\r\n      options.replay = options.replay === undefined || options.replay;\r\n\r\n      _this.on(player, 'play', function (e) {\r\n        return _this.handlePlay(e);\r\n      });\r\n\r\n      _this.on(player, 'pause', function (e) {\r\n        return _this.handlePause(e);\r\n      });\r\n\r\n      if (options.replay) {\r\n        _this.on(player, 'ended', function (e) {\r\n          return _this.handleEnded(e);\r\n        });\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = PlayToggle.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-play-control \" + _Button.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * This gets called when an `PlayToggle` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      if (this.player_.paused()) {\r\n        silencePromise(this.player_.play());\r\n      } else {\r\n        this.player_.pause();\r\n      }\r\n    }\r\n    /**\r\n     * This gets called once after the video has ended and the user seeks so that\r\n     * we can change the replay button back to a play button.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens Player#seeked\r\n     */\r\n    ;\r\n\r\n    _proto.handleSeeked = function handleSeeked(event) {\r\n      this.removeClass('vjs-ended');\r\n\r\n      if (this.player_.paused()) {\r\n        this.handlePause(event);\r\n      } else {\r\n        this.handlePlay(event);\r\n      }\r\n    }\r\n    /**\r\n     * Add the vjs-playing class to the element so it can change appearance.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens Player#play\r\n     */\r\n    ;\r\n\r\n    _proto.handlePlay = function handlePlay(event) {\r\n      this.removeClass('vjs-ended');\r\n      this.removeClass('vjs-paused');\r\n      this.addClass('vjs-playing'); // change the button text to \"Pause\"\r\n\r\n      this.controlText('Pause');\r\n    }\r\n    /**\r\n     * Add the vjs-paused class to the element so it can change appearance.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens Player#pause\r\n     */\r\n    ;\r\n\r\n    _proto.handlePause = function handlePause(event) {\r\n      this.removeClass('vjs-playing');\r\n      this.addClass('vjs-paused'); // change the button text to \"Play\"\r\n\r\n      this.controlText('Play');\r\n    }\r\n    /**\r\n     * Add the vjs-ended class to the element so it can change appearance\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens Player#ended\r\n     */\r\n    ;\r\n\r\n    _proto.handleEnded = function handleEnded(event) {\r\n      var _this2 = this;\r\n\r\n      this.removeClass('vjs-playing');\r\n      this.addClass('vjs-ended'); // change the button text to \"Replay\"\r\n\r\n      this.controlText('Replay'); // on the next seek remove the replay button\r\n\r\n      this.one(this.player_, 'seeked', function (e) {\r\n        return _this2.handleSeeked(e);\r\n      });\r\n    };\r\n\r\n    return PlayToggle;\r\n  }(Button);\r\n  /**\r\n   * The text that should display over the `PlayToggle`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  PlayToggle.prototype.controlText_ = 'Play';\r\n  Component$1.registerComponent('PlayToggle', PlayToggle);\r\n\r\n  /**\r\n   * @file format-time.js\r\n   * @module format-time\r\n   */\r\n\r\n  /**\r\n   * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in\r\n   * seconds) will force a number of leading zeros to cover the length of the\r\n   * guide.\r\n   *\r\n   * @private\r\n   * @param  {number} seconds\r\n   *         Number of seconds to be turned into a string\r\n   *\r\n   * @param  {number} guide\r\n   *         Number (in seconds) to model the string after\r\n   *\r\n   * @return {string}\r\n   *         Time formatted as H:MM:SS or M:SS\r\n   */\r\n  var defaultImplementation = function defaultImplementation(seconds, guide) {\r\n    seconds = seconds < 0 ? 0 : seconds;\r\n    var s = Math.floor(seconds % 60);\r\n    var m = Math.floor(seconds / 60 % 60);\r\n    var h = Math.floor(seconds / 3600);\r\n    var gm = Math.floor(guide / 60 % 60);\r\n    var gh = Math.floor(guide / 3600); // handle invalid times\r\n\r\n    if (isNaN(seconds) || seconds === Infinity) {\r\n      // '-' is false for all relational operators (e.g. <, >=) so this setting\r\n      // will add the minimum number of fields specified by the guide\r\n      h = m = s = '-';\r\n    } // Check if we need to show hours\r\n\r\n\r\n    h = h > 0 || gh > 0 ? h + ':' : ''; // If hours are showing, we may need to add a leading zero.\r\n    // Always show at least one digit of minutes.\r\n\r\n    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':'; // Check if leading zero is need for seconds\r\n\r\n    s = s < 10 ? '0' + s : s;\r\n    return h + m + s;\r\n  }; // Internal pointer to the current implementation.\r\n\r\n\r\n  var implementation = defaultImplementation;\r\n  /**\r\n   * Replaces the default formatTime implementation with a custom implementation.\r\n   *\r\n   * @param {Function} customImplementation\r\n   *        A function which will be used in place of the default formatTime\r\n   *        implementation. Will receive the current time in seconds and the\r\n   *        guide (in seconds) as arguments.\r\n   */\r\n\r\n  function setFormatTime(customImplementation) {\r\n    implementation = customImplementation;\r\n  }\r\n  /**\r\n   * Resets formatTime to the default implementation.\r\n   */\r\n\r\n  function resetFormatTime() {\r\n    implementation = defaultImplementation;\r\n  }\r\n  /**\r\n   * Delegates to either the default time formatting function or a custom\r\n   * function supplied via `setFormatTime`.\r\n   *\r\n   * Formats seconds as a time string (H:MM:SS or M:SS). Supplying a\r\n   * guide (in seconds) will force a number of leading zeros to cover the\r\n   * length of the guide.\r\n   *\r\n   * @static\r\n   * @example  formatTime(125, 600) === \"02:05\"\r\n   * @param    {number} seconds\r\n   *           Number of seconds to be turned into a string\r\n   *\r\n   * @param    {number} guide\r\n   *           Number (in seconds) to model the string after\r\n   *\r\n   * @return   {string}\r\n   *           Time formatted as H:MM:SS or M:SS\r\n   */\r\n\r\n  function formatTime(seconds, guide) {\r\n    if (guide === void 0) {\r\n      guide = seconds;\r\n    }\r\n\r\n    return implementation(seconds, guide);\r\n  }\r\n\r\n  /**\r\n   * Displays time information about the video\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var TimeDisplay = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(TimeDisplay, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function TimeDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n\r\n      _this.on(player, ['timeupdate', 'ended'], function (e) {\r\n        return _this.updateContent(e);\r\n      });\r\n\r\n      _this.updateTextNode_();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = TimeDisplay.prototype;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var className = this.buildCSSClass();\r\n\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        className: className + \" vjs-time-control vjs-control\"\r\n      });\r\n\r\n      var span = createEl('span', {\r\n        className: 'vjs-control-text',\r\n        textContent: this.localize(this.labelText_) + \"\\xA0\"\r\n      }, {\r\n        role: 'presentation'\r\n      });\r\n      el.appendChild(span);\r\n      this.contentEl_ = createEl('span', {\r\n        className: className + \"-display\"\r\n      }, {\r\n        // tell screen readers not to automatically read the time as it changes\r\n        'aria-live': 'off',\r\n        // span elements have no implicit role, but some screen readers (notably VoiceOver)\r\n        // treat them as a break between items in the DOM when using arrow keys\r\n        // (or left-to-right swipes on iOS) to read contents of a page. Using\r\n        // role='presentation' causes VoiceOver to NOT treat this span as a break.\r\n        'role': 'presentation'\r\n      });\r\n      el.appendChild(this.contentEl_);\r\n      return el;\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.contentEl_ = null;\r\n      this.textNode_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Updates the time display text node with a new time\r\n     *\r\n     * @param {number} [time=0] the time to update to\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.updateTextNode_ = function updateTextNode_(time) {\r\n      var _this2 = this;\r\n\r\n      if (time === void 0) {\r\n        time = 0;\r\n      }\r\n\r\n      time = formatTime(time);\r\n\r\n      if (this.formattedTime_ === time) {\r\n        return;\r\n      }\r\n\r\n      this.formattedTime_ = time;\r\n      this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', function () {\r\n        if (!_this2.contentEl_) {\r\n          return;\r\n        }\r\n\r\n        var oldNode = _this2.textNode_;\r\n\r\n        if (oldNode && _this2.contentEl_.firstChild !== oldNode) {\r\n          oldNode = null;\r\n          log$1.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');\r\n        }\r\n\r\n        _this2.textNode_ = document.createTextNode(_this2.formattedTime_);\r\n\r\n        if (!_this2.textNode_) {\r\n          return;\r\n        }\r\n\r\n        if (oldNode) {\r\n          _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);\r\n        } else {\r\n          _this2.contentEl_.appendChild(_this2.textNode_);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * To be filled out in the child class, should update the displayed time\r\n     * in accordance with the fact that the current time has changed.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `timeupdate`  event that caused this to run.\r\n     *\r\n     * @listens Player#timeupdate\r\n     */\r\n    ;\r\n\r\n    _proto.updateContent = function updateContent(event) {};\r\n\r\n    return TimeDisplay;\r\n  }(Component$1);\r\n  /**\r\n   * The text that is added to the `TimeDisplay` for screen reader users.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  TimeDisplay.prototype.labelText_ = 'Time';\r\n  /**\r\n   * The text that should display over the `TimeDisplay`s controls. Added to for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   *\r\n   * @deprecated in v7; controlText_ is not used in non-active display Components\r\n   */\r\n\r\n  TimeDisplay.prototype.controlText_ = 'Time';\r\n  Component$1.registerComponent('TimeDisplay', TimeDisplay);\r\n\r\n  /**\r\n   * Displays the current time\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var CurrentTimeDisplay = /*#__PURE__*/function (_TimeDisplay) {\r\n    inheritsLoose(CurrentTimeDisplay, _TimeDisplay);\r\n\r\n    function CurrentTimeDisplay() {\r\n      return _TimeDisplay.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = CurrentTimeDisplay.prototype;\r\n\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return 'vjs-current-time';\r\n    }\r\n    /**\r\n     * Update current time display\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `timeupdate` event that caused this function to run.\r\n     *\r\n     * @listens Player#timeupdate\r\n     */\r\n    ;\r\n\r\n    _proto.updateContent = function updateContent(event) {\r\n      // Allows for smooth scrubbing, when player can't keep up.\r\n      var time;\r\n\r\n      if (this.player_.ended()) {\r\n        time = this.player_.duration();\r\n      } else {\r\n        time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\r\n      }\r\n\r\n      this.updateTextNode_(time);\r\n    };\r\n\r\n    return CurrentTimeDisplay;\r\n  }(TimeDisplay);\r\n  /**\r\n   * The text that is added to the `CurrentTimeDisplay` for screen reader users.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  CurrentTimeDisplay.prototype.labelText_ = 'Current Time';\r\n  /**\r\n   * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   *\r\n   * @deprecated in v7; controlText_ is not used in non-active display Components\r\n   */\r\n\r\n  CurrentTimeDisplay.prototype.controlText_ = 'Current Time';\r\n  Component$1.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\r\n\r\n  /**\r\n   * Displays the duration\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var DurationDisplay = /*#__PURE__*/function (_TimeDisplay) {\r\n    inheritsLoose(DurationDisplay, _TimeDisplay);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function DurationDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _TimeDisplay.call(this, player, options) || this;\r\n\r\n      var updateContent = function updateContent(e) {\r\n        return _this.updateContent(e);\r\n      }; // we do not want to/need to throttle duration changes,\r\n      // as they should always display the changed duration as\r\n      // it has changed\r\n\r\n\r\n      _this.on(player, 'durationchange', updateContent); // Listen to loadstart because the player duration is reset when a new media element is loaded,\r\n      // but the durationchange on the user agent will not fire.\r\n      // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\r\n\r\n\r\n      _this.on(player, 'loadstart', updateContent); // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\r\n      // listeners could have broken dependent applications/libraries. These\r\n      // can likely be removed for 7.0.\r\n\r\n\r\n      _this.on(player, 'loadedmetadata', updateContent);\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = DurationDisplay.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return 'vjs-duration';\r\n    }\r\n    /**\r\n     * Update duration time display.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\r\n     *        this function to be called.\r\n     *\r\n     * @listens Player#durationchange\r\n     * @listens Player#timeupdate\r\n     * @listens Player#loadedmetadata\r\n     */\r\n    ;\r\n\r\n    _proto.updateContent = function updateContent(event) {\r\n      var duration = this.player_.duration();\r\n      this.updateTextNode_(duration);\r\n    };\r\n\r\n    return DurationDisplay;\r\n  }(TimeDisplay);\r\n  /**\r\n   * The text that is added to the `DurationDisplay` for screen reader users.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  DurationDisplay.prototype.labelText_ = 'Duration';\r\n  /**\r\n   * The text that should display over the `DurationDisplay`s controls. Added to for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   *\r\n   * @deprecated in v7; controlText_ is not used in non-active display Components\r\n   */\r\n\r\n  DurationDisplay.prototype.controlText_ = 'Duration';\r\n  Component$1.registerComponent('DurationDisplay', DurationDisplay);\r\n\r\n  /**\r\n   * The separator between the current time and duration.\r\n   * Can be hidden if it's not needed in the design.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var TimeDivider = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(TimeDivider, _Component);\r\n\r\n    function TimeDivider() {\r\n      return _Component.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = TimeDivider.prototype;\r\n\r\n    /**\r\n     * Create the component's DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    _proto.createEl = function createEl() {\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-time-control vjs-time-divider'\r\n      }, {\r\n        // this element and its contents can be hidden from assistive techs since\r\n        // it is made extraneous by the announcement of the control text\r\n        // for the current time and duration displays\r\n        'aria-hidden': true\r\n      });\r\n\r\n      var div = _Component.prototype.createEl.call(this, 'div');\r\n\r\n      var span = _Component.prototype.createEl.call(this, 'span', {\r\n        textContent: '/'\r\n      });\r\n\r\n      div.appendChild(span);\r\n      el.appendChild(div);\r\n      return el;\r\n    };\r\n\r\n    return TimeDivider;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('TimeDivider', TimeDivider);\r\n\r\n  /**\r\n   * Displays the time left in the video\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var RemainingTimeDisplay = /*#__PURE__*/function (_TimeDisplay) {\r\n    inheritsLoose(RemainingTimeDisplay, _TimeDisplay);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function RemainingTimeDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _TimeDisplay.call(this, player, options) || this;\r\n\r\n      _this.on(player, 'durationchange', function (e) {\r\n        return _this.updateContent(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = RemainingTimeDisplay.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return 'vjs-remaining-time';\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element with the \"minus\" characted prepend to the time\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var el = _TimeDisplay.prototype.createEl.call(this);\r\n\r\n      if (this.options_.displayNegative !== false) {\r\n        el.insertBefore(createEl('span', {}, {\r\n          'aria-hidden': true\r\n        }, '-'), this.contentEl_);\r\n      }\r\n\r\n      return el;\r\n    }\r\n    /**\r\n     * Update remaining time display.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `timeupdate` or `durationchange` event that caused this to run.\r\n     *\r\n     * @listens Player#timeupdate\r\n     * @listens Player#durationchange\r\n     */\r\n    ;\r\n\r\n    _proto.updateContent = function updateContent(event) {\r\n      if (typeof this.player_.duration() !== 'number') {\r\n        return;\r\n      }\r\n\r\n      var time; // @deprecated We should only use remainingTimeDisplay\r\n      // as of video.js 7\r\n\r\n      if (this.player_.ended()) {\r\n        time = 0;\r\n      } else if (this.player_.remainingTimeDisplay) {\r\n        time = this.player_.remainingTimeDisplay();\r\n      } else {\r\n        time = this.player_.remainingTime();\r\n      }\r\n\r\n      this.updateTextNode_(time);\r\n    };\r\n\r\n    return RemainingTimeDisplay;\r\n  }(TimeDisplay);\r\n  /**\r\n   * The text that is added to the `RemainingTimeDisplay` for screen reader users.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\r\n  /**\r\n   * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   *\r\n   * @deprecated in v7; controlText_ is not used in non-active display Components\r\n   */\r\n\r\n  RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\r\n  Component$1.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\r\n\r\n  /**\r\n   * Displays the live indicator when duration is Infinity.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var LiveDisplay = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(LiveDisplay, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function LiveDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n\r\n      _this.updateShowing();\r\n\r\n      _this.on(_this.player(), 'durationchange', function (e) {\r\n        return _this.updateShowing(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = LiveDisplay.prototype;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-live-control vjs-control'\r\n      });\r\n\r\n      this.contentEl_ = createEl('div', {\r\n        className: 'vjs-live-display'\r\n      }, {\r\n        'aria-live': 'off'\r\n      });\r\n      this.contentEl_.appendChild(createEl('span', {\r\n        className: 'vjs-control-text',\r\n        textContent: this.localize('Stream Type') + \"\\xA0\"\r\n      }));\r\n      this.contentEl_.appendChild(document.createTextNode(this.localize('LIVE')));\r\n      el.appendChild(this.contentEl_);\r\n      return el;\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.contentEl_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\r\n     * it accordingly\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The {@link Player#durationchange} event that caused this function to run.\r\n     *\r\n     * @listens Player#durationchange\r\n     */\r\n    ;\r\n\r\n    _proto.updateShowing = function updateShowing(event) {\r\n      if (this.player().duration() === Infinity) {\r\n        this.show();\r\n      } else {\r\n        this.hide();\r\n      }\r\n    };\r\n\r\n    return LiveDisplay;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('LiveDisplay', LiveDisplay);\r\n\r\n  /**\r\n   * Displays the live indicator when duration is Infinity.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var SeekToLive = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(SeekToLive, _Button);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function SeekToLive(player, options) {\r\n      var _this;\r\n\r\n      _this = _Button.call(this, player, options) || this;\r\n\r\n      _this.updateLiveEdgeStatus();\r\n\r\n      if (_this.player_.liveTracker) {\r\n        _this.updateLiveEdgeStatusHandler_ = function (e) {\r\n          return _this.updateLiveEdgeStatus(e);\r\n        };\r\n\r\n        _this.on(_this.player_.liveTracker, 'liveedgechange', _this.updateLiveEdgeStatusHandler_);\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = SeekToLive.prototype;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var el = _Button.prototype.createEl.call(this, 'button', {\r\n        className: 'vjs-seek-to-live-control vjs-control'\r\n      });\r\n\r\n      this.textEl_ = createEl('span', {\r\n        className: 'vjs-seek-to-live-text',\r\n        textContent: this.localize('LIVE')\r\n      }, {\r\n        'aria-hidden': 'true'\r\n      });\r\n      el.appendChild(this.textEl_);\r\n      return el;\r\n    }\r\n    /**\r\n     * Update the state of this button if we are at the live edge\r\n     * or not\r\n     */\r\n    ;\r\n\r\n    _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {\r\n      // default to live edge\r\n      if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {\r\n        this.setAttribute('aria-disabled', true);\r\n        this.addClass('vjs-at-live-edge');\r\n        this.controlText('Seek to live, currently playing live');\r\n      } else {\r\n        this.setAttribute('aria-disabled', false);\r\n        this.removeClass('vjs-at-live-edge');\r\n        this.controlText('Seek to live, currently behind live');\r\n      }\r\n    }\r\n    /**\r\n     * On click bring us as near to the live point as possible.\r\n     * This requires that we wait for the next `live-seekable-change`\r\n     * event which will happen every segment length seconds.\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick() {\r\n      this.player_.liveTracker.seekToLiveEdge();\r\n    }\r\n    /**\r\n     * Dispose of the element and stop tracking\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      if (this.player_.liveTracker) {\r\n        this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\r\n      }\r\n\r\n      this.textEl_ = null;\r\n\r\n      _Button.prototype.dispose.call(this);\r\n    };\r\n\r\n    return SeekToLive;\r\n  }(Button);\r\n\r\n  SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';\r\n  Component$1.registerComponent('SeekToLive', SeekToLive);\r\n\r\n  /**\r\n   * Keep a number between a min and a max value\r\n   *\r\n   * @param {number} number\r\n   *        The number to clamp\r\n   *\r\n   * @param {number} min\r\n   *        The minimum value\r\n   * @param {number} max\r\n   *        The maximum value\r\n   *\r\n   * @return {number}\r\n   *         the clamped number\r\n   */\r\n  var clamp = function clamp(number, min, max) {\r\n    number = Number(number);\r\n    return Math.min(max, Math.max(min, isNaN(number) ? min : number));\r\n  };\r\n\r\n  /**\r\n   * The base functionality for a slider. Can be vertical or horizontal.\r\n   * For instance the volume bar or the seek bar on a video is a slider.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var Slider = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(Slider, _Component);\r\n\r\n    /**\r\n    * Create an instance of this class\r\n    *\r\n    * @param {Player} player\r\n    *        The `Player` that this class should be attached to.\r\n    *\r\n    * @param {Object} [options]\r\n    *        The key/value store of player options.\r\n    */\r\n    function Slider(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n\r\n      _this.handleMouseDown_ = function (e) {\r\n        return _this.handleMouseDown(e);\r\n      };\r\n\r\n      _this.handleMouseUp_ = function (e) {\r\n        return _this.handleMouseUp(e);\r\n      };\r\n\r\n      _this.handleKeyDown_ = function (e) {\r\n        return _this.handleKeyDown(e);\r\n      };\r\n\r\n      _this.handleClick_ = function (e) {\r\n        return _this.handleClick(e);\r\n      };\r\n\r\n      _this.handleMouseMove_ = function (e) {\r\n        return _this.handleMouseMove(e);\r\n      };\r\n\r\n      _this.update_ = function (e) {\r\n        return _this.update(e);\r\n      }; // Set property names to bar to match with the child Slider class is looking for\r\n\r\n\r\n      _this.bar = _this.getChild(_this.options_.barName); // Set a horizontal or vertical class on the slider depending on the slider type\r\n\r\n      _this.vertical(!!_this.options_.vertical);\r\n\r\n      _this.enable();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Are controls are currently enabled for this slider or not.\r\n     *\r\n     * @return {boolean}\r\n     *         true if controls are enabled, false otherwise\r\n     */\r\n\r\n\r\n    var _proto = Slider.prototype;\r\n\r\n    _proto.enabled = function enabled() {\r\n      return this.enabled_;\r\n    }\r\n    /**\r\n     * Enable controls for this slider if they are disabled\r\n     */\r\n    ;\r\n\r\n    _proto.enable = function enable() {\r\n      if (this.enabled()) {\r\n        return;\r\n      }\r\n\r\n      this.on('mousedown', this.handleMouseDown_);\r\n      this.on('touchstart', this.handleMouseDown_);\r\n      this.on('keydown', this.handleKeyDown_);\r\n      this.on('click', this.handleClick_); // TODO: deprecated, controlsvisible does not seem to be fired\r\n\r\n      this.on(this.player_, 'controlsvisible', this.update);\r\n\r\n      if (this.playerEvent) {\r\n        this.on(this.player_, this.playerEvent, this.update);\r\n      }\r\n\r\n      this.removeClass('disabled');\r\n      this.setAttribute('tabindex', 0);\r\n      this.enabled_ = true;\r\n    }\r\n    /**\r\n     * Disable controls for this slider if they are enabled\r\n     */\r\n    ;\r\n\r\n    _proto.disable = function disable() {\r\n      if (!this.enabled()) {\r\n        return;\r\n      }\r\n\r\n      var doc = this.bar.el_.ownerDocument;\r\n      this.off('mousedown', this.handleMouseDown_);\r\n      this.off('touchstart', this.handleMouseDown_);\r\n      this.off('keydown', this.handleKeyDown_);\r\n      this.off('click', this.handleClick_);\r\n      this.off(this.player_, 'controlsvisible', this.update_);\r\n      this.off(doc, 'mousemove', this.handleMouseMove_);\r\n      this.off(doc, 'mouseup', this.handleMouseUp_);\r\n      this.off(doc, 'touchmove', this.handleMouseMove_);\r\n      this.off(doc, 'touchend', this.handleMouseUp_);\r\n      this.removeAttribute('tabindex');\r\n      this.addClass('disabled');\r\n\r\n      if (this.playerEvent) {\r\n        this.off(this.player_, this.playerEvent, this.update);\r\n      }\r\n\r\n      this.enabled_ = false;\r\n    }\r\n    /**\r\n     * Create the `Slider`s DOM element.\r\n     *\r\n     * @param {string} type\r\n     *        Type of element to create.\r\n     *\r\n     * @param {Object} [props={}]\r\n     *        List of properties in Object form.\r\n     *\r\n     * @param {Object} [attributes={}]\r\n     *        list of attributes in Object form.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl(type, props, attributes) {\r\n      if (props === void 0) {\r\n        props = {};\r\n      }\r\n\r\n      if (attributes === void 0) {\r\n        attributes = {};\r\n      }\r\n\r\n      // Add the slider element class to all sub classes\r\n      props.className = props.className + ' vjs-slider';\r\n      props = assign({\r\n        tabIndex: 0\r\n      }, props);\r\n      attributes = assign({\r\n        'role': 'slider',\r\n        'aria-valuenow': 0,\r\n        'aria-valuemin': 0,\r\n        'aria-valuemax': 100,\r\n        'tabIndex': 0\r\n      }, attributes);\r\n      return _Component.prototype.createEl.call(this, type, props, attributes);\r\n    }\r\n    /**\r\n     * Handle `mousedown` or `touchstart` events on the `Slider`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mousedown` or `touchstart` event that triggered this function\r\n     *\r\n     * @listens mousedown\r\n     * @listens touchstart\r\n     * @fires Slider#slideractive\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseDown = function handleMouseDown(event) {\r\n      var doc = this.bar.el_.ownerDocument;\r\n\r\n      if (event.type === 'mousedown') {\r\n        event.preventDefault();\r\n      } // Do not call preventDefault() on touchstart in Chrome\r\n      // to avoid console warnings. Use a 'touch-action: none' style\r\n      // instead to prevent unintented scrolling.\r\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\r\n\r\n\r\n      if (event.type === 'touchstart' && !IS_CHROME) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      blockTextSelection();\r\n      this.addClass('vjs-sliding');\r\n      /**\r\n       * Triggered when the slider is in an active state\r\n       *\r\n       * @event Slider#slideractive\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('slideractive');\r\n      this.on(doc, 'mousemove', this.handleMouseMove_);\r\n      this.on(doc, 'mouseup', this.handleMouseUp_);\r\n      this.on(doc, 'touchmove', this.handleMouseMove_);\r\n      this.on(doc, 'touchend', this.handleMouseUp_);\r\n      this.handleMouseMove(event, true);\r\n    }\r\n    /**\r\n     * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\r\n     * The `mousemove` and `touchmove` events will only only trigger this function during\r\n     * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\r\n     * {@link Slider#handleMouseUp}.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\r\n     *        this function\r\n     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.\r\n     *\r\n     * @listens mousemove\r\n     * @listens touchmove\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseMove = function handleMouseMove(event) {}\r\n    /**\r\n     * Handle `mouseup` or `touchend` events on the `Slider`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mouseup` or `touchend` event that triggered this function.\r\n     *\r\n     * @listens touchend\r\n     * @listens mouseup\r\n     * @fires Slider#sliderinactive\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseUp = function handleMouseUp() {\r\n      var doc = this.bar.el_.ownerDocument;\r\n      unblockTextSelection();\r\n      this.removeClass('vjs-sliding');\r\n      /**\r\n       * Triggered when the slider is no longer in an active state.\r\n       *\r\n       * @event Slider#sliderinactive\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('sliderinactive');\r\n      this.off(doc, 'mousemove', this.handleMouseMove_);\r\n      this.off(doc, 'mouseup', this.handleMouseUp_);\r\n      this.off(doc, 'touchmove', this.handleMouseMove_);\r\n      this.off(doc, 'touchend', this.handleMouseUp_);\r\n      this.update();\r\n    }\r\n    /**\r\n     * Update the progress bar of the `Slider`.\r\n     *\r\n     * @return {number}\r\n     *          The percentage of progress the progress bar represents as a\r\n     *          number from 0 to 1.\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update() {\r\n      var _this2 = this;\r\n\r\n      // In VolumeBar init we have a setTimeout for update that pops and update\r\n      // to the end of the execution stack. The player is destroyed before then\r\n      // update will cause an error\r\n      // If there's no bar...\r\n      if (!this.el_ || !this.bar) {\r\n        return;\r\n      } // clamp progress between 0 and 1\r\n      // and only round to four decimal places, as we round to two below\r\n\r\n\r\n      var progress = this.getProgress();\r\n\r\n      if (progress === this.progress_) {\r\n        return progress;\r\n      }\r\n\r\n      this.progress_ = progress;\r\n      this.requestNamedAnimationFrame('Slider#update', function () {\r\n        // Set the new bar width or height\r\n        var sizeKey = _this2.vertical() ? 'height' : 'width'; // Convert to a percentage for css value\r\n\r\n        _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';\r\n      });\r\n      return progress;\r\n    }\r\n    /**\r\n     * Get the percentage of the bar that should be filled\r\n     * but clamped and rounded.\r\n     *\r\n     * @return {number}\r\n     *         percentage filled that the slider is\r\n     */\r\n    ;\r\n\r\n    _proto.getProgress = function getProgress() {\r\n      return Number(clamp(this.getPercent(), 0, 1).toFixed(4));\r\n    }\r\n    /**\r\n     * Calculate distance for slider\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @return {number}\r\n     *         The current position of the Slider.\r\n     *         - position.x for vertical `Slider`s\r\n     *         - position.y for horizontal `Slider`s\r\n     */\r\n    ;\r\n\r\n    _proto.calculateDistance = function calculateDistance(event) {\r\n      var position = getPointerPosition(this.el_, event);\r\n\r\n      if (this.vertical()) {\r\n        return position.y;\r\n      }\r\n\r\n      return position.x;\r\n    }\r\n    /**\r\n     * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\r\n     * arrow keys. This function will only be called when the slider has focus. See\r\n     * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the `keydown` event that caused this function to run.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Left and Down Arrows\r\n      if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.stepBack(); // Up and Right Arrows\r\n      } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.stepForward();\r\n      } else {\r\n        // Pass keydown handling up for unsupported keys\r\n        _Component.prototype.handleKeyDown.call(this, event);\r\n      }\r\n    }\r\n    /**\r\n     * Listener for click events on slider, used to prevent clicks\r\n     *   from bubbling up to parent elements like button menus.\r\n     *\r\n     * @param {Object} event\r\n     *        Event that caused this object to run\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      event.stopPropagation();\r\n      event.preventDefault();\r\n    }\r\n    /**\r\n     * Get/set if slider is horizontal for vertical\r\n     *\r\n     * @param {boolean} [bool]\r\n     *        - true if slider is vertical,\r\n     *        - false is horizontal\r\n     *\r\n     * @return {boolean}\r\n     *         - true if slider is vertical, and getting\r\n     *         - false if the slider is horizontal, and getting\r\n     */\r\n    ;\r\n\r\n    _proto.vertical = function vertical(bool) {\r\n      if (bool === undefined) {\r\n        return this.vertical_ || false;\r\n      }\r\n\r\n      this.vertical_ = !!bool;\r\n\r\n      if (this.vertical_) {\r\n        this.addClass('vjs-slider-vertical');\r\n      } else {\r\n        this.addClass('vjs-slider-horizontal');\r\n      }\r\n    };\r\n\r\n    return Slider;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('Slider', Slider);\r\n\r\n  var percentify = function percentify(time, end) {\r\n    return clamp(time / end * 100, 0, 100).toFixed(2) + '%';\r\n  };\r\n  /**\r\n   * Shows loading progress\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n\r\n  var LoadProgressBar = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(LoadProgressBar, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function LoadProgressBar(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.partEls_ = [];\r\n\r\n      _this.on(player, 'progress', function (e) {\r\n        return _this.update(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = LoadProgressBar.prototype;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-load-progress'\r\n      });\r\n\r\n      var wrapper = createEl('span', {\r\n        className: 'vjs-control-text'\r\n      });\r\n      var loadedText = createEl('span', {\r\n        textContent: this.localize('Loaded')\r\n      });\r\n      var separator = document.createTextNode(': ');\r\n      this.percentageEl_ = createEl('span', {\r\n        className: 'vjs-control-text-loaded-percentage',\r\n        textContent: '0%'\r\n      });\r\n      el.appendChild(wrapper);\r\n      wrapper.appendChild(loadedText);\r\n      wrapper.appendChild(separator);\r\n      wrapper.appendChild(this.percentageEl_);\r\n      return el;\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.partEls_ = null;\r\n      this.percentageEl_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Update progress bar\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `progress` event that caused this function to run.\r\n     *\r\n     * @listens Player#progress\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(event) {\r\n      var _this2 = this;\r\n\r\n      this.requestNamedAnimationFrame('LoadProgressBar#update', function () {\r\n        var liveTracker = _this2.player_.liveTracker;\r\n\r\n        var buffered = _this2.player_.buffered();\r\n\r\n        var duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();\r\n\r\n        var bufferedEnd = _this2.player_.bufferedEnd();\r\n\r\n        var children = _this2.partEls_;\r\n        var percent = percentify(bufferedEnd, duration);\r\n\r\n        if (_this2.percent_ !== percent) {\r\n          // update the width of the progress bar\r\n          _this2.el_.style.width = percent; // update the control-text\r\n\r\n          textContent(_this2.percentageEl_, percent);\r\n          _this2.percent_ = percent;\r\n        } // add child elements to represent the individual buffered time ranges\r\n\r\n\r\n        for (var i = 0; i < buffered.length; i++) {\r\n          var start = buffered.start(i);\r\n          var end = buffered.end(i);\r\n          var part = children[i];\r\n\r\n          if (!part) {\r\n            part = _this2.el_.appendChild(createEl());\r\n            children[i] = part;\r\n          } //  only update if changed\r\n\r\n\r\n          if (part.dataset.start === start && part.dataset.end === end) {\r\n            continue;\r\n          }\r\n\r\n          part.dataset.start = start;\r\n          part.dataset.end = end; // set the percent based on the width of the progress bar (bufferedEnd)\r\n\r\n          part.style.left = percentify(start, bufferedEnd);\r\n          part.style.width = percentify(end - start, bufferedEnd);\r\n        } // remove unused buffered range elements\r\n\r\n\r\n        for (var _i = children.length; _i > buffered.length; _i--) {\r\n          _this2.el_.removeChild(children[_i - 1]);\r\n        }\r\n\r\n        children.length = buffered.length;\r\n      });\r\n    };\r\n\r\n    return LoadProgressBar;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('LoadProgressBar', LoadProgressBar);\r\n\r\n  /**\r\n   * Time tooltips display a time above the progress bar.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var TimeTooltip = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(TimeTooltip, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The {@link Player} that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function TimeTooltip(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the time tooltip DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = TimeTooltip.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-time-tooltip'\r\n      }, {\r\n        'aria-hidden': 'true'\r\n      });\r\n    }\r\n    /**\r\n     * Updates the position of the time tooltip relative to the `SeekBar`.\r\n     *\r\n     * @param {Object} seekBarRect\r\n     *        The `ClientRect` for the {@link SeekBar} element.\r\n     *\r\n     * @param {number} seekBarPoint\r\n     *        A number from 0 to 1, representing a horizontal reference point\r\n     *        from the left edge of the {@link SeekBar}\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(seekBarRect, seekBarPoint, content) {\r\n      var tooltipRect = findPosition(this.el_);\r\n      var playerRect = getBoundingClientRect(this.player_.el());\r\n      var seekBarPointPx = seekBarRect.width * seekBarPoint; // do nothing if either rect isn't available\r\n      // for example, if the player isn't in the DOM for testing\r\n\r\n      if (!playerRect || !tooltipRect) {\r\n        return;\r\n      } // This is the space left of the `seekBarPoint` available within the bounds\r\n      // of the player. We calculate any gap between the left edge of the player\r\n      // and the left edge of the `SeekBar` and add the number of pixels in the\r\n      // `SeekBar` before hitting the `seekBarPoint`\r\n\r\n\r\n      var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx; // This is the space right of the `seekBarPoint` available within the bounds\r\n      // of the player. We calculate the number of pixels from the `seekBarPoint`\r\n      // to the right edge of the `SeekBar` and add to that any gap between the\r\n      // right edge of the `SeekBar` and the player.\r\n\r\n      var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right); // This is the number of pixels by which the tooltip will need to be pulled\r\n      // further to the right to center it over the `seekBarPoint`.\r\n\r\n      var pullTooltipBy = tooltipRect.width / 2; // Adjust the `pullTooltipBy` distance to the left or right depending on\r\n      // the results of the space calculations above.\r\n\r\n      if (spaceLeftOfPoint < pullTooltipBy) {\r\n        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\r\n      } else if (spaceRightOfPoint < pullTooltipBy) {\r\n        pullTooltipBy = spaceRightOfPoint;\r\n      } // Due to the imprecision of decimal/ratio based calculations and varying\r\n      // rounding behaviors, there are cases where the spacing adjustment is off\r\n      // by a pixel or two. This adds insurance to these calculations.\r\n\r\n\r\n      if (pullTooltipBy < 0) {\r\n        pullTooltipBy = 0;\r\n      } else if (pullTooltipBy > tooltipRect.width) {\r\n        pullTooltipBy = tooltipRect.width;\r\n      } // prevent small width fluctuations within 0.4px from\r\n      // changing the value below.\r\n      // This really helps for live to prevent the play\r\n      // progress time tooltip from jittering\r\n\r\n\r\n      pullTooltipBy = Math.round(pullTooltipBy);\r\n      this.el_.style.right = \"-\" + pullTooltipBy + \"px\";\r\n      this.write(content);\r\n    }\r\n    /**\r\n     * Write the time to the tooltip DOM element.\r\n     *\r\n     * @param {string} content\r\n     *        The formatted time for the tooltip.\r\n     */\r\n    ;\r\n\r\n    _proto.write = function write(content) {\r\n      textContent(this.el_, content);\r\n    }\r\n    /**\r\n     * Updates the position of the time tooltip relative to the `SeekBar`.\r\n     *\r\n     * @param {Object} seekBarRect\r\n     *        The `ClientRect` for the {@link SeekBar} element.\r\n     *\r\n     * @param {number} seekBarPoint\r\n     *        A number from 0 to 1, representing a horizontal reference point\r\n     *        from the left edge of the {@link SeekBar}\r\n     *\r\n     * @param {number} time\r\n     *        The time to update the tooltip to, not used during live playback\r\n     *\r\n     * @param {Function} cb\r\n     *        A function that will be called during the request animation frame\r\n     *        for tooltips that need to do additional animations from the default\r\n     */\r\n    ;\r\n\r\n    _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time, cb) {\r\n      var _this2 = this;\r\n\r\n      this.requestNamedAnimationFrame('TimeTooltip#updateTime', function () {\r\n        var content;\r\n\r\n        var duration = _this2.player_.duration();\r\n\r\n        if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {\r\n          var liveWindow = _this2.player_.liveTracker.liveWindow();\r\n\r\n          var secondsBehind = liveWindow - seekBarPoint * liveWindow;\r\n          content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);\r\n        } else {\r\n          content = formatTime(time, duration);\r\n        }\r\n\r\n        _this2.update(seekBarRect, seekBarPoint, content);\r\n\r\n        if (cb) {\r\n          cb();\r\n        }\r\n      });\r\n    };\r\n\r\n    return TimeTooltip;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('TimeTooltip', TimeTooltip);\r\n\r\n  /**\r\n   * Used by {@link SeekBar} to display media playback progress as part of the\r\n   * {@link ProgressControl}.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var PlayProgressBar = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(PlayProgressBar, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The {@link Player} that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function PlayProgressBar(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the the DOM element for this class.\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = PlayProgressBar.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-play-progress vjs-slider-bar'\r\n      }, {\r\n        'aria-hidden': 'true'\r\n      });\r\n    }\r\n    /**\r\n     * Enqueues updates to its own DOM as well as the DOM of its\r\n     * {@link TimeTooltip} child.\r\n     *\r\n     * @param {Object} seekBarRect\r\n     *        The `ClientRect` for the {@link SeekBar} element.\r\n     *\r\n     * @param {number} seekBarPoint\r\n     *        A number from 0 to 1, representing a horizontal reference point\r\n     *        from the left edge of the {@link SeekBar}\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(seekBarRect, seekBarPoint) {\r\n      var timeTooltip = this.getChild('timeTooltip');\r\n\r\n      if (!timeTooltip) {\r\n        return;\r\n      }\r\n\r\n      var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\r\n      timeTooltip.updateTime(seekBarRect, seekBarPoint, time);\r\n    };\r\n\r\n    return PlayProgressBar;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for {@link PlayProgressBar}.\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  PlayProgressBar.prototype.options_ = {\r\n    children: []\r\n  }; // Time tooltips should not be added to a player on mobile devices\r\n\r\n  if (!IS_IOS && !IS_ANDROID) {\r\n    PlayProgressBar.prototype.options_.children.push('timeTooltip');\r\n  }\r\n\r\n  Component$1.registerComponent('PlayProgressBar', PlayProgressBar);\r\n\r\n  /**\r\n   * The {@link MouseTimeDisplay} component tracks mouse movement over the\r\n   * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\r\n   * indicating the time which is represented by a given point in the\r\n   * {@link ProgressControl}.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var MouseTimeDisplay = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(MouseTimeDisplay, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The {@link Player} that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function MouseTimeDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the DOM element for this class.\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = MouseTimeDisplay.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-mouse-display'\r\n      });\r\n    }\r\n    /**\r\n     * Enqueues updates to its own DOM as well as the DOM of its\r\n     * {@link TimeTooltip} child.\r\n     *\r\n     * @param {Object} seekBarRect\r\n     *        The `ClientRect` for the {@link SeekBar} element.\r\n     *\r\n     * @param {number} seekBarPoint\r\n     *        A number from 0 to 1, representing a horizontal reference point\r\n     *        from the left edge of the {@link SeekBar}\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(seekBarRect, seekBarPoint) {\r\n      var _this2 = this;\r\n\r\n      var time = seekBarPoint * this.player_.duration();\r\n      this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, function () {\r\n        _this2.el_.style.left = seekBarRect.width * seekBarPoint + \"px\";\r\n      });\r\n    };\r\n\r\n    return MouseTimeDisplay;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for `MouseTimeDisplay`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  MouseTimeDisplay.prototype.options_ = {\r\n    children: ['timeTooltip']\r\n  };\r\n  Component$1.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\r\n\r\n  var STEP_SECONDS = 5; // The multiplier of STEP_SECONDS that PgUp/PgDown move the timeline.\r\n\r\n  var PAGE_KEY_MULTIPLIER = 12;\r\n  /**\r\n   * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\r\n   * as its `bar`.\r\n   *\r\n   * @extends Slider\r\n   */\r\n\r\n  var SeekBar = /*#__PURE__*/function (_Slider) {\r\n    inheritsLoose(SeekBar, _Slider);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function SeekBar(player, options) {\r\n      var _this;\r\n\r\n      _this = _Slider.call(this, player, options) || this;\r\n\r\n      _this.setEventHandlers_();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Sets the event handlers\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var _proto = SeekBar.prototype;\r\n\r\n    _proto.setEventHandlers_ = function setEventHandlers_() {\r\n      var _this2 = this;\r\n\r\n      this.update_ = bind(this, this.update);\r\n      this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);\r\n      this.on(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\r\n\r\n      if (this.player_.liveTracker) {\r\n        this.on(this.player_.liveTracker, 'liveedgechange', this.update);\r\n      } // when playing, let's ensure we smoothly update the play progress bar\r\n      // via an interval\r\n\r\n\r\n      this.updateInterval = null;\r\n\r\n      this.enableIntervalHandler_ = function (e) {\r\n        return _this2.enableInterval_(e);\r\n      };\r\n\r\n      this.disableIntervalHandler_ = function (e) {\r\n        return _this2.disableInterval_(e);\r\n      };\r\n\r\n      this.on(this.player_, ['playing'], this.enableIntervalHandler_);\r\n      this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_); // we don't need to update the play progress if the document is hidden,\r\n      // also, this causes the CPU to spike and eventually crash the page on IE11.\r\n\r\n      if ('hidden' in document && 'visibilityState' in document) {\r\n        this.on(document, 'visibilitychange', this.toggleVisibility_);\r\n      }\r\n    };\r\n\r\n    _proto.toggleVisibility_ = function toggleVisibility_(e) {\r\n      if (document.visibilityState === 'hidden') {\r\n        this.cancelNamedAnimationFrame('SeekBar#update');\r\n        this.cancelNamedAnimationFrame('Slider#update');\r\n        this.disableInterval_(e);\r\n      } else {\r\n        if (!this.player_.ended() && !this.player_.paused()) {\r\n          this.enableInterval_();\r\n        } // we just switched back to the page and someone may be looking, so, update ASAP\r\n\r\n\r\n        this.update();\r\n      }\r\n    };\r\n\r\n    _proto.enableInterval_ = function enableInterval_() {\r\n      if (this.updateInterval) {\r\n        return;\r\n      }\r\n\r\n      this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);\r\n    };\r\n\r\n    _proto.disableInterval_ = function disableInterval_(e) {\r\n      if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {\r\n        return;\r\n      }\r\n\r\n      if (!this.updateInterval) {\r\n        return;\r\n      }\r\n\r\n      this.clearInterval(this.updateInterval);\r\n      this.updateInterval = null;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Slider.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-progress-holder'\r\n      }, {\r\n        'aria-label': this.localize('Progress Bar')\r\n      });\r\n    }\r\n    /**\r\n     * This function updates the play progress bar and accessibility\r\n     * attributes to whatever is passed in.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `timeupdate` or `ended` event that caused this to run.\r\n     *\r\n     * @listens Player#timeupdate\r\n     *\r\n     * @return {number}\r\n     *          The current percent at a number from 0-1\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(event) {\r\n      var _this3 = this;\r\n\r\n      // ignore updates while the tab is hidden\r\n      if (document.visibilityState === 'hidden') {\r\n        return;\r\n      }\r\n\r\n      var percent = _Slider.prototype.update.call(this);\r\n\r\n      this.requestNamedAnimationFrame('SeekBar#update', function () {\r\n        var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_();\r\n        var liveTracker = _this3.player_.liveTracker;\r\n\r\n        var duration = _this3.player_.duration();\r\n\r\n        if (liveTracker && liveTracker.isLive()) {\r\n          duration = _this3.player_.liveTracker.liveCurrentTime();\r\n        }\r\n\r\n        if (_this3.percent_ !== percent) {\r\n          // machine readable value of progress bar (percentage complete)\r\n          _this3.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\r\n\r\n          _this3.percent_ = percent;\r\n        }\r\n\r\n        if (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration) {\r\n          // human readable value of progress bar (time complete)\r\n          _this3.el_.setAttribute('aria-valuetext', _this3.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\r\n\r\n          _this3.currentTime_ = currentTime;\r\n          _this3.duration_ = duration;\r\n        } // update the progress bar time tooltip with the current time\r\n\r\n\r\n        if (_this3.bar) {\r\n          _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());\r\n        }\r\n      });\r\n      return percent;\r\n    }\r\n    /**\r\n     * Prevent liveThreshold from causing seeks to seem like they\r\n     * are not happening from a user perspective.\r\n     *\r\n     * @param {number} ct\r\n     *        current time to seek to\r\n     */\r\n    ;\r\n\r\n    _proto.userSeek_ = function userSeek_(ct) {\r\n      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\r\n        this.player_.liveTracker.nextSeekedFromUser();\r\n      }\r\n\r\n      this.player_.currentTime(ct);\r\n    }\r\n    /**\r\n     * Get the value of current time but allows for smooth scrubbing,\r\n     * when player can't keep up.\r\n     *\r\n     * @return {number}\r\n     *         The current time value to display\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.getCurrentTime_ = function getCurrentTime_() {\r\n      return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\r\n    }\r\n    /**\r\n     * Get the percentage of media played so far.\r\n     *\r\n     * @return {number}\r\n     *         The percentage of media played so far (0 to 1).\r\n     */\r\n    ;\r\n\r\n    _proto.getPercent = function getPercent() {\r\n      var currentTime = this.getCurrentTime_();\r\n      var percent;\r\n      var liveTracker = this.player_.liveTracker;\r\n\r\n      if (liveTracker && liveTracker.isLive()) {\r\n        percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow(); // prevent the percent from changing at the live edge\r\n\r\n        if (liveTracker.atLiveEdge()) {\r\n          percent = 1;\r\n        }\r\n      } else {\r\n        percent = currentTime / this.player_.duration();\r\n      }\r\n\r\n      return percent;\r\n    }\r\n    /**\r\n     * Handle mouse down on seek bar\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mousedown` event that caused this to run.\r\n     *\r\n     * @listens mousedown\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseDown = function handleMouseDown(event) {\r\n      if (!isSingleLeftClick(event)) {\r\n        return;\r\n      } // Stop event propagation to prevent double fire in progress-control.js\r\n\r\n\r\n      event.stopPropagation();\r\n      this.videoWasPlaying = !this.player_.paused();\r\n      this.player_.pause();\r\n\r\n      _Slider.prototype.handleMouseDown.call(this, event);\r\n    }\r\n    /**\r\n     * Handle mouse move on seek bar\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mousemove` event that caused this to run.\r\n     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false\r\n     *\r\n     * @listens mousemove\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseMove = function handleMouseMove(event, mouseDown) {\r\n      if (mouseDown === void 0) {\r\n        mouseDown = false;\r\n      }\r\n\r\n      if (!isSingleLeftClick(event)) {\r\n        return;\r\n      }\r\n\r\n      if (!mouseDown && !this.player_.scrubbing()) {\r\n        this.player_.scrubbing(true);\r\n      }\r\n\r\n      var newTime;\r\n      var distance = this.calculateDistance(event);\r\n      var liveTracker = this.player_.liveTracker;\r\n\r\n      if (!liveTracker || !liveTracker.isLive()) {\r\n        newTime = distance * this.player_.duration(); // Don't let video end while scrubbing.\r\n\r\n        if (newTime === this.player_.duration()) {\r\n          newTime = newTime - 0.1;\r\n        }\r\n      } else {\r\n        if (distance >= 0.99) {\r\n          liveTracker.seekToLiveEdge();\r\n          return;\r\n        }\r\n\r\n        var seekableStart = liveTracker.seekableStart();\r\n        var seekableEnd = liveTracker.liveCurrentTime();\r\n        newTime = seekableStart + distance * liveTracker.liveWindow(); // Don't let video end while scrubbing.\r\n\r\n        if (newTime >= seekableEnd) {\r\n          newTime = seekableEnd;\r\n        } // Compensate for precision differences so that currentTime is not less\r\n        // than seekable start\r\n\r\n\r\n        if (newTime <= seekableStart) {\r\n          newTime = seekableStart + 0.1;\r\n        } // On android seekableEnd can be Infinity sometimes,\r\n        // this will cause newTime to be Infinity, which is\r\n        // not a valid currentTime.\r\n\r\n\r\n        if (newTime === Infinity) {\r\n          return;\r\n        }\r\n      } // Set new time (tell player to seek to new time)\r\n\r\n\r\n      this.userSeek_(newTime);\r\n    };\r\n\r\n    _proto.enable = function enable() {\r\n      _Slider.prototype.enable.call(this);\r\n\r\n      var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\r\n\r\n      if (!mouseTimeDisplay) {\r\n        return;\r\n      }\r\n\r\n      mouseTimeDisplay.show();\r\n    };\r\n\r\n    _proto.disable = function disable() {\r\n      _Slider.prototype.disable.call(this);\r\n\r\n      var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\r\n\r\n      if (!mouseTimeDisplay) {\r\n        return;\r\n      }\r\n\r\n      mouseTimeDisplay.hide();\r\n    }\r\n    /**\r\n     * Handle mouse up on seek bar\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mouseup` event that caused this to run.\r\n     *\r\n     * @listens mouseup\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseUp = function handleMouseUp(event) {\r\n      _Slider.prototype.handleMouseUp.call(this, event); // Stop event propagation to prevent double fire in progress-control.js\r\n\r\n\r\n      if (event) {\r\n        event.stopPropagation();\r\n      }\r\n\r\n      this.player_.scrubbing(false);\r\n      /**\r\n       * Trigger timeupdate because we're done seeking and the time has changed.\r\n       * This is particularly useful for if the player is paused to time the time displays.\r\n       *\r\n       * @event Tech#timeupdate\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.player_.trigger({\r\n        type: 'timeupdate',\r\n        target: this,\r\n        manuallyTriggered: true\r\n      });\r\n\r\n      if (this.videoWasPlaying) {\r\n        silencePromise(this.player_.play());\r\n      } else {\r\n        // We're done seeking and the time has changed.\r\n        // If the player is paused, make sure we display the correct time on the seek bar.\r\n        this.update_();\r\n      }\r\n    }\r\n    /**\r\n     * Move more quickly fast forward for keyboard-only users\r\n     */\r\n    ;\r\n\r\n    _proto.stepForward = function stepForward() {\r\n      this.userSeek_(this.player_.currentTime() + STEP_SECONDS);\r\n    }\r\n    /**\r\n     * Move more quickly rewind for keyboard-only users\r\n     */\r\n    ;\r\n\r\n    _proto.stepBack = function stepBack() {\r\n      this.userSeek_(this.player_.currentTime() - STEP_SECONDS);\r\n    }\r\n    /**\r\n     * Toggles the playback state of the player\r\n     * This gets called when enter or space is used on the seekbar\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.handleAction = function handleAction(event) {\r\n      if (this.player_.paused()) {\r\n        this.player_.play();\r\n      } else {\r\n        this.player_.pause();\r\n      }\r\n    }\r\n    /**\r\n     * Called when this SeekBar has focus and a key gets pressed down.\r\n     * Supports the following keys:\r\n     *\r\n     *   Space or Enter key fire a click event\r\n     *   Home key moves to start of the timeline\r\n     *   End key moves to end of the timeline\r\n     *   Digit \"0\" through \"9\" keys move to 0%, 10% ... 80%, 90% of the timeline\r\n     *   PageDown key moves back a larger step than ArrowDown\r\n     *   PageUp key moves forward a large step\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      var liveTracker = this.player_.liveTracker;\r\n\r\n      if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.handleAction(event);\r\n      } else if (keycode.isEventKey(event, 'Home')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.userSeek_(0);\r\n      } else if (keycode.isEventKey(event, 'End')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        if (liveTracker && liveTracker.isLive()) {\r\n          this.userSeek_(liveTracker.liveCurrentTime());\r\n        } else {\r\n          this.userSeek_(this.player_.duration());\r\n        }\r\n      } else if (/^[0-9]$/.test(keycode(event))) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        var gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10.0 / 100.0;\r\n\r\n        if (liveTracker && liveTracker.isLive()) {\r\n          this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);\r\n        } else {\r\n          this.userSeek_(this.player_.duration() * gotoFraction);\r\n        }\r\n      } else if (keycode.isEventKey(event, 'PgDn')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);\r\n      } else if (keycode.isEventKey(event, 'PgUp')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);\r\n      } else {\r\n        // Pass keydown handling up for unsupported keys\r\n        _Slider.prototype.handleKeyDown.call(this, event);\r\n      }\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.disableInterval_();\r\n      this.off(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\r\n\r\n      if (this.player_.liveTracker) {\r\n        this.off(this.player_.liveTracker, 'liveedgechange', this.update);\r\n      }\r\n\r\n      this.off(this.player_, ['playing'], this.enableIntervalHandler_);\r\n      this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_); // we don't need to update the play progress if the document is hidden,\r\n      // also, this causes the CPU to spike and eventually crash the page on IE11.\r\n\r\n      if ('hidden' in document && 'visibilityState' in document) {\r\n        this.off(document, 'visibilitychange', this.toggleVisibility_);\r\n      }\r\n\r\n      _Slider.prototype.dispose.call(this);\r\n    };\r\n\r\n    return SeekBar;\r\n  }(Slider);\r\n  /**\r\n   * Default options for the `SeekBar`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  SeekBar.prototype.options_ = {\r\n    children: ['loadProgressBar', 'playProgressBar'],\r\n    barName: 'playProgressBar'\r\n  }; // MouseTimeDisplay tooltips should not be added to a player on mobile devices\r\n\r\n  if (!IS_IOS && !IS_ANDROID) {\r\n    SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\r\n  }\r\n\r\n  Component$1.registerComponent('SeekBar', SeekBar);\r\n\r\n  /**\r\n   * The Progress Control component contains the seek bar, load progress,\r\n   * and play progress.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var ProgressControl = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(ProgressControl, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function ProgressControl(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.handleMouseMove = throttle(bind(assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\r\n      _this.throttledHandleMouseSeek = throttle(bind(assertThisInitialized(_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);\r\n\r\n      _this.handleMouseUpHandler_ = function (e) {\r\n        return _this.handleMouseUp(e);\r\n      };\r\n\r\n      _this.handleMouseDownHandler_ = function (e) {\r\n        return _this.handleMouseDown(e);\r\n      };\r\n\r\n      _this.enable();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = ProgressControl.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-progress-control vjs-control'\r\n      });\r\n    }\r\n    /**\r\n     * When the mouse moves over the `ProgressControl`, the pointer position\r\n     * gets passed down to the `MouseTimeDisplay` component.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mousemove` event that caused this function to run.\r\n     *\r\n     * @listen mousemove\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseMove = function handleMouseMove(event) {\r\n      var seekBar = this.getChild('seekBar');\r\n\r\n      if (!seekBar) {\r\n        return;\r\n      }\r\n\r\n      var playProgressBar = seekBar.getChild('playProgressBar');\r\n      var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\r\n\r\n      if (!playProgressBar && !mouseTimeDisplay) {\r\n        return;\r\n      }\r\n\r\n      var seekBarEl = seekBar.el();\r\n      var seekBarRect = findPosition(seekBarEl);\r\n      var seekBarPoint = getPointerPosition(seekBarEl, event).x; // The default skin has a gap on either side of the `SeekBar`. This means\r\n      // that it's possible to trigger this behavior outside the boundaries of\r\n      // the `SeekBar`. This ensures we stay within it at all times.\r\n\r\n      seekBarPoint = clamp(seekBarPoint, 0, 1);\r\n\r\n      if (mouseTimeDisplay) {\r\n        mouseTimeDisplay.update(seekBarRect, seekBarPoint);\r\n      }\r\n\r\n      if (playProgressBar) {\r\n        playProgressBar.update(seekBarRect, seekBar.getProgress());\r\n      }\r\n    }\r\n    /**\r\n     * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\r\n     *\r\n     * @method ProgressControl#throttledHandleMouseSeek\r\n     * @param {EventTarget~Event} event\r\n     *        The `mousemove` event that caused this function to run.\r\n     *\r\n     * @listen mousemove\r\n     * @listen touchmove\r\n     */\r\n\r\n    /**\r\n     * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mousedown` or `touchstart` event that triggered this function\r\n     *\r\n     * @listens mousemove\r\n     * @listens touchmove\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseSeek = function handleMouseSeek(event) {\r\n      var seekBar = this.getChild('seekBar');\r\n\r\n      if (seekBar) {\r\n        seekBar.handleMouseMove(event);\r\n      }\r\n    }\r\n    /**\r\n     * Are controls are currently enabled for this progress control.\r\n     *\r\n     * @return {boolean}\r\n     *         true if controls are enabled, false otherwise\r\n     */\r\n    ;\r\n\r\n    _proto.enabled = function enabled() {\r\n      return this.enabled_;\r\n    }\r\n    /**\r\n     * Disable all controls on the progress control and its children\r\n     */\r\n    ;\r\n\r\n    _proto.disable = function disable() {\r\n      this.children().forEach(function (child) {\r\n        return child.disable && child.disable();\r\n      });\r\n\r\n      if (!this.enabled()) {\r\n        return;\r\n      }\r\n\r\n      this.off(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\r\n      this.off(this.el_, 'mousemove', this.handleMouseMove);\r\n      this.removeListenersAddedOnMousedownAndTouchstart();\r\n      this.addClass('disabled');\r\n      this.enabled_ = false; // Restore normal playback state if controls are disabled while scrubbing\r\n\r\n      if (this.player_.scrubbing()) {\r\n        var seekBar = this.getChild('seekBar');\r\n        this.player_.scrubbing(false);\r\n\r\n        if (seekBar.videoWasPlaying) {\r\n          silencePromise(this.player_.play());\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Enable all controls on the progress control and its children\r\n     */\r\n    ;\r\n\r\n    _proto.enable = function enable() {\r\n      this.children().forEach(function (child) {\r\n        return child.enable && child.enable();\r\n      });\r\n\r\n      if (this.enabled()) {\r\n        return;\r\n      }\r\n\r\n      this.on(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\r\n      this.on(this.el_, 'mousemove', this.handleMouseMove);\r\n      this.removeClass('disabled');\r\n      this.enabled_ = true;\r\n    }\r\n    /**\r\n     * Cleanup listeners after the user finishes interacting with the progress controls\r\n     */\r\n    ;\r\n\r\n    _proto.removeListenersAddedOnMousedownAndTouchstart = function removeListenersAddedOnMousedownAndTouchstart() {\r\n      var doc = this.el_.ownerDocument;\r\n      this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\r\n      this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\r\n      this.off(doc, 'mouseup', this.handleMouseUpHandler_);\r\n      this.off(doc, 'touchend', this.handleMouseUpHandler_);\r\n    }\r\n    /**\r\n     * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mousedown` or `touchstart` event that triggered this function\r\n     *\r\n     * @listens mousedown\r\n     * @listens touchstart\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseDown = function handleMouseDown(event) {\r\n      var doc = this.el_.ownerDocument;\r\n      var seekBar = this.getChild('seekBar');\r\n\r\n      if (seekBar) {\r\n        seekBar.handleMouseDown(event);\r\n      }\r\n\r\n      this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\r\n      this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\r\n      this.on(doc, 'mouseup', this.handleMouseUpHandler_);\r\n      this.on(doc, 'touchend', this.handleMouseUpHandler_);\r\n    }\r\n    /**\r\n     * Handle `mouseup` or `touchend` events on the `ProgressControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mouseup` or `touchend` event that triggered this function.\r\n     *\r\n     * @listens touchend\r\n     * @listens mouseup\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseUp = function handleMouseUp(event) {\r\n      var seekBar = this.getChild('seekBar');\r\n\r\n      if (seekBar) {\r\n        seekBar.handleMouseUp(event);\r\n      }\r\n\r\n      this.removeListenersAddedOnMousedownAndTouchstart();\r\n    };\r\n\r\n    return ProgressControl;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for `ProgressControl`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  ProgressControl.prototype.options_ = {\r\n    children: ['seekBar']\r\n  };\r\n  Component$1.registerComponent('ProgressControl', ProgressControl);\r\n\r\n  /**\r\n   * Toggle Picture-in-Picture mode\r\n   *\r\n   * @extends Button\r\n   */\r\n\r\n  var PictureInPictureToggle = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(PictureInPictureToggle, _Button);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @listens Player#enterpictureinpicture\r\n     * @listens Player#leavepictureinpicture\r\n     */\r\n    function PictureInPictureToggle(player, options) {\r\n      var _this;\r\n\r\n      _this = _Button.call(this, player, options) || this;\r\n\r\n      _this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], function (e) {\r\n        return _this.handlePictureInPictureChange(e);\r\n      });\r\n\r\n      _this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], function (e) {\r\n        return _this.handlePictureInPictureEnabledChange(e);\r\n      });\r\n\r\n      _this.on(player, ['loadedmetadata', 'audioonlymodechange', 'audiopostermodechange'], function () {\r\n        // This audio detection will not detect HLS or DASH audio-only streams because there was no reliable way to detect them at the time\r\n        var isSourceAudio = player.currentType().substring(0, 5) === 'audio';\r\n\r\n        if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {\r\n          if (player.isInPictureInPicture()) {\r\n            player.exitPictureInPicture();\r\n          }\r\n\r\n          _this.hide();\r\n        } else {\r\n          _this.show();\r\n        }\r\n      }); // TODO: Deactivate button on player emptied event.\r\n\r\n\r\n      _this.disable();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = PictureInPictureToggle.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-picture-in-picture-control \" + _Button.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Enables or disables button based on document.pictureInPictureEnabled property value\r\n     * or on value returned by player.disablePictureInPicture() method.\r\n     */\r\n    ;\r\n\r\n    _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {\r\n      if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {\r\n        this.enable();\r\n      } else {\r\n        this.disable();\r\n      }\r\n    }\r\n    /**\r\n     * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens Player#enterpictureinpicture\r\n     * @listens Player#leavepictureinpicture\r\n     */\r\n    ;\r\n\r\n    _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event) {\r\n      if (this.player_.isInPictureInPicture()) {\r\n        this.controlText('Exit Picture-in-Picture');\r\n      } else {\r\n        this.controlText('Picture-in-Picture');\r\n      }\r\n\r\n      this.handlePictureInPictureEnabledChange();\r\n    }\r\n    /**\r\n     * This gets called when an `PictureInPictureToggle` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      if (!this.player_.isInPictureInPicture()) {\r\n        this.player_.requestPictureInPicture();\r\n      } else {\r\n        this.player_.exitPictureInPicture();\r\n      }\r\n    };\r\n\r\n    return PictureInPictureToggle;\r\n  }(Button);\r\n  /**\r\n   * The text that should display over the `PictureInPictureToggle`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';\r\n  Component$1.registerComponent('PictureInPictureToggle', PictureInPictureToggle);\r\n\r\n  /**\r\n   * Toggle fullscreen video\r\n   *\r\n   * @extends Button\r\n   */\r\n\r\n  var FullscreenToggle = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(FullscreenToggle, _Button);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function FullscreenToggle(player, options) {\r\n      var _this;\r\n\r\n      _this = _Button.call(this, player, options) || this;\r\n\r\n      _this.on(player, 'fullscreenchange', function (e) {\r\n        return _this.handleFullscreenChange(e);\r\n      });\r\n\r\n      if (document[player.fsApi_.fullscreenEnabled] === false) {\r\n        _this.disable();\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = FullscreenToggle.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-fullscreen-control \" + _Button.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Handles fullscreenchange on the player and change control text accordingly.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The {@link Player#fullscreenchange} event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens Player#fullscreenchange\r\n     */\r\n    ;\r\n\r\n    _proto.handleFullscreenChange = function handleFullscreenChange(event) {\r\n      if (this.player_.isFullscreen()) {\r\n        this.controlText('Non-Fullscreen');\r\n      } else {\r\n        this.controlText('Fullscreen');\r\n      }\r\n    }\r\n    /**\r\n     * This gets called when an `FullscreenToggle` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      if (!this.player_.isFullscreen()) {\r\n        this.player_.requestFullscreen();\r\n      } else {\r\n        this.player_.exitFullscreen();\r\n      }\r\n    };\r\n\r\n    return FullscreenToggle;\r\n  }(Button);\r\n  /**\r\n   * The text that should display over the `FullscreenToggle`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  FullscreenToggle.prototype.controlText_ = 'Fullscreen';\r\n  Component$1.registerComponent('FullscreenToggle', FullscreenToggle);\r\n\r\n  /**\r\n   * Check if volume control is supported and if it isn't hide the\r\n   * `Component` that was passed  using the `vjs-hidden` class.\r\n   *\r\n   * @param {Component} self\r\n   *        The component that should be hidden if volume is unsupported\r\n   *\r\n   * @param {Player} player\r\n   *        A reference to the player\r\n   *\r\n   * @private\r\n   */\r\n  var checkVolumeSupport = function checkVolumeSupport(self, player) {\r\n    // hide volume controls when they're not supported by the current tech\r\n    if (player.tech_ && !player.tech_.featuresVolumeControl) {\r\n      self.addClass('vjs-hidden');\r\n    }\r\n\r\n    self.on(player, 'loadstart', function () {\r\n      if (!player.tech_.featuresVolumeControl) {\r\n        self.addClass('vjs-hidden');\r\n      } else {\r\n        self.removeClass('vjs-hidden');\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Shows volume level\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var VolumeLevel = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(VolumeLevel, _Component);\r\n\r\n    function VolumeLevel() {\r\n      return _Component.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = VolumeLevel.prototype;\r\n\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    _proto.createEl = function createEl() {\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-volume-level'\r\n      });\r\n\r\n      el.appendChild(_Component.prototype.createEl.call(this, 'span', {\r\n        className: 'vjs-control-text'\r\n      }));\r\n      return el;\r\n    };\r\n\r\n    return VolumeLevel;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('VolumeLevel', VolumeLevel);\r\n\r\n  /**\r\n   * Volume level tooltips display a volume above or side by side the volume bar.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var VolumeLevelTooltip = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(VolumeLevelTooltip, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The {@link Player} that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function VolumeLevelTooltip(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the volume tooltip DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = VolumeLevelTooltip.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-volume-tooltip'\r\n      }, {\r\n        'aria-hidden': 'true'\r\n      });\r\n    }\r\n    /**\r\n     * Updates the position of the tooltip relative to the `VolumeBar` and\r\n     * its content text.\r\n     *\r\n     * @param {Object} rangeBarRect\r\n     *        The `ClientRect` for the {@link VolumeBar} element.\r\n     *\r\n     * @param {number} rangeBarPoint\r\n     *        A number from 0 to 1, representing a horizontal/vertical reference point\r\n     *        from the left edge of the {@link VolumeBar}\r\n     *\r\n     * @param {boolean} vertical\r\n     *        Referees to the Volume control position\r\n     *        in the control bar{@link VolumeControl}\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(rangeBarRect, rangeBarPoint, vertical, content) {\r\n      if (!vertical) {\r\n        var tooltipRect = getBoundingClientRect(this.el_);\r\n        var playerRect = getBoundingClientRect(this.player_.el());\r\n        var volumeBarPointPx = rangeBarRect.width * rangeBarPoint;\r\n\r\n        if (!playerRect || !tooltipRect) {\r\n          return;\r\n        }\r\n\r\n        var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;\r\n        var spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);\r\n        var pullTooltipBy = tooltipRect.width / 2;\r\n\r\n        if (spaceLeftOfPoint < pullTooltipBy) {\r\n          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\r\n        } else if (spaceRightOfPoint < pullTooltipBy) {\r\n          pullTooltipBy = spaceRightOfPoint;\r\n        }\r\n\r\n        if (pullTooltipBy < 0) {\r\n          pullTooltipBy = 0;\r\n        } else if (pullTooltipBy > tooltipRect.width) {\r\n          pullTooltipBy = tooltipRect.width;\r\n        }\r\n\r\n        this.el_.style.right = \"-\" + pullTooltipBy + \"px\";\r\n      }\r\n\r\n      this.write(content + \"%\");\r\n    }\r\n    /**\r\n     * Write the volume to the tooltip DOM element.\r\n     *\r\n     * @param {string} content\r\n     *        The formatted volume for the tooltip.\r\n     */\r\n    ;\r\n\r\n    _proto.write = function write(content) {\r\n      textContent(this.el_, content);\r\n    }\r\n    /**\r\n     * Updates the position of the volume tooltip relative to the `VolumeBar`.\r\n     *\r\n     * @param {Object} rangeBarRect\r\n     *        The `ClientRect` for the {@link VolumeBar} element.\r\n     *\r\n     * @param {number} rangeBarPoint\r\n     *        A number from 0 to 1, representing a horizontal/vertical reference point\r\n     *        from the left edge of the {@link VolumeBar}\r\n     *\r\n     * @param {boolean} vertical\r\n     *        Referees to the Volume control position\r\n     *        in the control bar{@link VolumeControl}\r\n     *\r\n     * @param {number} volume\r\n     *        The volume level to update the tooltip to\r\n     *\r\n     * @param {Function} cb\r\n     *        A function that will be called during the request animation frame\r\n     *        for tooltips that need to do additional animations from the default\r\n     */\r\n    ;\r\n\r\n    _proto.updateVolume = function updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {\r\n      var _this2 = this;\r\n\r\n      this.requestNamedAnimationFrame('VolumeLevelTooltip#updateVolume', function () {\r\n        _this2.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));\r\n\r\n        if (cb) {\r\n          cb();\r\n        }\r\n      });\r\n    };\r\n\r\n    return VolumeLevelTooltip;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('VolumeLevelTooltip', VolumeLevelTooltip);\r\n\r\n  /**\r\n   * The {@link MouseVolumeLevelDisplay} component tracks mouse movement over the\r\n   * {@link VolumeControl}. It displays an indicator and a {@link VolumeLevelTooltip}\r\n   * indicating the volume level which is represented by a given point in the\r\n   * {@link VolumeBar}.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var MouseVolumeLevelDisplay = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(MouseVolumeLevelDisplay, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The {@link Player} that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function MouseVolumeLevelDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.update = throttle(bind(assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the DOM element for this class.\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = MouseVolumeLevelDisplay.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-mouse-display'\r\n      });\r\n    }\r\n    /**\r\n     * Enquires updates to its own DOM as well as the DOM of its\r\n     * {@link VolumeLevelTooltip} child.\r\n     *\r\n     * @param {Object} rangeBarRect\r\n     *        The `ClientRect` for the {@link VolumeBar} element.\r\n     *\r\n     * @param {number} rangeBarPoint\r\n     *        A number from 0 to 1, representing a horizontal/vertical reference point\r\n     *        from the left edge of the {@link VolumeBar}\r\n     *\r\n     * @param {boolean} vertical\r\n     *        Referees to the Volume control position\r\n     *        in the control bar{@link VolumeControl}\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(rangeBarRect, rangeBarPoint, vertical) {\r\n      var _this2 = this;\r\n\r\n      var volume = 100 * rangeBarPoint;\r\n      this.getChild('volumeLevelTooltip').updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, function () {\r\n        if (vertical) {\r\n          _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + \"px\";\r\n        } else {\r\n          _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + \"px\";\r\n        }\r\n      });\r\n    };\r\n\r\n    return MouseVolumeLevelDisplay;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for `MouseVolumeLevelDisplay`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  MouseVolumeLevelDisplay.prototype.options_ = {\r\n    children: ['volumeLevelTooltip']\r\n  };\r\n  Component$1.registerComponent('MouseVolumeLevelDisplay', MouseVolumeLevelDisplay);\r\n\r\n  /**\r\n   * The bar that contains the volume level and can be clicked on to adjust the level\r\n   *\r\n   * @extends Slider\r\n   */\r\n\r\n  var VolumeBar = /*#__PURE__*/function (_Slider) {\r\n    inheritsLoose(VolumeBar, _Slider);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function VolumeBar(player, options) {\r\n      var _this;\r\n\r\n      _this = _Slider.call(this, player, options) || this;\r\n\r\n      _this.on('slideractive', function (e) {\r\n        return _this.updateLastVolume_(e);\r\n      });\r\n\r\n      _this.on(player, 'volumechange', function (e) {\r\n        return _this.updateARIAAttributes(e);\r\n      });\r\n\r\n      player.ready(function () {\r\n        return _this.updateARIAAttributes();\r\n      });\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = VolumeBar.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Slider.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-volume-bar vjs-slider-bar'\r\n      }, {\r\n        'aria-label': this.localize('Volume Level'),\r\n        'aria-live': 'polite'\r\n      });\r\n    }\r\n    /**\r\n     * Handle mouse down on volume bar\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mousedown` event that caused this to run.\r\n     *\r\n     * @listens mousedown\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseDown = function handleMouseDown(event) {\r\n      if (!isSingleLeftClick(event)) {\r\n        return;\r\n      }\r\n\r\n      _Slider.prototype.handleMouseDown.call(this, event);\r\n    }\r\n    /**\r\n     * Handle movement events on the {@link VolumeMenuButton}.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens mousemove\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseMove = function handleMouseMove(event) {\r\n      var mouseVolumeLevelDisplay = this.getChild('mouseVolumeLevelDisplay');\r\n\r\n      if (mouseVolumeLevelDisplay) {\r\n        var volumeBarEl = this.el();\r\n        var volumeBarRect = getBoundingClientRect(volumeBarEl);\r\n        var vertical = this.vertical();\r\n        var volumeBarPoint = getPointerPosition(volumeBarEl, event);\r\n        volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x; // The default skin has a gap on either side of the `VolumeBar`. This means\r\n        // that it's possible to trigger this behavior outside the boundaries of\r\n        // the `VolumeBar`. This ensures we stay within it at all times.\r\n\r\n        volumeBarPoint = clamp(volumeBarPoint, 0, 1);\r\n        mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);\r\n      }\r\n\r\n      if (!isSingleLeftClick(event)) {\r\n        return;\r\n      }\r\n\r\n      this.checkMuted();\r\n      this.player_.volume(this.calculateDistance(event));\r\n    }\r\n    /**\r\n     * If the player is muted unmute it.\r\n     */\r\n    ;\r\n\r\n    _proto.checkMuted = function checkMuted() {\r\n      if (this.player_.muted()) {\r\n        this.player_.muted(false);\r\n      }\r\n    }\r\n    /**\r\n     * Get percent of volume level\r\n     *\r\n     * @return {number}\r\n     *         Volume level percent as a decimal number.\r\n     */\r\n    ;\r\n\r\n    _proto.getPercent = function getPercent() {\r\n      if (this.player_.muted()) {\r\n        return 0;\r\n      }\r\n\r\n      return this.player_.volume();\r\n    }\r\n    /**\r\n     * Increase volume level for keyboard users\r\n     */\r\n    ;\r\n\r\n    _proto.stepForward = function stepForward() {\r\n      this.checkMuted();\r\n      this.player_.volume(this.player_.volume() + 0.1);\r\n    }\r\n    /**\r\n     * Decrease volume level for keyboard users\r\n     */\r\n    ;\r\n\r\n    _proto.stepBack = function stepBack() {\r\n      this.checkMuted();\r\n      this.player_.volume(this.player_.volume() - 0.1);\r\n    }\r\n    /**\r\n     * Update ARIA accessibility attributes\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `volumechange` event that caused this function to run.\r\n     *\r\n     * @listens Player#volumechange\r\n     */\r\n    ;\r\n\r\n    _proto.updateARIAAttributes = function updateARIAAttributes(event) {\r\n      var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\r\n      this.el_.setAttribute('aria-valuenow', ariaValue);\r\n      this.el_.setAttribute('aria-valuetext', ariaValue + '%');\r\n    }\r\n    /**\r\n     * Returns the current value of the player volume as a percentage\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.volumeAsPercentage_ = function volumeAsPercentage_() {\r\n      return Math.round(this.player_.volume() * 100);\r\n    }\r\n    /**\r\n     * When user starts dragging the VolumeBar, store the volume and listen for\r\n     * the end of the drag. When the drag ends, if the volume was set to zero,\r\n     * set lastVolume to the stored volume.\r\n     *\r\n     * @listens slideractive\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.updateLastVolume_ = function updateLastVolume_() {\r\n      var _this2 = this;\r\n\r\n      var volumeBeforeDrag = this.player_.volume();\r\n      this.one('sliderinactive', function () {\r\n        if (_this2.player_.volume() === 0) {\r\n          _this2.player_.lastVolume_(volumeBeforeDrag);\r\n        }\r\n      });\r\n    };\r\n\r\n    return VolumeBar;\r\n  }(Slider);\r\n  /**\r\n   * Default options for the `VolumeBar`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  VolumeBar.prototype.options_ = {\r\n    children: ['volumeLevel'],\r\n    barName: 'volumeLevel'\r\n  }; // MouseVolumeLevelDisplay tooltip should not be added to a player on mobile devices\r\n\r\n  if (!IS_IOS && !IS_ANDROID) {\r\n    VolumeBar.prototype.options_.children.splice(0, 0, 'mouseVolumeLevelDisplay');\r\n  }\r\n  /**\r\n   * Call the update event for this Slider when this event happens on the player.\r\n   *\r\n   * @type {string}\r\n   */\r\n\r\n\r\n  VolumeBar.prototype.playerEvent = 'volumechange';\r\n  Component$1.registerComponent('VolumeBar', VolumeBar);\r\n\r\n  /**\r\n   * The component for controlling the volume level\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var VolumeControl = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(VolumeControl, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     */\r\n    function VolumeControl(player, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      options.vertical = options.vertical || false; // Pass the vertical option down to the VolumeBar if\r\n      // the VolumeBar is turned on.\r\n\r\n      if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\r\n        options.volumeBar = options.volumeBar || {};\r\n        options.volumeBar.vertical = options.vertical;\r\n      }\r\n\r\n      _this = _Component.call(this, player, options) || this; // hide this control if volume support is missing\r\n\r\n      checkVolumeSupport(assertThisInitialized(_this), player);\r\n      _this.throttledHandleMouseMove = throttle(bind(assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\r\n\r\n      _this.handleMouseUpHandler_ = function (e) {\r\n        return _this.handleMouseUp(e);\r\n      };\r\n\r\n      _this.on('mousedown', function (e) {\r\n        return _this.handleMouseDown(e);\r\n      });\r\n\r\n      _this.on('touchstart', function (e) {\r\n        return _this.handleMouseDown(e);\r\n      });\r\n\r\n      _this.on('mousemove', function (e) {\r\n        return _this.handleMouseMove(e);\r\n      }); // while the slider is active (the mouse has been pressed down and\r\n      // is dragging) or in focus we do not want to hide the VolumeBar\r\n\r\n\r\n      _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {\r\n        _this.volumeBar.addClass('vjs-slider-active');\r\n\r\n        _this.addClass('vjs-slider-active');\r\n\r\n        _this.trigger('slideractive');\r\n      });\r\n\r\n      _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {\r\n        _this.volumeBar.removeClass('vjs-slider-active');\r\n\r\n        _this.removeClass('vjs-slider-active');\r\n\r\n        _this.trigger('sliderinactive');\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = VolumeControl.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      var orientationClass = 'vjs-volume-horizontal';\r\n\r\n      if (this.options_.vertical) {\r\n        orientationClass = 'vjs-volume-vertical';\r\n      }\r\n\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: \"vjs-volume-control vjs-control \" + orientationClass\r\n      });\r\n    }\r\n    /**\r\n     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mousedown` or `touchstart` event that triggered this function\r\n     *\r\n     * @listens mousedown\r\n     * @listens touchstart\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseDown = function handleMouseDown(event) {\r\n      var doc = this.el_.ownerDocument;\r\n      this.on(doc, 'mousemove', this.throttledHandleMouseMove);\r\n      this.on(doc, 'touchmove', this.throttledHandleMouseMove);\r\n      this.on(doc, 'mouseup', this.handleMouseUpHandler_);\r\n      this.on(doc, 'touchend', this.handleMouseUpHandler_);\r\n    }\r\n    /**\r\n     * Handle `mouseup` or `touchend` events on the `VolumeControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mouseup` or `touchend` event that triggered this function.\r\n     *\r\n     * @listens touchend\r\n     * @listens mouseup\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseUp = function handleMouseUp(event) {\r\n      var doc = this.el_.ownerDocument;\r\n      this.off(doc, 'mousemove', this.throttledHandleMouseMove);\r\n      this.off(doc, 'touchmove', this.throttledHandleMouseMove);\r\n      this.off(doc, 'mouseup', this.handleMouseUpHandler_);\r\n      this.off(doc, 'touchend', this.handleMouseUpHandler_);\r\n    }\r\n    /**\r\n     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        `mousedown` or `touchstart` event that triggered this function\r\n     *\r\n     * @listens mousedown\r\n     * @listens touchstart\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseMove = function handleMouseMove(event) {\r\n      this.volumeBar.handleMouseMove(event);\r\n    };\r\n\r\n    return VolumeControl;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for the `VolumeControl`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  VolumeControl.prototype.options_ = {\r\n    children: ['volumeBar']\r\n  };\r\n  Component$1.registerComponent('VolumeControl', VolumeControl);\r\n\r\n  /**\r\n   * Check if muting volume is supported and if it isn't hide the mute toggle\r\n   * button.\r\n   *\r\n   * @param {Component} self\r\n   *        A reference to the mute toggle button\r\n   *\r\n   * @param {Player} player\r\n   *        A reference to the player\r\n   *\r\n   * @private\r\n   */\r\n  var checkMuteSupport = function checkMuteSupport(self, player) {\r\n    // hide mute toggle button if it's not supported by the current tech\r\n    if (player.tech_ && !player.tech_.featuresMuteControl) {\r\n      self.addClass('vjs-hidden');\r\n    }\r\n\r\n    self.on(player, 'loadstart', function () {\r\n      if (!player.tech_.featuresMuteControl) {\r\n        self.addClass('vjs-hidden');\r\n      } else {\r\n        self.removeClass('vjs-hidden');\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * A button component for muting the audio.\r\n   *\r\n   * @extends Button\r\n   */\r\n\r\n  var MuteToggle = /*#__PURE__*/function (_Button) {\r\n    inheritsLoose(MuteToggle, _Button);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function MuteToggle(player, options) {\r\n      var _this;\r\n\r\n      _this = _Button.call(this, player, options) || this; // hide this control if volume support is missing\r\n\r\n      checkMuteSupport(assertThisInitialized(_this), player);\r\n\r\n      _this.on(player, ['loadstart', 'volumechange'], function (e) {\r\n        return _this.update(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = MuteToggle.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-mute-control \" + _Button.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * This gets called when an `MuteToggle` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      var vol = this.player_.volume();\r\n      var lastVolume = this.player_.lastVolume_();\r\n\r\n      if (vol === 0) {\r\n        var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\r\n        this.player_.volume(volumeToSet);\r\n        this.player_.muted(false);\r\n      } else {\r\n        this.player_.muted(this.player_.muted() ? false : true);\r\n      }\r\n    }\r\n    /**\r\n     * Update the `MuteToggle` button based on the state of `volume` and `muted`\r\n     * on the player.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The {@link Player#loadstart} event if this function was called\r\n     *        through an event.\r\n     *\r\n     * @listens Player#loadstart\r\n     * @listens Player#volumechange\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(event) {\r\n      this.updateIcon_();\r\n      this.updateControlText_();\r\n    }\r\n    /**\r\n     * Update the appearance of the `MuteToggle` icon.\r\n     *\r\n     * Possible states (given `level` variable below):\r\n     * - 0: crossed out\r\n     * - 1: zero bars of volume\r\n     * - 2: one bar of volume\r\n     * - 3: two bars of volume\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.updateIcon_ = function updateIcon_() {\r\n      var vol = this.player_.volume();\r\n      var level = 3; // in iOS when a player is loaded with muted attribute\r\n      // and volume is changed with a native mute button\r\n      // we want to make sure muted state is updated\r\n\r\n      if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {\r\n        this.player_.muted(this.player_.tech_.el_.muted);\r\n      }\r\n\r\n      if (vol === 0 || this.player_.muted()) {\r\n        level = 0;\r\n      } else if (vol < 0.33) {\r\n        level = 1;\r\n      } else if (vol < 0.67) {\r\n        level = 2;\r\n      } // TODO improve muted icon classes\r\n\r\n\r\n      for (var i = 0; i < 4; i++) {\r\n        removeClass(this.el_, \"vjs-vol-\" + i);\r\n      }\r\n\r\n      addClass(this.el_, \"vjs-vol-\" + level);\r\n    }\r\n    /**\r\n     * If `muted` has changed on the player, update the control text\r\n     * (`title` attribute on `vjs-mute-control` element and content of\r\n     * `vjs-control-text` element).\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.updateControlText_ = function updateControlText_() {\r\n      var soundOff = this.player_.muted() || this.player_.volume() === 0;\r\n      var text = soundOff ? 'Unmute' : 'Mute';\r\n\r\n      if (this.controlText() !== text) {\r\n        this.controlText(text);\r\n      }\r\n    };\r\n\r\n    return MuteToggle;\r\n  }(Button);\r\n  /**\r\n   * The text that should display over the `MuteToggle`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  MuteToggle.prototype.controlText_ = 'Mute';\r\n  Component$1.registerComponent('MuteToggle', MuteToggle);\r\n\r\n  /**\r\n   * A Component to contain the MuteToggle and VolumeControl so that\r\n   * they can work together.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var VolumePanel = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(VolumePanel, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     */\r\n    function VolumePanel(player, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      if (typeof options.inline !== 'undefined') {\r\n        options.inline = options.inline;\r\n      } else {\r\n        options.inline = true;\r\n      } // pass the inline option down to the VolumeControl as vertical if\r\n      // the VolumeControl is on.\r\n\r\n\r\n      if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\r\n        options.volumeControl = options.volumeControl || {};\r\n        options.volumeControl.vertical = !options.inline;\r\n      }\r\n\r\n      _this = _Component.call(this, player, options) || this; // this handler is used by mouse handler methods below\r\n\r\n      _this.handleKeyPressHandler_ = function (e) {\r\n        return _this.handleKeyPress(e);\r\n      };\r\n\r\n      _this.on(player, ['loadstart'], function (e) {\r\n        return _this.volumePanelState_(e);\r\n      });\r\n\r\n      _this.on(_this.muteToggle, 'keyup', function (e) {\r\n        return _this.handleKeyPress(e);\r\n      });\r\n\r\n      _this.on(_this.volumeControl, 'keyup', function (e) {\r\n        return _this.handleVolumeControlKeyUp(e);\r\n      });\r\n\r\n      _this.on('keydown', function (e) {\r\n        return _this.handleKeyPress(e);\r\n      });\r\n\r\n      _this.on('mouseover', function (e) {\r\n        return _this.handleMouseOver(e);\r\n      });\r\n\r\n      _this.on('mouseout', function (e) {\r\n        return _this.handleMouseOut(e);\r\n      }); // while the slider is active (the mouse has been pressed down and\r\n      // is dragging) we do not want to hide the VolumeBar\r\n\r\n\r\n      _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);\r\n\r\n      _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Add vjs-slider-active class to the VolumePanel\r\n     *\r\n     * @listens VolumeControl#slideractive\r\n     * @private\r\n     */\r\n\r\n\r\n    var _proto = VolumePanel.prototype;\r\n\r\n    _proto.sliderActive_ = function sliderActive_() {\r\n      this.addClass('vjs-slider-active');\r\n    }\r\n    /**\r\n     * Removes vjs-slider-active class to the VolumePanel\r\n     *\r\n     * @listens VolumeControl#sliderinactive\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.sliderInactive_ = function sliderInactive_() {\r\n      this.removeClass('vjs-slider-active');\r\n    }\r\n    /**\r\n     * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\r\n     * depending on MuteToggle and VolumeControl state\r\n     *\r\n     * @listens Player#loadstart\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.volumePanelState_ = function volumePanelState_() {\r\n      // hide volume panel if neither volume control or mute toggle\r\n      // are displayed\r\n      if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\r\n        this.addClass('vjs-hidden');\r\n      } // if only mute toggle is visible we don't want\r\n      // volume panel expanding when hovered or active\r\n\r\n\r\n      if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\r\n        this.addClass('vjs-mute-toggle-only');\r\n      }\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      var orientationClass = 'vjs-volume-panel-horizontal';\r\n\r\n      if (!this.options_.inline) {\r\n        orientationClass = 'vjs-volume-panel-vertical';\r\n      }\r\n\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: \"vjs-volume-panel vjs-control \" + orientationClass\r\n      });\r\n    }\r\n    /**\r\n     * Dispose of the `volume-panel` and all child components.\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.handleMouseOut();\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes\r\n     * the volume panel and sets focus on `MuteToggle`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keyup` event that caused this function to be called.\r\n     *\r\n     * @listens keyup\r\n     */\r\n    ;\r\n\r\n    _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event) {\r\n      if (keycode.isEventKey(event, 'Esc')) {\r\n        this.muteToggle.focus();\r\n      }\r\n    }\r\n    /**\r\n     * This gets called when a `VolumePanel` gains hover via a `mouseover` event.\r\n     * Turns on listening for `mouseover` event. When they happen it\r\n     * calls `this.handleMouseOver`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mouseover` event that caused this function to be called.\r\n     *\r\n     * @listens mouseover\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseOver = function handleMouseOver(event) {\r\n      this.addClass('vjs-hover');\r\n      on(document, 'keyup', this.handleKeyPressHandler_);\r\n    }\r\n    /**\r\n     * This gets called when a `VolumePanel` gains hover via a `mouseout` event.\r\n     * Turns on listening for `mouseout` event. When they happen it\r\n     * calls `this.handleMouseOut`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mouseout` event that caused this function to be called.\r\n     *\r\n     * @listens mouseout\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseOut = function handleMouseOut(event) {\r\n      this.removeClass('vjs-hover');\r\n      off(document, 'keyup', this.handleKeyPressHandler_);\r\n    }\r\n    /**\r\n     * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,\r\n     * looking for ESC, which hides the `VolumeControl`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The keypress that triggered this event.\r\n     *\r\n     * @listens keydown | keyup\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyPress = function handleKeyPress(event) {\r\n      if (keycode.isEventKey(event, 'Esc')) {\r\n        this.handleMouseOut();\r\n      }\r\n    };\r\n\r\n    return VolumePanel;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for the `VolumeControl`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  VolumePanel.prototype.options_ = {\r\n    children: ['muteToggle', 'volumeControl']\r\n  };\r\n  Component$1.registerComponent('VolumePanel', VolumePanel);\r\n\r\n  /**\r\n   * The Menu component is used to build popup menus, including subtitle and\r\n   * captions selection menus.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var Menu = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(Menu, _Component);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        the player that this component should attach to\r\n     *\r\n     * @param {Object} [options]\r\n     *        Object of option names and values\r\n     *\r\n     */\r\n    function Menu(player, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n\r\n      if (options) {\r\n        _this.menuButton_ = options.menuButton;\r\n      }\r\n\r\n      _this.focusedChild_ = -1;\r\n\r\n      _this.on('keydown', function (e) {\r\n        return _this.handleKeyDown(e);\r\n      }); // All the menu item instances share the same blur handler provided by the menu container.\r\n\r\n\r\n      _this.boundHandleBlur_ = function (e) {\r\n        return _this.handleBlur(e);\r\n      };\r\n\r\n      _this.boundHandleTapClick_ = function (e) {\r\n        return _this.handleTapClick(e);\r\n      };\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Add event listeners to the {@link MenuItem}.\r\n     *\r\n     * @param {Object} component\r\n     *        The instance of the `MenuItem` to add listeners to.\r\n     *\r\n     */\r\n\r\n\r\n    var _proto = Menu.prototype;\r\n\r\n    _proto.addEventListenerForItem = function addEventListenerForItem(component) {\r\n      if (!(component instanceof Component$1)) {\r\n        return;\r\n      }\r\n\r\n      this.on(component, 'blur', this.boundHandleBlur_);\r\n      this.on(component, ['tap', 'click'], this.boundHandleTapClick_);\r\n    }\r\n    /**\r\n     * Remove event listeners from the {@link MenuItem}.\r\n     *\r\n     * @param {Object} component\r\n     *        The instance of the `MenuItem` to remove listeners.\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {\r\n      if (!(component instanceof Component$1)) {\r\n        return;\r\n      }\r\n\r\n      this.off(component, 'blur', this.boundHandleBlur_);\r\n      this.off(component, ['tap', 'click'], this.boundHandleTapClick_);\r\n    }\r\n    /**\r\n     * This method will be called indirectly when the component has been added\r\n     * before the component adds to the new menu instance by `addItem`.\r\n     * In this case, the original menu instance will remove the component\r\n     * by calling `removeChild`.\r\n     *\r\n     * @param {Object} component\r\n     *        The instance of the `MenuItem`\r\n     */\r\n    ;\r\n\r\n    _proto.removeChild = function removeChild(component) {\r\n      if (typeof component === 'string') {\r\n        component = this.getChild(component);\r\n      }\r\n\r\n      this.removeEventListenerForItem(component);\r\n\r\n      _Component.prototype.removeChild.call(this, component);\r\n    }\r\n    /**\r\n     * Add a {@link MenuItem} to the menu.\r\n     *\r\n     * @param {Object|string} component\r\n     *        The name or instance of the `MenuItem` to add.\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.addItem = function addItem(component) {\r\n      var childComponent = this.addChild(component);\r\n\r\n      if (childComponent) {\r\n        this.addEventListenerForItem(childComponent);\r\n      }\r\n    }\r\n    /**\r\n     * Create the `Menu`s DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         the element that was created\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var contentElType = this.options_.contentElType || 'ul';\r\n      this.contentEl_ = createEl(contentElType, {\r\n        className: 'vjs-menu-content'\r\n      });\r\n      this.contentEl_.setAttribute('role', 'menu');\r\n\r\n      var el = _Component.prototype.createEl.call(this, 'div', {\r\n        append: this.contentEl_,\r\n        className: 'vjs-menu'\r\n      });\r\n\r\n      el.appendChild(this.contentEl_); // Prevent clicks from bubbling up. Needed for Menu Buttons,\r\n      // where a click on the parent is significant\r\n\r\n      on(el, 'click', function (event) {\r\n        event.preventDefault();\r\n        event.stopImmediatePropagation();\r\n      });\r\n      return el;\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.contentEl_ = null;\r\n      this.boundHandleBlur_ = null;\r\n      this.boundHandleTapClick_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Called when a `MenuItem` loses focus.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `blur` event that caused this function to be called.\r\n     *\r\n     * @listens blur\r\n     */\r\n    ;\r\n\r\n    _proto.handleBlur = function handleBlur(event) {\r\n      var relatedTarget = event.relatedTarget || document.activeElement; // Close menu popup when a user clicks outside the menu\r\n\r\n      if (!this.children().some(function (element) {\r\n        return element.el() === relatedTarget;\r\n      })) {\r\n        var btn = this.menuButton_;\r\n\r\n        if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {\r\n          btn.unpressButton();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Called when a `MenuItem` gets clicked or tapped.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `click` or `tap` event that caused this function to be called.\r\n     *\r\n     * @listens click,tap\r\n     */\r\n    ;\r\n\r\n    _proto.handleTapClick = function handleTapClick(event) {\r\n      // Unpress the associated MenuButton, and move focus back to it\r\n      if (this.menuButton_) {\r\n        this.menuButton_.unpressButton();\r\n        var childComponents = this.children();\r\n\r\n        if (!Array.isArray(childComponents)) {\r\n          return;\r\n        }\r\n\r\n        var foundComponent = childComponents.filter(function (component) {\r\n          return component.el() === event.target;\r\n        })[0];\r\n\r\n        if (!foundComponent) {\r\n          return;\r\n        } // don't focus menu button if item is a caption settings item\r\n        // because focus will move elsewhere\r\n\r\n\r\n        if (foundComponent.name() !== 'CaptionSettingsMenuItem') {\r\n          this.menuButton_.focus();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Handle a `keydown` event on this menu. This listener is added in the constructor.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        A `keydown` event that happened on the menu.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Left and Down Arrows\r\n      if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.stepForward(); // Up and Right Arrows\r\n      } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.stepBack();\r\n      }\r\n    }\r\n    /**\r\n     * Move to next (lower) menu item for keyboard users.\r\n     */\r\n    ;\r\n\r\n    _proto.stepForward = function stepForward() {\r\n      var stepChild = 0;\r\n\r\n      if (this.focusedChild_ !== undefined) {\r\n        stepChild = this.focusedChild_ + 1;\r\n      }\r\n\r\n      this.focus(stepChild);\r\n    }\r\n    /**\r\n     * Move to previous (higher) menu item for keyboard users.\r\n     */\r\n    ;\r\n\r\n    _proto.stepBack = function stepBack() {\r\n      var stepChild = 0;\r\n\r\n      if (this.focusedChild_ !== undefined) {\r\n        stepChild = this.focusedChild_ - 1;\r\n      }\r\n\r\n      this.focus(stepChild);\r\n    }\r\n    /**\r\n     * Set focus on a {@link MenuItem} in the `Menu`.\r\n     *\r\n     * @param {Object|string} [item=0]\r\n     *        Index of child item set focus on.\r\n     */\r\n    ;\r\n\r\n    _proto.focus = function focus(item) {\r\n      if (item === void 0) {\r\n        item = 0;\r\n      }\r\n\r\n      var children = this.children().slice();\r\n      var haveTitle = children.length && children[0].hasClass('vjs-menu-title');\r\n\r\n      if (haveTitle) {\r\n        children.shift();\r\n      }\r\n\r\n      if (children.length > 0) {\r\n        if (item < 0) {\r\n          item = 0;\r\n        } else if (item >= children.length) {\r\n          item = children.length - 1;\r\n        }\r\n\r\n        this.focusedChild_ = item;\r\n        children[item].el_.focus();\r\n      }\r\n    };\r\n\r\n    return Menu;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('Menu', Menu);\r\n\r\n  /**\r\n   * A `MenuButton` class for any popup {@link Menu}.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var MenuButton = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(MenuButton, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     */\r\n    function MenuButton(player, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _Component.call(this, player, options) || this;\r\n      _this.menuButton_ = new Button(player, options);\r\n\r\n      _this.menuButton_.controlText(_this.controlText_);\r\n\r\n      _this.menuButton_.el_.setAttribute('aria-haspopup', 'true'); // Add buildCSSClass values to the button, not the wrapper\r\n\r\n\r\n      var buttonClass = Button.prototype.buildCSSClass();\r\n      _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;\r\n\r\n      _this.menuButton_.removeClass('vjs-control');\r\n\r\n      _this.addChild(_this.menuButton_);\r\n\r\n      _this.update();\r\n\r\n      _this.enabled_ = true;\r\n\r\n      var handleClick = function handleClick(e) {\r\n        return _this.handleClick(e);\r\n      };\r\n\r\n      _this.handleMenuKeyUp_ = function (e) {\r\n        return _this.handleMenuKeyUp(e);\r\n      };\r\n\r\n      _this.on(_this.menuButton_, 'tap', handleClick);\r\n\r\n      _this.on(_this.menuButton_, 'click', handleClick);\r\n\r\n      _this.on(_this.menuButton_, 'keydown', function (e) {\r\n        return _this.handleKeyDown(e);\r\n      });\r\n\r\n      _this.on(_this.menuButton_, 'mouseenter', function () {\r\n        _this.addClass('vjs-hover');\r\n\r\n        _this.menu.show();\r\n\r\n        on(document, 'keyup', _this.handleMenuKeyUp_);\r\n      });\r\n\r\n      _this.on('mouseleave', function (e) {\r\n        return _this.handleMouseLeave(e);\r\n      });\r\n\r\n      _this.on('keydown', function (e) {\r\n        return _this.handleSubmenuKeyDown(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Update the menu based on the current state of its items.\r\n     */\r\n\r\n\r\n    var _proto = MenuButton.prototype;\r\n\r\n    _proto.update = function update() {\r\n      var menu = this.createMenu();\r\n\r\n      if (this.menu) {\r\n        this.menu.dispose();\r\n        this.removeChild(this.menu);\r\n      }\r\n\r\n      this.menu = menu;\r\n      this.addChild(menu);\r\n      /**\r\n       * Track the state of the menu button\r\n       *\r\n       * @type {Boolean}\r\n       * @private\r\n       */\r\n\r\n      this.buttonPressed_ = false;\r\n      this.menuButton_.el_.setAttribute('aria-expanded', 'false');\r\n\r\n      if (this.items && this.items.length <= this.hideThreshold_) {\r\n        this.hide();\r\n        this.menu.contentEl_.removeAttribute('role');\r\n      } else {\r\n        this.show();\r\n        this.menu.contentEl_.setAttribute('role', 'menu');\r\n      }\r\n    }\r\n    /**\r\n     * Create the menu and add all items to it.\r\n     *\r\n     * @return {Menu}\r\n     *         The constructed menu\r\n     */\r\n    ;\r\n\r\n    _proto.createMenu = function createMenu() {\r\n      var menu = new Menu(this.player_, {\r\n        menuButton: this\r\n      });\r\n      /**\r\n       * Hide the menu if the number of items is less than or equal to this threshold. This defaults\r\n       * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\r\n       * it here because every time we run `createMenu` we need to reset the value.\r\n       *\r\n       * @protected\r\n       * @type {Number}\r\n       */\r\n\r\n      this.hideThreshold_ = 0; // Add a title list item to the top\r\n\r\n      if (this.options_.title) {\r\n        var titleEl = createEl('li', {\r\n          className: 'vjs-menu-title',\r\n          textContent: toTitleCase$1(this.options_.title),\r\n          tabIndex: -1\r\n        });\r\n        var titleComponent = new Component$1(this.player_, {\r\n          el: titleEl\r\n        });\r\n        menu.addItem(titleComponent);\r\n      }\r\n\r\n      this.items = this.createItems();\r\n\r\n      if (this.items) {\r\n        // Add menu items to the menu\r\n        for (var i = 0; i < this.items.length; i++) {\r\n          menu.addItem(this.items[i]);\r\n        }\r\n      }\r\n\r\n      return menu;\r\n    }\r\n    /**\r\n     * Create the list of menu items. Specific to each subclass.\r\n     *\r\n     * @abstract\r\n     */\r\n    ;\r\n\r\n    _proto.createItems = function createItems() {}\r\n    /**\r\n     * Create the `MenuButtons`s DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: this.buildWrapperCSSClass()\r\n      }, {});\r\n    }\r\n    /**\r\n     * Allow sub components to stack CSS class names for the wrapper element\r\n     *\r\n     * @return {string}\r\n     *         The constructed wrapper DOM `className`\r\n     */\r\n    ;\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      var menuButtonClass = 'vjs-menu-button'; // If the inline option is passed, we want to use different styles altogether.\r\n\r\n      if (this.options_.inline === true) {\r\n        menuButtonClass += '-inline';\r\n      } else {\r\n        menuButtonClass += '-popup';\r\n      } // TODO: Fix the CSS so that this isn't necessary\r\n\r\n\r\n      var buttonClass = Button.prototype.buildCSSClass();\r\n      return \"vjs-menu-button \" + menuButtonClass + \" \" + buttonClass + \" \" + _Component.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    ;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      var menuButtonClass = 'vjs-menu-button'; // If the inline option is passed, we want to use different styles altogether.\r\n\r\n      if (this.options_.inline === true) {\r\n        menuButtonClass += '-inline';\r\n      } else {\r\n        menuButtonClass += '-popup';\r\n      }\r\n\r\n      return \"vjs-menu-button \" + menuButtonClass + \" \" + _Component.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Get or set the localized control text that will be used for accessibility.\r\n     *\r\n     * > NOTE: This will come from the internal `menuButton_` element.\r\n     *\r\n     * @param {string} [text]\r\n     *        Control text for element.\r\n     *\r\n     * @param {Element} [el=this.menuButton_.el()]\r\n     *        Element to set the title on.\r\n     *\r\n     * @return {string}\r\n     *         - The control text when getting\r\n     */\r\n    ;\r\n\r\n    _proto.controlText = function controlText(text, el) {\r\n      if (el === void 0) {\r\n        el = this.menuButton_.el();\r\n      }\r\n\r\n      return this.menuButton_.controlText(text, el);\r\n    }\r\n    /**\r\n     * Dispose of the `menu-button` and all child components.\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.handleMouseLeave();\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Handle a click on a `MenuButton`.\r\n     * See {@link ClickableComponent#handleClick} for instances where this is called.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      if (this.buttonPressed_) {\r\n        this.unpressButton();\r\n      } else {\r\n        this.pressButton();\r\n      }\r\n    }\r\n    /**\r\n     * Handle `mouseleave` for `MenuButton`.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `mouseleave` event that caused this function to be called.\r\n     *\r\n     * @listens mouseleave\r\n     */\r\n    ;\r\n\r\n    _proto.handleMouseLeave = function handleMouseLeave(event) {\r\n      this.removeClass('vjs-hover');\r\n      off(document, 'keyup', this.handleMenuKeyUp_);\r\n    }\r\n    /**\r\n     * Set the focus to the actual button, not to this element\r\n     */\r\n    ;\r\n\r\n    _proto.focus = function focus() {\r\n      this.menuButton_.focus();\r\n    }\r\n    /**\r\n     * Remove the focus from the actual button, not this element\r\n     */\r\n    ;\r\n\r\n    _proto.blur = function blur() {\r\n      this.menuButton_.blur();\r\n    }\r\n    /**\r\n     * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\r\n     * {@link ClickableComponent#handleKeyDown} for instances where this is called.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      // Escape or Tab unpress the 'button'\r\n      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\r\n        if (this.buttonPressed_) {\r\n          this.unpressButton();\r\n        } // Don't preventDefault for Tab key - we still want to lose focus\r\n\r\n\r\n        if (!keycode.isEventKey(event, 'Tab')) {\r\n          event.preventDefault(); // Set focus back to the menu button's button\r\n\r\n          this.menuButton_.focus();\r\n        } // Up Arrow or Down Arrow also 'press' the button to open the menu\r\n\r\n      } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {\r\n        if (!this.buttonPressed_) {\r\n          event.preventDefault();\r\n          this.pressButton();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Handle a `keyup` event on a `MenuButton`. The listener for this is added in\r\n     * the constructor.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        Key press event\r\n     *\r\n     * @listens keyup\r\n     */\r\n    ;\r\n\r\n    _proto.handleMenuKeyUp = function handleMenuKeyUp(event) {\r\n      // Escape hides popup menu\r\n      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\r\n        this.removeClass('vjs-hover');\r\n      }\r\n    }\r\n    /**\r\n     * This method name now delegates to `handleSubmenuKeyDown`. This means\r\n     * anyone calling `handleSubmenuKeyPress` will not see their method calls\r\n     * stop working.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to be called.\r\n     */\r\n    ;\r\n\r\n    _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\r\n      this.handleSubmenuKeyDown(event);\r\n    }\r\n    /**\r\n     * Handle a `keydown` event on a sub-menu. The listener for this is added in\r\n     * the constructor.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        Key press event\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event) {\r\n      // Escape or Tab unpress the 'button'\r\n      if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\r\n        if (this.buttonPressed_) {\r\n          this.unpressButton();\r\n        } // Don't preventDefault for Tab key - we still want to lose focus\r\n\r\n\r\n        if (!keycode.isEventKey(event, 'Tab')) {\r\n          event.preventDefault(); // Set focus back to the menu button's button\r\n\r\n          this.menuButton_.focus();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Put the current `MenuButton` into a pressed state.\r\n     */\r\n    ;\r\n\r\n    _proto.pressButton = function pressButton() {\r\n      if (this.enabled_) {\r\n        this.buttonPressed_ = true;\r\n        this.menu.show();\r\n        this.menu.lockShowing();\r\n        this.menuButton_.el_.setAttribute('aria-expanded', 'true'); // set the focus into the submenu, except on iOS where it is resulting in\r\n        // undesired scrolling behavior when the player is in an iframe\r\n\r\n        if (IS_IOS && isInFrame()) {\r\n          // Return early so that the menu isn't focused\r\n          return;\r\n        }\r\n\r\n        this.menu.focus();\r\n      }\r\n    }\r\n    /**\r\n     * Take the current `MenuButton` out of a pressed state.\r\n     */\r\n    ;\r\n\r\n    _proto.unpressButton = function unpressButton() {\r\n      if (this.enabled_) {\r\n        this.buttonPressed_ = false;\r\n        this.menu.unlockShowing();\r\n        this.menu.hide();\r\n        this.menuButton_.el_.setAttribute('aria-expanded', 'false');\r\n      }\r\n    }\r\n    /**\r\n     * Disable the `MenuButton`. Don't allow it to be clicked.\r\n     */\r\n    ;\r\n\r\n    _proto.disable = function disable() {\r\n      this.unpressButton();\r\n      this.enabled_ = false;\r\n      this.addClass('vjs-disabled');\r\n      this.menuButton_.disable();\r\n    }\r\n    /**\r\n     * Enable the `MenuButton`. Allow it to be clicked.\r\n     */\r\n    ;\r\n\r\n    _proto.enable = function enable() {\r\n      this.enabled_ = true;\r\n      this.removeClass('vjs-disabled');\r\n      this.menuButton_.enable();\r\n    };\r\n\r\n    return MenuButton;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('MenuButton', MenuButton);\r\n\r\n  /**\r\n   * The base class for buttons that toggle specific  track types (e.g. subtitles).\r\n   *\r\n   * @extends MenuButton\r\n   */\r\n\r\n  var TrackButton = /*#__PURE__*/function (_MenuButton) {\r\n    inheritsLoose(TrackButton, _MenuButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function TrackButton(player, options) {\r\n      var _this;\r\n\r\n      var tracks = options.tracks;\r\n      _this = _MenuButton.call(this, player, options) || this;\r\n\r\n      if (_this.items.length <= 1) {\r\n        _this.hide();\r\n      }\r\n\r\n      if (!tracks) {\r\n        return assertThisInitialized(_this);\r\n      }\r\n\r\n      var updateHandler = bind(assertThisInitialized(_this), _this.update);\r\n      tracks.addEventListener('removetrack', updateHandler);\r\n      tracks.addEventListener('addtrack', updateHandler);\r\n      tracks.addEventListener('labelchange', updateHandler);\r\n\r\n      _this.player_.on('ready', updateHandler);\r\n\r\n      _this.player_.on('dispose', function () {\r\n        tracks.removeEventListener('removetrack', updateHandler);\r\n        tracks.removeEventListener('addtrack', updateHandler);\r\n        tracks.removeEventListener('labelchange', updateHandler);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n\r\n    return TrackButton;\r\n  }(MenuButton);\r\n\r\n  Component$1.registerComponent('TrackButton', TrackButton);\r\n\r\n  /**\r\n   * @file menu-keys.js\r\n   */\r\n\r\n  /**\r\n    * All keys used for operation of a menu (`MenuButton`, `Menu`, and `MenuItem`)\r\n    * Note that 'Enter' and 'Space' are not included here (otherwise they would\r\n    * prevent the `MenuButton` and `MenuItem` from being keyboard-clickable)\r\n    * @typedef MenuKeys\r\n    * @array\r\n    */\r\n  var MenuKeys = ['Tab', 'Esc', 'Up', 'Down', 'Right', 'Left'];\r\n\r\n  /**\r\n   * The component for a menu item. `<li>`\r\n   *\r\n   * @extends ClickableComponent\r\n   */\r\n\r\n  var MenuItem = /*#__PURE__*/function (_ClickableComponent) {\r\n    inheritsLoose(MenuItem, _ClickableComponent);\r\n\r\n    /**\r\n     * Creates an instance of the this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     *\r\n     */\r\n    function MenuItem(player, options) {\r\n      var _this;\r\n\r\n      _this = _ClickableComponent.call(this, player, options) || this;\r\n      _this.selectable = options.selectable;\r\n      _this.isSelected_ = options.selected || false;\r\n      _this.multiSelectable = options.multiSelectable;\r\n\r\n      _this.selected(_this.isSelected_);\r\n\r\n      if (_this.selectable) {\r\n        if (_this.multiSelectable) {\r\n          _this.el_.setAttribute('role', 'menuitemcheckbox');\r\n        } else {\r\n          _this.el_.setAttribute('role', 'menuitemradio');\r\n        }\r\n      } else {\r\n        _this.el_.setAttribute('role', 'menuitem');\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `MenuItem's DOM element\r\n     *\r\n     * @param {string} [type=li]\r\n     *        Element's node type, not actually used, always set to `li`.\r\n     *\r\n     * @param {Object} [props={}]\r\n     *        An object of properties that should be set on the element\r\n     *\r\n     * @param {Object} [attrs={}]\r\n     *        An object of attributes that should be set on the element\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n\r\n\r\n    var _proto = MenuItem.prototype;\r\n\r\n    _proto.createEl = function createEl$1(type, props, attrs) {\r\n      // The control is textual, not just an icon\r\n      this.nonIconControl = true;\r\n\r\n      var el = _ClickableComponent.prototype.createEl.call(this, 'li', assign({\r\n        className: 'vjs-menu-item',\r\n        tabIndex: -1\r\n      }, props), attrs); // swap icon with menu item text.\r\n\r\n\r\n      el.replaceChild(createEl('span', {\r\n        className: 'vjs-menu-item-text',\r\n        textContent: this.localize(this.options_.label)\r\n      }), el.querySelector('.vjs-icon-placeholder'));\r\n      return el;\r\n    }\r\n    /**\r\n     * Ignore keys which are used by the menu, but pass any other ones up. See\r\n     * {@link ClickableComponent#handleKeyDown} for instances where this is called.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      if (!MenuKeys.some(function (key) {\r\n        return keycode.isEventKey(event, key);\r\n      })) {\r\n        // Pass keydown handling up for unused keys\r\n        _ClickableComponent.prototype.handleKeyDown.call(this, event);\r\n      }\r\n    }\r\n    /**\r\n     * Any click on a `MenuItem` puts it into the selected state.\r\n     * See {@link ClickableComponent#handleClick} for instances where this is called.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      this.selected(true);\r\n    }\r\n    /**\r\n     * Set the state for this menu item as selected or not.\r\n     *\r\n     * @param {boolean} selected\r\n     *        if the menu item is selected or not\r\n     */\r\n    ;\r\n\r\n    _proto.selected = function selected(_selected) {\r\n      if (this.selectable) {\r\n        if (_selected) {\r\n          this.addClass('vjs-selected');\r\n          this.el_.setAttribute('aria-checked', 'true'); // aria-checked isn't fully supported by browsers/screen readers,\r\n          // so indicate selected state to screen reader in the control text.\r\n\r\n          this.controlText(', selected');\r\n          this.isSelected_ = true;\r\n        } else {\r\n          this.removeClass('vjs-selected');\r\n          this.el_.setAttribute('aria-checked', 'false'); // Indicate un-selected state to screen reader\r\n\r\n          this.controlText('');\r\n          this.isSelected_ = false;\r\n        }\r\n      }\r\n    };\r\n\r\n    return MenuItem;\r\n  }(ClickableComponent);\r\n\r\n  Component$1.registerComponent('MenuItem', MenuItem);\r\n\r\n  /**\r\n   * The specific menu item type for selecting a language within a text track kind\r\n   *\r\n   * @extends MenuItem\r\n   */\r\n\r\n  var TextTrackMenuItem = /*#__PURE__*/function (_MenuItem) {\r\n    inheritsLoose(TextTrackMenuItem, _MenuItem);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function TextTrackMenuItem(player, options) {\r\n      var _this;\r\n\r\n      var track = options.track;\r\n      var tracks = player.textTracks(); // Modify options for parent MenuItem class's init.\r\n\r\n      options.label = track.label || track.language || 'Unknown';\r\n      options.selected = track.mode === 'showing';\r\n      _this = _MenuItem.call(this, player, options) || this;\r\n      _this.track = track; // Determine the relevant kind(s) of tracks for this component and filter\r\n      // out empty kinds.\r\n\r\n      _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);\r\n\r\n      var changeHandler = function changeHandler() {\r\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n          args[_key] = arguments[_key];\r\n        }\r\n\r\n        _this.handleTracksChange.apply(assertThisInitialized(_this), args);\r\n      };\r\n\r\n      var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {\r\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n          args[_key2] = arguments[_key2];\r\n        }\r\n\r\n        _this.handleSelectedLanguageChange.apply(assertThisInitialized(_this), args);\r\n      };\r\n\r\n      player.on(['loadstart', 'texttrackchange'], changeHandler);\r\n      tracks.addEventListener('change', changeHandler);\r\n      tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\r\n\r\n      _this.on('dispose', function () {\r\n        player.off(['loadstart', 'texttrackchange'], changeHandler);\r\n        tracks.removeEventListener('change', changeHandler);\r\n        tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\r\n      }); // iOS7 doesn't dispatch change events to TextTrackLists when an\r\n      // associated track's mode changes. Without something like\r\n      // Object.observe() (also not present on iOS7), it's not\r\n      // possible to detect changes to the mode attribute and polyfill\r\n      // the change event. As a poor substitute, we manually dispatch\r\n      // change events whenever the controls modify the mode.\r\n\r\n\r\n      if (tracks.onchange === undefined) {\r\n        var event;\r\n\r\n        _this.on(['tap', 'click'], function () {\r\n          if (typeof window.Event !== 'object') {\r\n            // Android 2.3 throws an Illegal Constructor error for window.Event\r\n            try {\r\n              event = new window.Event('change');\r\n            } catch (err) {// continue regardless of error\r\n            }\r\n          }\r\n\r\n          if (!event) {\r\n            event = document.createEvent('Event');\r\n            event.initEvent('change', true, true);\r\n          }\r\n\r\n          tracks.dispatchEvent(event);\r\n        });\r\n      } // set the default state based on current tracks\r\n\r\n\r\n      _this.handleTracksChange();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * This gets called when an `TextTrackMenuItem` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n\r\n\r\n    var _proto = TextTrackMenuItem.prototype;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      var referenceTrack = this.track;\r\n      var tracks = this.player_.textTracks();\r\n\r\n      _MenuItem.prototype.handleClick.call(this, event);\r\n\r\n      if (!tracks) {\r\n        return;\r\n      }\r\n\r\n      for (var i = 0; i < tracks.length; i++) {\r\n        var track = tracks[i]; // If the track from the text tracks list is not of the right kind,\r\n        // skip it. We do not want to affect tracks of incompatible kind(s).\r\n\r\n        if (this.kinds.indexOf(track.kind) === -1) {\r\n          continue;\r\n        } // If this text track is the component's track and it is not showing,\r\n        // set it to showing.\r\n\r\n\r\n        if (track === referenceTrack) {\r\n          if (track.mode !== 'showing') {\r\n            track.mode = 'showing';\r\n          } // If this text track is not the component's track and it is not\r\n          // disabled, set it to disabled.\r\n\r\n        } else if (track.mode !== 'disabled') {\r\n          track.mode = 'disabled';\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Handle text track list change\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `change` event that caused this function to be called.\r\n     *\r\n     * @listens TextTrackList#change\r\n     */\r\n    ;\r\n\r\n    _proto.handleTracksChange = function handleTracksChange(event) {\r\n      var shouldBeSelected = this.track.mode === 'showing'; // Prevent redundant selected() calls because they may cause\r\n      // screen readers to read the appended control text unnecessarily\r\n\r\n      if (shouldBeSelected !== this.isSelected_) {\r\n        this.selected(shouldBeSelected);\r\n      }\r\n    };\r\n\r\n    _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\r\n      if (this.track.mode === 'showing') {\r\n        var selectedLanguage = this.player_.cache_.selectedLanguage; // Don't replace the kind of track across the same language\r\n\r\n        if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\r\n          return;\r\n        }\r\n\r\n        this.player_.cache_.selectedLanguage = {\r\n          enabled: true,\r\n          language: this.track.language,\r\n          kind: this.track.kind\r\n        };\r\n      }\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      // remove reference to track object on dispose\r\n      this.track = null;\r\n\r\n      _MenuItem.prototype.dispose.call(this);\r\n    };\r\n\r\n    return TextTrackMenuItem;\r\n  }(MenuItem);\r\n\r\n  Component$1.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\r\n\r\n  /**\r\n   * A special menu item for turning of a specific type of text track\r\n   *\r\n   * @extends TextTrackMenuItem\r\n   */\r\n\r\n  var OffTextTrackMenuItem = /*#__PURE__*/function (_TextTrackMenuItem) {\r\n    inheritsLoose(OffTextTrackMenuItem, _TextTrackMenuItem);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function OffTextTrackMenuItem(player, options) {\r\n      // Create pseudo track info\r\n      // Requires options['kind']\r\n      options.track = {\r\n        player: player,\r\n        // it is no longer necessary to store `kind` or `kinds` on the track itself\r\n        // since they are now stored in the `kinds` property of all instances of\r\n        // TextTrackMenuItem, but this will remain for backwards compatibility\r\n        kind: options.kind,\r\n        kinds: options.kinds,\r\n        \"default\": false,\r\n        mode: 'disabled'\r\n      };\r\n\r\n      if (!options.kinds) {\r\n        options.kinds = [options.kind];\r\n      }\r\n\r\n      if (options.label) {\r\n        options.track.label = options.label;\r\n      } else {\r\n        options.track.label = options.kinds.join(' and ') + ' off';\r\n      } // MenuItem is selectable\r\n\r\n\r\n      options.selectable = true; // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\r\n\r\n      options.multiSelectable = false;\r\n      return _TextTrackMenuItem.call(this, player, options) || this;\r\n    }\r\n    /**\r\n     * Handle text track change\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to run\r\n     */\r\n\r\n\r\n    var _proto = OffTextTrackMenuItem.prototype;\r\n\r\n    _proto.handleTracksChange = function handleTracksChange(event) {\r\n      var tracks = this.player().textTracks();\r\n      var shouldBeSelected = true;\r\n\r\n      for (var i = 0, l = tracks.length; i < l; i++) {\r\n        var track = tracks[i];\r\n\r\n        if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\r\n          shouldBeSelected = false;\r\n          break;\r\n        }\r\n      } // Prevent redundant selected() calls because they may cause\r\n      // screen readers to read the appended control text unnecessarily\r\n\r\n\r\n      if (shouldBeSelected !== this.isSelected_) {\r\n        this.selected(shouldBeSelected);\r\n      }\r\n    };\r\n\r\n    _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\r\n      var tracks = this.player().textTracks();\r\n      var allHidden = true;\r\n\r\n      for (var i = 0, l = tracks.length; i < l; i++) {\r\n        var track = tracks[i];\r\n\r\n        if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\r\n          allHidden = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (allHidden) {\r\n        this.player_.cache_.selectedLanguage = {\r\n          enabled: false\r\n        };\r\n      }\r\n    };\r\n\r\n    return OffTextTrackMenuItem;\r\n  }(TextTrackMenuItem);\r\n\r\n  Component$1.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\r\n\r\n  /**\r\n   * The base class for buttons that toggle specific text track types (e.g. subtitles)\r\n   *\r\n   * @extends MenuButton\r\n   */\r\n\r\n  var TextTrackButton = /*#__PURE__*/function (_TrackButton) {\r\n    inheritsLoose(TextTrackButton, _TrackButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     */\r\n    function TextTrackButton(player, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      options.tracks = player.textTracks();\r\n      return _TrackButton.call(this, player, options) || this;\r\n    }\r\n    /**\r\n     * Create a menu item for each text track\r\n     *\r\n     * @param {TextTrackMenuItem[]} [items=[]]\r\n     *        Existing array of items to use during creation\r\n     *\r\n     * @return {TextTrackMenuItem[]}\r\n     *         Array of menu items that were created\r\n     */\r\n\r\n\r\n    var _proto = TextTrackButton.prototype;\r\n\r\n    _proto.createItems = function createItems(items, TrackMenuItem) {\r\n      if (items === void 0) {\r\n        items = [];\r\n      }\r\n\r\n      if (TrackMenuItem === void 0) {\r\n        TrackMenuItem = TextTrackMenuItem;\r\n      }\r\n\r\n      // Label is an override for the [track] off label\r\n      // USed to localise captions/subtitles\r\n      var label;\r\n\r\n      if (this.label_) {\r\n        label = this.label_ + \" off\";\r\n      } // Add an OFF menu item to turn all tracks off\r\n\r\n\r\n      items.push(new OffTextTrackMenuItem(this.player_, {\r\n        kinds: this.kinds_,\r\n        kind: this.kind_,\r\n        label: label\r\n      }));\r\n      this.hideThreshold_ += 1;\r\n      var tracks = this.player_.textTracks();\r\n\r\n      if (!Array.isArray(this.kinds_)) {\r\n        this.kinds_ = [this.kind_];\r\n      }\r\n\r\n      for (var i = 0; i < tracks.length; i++) {\r\n        var track = tracks[i]; // only add tracks that are of an appropriate kind and have a label\r\n\r\n        if (this.kinds_.indexOf(track.kind) > -1) {\r\n          var item = new TrackMenuItem(this.player_, {\r\n            track: track,\r\n            kinds: this.kinds_,\r\n            kind: this.kind_,\r\n            // MenuItem is selectable\r\n            selectable: true,\r\n            // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\r\n            multiSelectable: false\r\n          });\r\n          item.addClass(\"vjs-\" + track.kind + \"-menu-item\");\r\n          items.push(item);\r\n        }\r\n      }\r\n\r\n      return items;\r\n    };\r\n\r\n    return TextTrackButton;\r\n  }(TrackButton);\r\n\r\n  Component$1.registerComponent('TextTrackButton', TextTrackButton);\r\n\r\n  /**\r\n   * The chapter track menu item\r\n   *\r\n   * @extends MenuItem\r\n   */\r\n\r\n  var ChaptersTrackMenuItem = /*#__PURE__*/function (_MenuItem) {\r\n    inheritsLoose(ChaptersTrackMenuItem, _MenuItem);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function ChaptersTrackMenuItem(player, options) {\r\n      var _this;\r\n\r\n      var track = options.track;\r\n      var cue = options.cue;\r\n      var currentTime = player.currentTime(); // Modify options for parent MenuItem class's init.\r\n\r\n      options.selectable = true;\r\n      options.multiSelectable = false;\r\n      options.label = cue.text;\r\n      options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\r\n      _this = _MenuItem.call(this, player, options) || this;\r\n      _this.track = track;\r\n      _this.cue = cue;\r\n      return _this;\r\n    }\r\n    /**\r\n     * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n\r\n\r\n    var _proto = ChaptersTrackMenuItem.prototype;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      _MenuItem.prototype.handleClick.call(this);\r\n\r\n      this.player_.currentTime(this.cue.startTime);\r\n    };\r\n\r\n    return ChaptersTrackMenuItem;\r\n  }(MenuItem);\r\n\r\n  Component$1.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\r\n\r\n  /**\r\n   * The button component for toggling and selecting chapters\r\n   * Chapters act much differently than other text tracks\r\n   * Cues are navigation vs. other tracks of alternative languages\r\n   *\r\n   * @extends TextTrackButton\r\n   */\r\n\r\n  var ChaptersButton = /*#__PURE__*/function (_TextTrackButton) {\r\n    inheritsLoose(ChaptersButton, _TextTrackButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        The function to call when this function is ready.\r\n     */\r\n    function ChaptersButton(player, options, ready) {\r\n      var _this;\r\n\r\n      _this = _TextTrackButton.call(this, player, options, ready) || this;\r\n\r\n      _this.selectCurrentItem_ = function () {\r\n        _this.items.forEach(function (item) {\r\n          item.selected(_this.track_.activeCues[0] === item.cue);\r\n        });\r\n      };\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = ChaptersButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-chapters-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-chapters-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Update the menu based on the current state of its items.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        An event that triggered this function to run.\r\n     *\r\n     * @listens TextTrackList#addtrack\r\n     * @listens TextTrackList#removetrack\r\n     * @listens TextTrackList#change\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(event) {\r\n      if (event && event.track && event.track.kind !== 'chapters') {\r\n        return;\r\n      }\r\n\r\n      var track = this.findChaptersTrack();\r\n\r\n      if (track !== this.track_) {\r\n        this.setTrack(track);\r\n\r\n        _TextTrackButton.prototype.update.call(this);\r\n      } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {\r\n        // Update the menu initially or if the number of cues has changed since set\r\n        _TextTrackButton.prototype.update.call(this);\r\n      }\r\n    }\r\n    /**\r\n     * Set the currently selected track for the chapters button.\r\n     *\r\n     * @param {TextTrack} track\r\n     *        The new track to select. Nothing will change if this is the currently selected\r\n     *        track.\r\n     */\r\n    ;\r\n\r\n    _proto.setTrack = function setTrack(track) {\r\n      if (this.track_ === track) {\r\n        return;\r\n      }\r\n\r\n      if (!this.updateHandler_) {\r\n        this.updateHandler_ = this.update.bind(this);\r\n      } // here this.track_ refers to the old track instance\r\n\r\n\r\n      if (this.track_) {\r\n        var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\r\n\r\n        if (remoteTextTrackEl) {\r\n          remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\r\n        }\r\n\r\n        this.track_.removeEventListener('cuechange', this.selectCurrentItem_);\r\n        this.track_ = null;\r\n      }\r\n\r\n      this.track_ = track; // here this.track_ refers to the new track instance\r\n\r\n      if (this.track_) {\r\n        this.track_.mode = 'hidden';\r\n\r\n        var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\r\n\r\n        if (_remoteTextTrackEl) {\r\n          _remoteTextTrackEl.addEventListener('load', this.updateHandler_);\r\n        }\r\n\r\n        this.track_.addEventListener('cuechange', this.selectCurrentItem_);\r\n      }\r\n    }\r\n    /**\r\n     * Find the track object that is currently in use by this ChaptersButton\r\n     *\r\n     * @return {TextTrack|undefined}\r\n     *         The current track or undefined if none was found.\r\n     */\r\n    ;\r\n\r\n    _proto.findChaptersTrack = function findChaptersTrack() {\r\n      var tracks = this.player_.textTracks() || [];\r\n\r\n      for (var i = tracks.length - 1; i >= 0; i--) {\r\n        // We will always choose the last track as our chaptersTrack\r\n        var track = tracks[i];\r\n\r\n        if (track.kind === this.kind_) {\r\n          return track;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Get the caption for the ChaptersButton based on the track label. This will also\r\n     * use the current tracks localized kind as a fallback if a label does not exist.\r\n     *\r\n     * @return {string}\r\n     *         The tracks current label or the localized track kind.\r\n     */\r\n    ;\r\n\r\n    _proto.getMenuCaption = function getMenuCaption() {\r\n      if (this.track_ && this.track_.label) {\r\n        return this.track_.label;\r\n      }\r\n\r\n      return this.localize(toTitleCase$1(this.kind_));\r\n    }\r\n    /**\r\n     * Create menu from chapter track\r\n     *\r\n     * @return {Menu}\r\n     *         New menu for the chapter buttons\r\n     */\r\n    ;\r\n\r\n    _proto.createMenu = function createMenu() {\r\n      this.options_.title = this.getMenuCaption();\r\n      return _TextTrackButton.prototype.createMenu.call(this);\r\n    }\r\n    /**\r\n     * Create a menu item for each text track\r\n     *\r\n     * @return {TextTrackMenuItem[]}\r\n     *         Array of menu items\r\n     */\r\n    ;\r\n\r\n    _proto.createItems = function createItems() {\r\n      var items = [];\r\n\r\n      if (!this.track_) {\r\n        return items;\r\n      }\r\n\r\n      var cues = this.track_.cues;\r\n\r\n      if (!cues) {\r\n        return items;\r\n      }\r\n\r\n      for (var i = 0, l = cues.length; i < l; i++) {\r\n        var cue = cues[i];\r\n        var mi = new ChaptersTrackMenuItem(this.player_, {\r\n          track: this.track_,\r\n          cue: cue\r\n        });\r\n        items.push(mi);\r\n      }\r\n\r\n      return items;\r\n    };\r\n\r\n    return ChaptersButton;\r\n  }(TextTrackButton);\r\n  /**\r\n   * `kind` of TextTrack to look for to associate it with this menu.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  ChaptersButton.prototype.kind_ = 'chapters';\r\n  /**\r\n   * The text that should display over the `ChaptersButton`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n  ChaptersButton.prototype.controlText_ = 'Chapters';\r\n  Component$1.registerComponent('ChaptersButton', ChaptersButton);\r\n\r\n  /**\r\n   * The button component for toggling and selecting descriptions\r\n   *\r\n   * @extends TextTrackButton\r\n   */\r\n\r\n  var DescriptionsButton = /*#__PURE__*/function (_TextTrackButton) {\r\n    inheritsLoose(DescriptionsButton, _TextTrackButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        The function to call when this component is ready.\r\n     */\r\n    function DescriptionsButton(player, options, ready) {\r\n      var _this;\r\n\r\n      _this = _TextTrackButton.call(this, player, options, ready) || this;\r\n      var tracks = player.textTracks();\r\n      var changeHandler = bind(assertThisInitialized(_this), _this.handleTracksChange);\r\n      tracks.addEventListener('change', changeHandler);\r\n\r\n      _this.on('dispose', function () {\r\n        tracks.removeEventListener('change', changeHandler);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Handle text track change\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The event that caused this function to run\r\n     *\r\n     * @listens TextTrackList#change\r\n     */\r\n\r\n\r\n    var _proto = DescriptionsButton.prototype;\r\n\r\n    _proto.handleTracksChange = function handleTracksChange(event) {\r\n      var tracks = this.player().textTracks();\r\n      var disabled = false; // Check whether a track of a different kind is showing\r\n\r\n      for (var i = 0, l = tracks.length; i < l; i++) {\r\n        var track = tracks[i];\r\n\r\n        if (track.kind !== this.kind_ && track.mode === 'showing') {\r\n          disabled = true;\r\n          break;\r\n        }\r\n      } // If another track is showing, disable this menu button\r\n\r\n\r\n      if (disabled) {\r\n        this.disable();\r\n      } else {\r\n        this.enable();\r\n      }\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    ;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-descriptions-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-descriptions-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\r\n    };\r\n\r\n    return DescriptionsButton;\r\n  }(TextTrackButton);\r\n  /**\r\n   * `kind` of TextTrack to look for to associate it with this menu.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  DescriptionsButton.prototype.kind_ = 'descriptions';\r\n  /**\r\n   * The text that should display over the `DescriptionsButton`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n  DescriptionsButton.prototype.controlText_ = 'Descriptions';\r\n  Component$1.registerComponent('DescriptionsButton', DescriptionsButton);\r\n\r\n  /**\r\n   * The button component for toggling and selecting subtitles\r\n   *\r\n   * @extends TextTrackButton\r\n   */\r\n\r\n  var SubtitlesButton = /*#__PURE__*/function (_TextTrackButton) {\r\n    inheritsLoose(SubtitlesButton, _TextTrackButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        The function to call when this component is ready.\r\n     */\r\n    function SubtitlesButton(player, options, ready) {\r\n      return _TextTrackButton.call(this, player, options, ready) || this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = SubtitlesButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-subtitles-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-subtitles-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\r\n    };\r\n\r\n    return SubtitlesButton;\r\n  }(TextTrackButton);\r\n  /**\r\n   * `kind` of TextTrack to look for to associate it with this menu.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  SubtitlesButton.prototype.kind_ = 'subtitles';\r\n  /**\r\n   * The text that should display over the `SubtitlesButton`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n  SubtitlesButton.prototype.controlText_ = 'Subtitles';\r\n  Component$1.registerComponent('SubtitlesButton', SubtitlesButton);\r\n\r\n  /**\r\n   * The menu item for caption track settings menu\r\n   *\r\n   * @extends TextTrackMenuItem\r\n   */\r\n\r\n  var CaptionSettingsMenuItem = /*#__PURE__*/function (_TextTrackMenuItem) {\r\n    inheritsLoose(CaptionSettingsMenuItem, _TextTrackMenuItem);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function CaptionSettingsMenuItem(player, options) {\r\n      var _this;\r\n\r\n      options.track = {\r\n        player: player,\r\n        kind: options.kind,\r\n        label: options.kind + ' settings',\r\n        selectable: false,\r\n        \"default\": false,\r\n        mode: 'disabled'\r\n      }; // CaptionSettingsMenuItem has no concept of 'selected'\r\n\r\n      options.selectable = false;\r\n      options.name = 'CaptionSettingsMenuItem';\r\n      _this = _TextTrackMenuItem.call(this, player, options) || this;\r\n\r\n      _this.addClass('vjs-texttrack-settings');\r\n\r\n      _this.controlText(', opens ' + options.kind + ' settings dialog');\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n\r\n\r\n    var _proto = CaptionSettingsMenuItem.prototype;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      this.player().getChild('textTrackSettings').open();\r\n    };\r\n\r\n    return CaptionSettingsMenuItem;\r\n  }(TextTrackMenuItem);\r\n\r\n  Component$1.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\r\n\r\n  /**\r\n   * The button component for toggling and selecting captions\r\n   *\r\n   * @extends TextTrackButton\r\n   */\r\n\r\n  var CaptionsButton = /*#__PURE__*/function (_TextTrackButton) {\r\n    inheritsLoose(CaptionsButton, _TextTrackButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        The function to call when this component is ready.\r\n     */\r\n    function CaptionsButton(player, options, ready) {\r\n      return _TextTrackButton.call(this, player, options, ready) || this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = CaptionsButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-captions-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-captions-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Create caption menu items\r\n     *\r\n     * @return {CaptionSettingsMenuItem[]}\r\n     *         The array of current menu items.\r\n     */\r\n    ;\r\n\r\n    _proto.createItems = function createItems() {\r\n      var items = [];\r\n\r\n      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\r\n        items.push(new CaptionSettingsMenuItem(this.player_, {\r\n          kind: this.kind_\r\n        }));\r\n        this.hideThreshold_ += 1;\r\n      }\r\n\r\n      return _TextTrackButton.prototype.createItems.call(this, items);\r\n    };\r\n\r\n    return CaptionsButton;\r\n  }(TextTrackButton);\r\n  /**\r\n   * `kind` of TextTrack to look for to associate it with this menu.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  CaptionsButton.prototype.kind_ = 'captions';\r\n  /**\r\n   * The text that should display over the `CaptionsButton`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n  CaptionsButton.prototype.controlText_ = 'Captions';\r\n  Component$1.registerComponent('CaptionsButton', CaptionsButton);\r\n\r\n  /**\r\n   * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\r\n   * in the SubsCapsMenu.\r\n   *\r\n   * @extends TextTrackMenuItem\r\n   */\r\n\r\n  var SubsCapsMenuItem = /*#__PURE__*/function (_TextTrackMenuItem) {\r\n    inheritsLoose(SubsCapsMenuItem, _TextTrackMenuItem);\r\n\r\n    function SubsCapsMenuItem() {\r\n      return _TextTrackMenuItem.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = SubsCapsMenuItem.prototype;\r\n\r\n    _proto.createEl = function createEl$1(type, props, attrs) {\r\n      var el = _TextTrackMenuItem.prototype.createEl.call(this, type, props, attrs);\r\n\r\n      var parentSpan = el.querySelector('.vjs-menu-item-text');\r\n\r\n      if (this.options_.track.kind === 'captions') {\r\n        parentSpan.appendChild(createEl('span', {\r\n          className: 'vjs-icon-placeholder'\r\n        }, {\r\n          'aria-hidden': true\r\n        }));\r\n        parentSpan.appendChild(createEl('span', {\r\n          className: 'vjs-control-text',\r\n          // space added as the text will visually flow with the\r\n          // label\r\n          textContent: \" \" + this.localize('Captions')\r\n        }));\r\n      }\r\n\r\n      return el;\r\n    };\r\n\r\n    return SubsCapsMenuItem;\r\n  }(TextTrackMenuItem);\r\n\r\n  Component$1.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\r\n\r\n  /**\r\n   * The button component for toggling and selecting captions and/or subtitles\r\n   *\r\n   * @extends TextTrackButton\r\n   */\r\n\r\n  var SubsCapsButton = /*#__PURE__*/function (_TextTrackButton) {\r\n    inheritsLoose(SubsCapsButton, _TextTrackButton);\r\n\r\n    function SubsCapsButton(player, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _TextTrackButton.call(this, player, options) || this; // Although North America uses \"captions\" in most cases for\r\n      // \"captions and subtitles\" other locales use \"subtitles\"\r\n\r\n      _this.label_ = 'subtitles';\r\n\r\n      if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {\r\n        _this.label_ = 'captions';\r\n      }\r\n\r\n      _this.menuButton_.controlText(toTitleCase$1(_this.label_));\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = SubsCapsButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-subs-caps-button \" + _TextTrackButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-subs-caps-button \" + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Create caption/subtitles menu items\r\n     *\r\n     * @return {CaptionSettingsMenuItem[]}\r\n     *         The array of current menu items.\r\n     */\r\n    ;\r\n\r\n    _proto.createItems = function createItems() {\r\n      var items = [];\r\n\r\n      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\r\n        items.push(new CaptionSettingsMenuItem(this.player_, {\r\n          kind: this.label_\r\n        }));\r\n        this.hideThreshold_ += 1;\r\n      }\r\n\r\n      items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);\r\n      return items;\r\n    };\r\n\r\n    return SubsCapsButton;\r\n  }(TextTrackButton);\r\n  /**\r\n   * `kind`s of TextTrack to look for to associate it with this menu.\r\n   *\r\n   * @type {array}\r\n   * @private\r\n   */\r\n\r\n\r\n  SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\r\n  /**\r\n   * The text that should display over the `SubsCapsButton`s controls.\r\n   *\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n  SubsCapsButton.prototype.controlText_ = 'Subtitles';\r\n  Component$1.registerComponent('SubsCapsButton', SubsCapsButton);\r\n\r\n  /**\r\n   * An {@link AudioTrack} {@link MenuItem}\r\n   *\r\n   * @extends MenuItem\r\n   */\r\n\r\n  var AudioTrackMenuItem = /*#__PURE__*/function (_MenuItem) {\r\n    inheritsLoose(AudioTrackMenuItem, _MenuItem);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function AudioTrackMenuItem(player, options) {\r\n      var _this;\r\n\r\n      var track = options.track;\r\n      var tracks = player.audioTracks(); // Modify options for parent MenuItem class's init.\r\n\r\n      options.label = track.label || track.language || 'Unknown';\r\n      options.selected = track.enabled;\r\n      _this = _MenuItem.call(this, player, options) || this;\r\n      _this.track = track;\r\n\r\n      _this.addClass(\"vjs-\" + track.kind + \"-menu-item\");\r\n\r\n      var changeHandler = function changeHandler() {\r\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n          args[_key] = arguments[_key];\r\n        }\r\n\r\n        _this.handleTracksChange.apply(assertThisInitialized(_this), args);\r\n      };\r\n\r\n      tracks.addEventListener('change', changeHandler);\r\n\r\n      _this.on('dispose', function () {\r\n        tracks.removeEventListener('change', changeHandler);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = AudioTrackMenuItem.prototype;\r\n\r\n    _proto.createEl = function createEl$1(type, props, attrs) {\r\n      var el = _MenuItem.prototype.createEl.call(this, type, props, attrs);\r\n\r\n      var parentSpan = el.querySelector('.vjs-menu-item-text');\r\n\r\n      if (this.options_.track.kind === 'main-desc') {\r\n        parentSpan.appendChild(createEl('span', {\r\n          className: 'vjs-icon-placeholder'\r\n        }, {\r\n          'aria-hidden': true\r\n        }));\r\n        parentSpan.appendChild(createEl('span', {\r\n          className: 'vjs-control-text',\r\n          textContent: ' ' + this.localize('Descriptions')\r\n        }));\r\n      }\r\n\r\n      return el;\r\n    }\r\n    /**\r\n     * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\r\n     * for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      _MenuItem.prototype.handleClick.call(this, event); // the audio track list will automatically toggle other tracks\r\n      // off for us.\r\n\r\n\r\n      this.track.enabled = true; // when native audio tracks are used, we want to make sure that other tracks are turned off\r\n\r\n      if (this.player_.tech_.featuresNativeAudioTracks) {\r\n        var tracks = this.player_.audioTracks();\r\n\r\n        for (var i = 0; i < tracks.length; i++) {\r\n          var track = tracks[i]; // skip the current track since we enabled it above\r\n\r\n          if (track === this.track) {\r\n            continue;\r\n          }\r\n\r\n          track.enabled = track === this.track;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Handle any {@link AudioTrack} change.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The {@link AudioTrackList#change} event that caused this to run.\r\n     *\r\n     * @listens AudioTrackList#change\r\n     */\r\n    ;\r\n\r\n    _proto.handleTracksChange = function handleTracksChange(event) {\r\n      this.selected(this.track.enabled);\r\n    };\r\n\r\n    return AudioTrackMenuItem;\r\n  }(MenuItem);\r\n\r\n  Component$1.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\r\n\r\n  /**\r\n   * The base class for buttons that toggle specific {@link AudioTrack} types.\r\n   *\r\n   * @extends TrackButton\r\n   */\r\n\r\n  var AudioTrackButton = /*#__PURE__*/function (_TrackButton) {\r\n    inheritsLoose(AudioTrackButton, _TrackButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options={}]\r\n     *        The key/value store of player options.\r\n     */\r\n    function AudioTrackButton(player, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      options.tracks = player.audioTracks();\r\n      return _TrackButton.call(this, player, options) || this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n\r\n\r\n    var _proto = AudioTrackButton.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-audio-button \" + _TrackButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-audio-button \" + _TrackButton.prototype.buildWrapperCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Create a menu item for each audio track\r\n     *\r\n     * @param {AudioTrackMenuItem[]} [items=[]]\r\n     *        An array of existing menu items to use.\r\n     *\r\n     * @return {AudioTrackMenuItem[]}\r\n     *         An array of menu items\r\n     */\r\n    ;\r\n\r\n    _proto.createItems = function createItems(items) {\r\n      if (items === void 0) {\r\n        items = [];\r\n      }\r\n\r\n      // if there's only one audio track, there no point in showing it\r\n      this.hideThreshold_ = 1;\r\n      var tracks = this.player_.audioTracks();\r\n\r\n      for (var i = 0; i < tracks.length; i++) {\r\n        var track = tracks[i];\r\n        items.push(new AudioTrackMenuItem(this.player_, {\r\n          track: track,\r\n          // MenuItem is selectable\r\n          selectable: true,\r\n          // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\r\n          multiSelectable: false\r\n        }));\r\n      }\r\n\r\n      return items;\r\n    };\r\n\r\n    return AudioTrackButton;\r\n  }(TrackButton);\r\n  /**\r\n   * The text that should display over the `AudioTrackButton`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  AudioTrackButton.prototype.controlText_ = 'Audio Track';\r\n  Component$1.registerComponent('AudioTrackButton', AudioTrackButton);\r\n\r\n  /**\r\n   * The specific menu item type for selecting a playback rate.\r\n   *\r\n   * @extends MenuItem\r\n   */\r\n\r\n  var PlaybackRateMenuItem = /*#__PURE__*/function (_MenuItem) {\r\n    inheritsLoose(PlaybackRateMenuItem, _MenuItem);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function PlaybackRateMenuItem(player, options) {\r\n      var _this;\r\n\r\n      var label = options.rate;\r\n      var rate = parseFloat(label, 10); // Modify options for parent MenuItem class's init.\r\n\r\n      options.label = label;\r\n      options.selected = rate === player.playbackRate();\r\n      options.selectable = true;\r\n      options.multiSelectable = false;\r\n      _this = _MenuItem.call(this, player, options) || this;\r\n      _this.label = label;\r\n      _this.rate = rate;\r\n\r\n      _this.on(player, 'ratechange', function (e) {\r\n        return _this.update(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n\r\n\r\n    var _proto = PlaybackRateMenuItem.prototype;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      _MenuItem.prototype.handleClick.call(this);\r\n\r\n      this.player().playbackRate(this.rate);\r\n    }\r\n    /**\r\n     * Update the PlaybackRateMenuItem when the playbackrate changes.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `ratechange` event that caused this function to run.\r\n     *\r\n     * @listens Player#ratechange\r\n     */\r\n    ;\r\n\r\n    _proto.update = function update(event) {\r\n      this.selected(this.player().playbackRate() === this.rate);\r\n    };\r\n\r\n    return PlaybackRateMenuItem;\r\n  }(MenuItem);\r\n  /**\r\n   * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  PlaybackRateMenuItem.prototype.contentElType = 'button';\r\n  Component$1.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\r\n\r\n  /**\r\n   * The component for controlling the playback rate.\r\n   *\r\n   * @extends MenuButton\r\n   */\r\n\r\n  var PlaybackRateMenuButton = /*#__PURE__*/function (_MenuButton) {\r\n    inheritsLoose(PlaybackRateMenuButton, _MenuButton);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     */\r\n    function PlaybackRateMenuButton(player, options) {\r\n      var _this;\r\n\r\n      _this = _MenuButton.call(this, player, options) || this;\r\n\r\n      _this.menuButton_.el_.setAttribute('aria-describedby', _this.labelElId_);\r\n\r\n      _this.updateVisibility();\r\n\r\n      _this.updateLabel();\r\n\r\n      _this.on(player, 'loadstart', function (e) {\r\n        return _this.updateVisibility(e);\r\n      });\r\n\r\n      _this.on(player, 'ratechange', function (e) {\r\n        return _this.updateLabel(e);\r\n      });\r\n\r\n      _this.on(player, 'playbackrateschange', function (e) {\r\n        return _this.handlePlaybackRateschange(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n\r\n\r\n    var _proto = PlaybackRateMenuButton.prototype;\r\n\r\n    _proto.createEl = function createEl$1() {\r\n      var el = _MenuButton.prototype.createEl.call(this);\r\n\r\n      this.labelElId_ = 'vjs-playback-rate-value-label-' + this.id_;\r\n      this.labelEl_ = createEl('div', {\r\n        className: 'vjs-playback-rate-value',\r\n        id: this.labelElId_,\r\n        textContent: '1x'\r\n      });\r\n      el.appendChild(this.labelEl_);\r\n      return el;\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.labelEl_ = null;\r\n\r\n      _MenuButton.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    ;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-playback-rate \" + _MenuButton.prototype.buildCSSClass.call(this);\r\n    };\r\n\r\n    _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {\r\n      return \"vjs-playback-rate \" + _MenuButton.prototype.buildWrapperCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Create the list of menu items. Specific to each subclass.\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.createItems = function createItems() {\r\n      var rates = this.playbackRates();\r\n      var items = [];\r\n\r\n      for (var i = rates.length - 1; i >= 0; i--) {\r\n        items.push(new PlaybackRateMenuItem(this.player(), {\r\n          rate: rates[i] + 'x'\r\n        }));\r\n      }\r\n\r\n      return items;\r\n    }\r\n    /**\r\n     * Updates ARIA accessibility attributes\r\n     */\r\n    ;\r\n\r\n    _proto.updateARIAAttributes = function updateARIAAttributes() {\r\n      // Current playback rate\r\n      this.el().setAttribute('aria-valuenow', this.player().playbackRate());\r\n    }\r\n    /**\r\n     * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\r\n     * {@link ClickableComponent} for more detailed information on what a click can be.\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\r\n     *        called.\r\n     *\r\n     * @listens tap\r\n     * @listens click\r\n     */\r\n    ;\r\n\r\n    _proto.handleClick = function handleClick(event) {\r\n      // select next rate option\r\n      var currentRate = this.player().playbackRate();\r\n      var rates = this.playbackRates();\r\n      var currentIndex = rates.indexOf(currentRate); // this get the next rate and it will select first one if the last one currently selected\r\n\r\n      var newIndex = (currentIndex + 1) % rates.length;\r\n      this.player().playbackRate(rates[newIndex]);\r\n    }\r\n    /**\r\n     * On playbackrateschange, update the menu to account for the new items.\r\n     *\r\n     * @listens Player#playbackrateschange\r\n     */\r\n    ;\r\n\r\n    _proto.handlePlaybackRateschange = function handlePlaybackRateschange(event) {\r\n      this.update();\r\n    }\r\n    /**\r\n     * Get possible playback rates\r\n     *\r\n     * @return {Array}\r\n     *         All possible playback rates\r\n     */\r\n    ;\r\n\r\n    _proto.playbackRates = function playbackRates() {\r\n      var player = this.player();\r\n      return player.playbackRates && player.playbackRates() || [];\r\n    }\r\n    /**\r\n     * Get whether playback rates is supported by the tech\r\n     * and an array of playback rates exists\r\n     *\r\n     * @return {boolean}\r\n     *         Whether changing playback rate is supported\r\n     */\r\n    ;\r\n\r\n    _proto.playbackRateSupported = function playbackRateSupported() {\r\n      return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\r\n    }\r\n    /**\r\n     * Hide playback rate controls when they're no playback rate options to select\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens Player#loadstart\r\n     */\r\n    ;\r\n\r\n    _proto.updateVisibility = function updateVisibility(event) {\r\n      if (this.playbackRateSupported()) {\r\n        this.removeClass('vjs-hidden');\r\n      } else {\r\n        this.addClass('vjs-hidden');\r\n      }\r\n    }\r\n    /**\r\n     * Update button label when rate changed\r\n     *\r\n     * @param {EventTarget~Event} [event]\r\n     *        The event that caused this function to run.\r\n     *\r\n     * @listens Player#ratechange\r\n     */\r\n    ;\r\n\r\n    _proto.updateLabel = function updateLabel(event) {\r\n      if (this.playbackRateSupported()) {\r\n        this.labelEl_.textContent = this.player().playbackRate() + 'x';\r\n      }\r\n    };\r\n\r\n    return PlaybackRateMenuButton;\r\n  }(MenuButton);\r\n  /**\r\n   * The text that should display over the `FullscreenToggle`s controls. Added for localization.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n\r\n\r\n  PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\r\n  Component$1.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\r\n\r\n  /**\r\n   * Just an empty spacer element that can be used as an append point for plugins, etc.\r\n   * Also can be used to create space between elements when necessary.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var Spacer = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(Spacer, _Component);\r\n\r\n    function Spacer() {\r\n      return _Component.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = Spacer.prototype;\r\n\r\n    /**\r\n    * Builds the default DOM `className`.\r\n    *\r\n    * @return {string}\r\n    *         The DOM `className` for this object.\r\n    */\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-spacer \" + _Component.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl(tag, props, attributes) {\r\n      if (tag === void 0) {\r\n        tag = 'div';\r\n      }\r\n\r\n      if (props === void 0) {\r\n        props = {};\r\n      }\r\n\r\n      if (attributes === void 0) {\r\n        attributes = {};\r\n      }\r\n\r\n      if (!props.className) {\r\n        props.className = this.buildCSSClass();\r\n      }\r\n\r\n      return _Component.prototype.createEl.call(this, tag, props, attributes);\r\n    };\r\n\r\n    return Spacer;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('Spacer', Spacer);\r\n\r\n  /**\r\n   * Spacer specifically meant to be used as an insertion point for new plugins, etc.\r\n   *\r\n   * @extends Spacer\r\n   */\r\n\r\n  var CustomControlSpacer = /*#__PURE__*/function (_Spacer) {\r\n    inheritsLoose(CustomControlSpacer, _Spacer);\r\n\r\n    function CustomControlSpacer() {\r\n      return _Spacer.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = CustomControlSpacer.prototype;\r\n\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     */\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-custom-control-spacer \" + _Spacer.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Spacer.prototype.createEl.call(this, 'div', {\r\n        className: this.buildCSSClass(),\r\n        // No-flex/table-cell mode requires there be some content\r\n        // in the cell to fill the remaining space of the table.\r\n        textContent: \"\\xA0\"\r\n      });\r\n    };\r\n\r\n    return CustomControlSpacer;\r\n  }(Spacer);\r\n\r\n  Component$1.registerComponent('CustomControlSpacer', CustomControlSpacer);\r\n\r\n  /**\r\n   * Container of main controls.\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var ControlBar = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(ControlBar, _Component);\r\n\r\n    function ControlBar() {\r\n      return _Component.apply(this, arguments) || this;\r\n    }\r\n\r\n    var _proto = ControlBar.prototype;\r\n\r\n    /**\r\n     * Create the `Component`'s DOM element\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     */\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'div', {\r\n        className: 'vjs-control-bar',\r\n        dir: 'ltr'\r\n      });\r\n    };\r\n\r\n    return ControlBar;\r\n  }(Component$1);\r\n  /**\r\n   * Default options for `ControlBar`\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n\r\n  ControlBar.prototype.options_ = {\r\n    children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\r\n  };\r\n\r\n  if ('exitPictureInPicture' in document) {\r\n    ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, 'pictureInPictureToggle');\r\n  }\r\n\r\n  Component$1.registerComponent('ControlBar', ControlBar);\r\n\r\n  /**\r\n   * A display that indicates an error has occurred. This means that the video\r\n   * is unplayable.\r\n   *\r\n   * @extends ModalDialog\r\n   */\r\n\r\n  var ErrorDisplay = /*#__PURE__*/function (_ModalDialog) {\r\n    inheritsLoose(ErrorDisplay, _ModalDialog);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param  {Player} player\r\n     *         The `Player` that this class should be attached to.\r\n     *\r\n     * @param  {Object} [options]\r\n     *         The key/value store of player options.\r\n     */\r\n    function ErrorDisplay(player, options) {\r\n      var _this;\r\n\r\n      _this = _ModalDialog.call(this, player, options) || this;\r\n\r\n      _this.on(player, 'error', function (e) {\r\n        return _this.open(e);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Builds the default DOM `className`.\r\n     *\r\n     * @return {string}\r\n     *         The DOM `className` for this object.\r\n     *\r\n     * @deprecated Since version 5.\r\n     */\r\n\r\n\r\n    var _proto = ErrorDisplay.prototype;\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return \"vjs-error-display \" + _ModalDialog.prototype.buildCSSClass.call(this);\r\n    }\r\n    /**\r\n     * Gets the localized error message based on the `Player`s error.\r\n     *\r\n     * @return {string}\r\n     *         The `Player`s error message localized or an empty string.\r\n     */\r\n    ;\r\n\r\n    _proto.content = function content() {\r\n      var error = this.player().error();\r\n      return error ? this.localize(error.message) : '';\r\n    };\r\n\r\n    return ErrorDisplay;\r\n  }(ModalDialog);\r\n  /**\r\n   * The default options for an `ErrorDisplay`.\r\n   *\r\n   * @private\r\n   */\r\n\r\n\r\n  ErrorDisplay.prototype.options_ = _extends_1({}, ModalDialog.prototype.options_, {\r\n    pauseOnOpen: false,\r\n    fillAlways: true,\r\n    temporary: false,\r\n    uncloseable: true\r\n  });\r\n  Component$1.registerComponent('ErrorDisplay', ErrorDisplay);\r\n\r\n  var LOCAL_STORAGE_KEY$1 = 'vjs-text-track-settings';\r\n  var COLOR_BLACK = ['#000', 'Black'];\r\n  var COLOR_BLUE = ['#00F', 'Blue'];\r\n  var COLOR_CYAN = ['#0FF', 'Cyan'];\r\n  var COLOR_GREEN = ['#0F0', 'Green'];\r\n  var COLOR_MAGENTA = ['#F0F', 'Magenta'];\r\n  var COLOR_RED = ['#F00', 'Red'];\r\n  var COLOR_WHITE = ['#FFF', 'White'];\r\n  var COLOR_YELLOW = ['#FF0', 'Yellow'];\r\n  var OPACITY_OPAQUE = ['1', 'Opaque'];\r\n  var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\r\n  var OPACITY_TRANS = ['0', 'Transparent']; // Configuration for the various <select> elements in the DOM of this component.\r\n  //\r\n  // Possible keys include:\r\n  //\r\n  // `default`:\r\n  //   The default option index. Only needs to be provided if not zero.\r\n  // `parser`:\r\n  //   A function which is used to parse the value from the selected option in\r\n  //   a customized way.\r\n  // `selector`:\r\n  //   The selector used to find the associated <select> element.\r\n\r\n  var selectConfigs = {\r\n    backgroundColor: {\r\n      selector: '.vjs-bg-color > select',\r\n      id: 'captions-background-color-%s',\r\n      label: 'Color',\r\n      options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\r\n    },\r\n    backgroundOpacity: {\r\n      selector: '.vjs-bg-opacity > select',\r\n      id: 'captions-background-opacity-%s',\r\n      label: 'Transparency',\r\n      options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\r\n    },\r\n    color: {\r\n      selector: '.vjs-fg-color > select',\r\n      id: 'captions-foreground-color-%s',\r\n      label: 'Color',\r\n      options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\r\n    },\r\n    edgeStyle: {\r\n      selector: '.vjs-edge-style > select',\r\n      id: '%s',\r\n      label: 'Text Edge Style',\r\n      options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\r\n    },\r\n    fontFamily: {\r\n      selector: '.vjs-font-family > select',\r\n      id: 'captions-font-family-%s',\r\n      label: 'Font Family',\r\n      options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\r\n    },\r\n    fontPercent: {\r\n      selector: '.vjs-font-percent > select',\r\n      id: 'captions-font-size-%s',\r\n      label: 'Font Size',\r\n      options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\r\n      \"default\": 2,\r\n      parser: function parser(v) {\r\n        return v === '1.00' ? null : Number(v);\r\n      }\r\n    },\r\n    textOpacity: {\r\n      selector: '.vjs-text-opacity > select',\r\n      id: 'captions-foreground-opacity-%s',\r\n      label: 'Transparency',\r\n      options: [OPACITY_OPAQUE, OPACITY_SEMI]\r\n    },\r\n    // Options for this object are defined below.\r\n    windowColor: {\r\n      selector: '.vjs-window-color > select',\r\n      id: 'captions-window-color-%s',\r\n      label: 'Color'\r\n    },\r\n    // Options for this object are defined below.\r\n    windowOpacity: {\r\n      selector: '.vjs-window-opacity > select',\r\n      id: 'captions-window-opacity-%s',\r\n      label: 'Transparency',\r\n      options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\r\n    }\r\n  };\r\n  selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\r\n  /**\r\n   * Get the actual value of an option.\r\n   *\r\n   * @param  {string} value\r\n   *         The value to get\r\n   *\r\n   * @param  {Function} [parser]\r\n   *         Optional function to adjust the value.\r\n   *\r\n   * @return {Mixed}\r\n   *         - Will be `undefined` if no value exists\r\n   *         - Will be `undefined` if the given value is \"none\".\r\n   *         - Will be the actual value otherwise.\r\n   *\r\n   * @private\r\n   */\r\n\r\n  function parseOptionValue(value, parser) {\r\n    if (parser) {\r\n      value = parser(value);\r\n    }\r\n\r\n    if (value && value !== 'none') {\r\n      return value;\r\n    }\r\n  }\r\n  /**\r\n   * Gets the value of the selected <option> element within a <select> element.\r\n   *\r\n   * @param  {Element} el\r\n   *         the element to look in\r\n   *\r\n   * @param  {Function} [parser]\r\n   *         Optional function to adjust the value.\r\n   *\r\n   * @return {Mixed}\r\n   *         - Will be `undefined` if no value exists\r\n   *         - Will be `undefined` if the given value is \"none\".\r\n   *         - Will be the actual value otherwise.\r\n   *\r\n   * @private\r\n   */\r\n\r\n\r\n  function getSelectedOptionValue(el, parser) {\r\n    var value = el.options[el.options.selectedIndex].value;\r\n    return parseOptionValue(value, parser);\r\n  }\r\n  /**\r\n   * Sets the selected <option> element within a <select> element based on a\r\n   * given value.\r\n   *\r\n   * @param {Element} el\r\n   *        The element to look in.\r\n   *\r\n   * @param {string} value\r\n   *        the property to look on.\r\n   *\r\n   * @param {Function} [parser]\r\n   *        Optional function to adjust the value before comparing.\r\n   *\r\n   * @private\r\n   */\r\n\r\n\r\n  function setSelectedOption(el, value, parser) {\r\n    if (!value) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < el.options.length; i++) {\r\n      if (parseOptionValue(el.options[i].value, parser) === value) {\r\n        el.selectedIndex = i;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Manipulate Text Tracks settings.\r\n   *\r\n   * @extends ModalDialog\r\n   */\r\n\r\n\r\n  var TextTrackSettings = /*#__PURE__*/function (_ModalDialog) {\r\n    inheritsLoose(TextTrackSettings, _ModalDialog);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *         The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *         The key/value store of player options.\r\n     */\r\n    function TextTrackSettings(player, options) {\r\n      var _this;\r\n\r\n      options.temporary = false;\r\n      _this = _ModalDialog.call(this, player, options) || this;\r\n      _this.updateDisplay = _this.updateDisplay.bind(assertThisInitialized(_this)); // fill the modal and pretend we have opened it\r\n\r\n      _this.fill();\r\n\r\n      _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;\r\n      _this.endDialog = createEl('p', {\r\n        className: 'vjs-control-text',\r\n        textContent: _this.localize('End of dialog window.')\r\n      });\r\n\r\n      _this.el().appendChild(_this.endDialog);\r\n\r\n      _this.setDefaults(); // Grab `persistTextTrackSettings` from the player options if not passed in child options\r\n\r\n\r\n      if (options.persistTextTrackSettings === undefined) {\r\n        _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;\r\n      }\r\n\r\n      _this.on(_this.$('.vjs-done-button'), 'click', function () {\r\n        _this.saveSettings();\r\n\r\n        _this.close();\r\n      });\r\n\r\n      _this.on(_this.$('.vjs-default-button'), 'click', function () {\r\n        _this.setDefaults();\r\n\r\n        _this.updateDisplay();\r\n      });\r\n\r\n      each(selectConfigs, function (config) {\r\n        _this.on(_this.$(config.selector), 'change', _this.updateDisplay);\r\n      });\r\n\r\n      if (_this.options_.persistTextTrackSettings) {\r\n        _this.restoreSettings();\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = TextTrackSettings.prototype;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.endDialog = null;\r\n\r\n      _ModalDialog.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Create a <select> element with configured options.\r\n     *\r\n     * @param {string} key\r\n     *        Configuration key to use during creation.\r\n     *\r\n     * @return {string}\r\n     *         An HTML string.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElSelect_ = function createElSelect_(key, legendId, type) {\r\n      var _this2 = this;\r\n\r\n      if (legendId === void 0) {\r\n        legendId = '';\r\n      }\r\n\r\n      if (type === void 0) {\r\n        type = 'label';\r\n      }\r\n\r\n      var config = selectConfigs[key];\r\n      var id = config.id.replace('%s', this.id_);\r\n      var selectLabelledbyIds = [legendId, id].join(' ').trim();\r\n      return [\"<\" + type + \" id=\\\"\" + id + \"\\\" class=\\\"\" + (type === 'label' ? 'vjs-label' : '') + \"\\\">\", this.localize(config.label), \"</\" + type + \">\", \"<select aria-labelledby=\\\"\" + selectLabelledbyIds + \"\\\">\"].concat(config.options.map(function (o) {\r\n        var optionId = id + '-' + o[1].replace(/\\W+/g, '');\r\n        return [\"<option id=\\\"\" + optionId + \"\\\" value=\\\"\" + o[0] + \"\\\" \", \"aria-labelledby=\\\"\" + selectLabelledbyIds + \" \" + optionId + \"\\\">\", _this2.localize(o[1]), '</option>'].join('');\r\n      })).concat('</select>').join('');\r\n    }\r\n    /**\r\n     * Create foreground color element for the component\r\n     *\r\n     * @return {string}\r\n     *         An HTML string.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElFgColor_ = function createElFgColor_() {\r\n      var legendId = \"captions-text-legend-\" + this.id_;\r\n      return ['<fieldset class=\"vjs-fg-color vjs-track-setting\">', \"<legend id=\\\"\" + legendId + \"\\\">\", this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\r\n    }\r\n    /**\r\n     * Create background color element for the component\r\n     *\r\n     * @return {string}\r\n     *         An HTML string.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElBgColor_ = function createElBgColor_() {\r\n      var legendId = \"captions-background-\" + this.id_;\r\n      return ['<fieldset class=\"vjs-bg-color vjs-track-setting\">', \"<legend id=\\\"\" + legendId + \"\\\">\", this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\r\n    }\r\n    /**\r\n     * Create window color element for the component\r\n     *\r\n     * @return {string}\r\n     *         An HTML string.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElWinColor_ = function createElWinColor_() {\r\n      var legendId = \"captions-window-\" + this.id_;\r\n      return ['<fieldset class=\"vjs-window-color vjs-track-setting\">', \"<legend id=\\\"\" + legendId + \"\\\">\", this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\r\n    }\r\n    /**\r\n     * Create color elements for the component\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElColors_ = function createElColors_() {\r\n      return createEl('div', {\r\n        className: 'vjs-track-settings-colors',\r\n        innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\r\n      });\r\n    }\r\n    /**\r\n     * Create font elements for the component\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElFont_ = function createElFont_() {\r\n      return createEl('div', {\r\n        className: 'vjs-track-settings-font',\r\n        innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\r\n      });\r\n    }\r\n    /**\r\n     * Create controls for the component\r\n     *\r\n     * @return {Element}\r\n     *         The element that was created.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.createElControls_ = function createElControls_() {\r\n      var defaultsDescription = this.localize('restore all settings to the default values');\r\n      return createEl('div', {\r\n        className: 'vjs-track-settings-controls',\r\n        innerHTML: [\"<button type=\\\"button\\\" class=\\\"vjs-default-button\\\" title=\\\"\" + defaultsDescription + \"\\\">\", this.localize('Reset'), \"<span class=\\\"vjs-control-text\\\"> \" + defaultsDescription + \"</span>\", '</button>', \"<button type=\\\"button\\\" class=\\\"vjs-done-button\\\">\" + this.localize('Done') + \"</button>\"].join('')\r\n      });\r\n    };\r\n\r\n    _proto.content = function content() {\r\n      return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\r\n    };\r\n\r\n    _proto.label = function label() {\r\n      return this.localize('Caption Settings Dialog');\r\n    };\r\n\r\n    _proto.description = function description() {\r\n      return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\r\n    };\r\n\r\n    _proto.buildCSSClass = function buildCSSClass() {\r\n      return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';\r\n    }\r\n    /**\r\n     * Gets an object of text track settings (or null).\r\n     *\r\n     * @return {Object}\r\n     *         An object with config values parsed from the DOM or localStorage.\r\n     */\r\n    ;\r\n\r\n    _proto.getValues = function getValues() {\r\n      var _this3 = this;\r\n\r\n      return reduce(selectConfigs, function (accum, config, key) {\r\n        var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);\r\n\r\n        if (value !== undefined) {\r\n          accum[key] = value;\r\n        }\r\n\r\n        return accum;\r\n      }, {});\r\n    }\r\n    /**\r\n     * Sets text track settings from an object of values.\r\n     *\r\n     * @param {Object} values\r\n     *        An object with config values parsed from the DOM or localStorage.\r\n     */\r\n    ;\r\n\r\n    _proto.setValues = function setValues(values) {\r\n      var _this4 = this;\r\n\r\n      each(selectConfigs, function (config, key) {\r\n        setSelectedOption(_this4.$(config.selector), values[key], config.parser);\r\n      });\r\n    }\r\n    /**\r\n     * Sets all `<select>` elements to their default values.\r\n     */\r\n    ;\r\n\r\n    _proto.setDefaults = function setDefaults() {\r\n      var _this5 = this;\r\n\r\n      each(selectConfigs, function (config) {\r\n        var index = config.hasOwnProperty('default') ? config[\"default\"] : 0;\r\n        _this5.$(config.selector).selectedIndex = index;\r\n      });\r\n    }\r\n    /**\r\n     * Restore texttrack settings from localStorage\r\n     */\r\n    ;\r\n\r\n    _proto.restoreSettings = function restoreSettings() {\r\n      var values;\r\n\r\n      try {\r\n        values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY$1));\r\n      } catch (err) {\r\n        log$1.warn(err);\r\n      }\r\n\r\n      if (values) {\r\n        this.setValues(values);\r\n      }\r\n    }\r\n    /**\r\n     * Save text track settings to localStorage\r\n     */\r\n    ;\r\n\r\n    _proto.saveSettings = function saveSettings() {\r\n      if (!this.options_.persistTextTrackSettings) {\r\n        return;\r\n      }\r\n\r\n      var values = this.getValues();\r\n\r\n      try {\r\n        if (Object.keys(values).length) {\r\n          window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values));\r\n        } else {\r\n          window.localStorage.removeItem(LOCAL_STORAGE_KEY$1);\r\n        }\r\n      } catch (err) {\r\n        log$1.warn(err);\r\n      }\r\n    }\r\n    /**\r\n     * Update display of text track settings\r\n     */\r\n    ;\r\n\r\n    _proto.updateDisplay = function updateDisplay() {\r\n      var ttDisplay = this.player_.getChild('textTrackDisplay');\r\n\r\n      if (ttDisplay) {\r\n        ttDisplay.updateDisplay();\r\n      }\r\n    }\r\n    /**\r\n     * conditionally blur the element and refocus the captions button\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.conditionalBlur_ = function conditionalBlur_() {\r\n      this.previouslyActiveEl_ = null;\r\n      var cb = this.player_.controlBar;\r\n      var subsCapsBtn = cb && cb.subsCapsButton;\r\n      var ccBtn = cb && cb.captionsButton;\r\n\r\n      if (subsCapsBtn) {\r\n        subsCapsBtn.focus();\r\n      } else if (ccBtn) {\r\n        ccBtn.focus();\r\n      }\r\n    };\r\n\r\n    return TextTrackSettings;\r\n  }(ModalDialog);\r\n\r\n  Component$1.registerComponent('TextTrackSettings', TextTrackSettings);\r\n\r\n  /**\r\n   * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\r\n   *\r\n   * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\r\n   *\r\n   * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\r\n   * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\r\n   * @example <caption>How to disable the resize manager</caption>\r\n   * const player = videojs('#vid', {\r\n   *   resizeManager: false\r\n   * });\r\n   *\r\n   * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var ResizeManager = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(ResizeManager, _Component);\r\n\r\n    /**\r\n     * Create the ResizeManager.\r\n     *\r\n     * @param {Object} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of ResizeManager options.\r\n     *\r\n     * @param {Object} [options.ResizeObserver]\r\n     *        A polyfill for ResizeObserver can be passed in here.\r\n     *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\r\n     */\r\n    function ResizeManager(player, options) {\r\n      var _this;\r\n\r\n      var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver; // if `null` was passed, we want to disable the ResizeObserver\r\n\r\n      if (options.ResizeObserver === null) {\r\n        RESIZE_OBSERVER_AVAILABLE = false;\r\n      } // Only create an element when ResizeObserver isn't available\r\n\r\n\r\n      var options_ = mergeOptions$3({\r\n        createEl: !RESIZE_OBSERVER_AVAILABLE,\r\n        reportTouchActivity: false\r\n      }, options);\r\n      _this = _Component.call(this, player, options_) || this;\r\n      _this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;\r\n      _this.loadListener_ = null;\r\n      _this.resizeObserver_ = null;\r\n      _this.debouncedHandler_ = debounce(function () {\r\n        _this.resizeHandler();\r\n      }, 100, false, assertThisInitialized(_this));\r\n\r\n      if (RESIZE_OBSERVER_AVAILABLE) {\r\n        _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);\r\n\r\n        _this.resizeObserver_.observe(player.el());\r\n      } else {\r\n        _this.loadListener_ = function () {\r\n          if (!_this.el_ || !_this.el_.contentWindow) {\r\n            return;\r\n          }\r\n\r\n          var debouncedHandler_ = _this.debouncedHandler_;\r\n\r\n          var unloadListener_ = _this.unloadListener_ = function () {\r\n            off(this, 'resize', debouncedHandler_);\r\n            off(this, 'unload', unloadListener_);\r\n            unloadListener_ = null;\r\n          }; // safari and edge can unload the iframe before resizemanager dispose\r\n          // we have to dispose of event handlers correctly before that happens\r\n\r\n\r\n          on(_this.el_.contentWindow, 'unload', unloadListener_);\r\n          on(_this.el_.contentWindow, 'resize', debouncedHandler_);\r\n        };\r\n\r\n        _this.one('load', _this.loadListener_);\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = ResizeManager.prototype;\r\n\r\n    _proto.createEl = function createEl() {\r\n      return _Component.prototype.createEl.call(this, 'iframe', {\r\n        className: 'vjs-resize-manager',\r\n        tabIndex: -1,\r\n        title: this.localize('No content')\r\n      }, {\r\n        'aria-hidden': 'true'\r\n      });\r\n    }\r\n    /**\r\n     * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\r\n     *\r\n     * @fires Player#playerresize\r\n     */\r\n    ;\r\n\r\n    _proto.resizeHandler = function resizeHandler() {\r\n      /**\r\n       * Called when the player size has changed\r\n       *\r\n       * @event Player#playerresize\r\n       * @type {EventTarget~Event}\r\n       */\r\n      // make sure player is still around to trigger\r\n      // prevents this from causing an error after dispose\r\n      if (!this.player_ || !this.player_.trigger) {\r\n        return;\r\n      }\r\n\r\n      this.player_.trigger('playerresize');\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      if (this.debouncedHandler_) {\r\n        this.debouncedHandler_.cancel();\r\n      }\r\n\r\n      if (this.resizeObserver_) {\r\n        if (this.player_.el()) {\r\n          this.resizeObserver_.unobserve(this.player_.el());\r\n        }\r\n\r\n        this.resizeObserver_.disconnect();\r\n      }\r\n\r\n      if (this.loadListener_) {\r\n        this.off('load', this.loadListener_);\r\n      }\r\n\r\n      if (this.el_ && this.el_.contentWindow && this.unloadListener_) {\r\n        this.unloadListener_.call(this.el_.contentWindow);\r\n      }\r\n\r\n      this.ResizeObserver = null;\r\n      this.resizeObserver = null;\r\n      this.debouncedHandler_ = null;\r\n      this.loadListener_ = null;\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    };\r\n\r\n    return ResizeManager;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('ResizeManager', ResizeManager);\r\n\r\n  var defaults = {\r\n    trackingThreshold: 20,\r\n    liveTolerance: 15\r\n  };\r\n  /*\r\n    track when we are at the live edge, and other helpers for live playback */\r\n\r\n  /**\r\n   * A class for checking live current time and determining when the player\r\n   * is at or behind the live edge.\r\n   */\r\n\r\n  var LiveTracker = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(LiveTracker, _Component);\r\n\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * @param {Player} player\r\n     *        The `Player` that this class should be attached to.\r\n     *\r\n     * @param {Object} [options]\r\n     *        The key/value store of player options.\r\n     *\r\n     * @param {number} [options.trackingThreshold=20]\r\n     *        Number of seconds of live window (seekableEnd - seekableStart) that\r\n     *        media needs to have before the liveui will be shown.\r\n     *\r\n     * @param {number} [options.liveTolerance=15]\r\n     *        Number of seconds behind live that we have to be\r\n     *        before we will be considered non-live. Note that this will only\r\n     *        be used when playing at the live edge. This allows large seekable end\r\n     *        changes to not effect wether we are live or not.\r\n     */\r\n    function LiveTracker(player, options) {\r\n      var _this;\r\n\r\n      // LiveTracker does not need an element\r\n      var options_ = mergeOptions$3(defaults, options, {\r\n        createEl: false\r\n      });\r\n      _this = _Component.call(this, player, options_) || this;\r\n\r\n      _this.handleVisibilityChange_ = function (e) {\r\n        return _this.handleVisibilityChange(e);\r\n      };\r\n\r\n      _this.trackLiveHandler_ = function () {\r\n        return _this.trackLive_();\r\n      };\r\n\r\n      _this.handlePlay_ = function (e) {\r\n        return _this.handlePlay(e);\r\n      };\r\n\r\n      _this.handleFirstTimeupdate_ = function (e) {\r\n        return _this.handleFirstTimeupdate(e);\r\n      };\r\n\r\n      _this.handleSeeked_ = function (e) {\r\n        return _this.handleSeeked(e);\r\n      };\r\n\r\n      _this.seekToLiveEdge_ = function (e) {\r\n        return _this.seekToLiveEdge(e);\r\n      };\r\n\r\n      _this.reset_();\r\n\r\n      _this.on(_this.player_, 'durationchange', function (e) {\r\n        return _this.handleDurationchange(e);\r\n      }); // we should try to toggle tracking on canplay as native playback engines, like Safari\r\n      // may not have the proper values for things like seekableEnd until then\r\n\r\n\r\n      _this.on(_this.player_, 'canplay', function () {\r\n        return _this.toggleTracking();\r\n      }); // we don't need to track live playback if the document is hidden,\r\n      // also, tracking when the document is hidden can\r\n      // cause the CPU to spike and eventually crash the page on IE11.\r\n\r\n\r\n      if (IE_VERSION && 'hidden' in document && 'visibilityState' in document) {\r\n        _this.on(document, 'visibilitychange', _this.handleVisibilityChange_);\r\n      }\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * toggle tracking based on document visiblility\r\n     */\r\n\r\n\r\n    var _proto = LiveTracker.prototype;\r\n\r\n    _proto.handleVisibilityChange = function handleVisibilityChange() {\r\n      if (this.player_.duration() !== Infinity) {\r\n        return;\r\n      }\r\n\r\n      if (document.hidden) {\r\n        this.stopTracking();\r\n      } else {\r\n        this.startTracking();\r\n      }\r\n    }\r\n    /**\r\n     * all the functionality for tracking when seek end changes\r\n     * and for tracking how far past seek end we should be\r\n     */\r\n    ;\r\n\r\n    _proto.trackLive_ = function trackLive_() {\r\n      var seekable = this.player_.seekable(); // skip undefined seekable\r\n\r\n      if (!seekable || !seekable.length) {\r\n        return;\r\n      }\r\n\r\n      var newTime = Number(window.performance.now().toFixed(4));\r\n      var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;\r\n      this.lastTime_ = newTime;\r\n      this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;\r\n      var liveCurrentTime = this.liveCurrentTime();\r\n      var currentTime = this.player_.currentTime(); // we are behind live if any are true\r\n      // 1. the player is paused\r\n      // 2. the user seeked to a location 2 seconds away from live\r\n      // 3. the difference between live and current time is greater\r\n      //    liveTolerance which defaults to 15s\r\n\r\n      var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance; // we cannot be behind if\r\n      // 1. until we have not seen a timeupdate yet\r\n      // 2. liveCurrentTime is Infinity, which happens on Android and Native Safari\r\n\r\n      if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {\r\n        isBehind = false;\r\n      }\r\n\r\n      if (isBehind !== this.behindLiveEdge_) {\r\n        this.behindLiveEdge_ = isBehind;\r\n        this.trigger('liveedgechange');\r\n      }\r\n    }\r\n    /**\r\n     * handle a durationchange event on the player\r\n     * and start/stop tracking accordingly.\r\n     */\r\n    ;\r\n\r\n    _proto.handleDurationchange = function handleDurationchange() {\r\n      this.toggleTracking();\r\n    }\r\n    /**\r\n     * start/stop tracking\r\n     */\r\n    ;\r\n\r\n    _proto.toggleTracking = function toggleTracking() {\r\n      if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {\r\n        if (this.player_.options_.liveui) {\r\n          this.player_.addClass('vjs-liveui');\r\n        }\r\n\r\n        this.startTracking();\r\n      } else {\r\n        this.player_.removeClass('vjs-liveui');\r\n        this.stopTracking();\r\n      }\r\n    }\r\n    /**\r\n     * start tracking live playback\r\n     */\r\n    ;\r\n\r\n    _proto.startTracking = function startTracking() {\r\n      if (this.isTracking()) {\r\n        return;\r\n      } // If we haven't seen a timeupdate, we need to check whether playback\r\n      // began before this component started tracking. This can happen commonly\r\n      // when using autoplay.\r\n\r\n\r\n      if (!this.timeupdateSeen_) {\r\n        this.timeupdateSeen_ = this.player_.hasStarted();\r\n      }\r\n\r\n      this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);\r\n      this.trackLive_();\r\n      this.on(this.player_, ['play', 'pause'], this.trackLiveHandler_);\r\n\r\n      if (!this.timeupdateSeen_) {\r\n        this.one(this.player_, 'play', this.handlePlay_);\r\n        this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\r\n      } else {\r\n        this.on(this.player_, 'seeked', this.handleSeeked_);\r\n      }\r\n    }\r\n    /**\r\n     * handle the first timeupdate on the player if it wasn't already playing\r\n     * when live tracker started tracking.\r\n     */\r\n    ;\r\n\r\n    _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {\r\n      this.timeupdateSeen_ = true;\r\n      this.on(this.player_, 'seeked', this.handleSeeked_);\r\n    }\r\n    /**\r\n     * Keep track of what time a seek starts, and listen for seeked\r\n     * to find where a seek ends.\r\n     */\r\n    ;\r\n\r\n    _proto.handleSeeked = function handleSeeked() {\r\n      var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());\r\n      this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;\r\n      this.nextSeekedFromUser_ = false;\r\n      this.trackLive_();\r\n    }\r\n    /**\r\n     * handle the first play on the player, and make sure that we seek\r\n     * right to the live edge.\r\n     */\r\n    ;\r\n\r\n    _proto.handlePlay = function handlePlay() {\r\n      this.one(this.player_, 'timeupdate', this.seekToLiveEdge_);\r\n    }\r\n    /**\r\n     * Stop tracking, and set all internal variables to\r\n     * their initial value.\r\n     */\r\n    ;\r\n\r\n    _proto.reset_ = function reset_() {\r\n      this.lastTime_ = -1;\r\n      this.pastSeekEnd_ = 0;\r\n      this.lastSeekEnd_ = -1;\r\n      this.behindLiveEdge_ = true;\r\n      this.timeupdateSeen_ = false;\r\n      this.seekedBehindLive_ = false;\r\n      this.nextSeekedFromUser_ = false;\r\n      this.clearInterval(this.trackingInterval_);\r\n      this.trackingInterval_ = null;\r\n      this.off(this.player_, ['play', 'pause'], this.trackLiveHandler_);\r\n      this.off(this.player_, 'seeked', this.handleSeeked_);\r\n      this.off(this.player_, 'play', this.handlePlay_);\r\n      this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\r\n      this.off(this.player_, 'timeupdate', this.seekToLiveEdge_);\r\n    }\r\n    /**\r\n     * The next seeked event is from the user. Meaning that any seek\r\n     * > 2s behind live will be considered behind live for real and\r\n     * liveTolerance will be ignored.\r\n     */\r\n    ;\r\n\r\n    _proto.nextSeekedFromUser = function nextSeekedFromUser() {\r\n      this.nextSeekedFromUser_ = true;\r\n    }\r\n    /**\r\n     * stop tracking live playback\r\n     */\r\n    ;\r\n\r\n    _proto.stopTracking = function stopTracking() {\r\n      if (!this.isTracking()) {\r\n        return;\r\n      }\r\n\r\n      this.reset_();\r\n      this.trigger('liveedgechange');\r\n    }\r\n    /**\r\n     * A helper to get the player seekable end\r\n     * so that we don't have to null check everywhere\r\n     *\r\n     * @return {number}\r\n     *         The furthest seekable end or Infinity.\r\n     */\r\n    ;\r\n\r\n    _proto.seekableEnd = function seekableEnd() {\r\n      var seekable = this.player_.seekable();\r\n      var seekableEnds = [];\r\n      var i = seekable ? seekable.length : 0;\r\n\r\n      while (i--) {\r\n        seekableEnds.push(seekable.end(i));\r\n      } // grab the furthest seekable end after sorting, or if there are none\r\n      // default to Infinity\r\n\r\n\r\n      return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;\r\n    }\r\n    /**\r\n     * A helper to get the player seekable start\r\n     * so that we don't have to null check everywhere\r\n     *\r\n     * @return {number}\r\n     *         The earliest seekable start or 0.\r\n     */\r\n    ;\r\n\r\n    _proto.seekableStart = function seekableStart() {\r\n      var seekable = this.player_.seekable();\r\n      var seekableStarts = [];\r\n      var i = seekable ? seekable.length : 0;\r\n\r\n      while (i--) {\r\n        seekableStarts.push(seekable.start(i));\r\n      } // grab the first seekable start after sorting, or if there are none\r\n      // default to 0\r\n\r\n\r\n      return seekableStarts.length ? seekableStarts.sort()[0] : 0;\r\n    }\r\n    /**\r\n     * Get the live time window aka\r\n     * the amount of time between seekable start and\r\n     * live current time.\r\n     *\r\n     * @return {number}\r\n     *         The amount of seconds that are seekable in\r\n     *         the live video.\r\n     */\r\n    ;\r\n\r\n    _proto.liveWindow = function liveWindow() {\r\n      var liveCurrentTime = this.liveCurrentTime(); // if liveCurrenTime is Infinity then we don't have a liveWindow at all\r\n\r\n      if (liveCurrentTime === Infinity) {\r\n        return 0;\r\n      }\r\n\r\n      return liveCurrentTime - this.seekableStart();\r\n    }\r\n    /**\r\n     * Determines if the player is live, only checks if this component\r\n     * is tracking live playback or not\r\n     *\r\n     * @return {boolean}\r\n     *         Wether liveTracker is tracking\r\n     */\r\n    ;\r\n\r\n    _proto.isLive = function isLive() {\r\n      return this.isTracking();\r\n    }\r\n    /**\r\n     * Determines if currentTime is at the live edge and won't fall behind\r\n     * on each seekableendchange\r\n     *\r\n     * @return {boolean}\r\n     *         Wether playback is at the live edge\r\n     */\r\n    ;\r\n\r\n    _proto.atLiveEdge = function atLiveEdge() {\r\n      return !this.behindLiveEdge();\r\n    }\r\n    /**\r\n     * get what we expect the live current time to be\r\n     *\r\n     * @return {number}\r\n     *         The expected live current time\r\n     */\r\n    ;\r\n\r\n    _proto.liveCurrentTime = function liveCurrentTime() {\r\n      return this.pastSeekEnd() + this.seekableEnd();\r\n    }\r\n    /**\r\n     * The number of seconds that have occured after seekable end\r\n     * changed. This will be reset to 0 once seekable end changes.\r\n     *\r\n     * @return {number}\r\n     *         Seconds past the current seekable end\r\n     */\r\n    ;\r\n\r\n    _proto.pastSeekEnd = function pastSeekEnd() {\r\n      var seekableEnd = this.seekableEnd();\r\n\r\n      if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {\r\n        this.pastSeekEnd_ = 0;\r\n      }\r\n\r\n      this.lastSeekEnd_ = seekableEnd;\r\n      return this.pastSeekEnd_;\r\n    }\r\n    /**\r\n     * If we are currently behind the live edge, aka currentTime will be\r\n     * behind on a seekableendchange\r\n     *\r\n     * @return {boolean}\r\n     *         If we are behind the live edge\r\n     */\r\n    ;\r\n\r\n    _proto.behindLiveEdge = function behindLiveEdge() {\r\n      return this.behindLiveEdge_;\r\n    }\r\n    /**\r\n     * Wether live tracker is currently tracking or not.\r\n     */\r\n    ;\r\n\r\n    _proto.isTracking = function isTracking() {\r\n      return typeof this.trackingInterval_ === 'number';\r\n    }\r\n    /**\r\n     * Seek to the live edge if we are behind the live edge\r\n     */\r\n    ;\r\n\r\n    _proto.seekToLiveEdge = function seekToLiveEdge() {\r\n      this.seekedBehindLive_ = false;\r\n\r\n      if (this.atLiveEdge()) {\r\n        return;\r\n      }\r\n\r\n      this.nextSeekedFromUser_ = false;\r\n      this.player_.currentTime(this.liveCurrentTime());\r\n    }\r\n    /**\r\n     * Dispose of liveTracker\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.off(document, 'visibilitychange', this.handleVisibilityChange_);\r\n      this.stopTracking();\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    };\r\n\r\n    return LiveTracker;\r\n  }(Component$1);\r\n\r\n  Component$1.registerComponent('LiveTracker', LiveTracker);\r\n\r\n  /**\r\n   * This function is used to fire a sourceset when there is something\r\n   * similar to `mediaEl.load()` being called. It will try to find the source via\r\n   * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\r\n   * with the source that was found or empty string if we cannot know. If it cannot\r\n   * find a source then `sourceset` will not be fired.\r\n   *\r\n   * @param {Html5} tech\r\n   *        The tech object that sourceset was setup on\r\n   *\r\n   * @return {boolean}\r\n   *         returns false if the sourceset was not fired and true otherwise.\r\n   */\r\n\r\n  var sourcesetLoad = function sourcesetLoad(tech) {\r\n    var el = tech.el(); // if `el.src` is set, that source will be loaded.\r\n\r\n    if (el.hasAttribute('src')) {\r\n      tech.triggerSourceset(el.src);\r\n      return true;\r\n    }\r\n    /**\r\n     * Since there isn't a src property on the media element, source elements will be used for\r\n     * implementing the source selection algorithm. This happens asynchronously and\r\n     * for most cases were there is more than one source we cannot tell what source will\r\n     * be loaded, without re-implementing the source selection algorithm. At this time we are not\r\n     * going to do that. There are three special cases that we do handle here though:\r\n     *\r\n     * 1. If there are no sources, do not fire `sourceset`.\r\n     * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\r\n     * 3. If there is more than one `<source>` but all of them have the same `src` url.\r\n     *    That will be our src.\r\n     */\r\n\r\n\r\n    var sources = tech.$$('source');\r\n    var srcUrls = [];\r\n    var src = ''; // if there are no sources, do not fire sourceset\r\n\r\n    if (!sources.length) {\r\n      return false;\r\n    } // only count valid/non-duplicate source elements\r\n\r\n\r\n    for (var i = 0; i < sources.length; i++) {\r\n      var url = sources[i].src;\r\n\r\n      if (url && srcUrls.indexOf(url) === -1) {\r\n        srcUrls.push(url);\r\n      }\r\n    } // there were no valid sources\r\n\r\n\r\n    if (!srcUrls.length) {\r\n      return false;\r\n    } // there is only one valid source element url\r\n    // use that\r\n\r\n\r\n    if (srcUrls.length === 1) {\r\n      src = srcUrls[0];\r\n    }\r\n\r\n    tech.triggerSourceset(src);\r\n    return true;\r\n  };\r\n  /**\r\n   * our implementation of an `innerHTML` descriptor for browsers\r\n   * that do not have one.\r\n   */\r\n\r\n\r\n  var innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\r\n    get: function get() {\r\n      return this.cloneNode(true).innerHTML;\r\n    },\r\n    set: function set(v) {\r\n      // make a dummy node to use innerHTML on\r\n      var dummy = document.createElement(this.nodeName.toLowerCase()); // set innerHTML to the value provided\r\n\r\n      dummy.innerHTML = v; // make a document fragment to hold the nodes from dummy\r\n\r\n      var docFrag = document.createDocumentFragment(); // copy all of the nodes created by the innerHTML on dummy\r\n      // to the document fragment\r\n\r\n      while (dummy.childNodes.length) {\r\n        docFrag.appendChild(dummy.childNodes[0]);\r\n      } // remove content\r\n\r\n\r\n      this.innerText = ''; // now we add all of that html in one by appending the\r\n      // document fragment. This is how innerHTML does it.\r\n\r\n      window.Element.prototype.appendChild.call(this, docFrag); // then return the result that innerHTML's setter would\r\n\r\n      return this.innerHTML;\r\n    }\r\n  });\r\n  /**\r\n   * Get a property descriptor given a list of priorities and the\r\n   * property to get.\r\n   */\r\n\r\n  var getDescriptor = function getDescriptor(priority, prop) {\r\n    var descriptor = {};\r\n\r\n    for (var i = 0; i < priority.length; i++) {\r\n      descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\r\n\r\n      if (descriptor && descriptor.set && descriptor.get) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    descriptor.enumerable = true;\r\n    descriptor.configurable = true;\r\n    return descriptor;\r\n  };\r\n\r\n  var getInnerHTMLDescriptor = function getInnerHTMLDescriptor(tech) {\r\n    return getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\r\n  };\r\n  /**\r\n   * Patches browser internal functions so that we can tell synchronously\r\n   * if a `<source>` was appended to the media element. For some reason this\r\n   * causes a `sourceset` if the the media element is ready and has no source.\r\n   * This happens when:\r\n   * - The page has just loaded and the media element does not have a source.\r\n   * - The media element was emptied of all sources, then `load()` was called.\r\n   *\r\n   * It does this by patching the following functions/properties when they are supported:\r\n   *\r\n   * - `append()` - can be used to add a `<source>` element to the media element\r\n   * - `appendChild()` - can be used to add a `<source>` element to the media element\r\n   * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\r\n   * - `innerHTML` -  can be used to add a `<source>` element to the media element\r\n   *\r\n   * @param {Html5} tech\r\n   *        The tech object that sourceset is being setup on.\r\n   */\r\n\r\n\r\n  var firstSourceWatch = function firstSourceWatch(tech) {\r\n    var el = tech.el(); // make sure firstSourceWatch isn't setup twice.\r\n\r\n    if (el.resetSourceWatch_) {\r\n      return;\r\n    }\r\n\r\n    var old = {};\r\n    var innerDescriptor = getInnerHTMLDescriptor(tech);\r\n\r\n    var appendWrapper = function appendWrapper(appendFn) {\r\n      return function () {\r\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n          args[_key] = arguments[_key];\r\n        }\r\n\r\n        var retval = appendFn.apply(el, args);\r\n        sourcesetLoad(tech);\r\n        return retval;\r\n      };\r\n    };\r\n\r\n    ['append', 'appendChild', 'insertAdjacentHTML'].forEach(function (k) {\r\n      if (!el[k]) {\r\n        return;\r\n      } // store the old function\r\n\r\n\r\n      old[k] = el[k]; // call the old function with a sourceset if a source\r\n      // was loaded\r\n\r\n      el[k] = appendWrapper(old[k]);\r\n    });\r\n    Object.defineProperty(el, 'innerHTML', mergeOptions$3(innerDescriptor, {\r\n      set: appendWrapper(innerDescriptor.set)\r\n    }));\r\n\r\n    el.resetSourceWatch_ = function () {\r\n      el.resetSourceWatch_ = null;\r\n      Object.keys(old).forEach(function (k) {\r\n        el[k] = old[k];\r\n      });\r\n      Object.defineProperty(el, 'innerHTML', innerDescriptor);\r\n    }; // on the first sourceset, we need to revert our changes\r\n\r\n\r\n    tech.one('sourceset', el.resetSourceWatch_);\r\n  };\r\n  /**\r\n   * our implementation of a `src` descriptor for browsers\r\n   * that do not have one.\r\n   */\r\n\r\n\r\n  var srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\r\n    get: function get() {\r\n      if (this.hasAttribute('src')) {\r\n        return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));\r\n      }\r\n\r\n      return '';\r\n    },\r\n    set: function set(v) {\r\n      window.Element.prototype.setAttribute.call(this, 'src', v);\r\n      return v;\r\n    }\r\n  });\r\n\r\n  var getSrcDescriptor = function getSrcDescriptor(tech) {\r\n    return getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\r\n  };\r\n  /**\r\n   * setup `sourceset` handling on the `Html5` tech. This function\r\n   * patches the following element properties/functions:\r\n   *\r\n   * - `src` - to determine when `src` is set\r\n   * - `setAttribute()` - to determine when `src` is set\r\n   * - `load()` - this re-triggers the source selection algorithm, and can\r\n   *              cause a sourceset.\r\n   *\r\n   * If there is no source when we are adding `sourceset` support or during a `load()`\r\n   * we also patch the functions listed in `firstSourceWatch`.\r\n   *\r\n   * @param {Html5} tech\r\n   *        The tech to patch\r\n   */\r\n\r\n\r\n  var setupSourceset = function setupSourceset(tech) {\r\n    if (!tech.featuresSourceset) {\r\n      return;\r\n    }\r\n\r\n    var el = tech.el(); // make sure sourceset isn't setup twice.\r\n\r\n    if (el.resetSourceset_) {\r\n      return;\r\n    }\r\n\r\n    var srcDescriptor = getSrcDescriptor(tech);\r\n    var oldSetAttribute = el.setAttribute;\r\n    var oldLoad = el.load;\r\n    Object.defineProperty(el, 'src', mergeOptions$3(srcDescriptor, {\r\n      set: function set(v) {\r\n        var retval = srcDescriptor.set.call(el, v); // we use the getter here to get the actual value set on src\r\n\r\n        tech.triggerSourceset(el.src);\r\n        return retval;\r\n      }\r\n    }));\r\n\r\n    el.setAttribute = function (n, v) {\r\n      var retval = oldSetAttribute.call(el, n, v);\r\n\r\n      if (/src/i.test(n)) {\r\n        tech.triggerSourceset(el.src);\r\n      }\r\n\r\n      return retval;\r\n    };\r\n\r\n    el.load = function () {\r\n      var retval = oldLoad.call(el); // if load was called, but there was no source to fire\r\n      // sourceset on. We have to watch for a source append\r\n      // as that can trigger a `sourceset` when the media element\r\n      // has no source\r\n\r\n      if (!sourcesetLoad(tech)) {\r\n        tech.triggerSourceset('');\r\n        firstSourceWatch(tech);\r\n      }\r\n\r\n      return retval;\r\n    };\r\n\r\n    if (el.currentSrc) {\r\n      tech.triggerSourceset(el.currentSrc);\r\n    } else if (!sourcesetLoad(tech)) {\r\n      firstSourceWatch(tech);\r\n    }\r\n\r\n    el.resetSourceset_ = function () {\r\n      el.resetSourceset_ = null;\r\n      el.load = oldLoad;\r\n      el.setAttribute = oldSetAttribute;\r\n      Object.defineProperty(el, 'src', srcDescriptor);\r\n\r\n      if (el.resetSourceWatch_) {\r\n        el.resetSourceWatch_();\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Object.defineProperty but \"lazy\", which means that the value is only set after\r\n   * it retrieved the first time, rather than being set right away.\r\n   *\r\n   * @param {Object} obj the object to set the property on\r\n   * @param {string} key the key for the property to set\r\n   * @param {Function} getValue the function used to get the value when it is needed.\r\n   * @param {boolean} setter wether a setter shoould be allowed or not\r\n   */\r\n  var defineLazyProperty = function defineLazyProperty(obj, key, getValue, setter) {\r\n    if (setter === void 0) {\r\n      setter = true;\r\n    }\r\n\r\n    var set = function set(value) {\r\n      return Object.defineProperty(obj, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        writable: true\r\n      });\r\n    };\r\n\r\n    var options = {\r\n      configurable: true,\r\n      enumerable: true,\r\n      get: function get() {\r\n        var value = getValue();\r\n        set(value);\r\n        return value;\r\n      }\r\n    };\r\n\r\n    if (setter) {\r\n      options.set = set;\r\n    }\r\n\r\n    return Object.defineProperty(obj, key, options);\r\n  };\r\n\r\n  /**\r\n   * HTML5 Media Controller - Wrapper for HTML5 Media API\r\n   *\r\n   * @mixes Tech~SourceHandlerAdditions\r\n   * @extends Tech\r\n   */\r\n\r\n  var Html5 = /*#__PURE__*/function (_Tech) {\r\n    inheritsLoose(Html5, _Tech);\r\n\r\n    /**\r\n    * Create an instance of this Tech.\r\n    *\r\n    * @param {Object} [options]\r\n    *        The key/value store of player options.\r\n    *\r\n    * @param {Component~ReadyCallback} ready\r\n    *        Callback function to call when the `HTML5` Tech is ready.\r\n    */\r\n    function Html5(options, ready) {\r\n      var _this;\r\n\r\n      _this = _Tech.call(this, options, ready) || this;\r\n      var source = options.source;\r\n      var crossoriginTracks = false;\r\n      _this.featuresVideoFrameCallback = _this.featuresVideoFrameCallback && _this.el_.tagName === 'VIDEO'; // Set the source if one is provided\r\n      // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\r\n      // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\r\n      // anyway so the error gets fired.\r\n\r\n      if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\r\n        _this.setSource(source);\r\n      } else {\r\n        _this.handleLateInit_(_this.el_);\r\n      } // setup sourceset after late sourceset/init\r\n\r\n\r\n      if (options.enableSourceset) {\r\n        _this.setupSourcesetHandling_();\r\n      }\r\n\r\n      _this.isScrubbing_ = false;\r\n\r\n      if (_this.el_.hasChildNodes()) {\r\n        var nodes = _this.el_.childNodes;\r\n        var nodesLength = nodes.length;\r\n        var removeNodes = [];\r\n\r\n        while (nodesLength--) {\r\n          var node = nodes[nodesLength];\r\n          var nodeName = node.nodeName.toLowerCase();\r\n\r\n          if (nodeName === 'track') {\r\n            if (!_this.featuresNativeTextTracks) {\r\n              // Empty video tag tracks so the built-in player doesn't use them also.\r\n              // This may not be fast enough to stop HTML5 browsers from reading the tags\r\n              // so we'll need to turn off any default tracks if we're manually doing\r\n              // captions and subtitles. videoElement.textTracks\r\n              removeNodes.push(node);\r\n            } else {\r\n              // store HTMLTrackElement and TextTrack to remote list\r\n              _this.remoteTextTrackEls().addTrackElement_(node);\r\n\r\n              _this.remoteTextTracks().addTrack(node.track);\r\n\r\n              _this.textTracks().addTrack(node.track);\r\n\r\n              if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\r\n                crossoriginTracks = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        for (var i = 0; i < removeNodes.length; i++) {\r\n          _this.el_.removeChild(removeNodes[i]);\r\n        }\r\n      }\r\n\r\n      _this.proxyNativeTracks_();\r\n\r\n      if (_this.featuresNativeTextTracks && crossoriginTracks) {\r\n        log$1.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n' + 'This may prevent text tracks from loading.');\r\n      } // prevent iOS Safari from disabling metadata text tracks during native playback\r\n\r\n\r\n      _this.restoreMetadataTracksInIOSNativePlayer_(); // Determine if native controls should be used\r\n      // Our goal should be to get the custom controls on mobile solid everywhere\r\n      // so we can remove this all together. Right now this will block custom\r\n      // controls on touch enabled laptops like the Chrome Pixel\r\n\r\n\r\n      if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\r\n        _this.setControls(true);\r\n      } // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\r\n      // into a `fullscreenchange` event\r\n\r\n\r\n      _this.proxyWebkitFullscreen_();\r\n\r\n      _this.triggerReady();\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Dispose of `HTML5` media element and remove all tracks.\r\n     */\r\n\r\n\r\n    var _proto = Html5.prototype;\r\n\r\n    _proto.dispose = function dispose() {\r\n      if (this.el_ && this.el_.resetSourceset_) {\r\n        this.el_.resetSourceset_();\r\n      }\r\n\r\n      Html5.disposeMediaElement(this.el_);\r\n      this.options_ = null; // tech will handle clearing of the emulated track list\r\n\r\n      _Tech.prototype.dispose.call(this);\r\n    }\r\n    /**\r\n     * Modify the media element so that we can detect when\r\n     * the source is changed. Fires `sourceset` just after the source has changed\r\n     */\r\n    ;\r\n\r\n    _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {\r\n      setupSourceset(this);\r\n    }\r\n    /**\r\n     * When a captions track is enabled in the iOS Safari native player, all other\r\n     * tracks are disabled (including metadata tracks), which nulls all of their\r\n     * associated cue points. This will restore metadata tracks to their pre-fullscreen\r\n     * state in those cases so that cue points are not needlessly lost.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {\r\n      var textTracks = this.textTracks();\r\n      var metadataTracksPreFullscreenState; // captures a snapshot of every metadata track's current state\r\n\r\n      var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {\r\n        metadataTracksPreFullscreenState = [];\r\n\r\n        for (var i = 0; i < textTracks.length; i++) {\r\n          var track = textTracks[i];\r\n\r\n          if (track.kind === 'metadata') {\r\n            metadataTracksPreFullscreenState.push({\r\n              track: track,\r\n              storedMode: track.mode\r\n            });\r\n          }\r\n        }\r\n      }; // snapshot each metadata track's initial state, and update the snapshot\r\n      // each time there is a track 'change' event\r\n\r\n\r\n      takeMetadataTrackSnapshot();\r\n      textTracks.addEventListener('change', takeMetadataTrackSnapshot);\r\n      this.on('dispose', function () {\r\n        return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\r\n      });\r\n\r\n      var restoreTrackMode = function restoreTrackMode() {\r\n        for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {\r\n          var storedTrack = metadataTracksPreFullscreenState[i];\r\n\r\n          if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\r\n            storedTrack.track.mode = storedTrack.storedMode;\r\n          }\r\n        } // we only want this handler to be executed on the first 'change' event\r\n\r\n\r\n        textTracks.removeEventListener('change', restoreTrackMode);\r\n      }; // when we enter fullscreen playback, stop updating the snapshot and\r\n      // restore all track modes to their pre-fullscreen state\r\n\r\n\r\n      this.on('webkitbeginfullscreen', function () {\r\n        textTracks.removeEventListener('change', takeMetadataTrackSnapshot); // remove the listener before adding it just in case it wasn't previously removed\r\n\r\n        textTracks.removeEventListener('change', restoreTrackMode);\r\n        textTracks.addEventListener('change', restoreTrackMode);\r\n      }); // start updating the snapshot again after leaving fullscreen\r\n\r\n      this.on('webkitendfullscreen', function () {\r\n        // remove the listener before adding it just in case it wasn't previously removed\r\n        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\r\n        textTracks.addEventListener('change', takeMetadataTrackSnapshot); // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\r\n\r\n        textTracks.removeEventListener('change', restoreTrackMode);\r\n      });\r\n    }\r\n    /**\r\n     * Attempt to force override of tracks for the given type\r\n     *\r\n     * @param {string} type - Track type to override, possible values include 'Audio',\r\n     * 'Video', and 'Text'.\r\n     * @param {boolean} override - If set to true native audio/video will be overridden,\r\n     * otherwise native audio/video will potentially be used.\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.overrideNative_ = function overrideNative_(type, override) {\r\n      var _this2 = this;\r\n\r\n      // If there is no behavioral change don't add/remove listeners\r\n      if (override !== this[\"featuresNative\" + type + \"Tracks\"]) {\r\n        return;\r\n      }\r\n\r\n      var lowerCaseType = type.toLowerCase();\r\n\r\n      if (this[lowerCaseType + \"TracksListeners_\"]) {\r\n        Object.keys(this[lowerCaseType + \"TracksListeners_\"]).forEach(function (eventName) {\r\n          var elTracks = _this2.el()[lowerCaseType + \"Tracks\"];\r\n\r\n          elTracks.removeEventListener(eventName, _this2[lowerCaseType + \"TracksListeners_\"][eventName]);\r\n        });\r\n      }\r\n\r\n      this[\"featuresNative\" + type + \"Tracks\"] = !override;\r\n      this[lowerCaseType + \"TracksListeners_\"] = null;\r\n      this.proxyNativeTracksForType_(lowerCaseType);\r\n    }\r\n    /**\r\n     * Attempt to force override of native audio tracks.\r\n     *\r\n     * @param {boolean} override - If set to true native audio will be overridden,\r\n     * otherwise native audio will potentially be used.\r\n     */\r\n    ;\r\n\r\n    _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {\r\n      this.overrideNative_('Audio', override);\r\n    }\r\n    /**\r\n     * Attempt to force override of native video tracks.\r\n     *\r\n     * @param {boolean} override - If set to true native video will be overridden,\r\n     * otherwise native video will potentially be used.\r\n     */\r\n    ;\r\n\r\n    _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {\r\n      this.overrideNative_('Video', override);\r\n    }\r\n    /**\r\n     * Proxy native track list events for the given type to our track\r\n     * lists if the browser we are playing in supports that type of track list.\r\n     *\r\n     * @param {string} name - Track type; values include 'audio', 'video', and 'text'\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {\r\n      var _this3 = this;\r\n\r\n      var props = NORMAL[name];\r\n      var elTracks = this.el()[props.getterName];\r\n      var techTracks = this[props.getterName]();\r\n\r\n      if (!this[\"featuresNative\" + props.capitalName + \"Tracks\"] || !elTracks || !elTracks.addEventListener) {\r\n        return;\r\n      }\r\n\r\n      var listeners = {\r\n        change: function change(e) {\r\n          var event = {\r\n            type: 'change',\r\n            target: techTracks,\r\n            currentTarget: techTracks,\r\n            srcElement: techTracks\r\n          };\r\n          techTracks.trigger(event); // if we are a text track change event, we should also notify the\r\n          // remote text track list. This can potentially cause a false positive\r\n          // if we were to get a change event on a non-remote track and\r\n          // we triggered the event on the remote text track list which doesn't\r\n          // contain that track. However, best practices mean looping through the\r\n          // list of tracks and searching for the appropriate mode value, so,\r\n          // this shouldn't pose an issue\r\n\r\n          if (name === 'text') {\r\n            _this3[REMOTE.remoteText.getterName]().trigger(event);\r\n          }\r\n        },\r\n        addtrack: function addtrack(e) {\r\n          techTracks.addTrack(e.track);\r\n        },\r\n        removetrack: function removetrack(e) {\r\n          techTracks.removeTrack(e.track);\r\n        }\r\n      };\r\n\r\n      var removeOldTracks = function removeOldTracks() {\r\n        var removeTracks = [];\r\n\r\n        for (var i = 0; i < techTracks.length; i++) {\r\n          var found = false;\r\n\r\n          for (var j = 0; j < elTracks.length; j++) {\r\n            if (elTracks[j] === techTracks[i]) {\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (!found) {\r\n            removeTracks.push(techTracks[i]);\r\n          }\r\n        }\r\n\r\n        while (removeTracks.length) {\r\n          techTracks.removeTrack(removeTracks.shift());\r\n        }\r\n      };\r\n\r\n      this[props.getterName + 'Listeners_'] = listeners;\r\n      Object.keys(listeners).forEach(function (eventName) {\r\n        var listener = listeners[eventName];\r\n        elTracks.addEventListener(eventName, listener);\r\n\r\n        _this3.on('dispose', function (e) {\r\n          return elTracks.removeEventListener(eventName, listener);\r\n        });\r\n      }); // Remove (native) tracks that are not used anymore\r\n\r\n      this.on('loadstart', removeOldTracks);\r\n      this.on('dispose', function (e) {\r\n        return _this3.off('loadstart', removeOldTracks);\r\n      });\r\n    }\r\n    /**\r\n     * Proxy all native track list events to our track lists if the browser we are playing\r\n     * in supports that type of track list.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.proxyNativeTracks_ = function proxyNativeTracks_() {\r\n      var _this4 = this;\r\n\r\n      NORMAL.names.forEach(function (name) {\r\n        _this4.proxyNativeTracksForType_(name);\r\n      });\r\n    }\r\n    /**\r\n     * Create the `Html5` Tech's DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         The element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      var el = this.options_.tag; // Check if this browser supports moving the element into the box.\r\n      // On the iPhone video will break if you move the element,\r\n      // So we have to create a brand new element.\r\n      // If we ingested the player div, we do not need to move the media element.\r\n\r\n      if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\r\n        // If the original tag is still there, clone and remove it.\r\n        if (el) {\r\n          var clone = el.cloneNode(true);\r\n\r\n          if (el.parentNode) {\r\n            el.parentNode.insertBefore(clone, el);\r\n          }\r\n\r\n          Html5.disposeMediaElement(el);\r\n          el = clone;\r\n        } else {\r\n          el = document.createElement('video'); // determine if native controls should be used\r\n\r\n          var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\r\n          var attributes = mergeOptions$3({}, tagAttributes);\r\n\r\n          if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\r\n            delete attributes.controls;\r\n          }\r\n\r\n          setAttributes(el, assign(attributes, {\r\n            id: this.options_.techId,\r\n            \"class\": 'vjs-tech'\r\n          }));\r\n        }\r\n\r\n        el.playerId = this.options_.playerId;\r\n      }\r\n\r\n      if (typeof this.options_.preload !== 'undefined') {\r\n        setAttribute(el, 'preload', this.options_.preload);\r\n      }\r\n\r\n      if (this.options_.disablePictureInPicture !== undefined) {\r\n        el.disablePictureInPicture = this.options_.disablePictureInPicture;\r\n      } // Update specific tag settings, in case they were overridden\r\n      // `autoplay` has to be *last* so that `muted` and `playsinline` are present\r\n      // when iOS/Safari or other browsers attempt to autoplay.\r\n\r\n\r\n      var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\r\n\r\n      for (var i = 0; i < settingsAttrs.length; i++) {\r\n        var attr = settingsAttrs[i];\r\n        var value = this.options_[attr];\r\n\r\n        if (typeof value !== 'undefined') {\r\n          if (value) {\r\n            setAttribute(el, attr, attr);\r\n          } else {\r\n            removeAttribute(el, attr);\r\n          }\r\n\r\n          el[attr] = value;\r\n        }\r\n      }\r\n\r\n      return el;\r\n    }\r\n    /**\r\n     * This will be triggered if the loadstart event has already fired, before videojs was\r\n     * ready. Two known examples of when this can happen are:\r\n     * 1. If we're loading the playback object after it has started loading\r\n     * 2. The media is already playing the (often with autoplay on) then\r\n     *\r\n     * This function will fire another loadstart so that videojs can catchup.\r\n     *\r\n     * @fires Tech#loadstart\r\n     *\r\n     * @return {undefined}\r\n     *         returns nothing.\r\n     */\r\n    ;\r\n\r\n    _proto.handleLateInit_ = function handleLateInit_(el) {\r\n      if (el.networkState === 0 || el.networkState === 3) {\r\n        // The video element hasn't started loading the source yet\r\n        // or didn't find a source\r\n        return;\r\n      }\r\n\r\n      if (el.readyState === 0) {\r\n        // NetworkState is set synchronously BUT loadstart is fired at the\r\n        // end of the current stack, usually before setInterval(fn, 0).\r\n        // So at this point we know loadstart may have already fired or is\r\n        // about to fire, and either way the player hasn't seen it yet.\r\n        // We don't want to fire loadstart prematurely here and cause a\r\n        // double loadstart so we'll wait and see if it happens between now\r\n        // and the next loop, and fire it if not.\r\n        // HOWEVER, we also want to make sure it fires before loadedmetadata\r\n        // which could also happen between now and the next loop, so we'll\r\n        // watch for that also.\r\n        var loadstartFired = false;\r\n\r\n        var setLoadstartFired = function setLoadstartFired() {\r\n          loadstartFired = true;\r\n        };\r\n\r\n        this.on('loadstart', setLoadstartFired);\r\n\r\n        var triggerLoadstart = function triggerLoadstart() {\r\n          // We did miss the original loadstart. Make sure the player\r\n          // sees loadstart before loadedmetadata\r\n          if (!loadstartFired) {\r\n            this.trigger('loadstart');\r\n          }\r\n        };\r\n\r\n        this.on('loadedmetadata', triggerLoadstart);\r\n        this.ready(function () {\r\n          this.off('loadstart', setLoadstartFired);\r\n          this.off('loadedmetadata', triggerLoadstart);\r\n\r\n          if (!loadstartFired) {\r\n            // We did miss the original native loadstart. Fire it now.\r\n            this.trigger('loadstart');\r\n          }\r\n        });\r\n        return;\r\n      } // From here on we know that loadstart already fired and we missed it.\r\n      // The other readyState events aren't as much of a problem if we double\r\n      // them, so not going to go to as much trouble as loadstart to prevent\r\n      // that unless we find reason to.\r\n\r\n\r\n      var eventsToTrigger = ['loadstart']; // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\r\n\r\n      eventsToTrigger.push('loadedmetadata'); // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\r\n\r\n      if (el.readyState >= 2) {\r\n        eventsToTrigger.push('loadeddata');\r\n      } // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\r\n\r\n\r\n      if (el.readyState >= 3) {\r\n        eventsToTrigger.push('canplay');\r\n      } // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\r\n\r\n\r\n      if (el.readyState >= 4) {\r\n        eventsToTrigger.push('canplaythrough');\r\n      } // We still need to give the player time to add event listeners\r\n\r\n\r\n      this.ready(function () {\r\n        eventsToTrigger.forEach(function (type) {\r\n          this.trigger(type);\r\n        }, this);\r\n      });\r\n    }\r\n    /**\r\n     * Set whether we are scrubbing or not.\r\n     * This is used to decide whether we should use `fastSeek` or not.\r\n     * `fastSeek` is used to provide trick play on Safari browsers.\r\n     *\r\n     * @param {boolean} isScrubbing\r\n     *                  - true for we are currently scrubbing\r\n     *                  - false for we are no longer scrubbing\r\n     */\r\n    ;\r\n\r\n    _proto.setScrubbing = function setScrubbing(isScrubbing) {\r\n      this.isScrubbing_ = isScrubbing;\r\n    }\r\n    /**\r\n     * Get whether we are scrubbing or not.\r\n     *\r\n     * @return {boolean} isScrubbing\r\n     *                  - true for we are currently scrubbing\r\n     *                  - false for we are no longer scrubbing\r\n     */\r\n    ;\r\n\r\n    _proto.scrubbing = function scrubbing() {\r\n      return this.isScrubbing_;\r\n    }\r\n    /**\r\n     * Set current time for the `HTML5` tech.\r\n     *\r\n     * @param {number} seconds\r\n     *        Set the current time of the media to this.\r\n     */\r\n    ;\r\n\r\n    _proto.setCurrentTime = function setCurrentTime(seconds) {\r\n      try {\r\n        if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {\r\n          this.el_.fastSeek(seconds);\r\n        } else {\r\n          this.el_.currentTime = seconds;\r\n        }\r\n      } catch (e) {\r\n        log$1(e, 'Video is not ready. (Video.js)'); // this.warning(VideoJS.warnings.videoNotReady);\r\n      }\r\n    }\r\n    /**\r\n     * Get the current duration of the HTML5 media element.\r\n     *\r\n     * @return {number}\r\n     *         The duration of the media or 0 if there is no duration.\r\n     */\r\n    ;\r\n\r\n    _proto.duration = function duration() {\r\n      var _this5 = this;\r\n\r\n      // Android Chrome will report duration as Infinity for VOD HLS until after\r\n      // playback has started, which triggers the live display erroneously.\r\n      // Return NaN if playback has not started and trigger a durationupdate once\r\n      // the duration can be reliably known.\r\n      if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\r\n        // Wait for the first `timeupdate` with currentTime > 0 - there may be\r\n        // several with 0\r\n        var checkProgress = function checkProgress() {\r\n          if (_this5.el_.currentTime > 0) {\r\n            // Trigger durationchange for genuinely live video\r\n            if (_this5.el_.duration === Infinity) {\r\n              _this5.trigger('durationchange');\r\n            }\r\n\r\n            _this5.off('timeupdate', checkProgress);\r\n          }\r\n        };\r\n\r\n        this.on('timeupdate', checkProgress);\r\n        return NaN;\r\n      }\r\n\r\n      return this.el_.duration || NaN;\r\n    }\r\n    /**\r\n     * Get the current width of the HTML5 media element.\r\n     *\r\n     * @return {number}\r\n     *         The width of the HTML5 media element.\r\n     */\r\n    ;\r\n\r\n    _proto.width = function width() {\r\n      return this.el_.offsetWidth;\r\n    }\r\n    /**\r\n     * Get the current height of the HTML5 media element.\r\n     *\r\n     * @return {number}\r\n     *         The height of the HTML5 media element.\r\n     */\r\n    ;\r\n\r\n    _proto.height = function height() {\r\n      return this.el_.offsetHeight;\r\n    }\r\n    /**\r\n     * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\r\n     * `fullscreenchange` event.\r\n     *\r\n     * @private\r\n     * @fires fullscreenchange\r\n     * @listens webkitendfullscreen\r\n     * @listens webkitbeginfullscreen\r\n     * @listens webkitbeginfullscreen\r\n     */\r\n    ;\r\n\r\n    _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {\r\n      var _this6 = this;\r\n\r\n      if (!('webkitDisplayingFullscreen' in this.el_)) {\r\n        return;\r\n      }\r\n\r\n      var endFn = function endFn() {\r\n        this.trigger('fullscreenchange', {\r\n          isFullscreen: false\r\n        }); // Safari will sometimes set contols on the videoelement when existing fullscreen.\r\n\r\n        if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {\r\n          this.el_.controls = false;\r\n        }\r\n      };\r\n\r\n      var beginFn = function beginFn() {\r\n        if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\r\n          this.one('webkitendfullscreen', endFn);\r\n          this.trigger('fullscreenchange', {\r\n            isFullscreen: true,\r\n            // set a flag in case another tech triggers fullscreenchange\r\n            nativeIOSFullscreen: true\r\n          });\r\n        }\r\n      };\r\n\r\n      this.on('webkitbeginfullscreen', beginFn);\r\n      this.on('dispose', function () {\r\n        _this6.off('webkitbeginfullscreen', beginFn);\r\n\r\n        _this6.off('webkitendfullscreen', endFn);\r\n      });\r\n    }\r\n    /**\r\n     * Check if fullscreen is supported on the current playback device.\r\n     *\r\n     * @return {boolean}\r\n     *         - True if fullscreen is supported.\r\n     *         - False if fullscreen is not supported.\r\n     */\r\n    ;\r\n\r\n    _proto.supportsFullScreen = function supportsFullScreen() {\r\n      if (typeof this.el_.webkitEnterFullScreen === 'function') {\r\n        var userAgent = window.navigator && window.navigator.userAgent || ''; // Seems to be broken in Chromium/Chrome && Safari in Leopard\r\n\r\n        if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Request that the `HTML5` Tech enter fullscreen.\r\n     */\r\n    ;\r\n\r\n    _proto.enterFullScreen = function enterFullScreen() {\r\n      var video = this.el_;\r\n\r\n      if (video.paused && video.networkState <= video.HAVE_METADATA) {\r\n        // attempt to prime the video element for programmatic access\r\n        // this isn't necessary on the desktop but shouldn't hurt\r\n        silencePromise(this.el_.play()); // playing and pausing synchronously during the transition to fullscreen\r\n        // can get iOS ~6.1 devices into a play/pause loop\r\n\r\n        this.setTimeout(function () {\r\n          video.pause();\r\n\r\n          try {\r\n            video.webkitEnterFullScreen();\r\n          } catch (e) {\r\n            this.trigger('fullscreenerror', e);\r\n          }\r\n        }, 0);\r\n      } else {\r\n        try {\r\n          video.webkitEnterFullScreen();\r\n        } catch (e) {\r\n          this.trigger('fullscreenerror', e);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Request that the `HTML5` Tech exit fullscreen.\r\n     */\r\n    ;\r\n\r\n    _proto.exitFullScreen = function exitFullScreen() {\r\n      if (!this.el_.webkitDisplayingFullscreen) {\r\n        this.trigger('fullscreenerror', new Error('The video is not fullscreen'));\r\n        return;\r\n      }\r\n\r\n      this.el_.webkitExitFullScreen();\r\n    }\r\n    /**\r\n     * Create a floating video window always on top of other windows so that users may\r\n     * continue consuming media while they interact with other content sites, or\r\n     * applications on their device.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\r\n     *\r\n     * @return {Promise}\r\n     *         A promise with a Picture-in-Picture window.\r\n     */\r\n    ;\r\n\r\n    _proto.requestPictureInPicture = function requestPictureInPicture() {\r\n      return this.el_.requestPictureInPicture();\r\n    }\r\n    /**\r\n     * Native requestVideoFrameCallback if supported by browser/tech, or fallback\r\n     * Don't use rVCF on Safari when DRM is playing, as it doesn't fire\r\n     * Needs to be checked later than the constructor\r\n     * This will be a false positive for clear sources loaded after a Fairplay source\r\n     *\r\n     * @param {function} cb function to call\r\n     * @return {number} id of request\r\n     */\r\n    ;\r\n\r\n    _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {\r\n      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\r\n        return this.el_.requestVideoFrameCallback(cb);\r\n      }\r\n\r\n      return _Tech.prototype.requestVideoFrameCallback.call(this, cb);\r\n    }\r\n    /**\r\n     * Native or fallback requestVideoFrameCallback\r\n     *\r\n     * @param {number} id request id to cancel\r\n     */\r\n    ;\r\n\r\n    _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {\r\n      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\r\n        this.el_.cancelVideoFrameCallback(id);\r\n      } else {\r\n        _Tech.prototype.cancelVideoFrameCallback.call(this, id);\r\n      }\r\n    }\r\n    /**\r\n     * A getter/setter for the `Html5` Tech's source object.\r\n     * > Note: Please use {@link Html5#setSource}\r\n     *\r\n     * @param {Tech~SourceObject} [src]\r\n     *        The source object you want to set on the `HTML5` techs element.\r\n     *\r\n     * @return {Tech~SourceObject|undefined}\r\n     *         - The current source object when a source is not passed in.\r\n     *         - undefined when setting\r\n     *\r\n     * @deprecated Since version 5.\r\n     */\r\n    ;\r\n\r\n    _proto.src = function src(_src) {\r\n      if (_src === undefined) {\r\n        return this.el_.src;\r\n      } // Setting src through `src` instead of `setSrc` will be deprecated\r\n\r\n\r\n      this.setSrc(_src);\r\n    }\r\n    /**\r\n     * Reset the tech by removing all sources and then calling\r\n     * {@link Html5.resetMediaElement}.\r\n     */\r\n    ;\r\n\r\n    _proto.reset = function reset() {\r\n      Html5.resetMediaElement(this.el_);\r\n    }\r\n    /**\r\n     * Get the current source on the `HTML5` Tech. Falls back to returning the source from\r\n     * the HTML5 media element.\r\n     *\r\n     * @return {Tech~SourceObject}\r\n     *         The current source object from the HTML5 tech. With a fallback to the\r\n     *         elements source.\r\n     */\r\n    ;\r\n\r\n    _proto.currentSrc = function currentSrc() {\r\n      if (this.currentSource_) {\r\n        return this.currentSource_.src;\r\n      }\r\n\r\n      return this.el_.currentSrc;\r\n    }\r\n    /**\r\n     * Set controls attribute for the HTML5 media Element.\r\n     *\r\n     * @param {string} val\r\n     *        Value to set the controls attribute to\r\n     */\r\n    ;\r\n\r\n    _proto.setControls = function setControls(val) {\r\n      this.el_.controls = !!val;\r\n    }\r\n    /**\r\n     * Create and returns a remote {@link TextTrack} object.\r\n     *\r\n     * @param {string} kind\r\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\r\n     *\r\n     * @param {string} [label]\r\n     *        Label to identify the text track\r\n     *\r\n     * @param {string} [language]\r\n     *        Two letter language abbreviation\r\n     *\r\n     * @return {TextTrack}\r\n     *         The TextTrack that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.addTextTrack = function addTextTrack(kind, label, language) {\r\n      if (!this.featuresNativeTextTracks) {\r\n        return _Tech.prototype.addTextTrack.call(this, kind, label, language);\r\n      }\r\n\r\n      return this.el_.addTextTrack(kind, label, language);\r\n    }\r\n    /**\r\n     * Creates either native TextTrack or an emulated TextTrack depending\r\n     * on the value of `featuresNativeTextTracks`\r\n     *\r\n     * @param {Object} options\r\n     *        The object should contain the options to initialize the TextTrack with.\r\n     *\r\n     * @param {string} [options.kind]\r\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\r\n     *\r\n     * @param {string} [options.label]\r\n     *        Label to identify the text track\r\n     *\r\n     * @param {string} [options.language]\r\n     *        Two letter language abbreviation.\r\n     *\r\n     * @param {boolean} [options.default]\r\n     *        Default this track to on.\r\n     *\r\n     * @param {string} [options.id]\r\n     *        The internal id to assign this track.\r\n     *\r\n     * @param {string} [options.src]\r\n     *        A source url for the track.\r\n     *\r\n     * @return {HTMLTrackElement}\r\n     *         The track element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {\r\n      if (!this.featuresNativeTextTracks) {\r\n        return _Tech.prototype.createRemoteTextTrack.call(this, options);\r\n      }\r\n\r\n      var htmlTrackElement = document.createElement('track');\r\n\r\n      if (options.kind) {\r\n        htmlTrackElement.kind = options.kind;\r\n      }\r\n\r\n      if (options.label) {\r\n        htmlTrackElement.label = options.label;\r\n      }\r\n\r\n      if (options.language || options.srclang) {\r\n        htmlTrackElement.srclang = options.language || options.srclang;\r\n      }\r\n\r\n      if (options[\"default\"]) {\r\n        htmlTrackElement[\"default\"] = options[\"default\"];\r\n      }\r\n\r\n      if (options.id) {\r\n        htmlTrackElement.id = options.id;\r\n      }\r\n\r\n      if (options.src) {\r\n        htmlTrackElement.src = options.src;\r\n      }\r\n\r\n      return htmlTrackElement;\r\n    }\r\n    /**\r\n     * Creates a remote text track object and returns an html track element.\r\n     *\r\n     * @param {Object} options The object should contain values for\r\n     * kind, language, label, and src (location of the WebVTT file)\r\n     * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\r\n     * automatically removed from the video element whenever the source changes\r\n     * @return {HTMLTrackElement} An Html Track Element.\r\n     * This can be an emulated {@link HTMLTrackElement} or a native one.\r\n     * @deprecated The default value of the \"manualCleanup\" parameter will default\r\n     * to \"false\" in upcoming versions of Video.js\r\n     */\r\n    ;\r\n\r\n    _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\r\n      var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);\r\n\r\n      if (this.featuresNativeTextTracks) {\r\n        this.el().appendChild(htmlTrackElement);\r\n      }\r\n\r\n      return htmlTrackElement;\r\n    }\r\n    /**\r\n     * Remove remote `TextTrack` from `TextTrackList` object\r\n     *\r\n     * @param {TextTrack} track\r\n     *        `TextTrack` object to remove\r\n     */\r\n    ;\r\n\r\n    _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\r\n      _Tech.prototype.removeRemoteTextTrack.call(this, track);\r\n\r\n      if (this.featuresNativeTextTracks) {\r\n        var tracks = this.$$('track');\r\n        var i = tracks.length;\r\n\r\n        while (i--) {\r\n          if (track === tracks[i] || track === tracks[i].track) {\r\n            this.el().removeChild(tracks[i]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Gets available media playback quality metrics as specified by the W3C's Media\r\n     * Playback Quality API.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\r\n     *\r\n     * @return {Object}\r\n     *         An object with supported media playback quality metrics\r\n     */\r\n    ;\r\n\r\n    _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\r\n      if (typeof this.el().getVideoPlaybackQuality === 'function') {\r\n        return this.el().getVideoPlaybackQuality();\r\n      }\r\n\r\n      var videoPlaybackQuality = {};\r\n\r\n      if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\r\n        videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\r\n        videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\r\n      }\r\n\r\n      if (window.performance && typeof window.performance.now === 'function') {\r\n        videoPlaybackQuality.creationTime = window.performance.now();\r\n      } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {\r\n        videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;\r\n      }\r\n\r\n      return videoPlaybackQuality;\r\n    };\r\n\r\n    return Html5;\r\n  }(Tech);\r\n  /* HTML5 Support Testing ---------------------------------------------------- */\r\n\r\n  /**\r\n   * Element for testing browser HTML5 media capabilities\r\n   *\r\n   * @type {Element}\r\n   * @constant\r\n   * @private\r\n   */\r\n\r\n\r\n  defineLazyProperty(Html5, 'TEST_VID', function () {\r\n    if (!isReal()) {\r\n      return;\r\n    }\r\n\r\n    var video = document.createElement('video');\r\n    var track = document.createElement('track');\r\n    track.kind = 'captions';\r\n    track.srclang = 'en';\r\n    track.label = 'English';\r\n    video.appendChild(track);\r\n    return video;\r\n  });\r\n  /**\r\n   * Check if HTML5 media is supported by this browser/device.\r\n   *\r\n   * @return {boolean}\r\n   *         - True if HTML5 media is supported.\r\n   *         - False if HTML5 media is not supported.\r\n   */\r\n\r\n  Html5.isSupported = function () {\r\n    // IE with no Media Player is a LIAR! (#984)\r\n    try {\r\n      Html5.TEST_VID.volume = 0.5;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\r\n  };\r\n  /**\r\n   * Check if the tech can support the given type\r\n   *\r\n   * @param {string} type\r\n   *        The mimetype to check\r\n   * @return {string} 'probably', 'maybe', or '' (empty string)\r\n   */\r\n\r\n\r\n  Html5.canPlayType = function (type) {\r\n    return Html5.TEST_VID.canPlayType(type);\r\n  };\r\n  /**\r\n   * Check if the tech can support the given source\r\n   *\r\n   * @param {Object} srcObj\r\n   *        The source object\r\n   * @param {Object} options\r\n   *        The options passed to the tech\r\n   * @return {string} 'probably', 'maybe', or '' (empty string)\r\n   */\r\n\r\n\r\n  Html5.canPlaySource = function (srcObj, options) {\r\n    return Html5.canPlayType(srcObj.type);\r\n  };\r\n  /**\r\n   * Check if the volume can be changed in this browser/device.\r\n   * Volume cannot be changed in a lot of mobile devices.\r\n   * Specifically, it can't be changed from 1 on iOS.\r\n   *\r\n   * @return {boolean}\r\n   *         - True if volume can be controlled\r\n   *         - False otherwise\r\n   */\r\n\r\n\r\n  Html5.canControlVolume = function () {\r\n    // IE will error if Windows Media Player not installed #3315\r\n    try {\r\n      var volume = Html5.TEST_VID.volume;\r\n      Html5.TEST_VID.volume = volume / 2 + 0.1;\r\n      var canControl = volume !== Html5.TEST_VID.volume; // With the introduction of iOS 15, there are cases where the volume is read as\r\n      // changed but reverts back to its original state at the start of the next tick.\r\n      // To determine whether volume can be controlled on iOS,\r\n      // a timeout is set and the volume is checked asynchronously.\r\n      // Since `features` doesn't currently work asynchronously, the value is manually set.\r\n\r\n      if (canControl && IS_IOS) {\r\n        window.setTimeout(function () {\r\n          if (Html5 && Html5.prototype) {\r\n            Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;\r\n          }\r\n        }); // default iOS to false, which will be updated in the timeout above.\r\n\r\n        return false;\r\n      }\r\n\r\n      return canControl;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  };\r\n  /**\r\n   * Check if the volume can be muted in this browser/device.\r\n   * Some devices, e.g. iOS, don't allow changing volume\r\n   * but permits muting/unmuting.\r\n   *\r\n   * @return {bolean}\r\n   *      - True if volume can be muted\r\n   *      - False otherwise\r\n   */\r\n\r\n\r\n  Html5.canMuteVolume = function () {\r\n    try {\r\n      var muted = Html5.TEST_VID.muted; // in some versions of iOS muted property doesn't always\r\n      // work, so we want to set both property and attribute\r\n\r\n      Html5.TEST_VID.muted = !muted;\r\n\r\n      if (Html5.TEST_VID.muted) {\r\n        setAttribute(Html5.TEST_VID, 'muted', 'muted');\r\n      } else {\r\n        removeAttribute(Html5.TEST_VID, 'muted', 'muted');\r\n      }\r\n\r\n      return muted !== Html5.TEST_VID.muted;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  };\r\n  /**\r\n   * Check if the playback rate can be changed in this browser/device.\r\n   *\r\n   * @return {boolean}\r\n   *         - True if playback rate can be controlled\r\n   *         - False otherwise\r\n   */\r\n\r\n\r\n  Html5.canControlPlaybackRate = function () {\r\n    // Playback rate API is implemented in Android Chrome, but doesn't do anything\r\n    // https://github.com/videojs/video.js/issues/3180\r\n    if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\r\n      return false;\r\n    } // IE will error if Windows Media Player not installed #3315\r\n\r\n\r\n    try {\r\n      var playbackRate = Html5.TEST_VID.playbackRate;\r\n      Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\r\n      return playbackRate !== Html5.TEST_VID.playbackRate;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  };\r\n  /**\r\n   * Check if we can override a video/audio elements attributes, with\r\n   * Object.defineProperty.\r\n   *\r\n   * @return {boolean}\r\n   *         - True if builtin attributes can be overridden\r\n   *         - False otherwise\r\n   */\r\n\r\n\r\n  Html5.canOverrideAttributes = function () {\r\n    // if we cannot overwrite the src/innerHTML property, there is no support\r\n    // iOS 7 safari for instance cannot do this.\r\n    try {\r\n      var noop = function noop() {};\r\n\r\n      Object.defineProperty(document.createElement('video'), 'src', {\r\n        get: noop,\r\n        set: noop\r\n      });\r\n      Object.defineProperty(document.createElement('audio'), 'src', {\r\n        get: noop,\r\n        set: noop\r\n      });\r\n      Object.defineProperty(document.createElement('video'), 'innerHTML', {\r\n        get: noop,\r\n        set: noop\r\n      });\r\n      Object.defineProperty(document.createElement('audio'), 'innerHTML', {\r\n        get: noop,\r\n        set: noop\r\n      });\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * Check to see if native `TextTrack`s are supported by this browser/device.\r\n   *\r\n   * @return {boolean}\r\n   *         - True if native `TextTrack`s are supported.\r\n   *         - False otherwise\r\n   */\r\n\r\n\r\n  Html5.supportsNativeTextTracks = function () {\r\n    return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\r\n  };\r\n  /**\r\n   * Check to see if native `VideoTrack`s are supported by this browser/device\r\n   *\r\n   * @return {boolean}\r\n   *        - True if native `VideoTrack`s are supported.\r\n   *        - False otherwise\r\n   */\r\n\r\n\r\n  Html5.supportsNativeVideoTracks = function () {\r\n    return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\r\n  };\r\n  /**\r\n   * Check to see if native `AudioTrack`s are supported by this browser/device\r\n   *\r\n   * @return {boolean}\r\n   *        - True if native `AudioTrack`s are supported.\r\n   *        - False otherwise\r\n   */\r\n\r\n\r\n  Html5.supportsNativeAudioTracks = function () {\r\n    return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\r\n  };\r\n  /**\r\n   * An array of events available on the Html5 tech.\r\n   *\r\n   * @private\r\n   * @type {Array}\r\n   */\r\n\r\n\r\n  Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports volume control.\r\n   *\r\n   * @type {boolean}\r\n   * @default {@link Html5.canControlVolume}\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports muting volume.\r\n   *\r\n   * @type {bolean}\r\n   * @default {@link Html5.canMuteVolume}\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports changing the speed at which the media\r\n   * plays. Examples:\r\n   *   - Set player to play 2x (twice) as fast\r\n   *   - Set player to play 0.5x (half) as fast\r\n   *\r\n   * @type {boolean}\r\n   * @default {@link Html5.canControlPlaybackRate}\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `Tech` supports the `sourceset` event.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\r\n   *\r\n   * @type {boolean}\r\n   * @default {@link Html5.supportsNativeTextTracks}\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\r\n   *\r\n   * @type {boolean}\r\n   * @default {@link Html5.supportsNativeVideoTracks}\r\n   */\r\n\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\r\n   *\r\n   * @type {boolean}\r\n   * @default {@link Html5.supportsNativeAudioTracks}\r\n   */\r\n\r\n  [['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function (_ref) {\r\n    var key = _ref[0],\r\n        fn = _ref[1];\r\n    defineLazyProperty(Html5.prototype, key, function () {\r\n      return Html5[fn]();\r\n    }, true);\r\n  });\r\n  Html5.prototype.featuresVolumeControl = Html5.canControlVolume();\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports the media element\r\n   * moving in the DOM. iOS breaks if you move the media element, so this is set this to\r\n   * false there. Everywhere else this should be true.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Html5.prototype.movingMediaElementInDOM = !IS_IOS; // TODO: Previous comment: No longer appears to be used. Can probably be removed.\r\n  //       Is this true?\r\n\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\r\n   * when going into fullscreen.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Html5.prototype.featuresFullscreenResize = true;\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports the progress event.\r\n   * If this is false, manual `progress` events will be triggered instead.\r\n   *\r\n   * @type {boolean}\r\n   * @default\r\n   */\r\n\r\n  Html5.prototype.featuresProgressEvents = true;\r\n  /**\r\n   * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\r\n   * If this is false, manual `timeupdate` events will be triggered instead.\r\n   *\r\n   * @default\r\n   */\r\n\r\n  Html5.prototype.featuresTimeupdateEvents = true;\r\n  /**\r\n   * Whether the HTML5 el supports `requestVideoFrameCallback`\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback); // HTML5 Feature detection and Device Fixes --------------------------------- //\r\n\r\n  var canPlayType;\r\n\r\n  Html5.patchCanPlayType = function () {\r\n    // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\r\n    // Firefox and Chrome report correctly\r\n    if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX && !IS_CHROME) {\r\n      canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;\r\n\r\n      Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\r\n        var mpegurlRE = /^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;\r\n\r\n        if (type && mpegurlRE.test(type)) {\r\n          return 'maybe';\r\n        }\r\n\r\n        return canPlayType.call(this, type);\r\n      };\r\n    }\r\n  };\r\n\r\n  Html5.unpatchCanPlayType = function () {\r\n    var r = Html5.TEST_VID.constructor.prototype.canPlayType;\r\n\r\n    if (canPlayType) {\r\n      Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\r\n    }\r\n\r\n    return r;\r\n  }; // by default, patch the media element\r\n\r\n\r\n  Html5.patchCanPlayType();\r\n\r\n  Html5.disposeMediaElement = function (el) {\r\n    if (!el) {\r\n      return;\r\n    }\r\n\r\n    if (el.parentNode) {\r\n      el.parentNode.removeChild(el);\r\n    } // remove any child track or source nodes to prevent their loading\r\n\r\n\r\n    while (el.hasChildNodes()) {\r\n      el.removeChild(el.firstChild);\r\n    } // remove any src reference. not setting `src=''` because that causes a warning\r\n    // in firefox\r\n\r\n\r\n    el.removeAttribute('src'); // force the media element to update its loading state by calling load()\r\n    // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\r\n\r\n    if (typeof el.load === 'function') {\r\n      // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\r\n      (function () {\r\n        try {\r\n          el.load();\r\n        } catch (e) {// not supported\r\n        }\r\n      })();\r\n    }\r\n  };\r\n\r\n  Html5.resetMediaElement = function (el) {\r\n    if (!el) {\r\n      return;\r\n    }\r\n\r\n    var sources = el.querySelectorAll('source');\r\n    var i = sources.length;\r\n\r\n    while (i--) {\r\n      el.removeChild(sources[i]);\r\n    } // remove any src reference.\r\n    // not setting `src=''` because that throws an error\r\n\r\n\r\n    el.removeAttribute('src');\r\n\r\n    if (typeof el.load === 'function') {\r\n      // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\r\n      (function () {\r\n        try {\r\n          el.load();\r\n        } catch (e) {// satisfy linter\r\n        }\r\n      })();\r\n    }\r\n  };\r\n  /* Native HTML5 element property wrapping ----------------------------------- */\r\n  // Wrap native boolean attributes with getters that check both property and attribute\r\n  // The list is as followed:\r\n  // muted, defaultMuted, autoplay, controls, loop, playsinline\r\n\r\n\r\n  [\r\n  /**\r\n   * Get the value of `muted` from the media element. `muted` indicates\r\n   * that the volume for the media should be set to silent. This does not actually change\r\n   * the `volume` attribute.\r\n   *\r\n   * @method Html5#muted\r\n   * @return {boolean}\r\n   *         - True if the value of `volume` should be ignored and the audio set to silent.\r\n   *         - False if the value of `volume` should be used.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\r\n   */\r\n  'muted',\r\n  /**\r\n   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\r\n   * whether the media should start muted or not. Only changes the default state of the\r\n   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\r\n   * current state.\r\n   *\r\n   * @method Html5#defaultMuted\r\n   * @return {boolean}\r\n   *         - The value of `defaultMuted` from the media element.\r\n   *         - True indicates that the media should start muted.\r\n   *         - False indicates that the media should not start muted\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\r\n   */\r\n  'defaultMuted',\r\n  /**\r\n   * Get the value of `autoplay` from the media element. `autoplay` indicates\r\n   * that the media should start to play as soon as the page is ready.\r\n   *\r\n   * @method Html5#autoplay\r\n   * @return {boolean}\r\n   *         - The value of `autoplay` from the media element.\r\n   *         - True indicates that the media should start as soon as the page loads.\r\n   *         - False indicates that the media should not start as soon as the page loads.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\r\n   */\r\n  'autoplay',\r\n  /**\r\n   * Get the value of `controls` from the media element. `controls` indicates\r\n   * whether the native media controls should be shown or hidden.\r\n   *\r\n   * @method Html5#controls\r\n   * @return {boolean}\r\n   *         - The value of `controls` from the media element.\r\n   *         - True indicates that native controls should be showing.\r\n   *         - False indicates that native controls should be hidden.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\r\n   */\r\n  'controls',\r\n  /**\r\n   * Get the value of `loop` from the media element. `loop` indicates\r\n   * that the media should return to the start of the media and continue playing once\r\n   * it reaches the end.\r\n   *\r\n   * @method Html5#loop\r\n   * @return {boolean}\r\n   *         - The value of `loop` from the media element.\r\n   *         - True indicates that playback should seek back to start once\r\n   *           the end of a media is reached.\r\n   *         - False indicates that playback should not loop back to the start when the\r\n   *           end of the media is reached.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\r\n   */\r\n  'loop',\r\n  /**\r\n   * Get the value of `playsinline` from the media element. `playsinline` indicates\r\n   * to the browser that non-fullscreen playback is preferred when fullscreen\r\n   * playback is the native default, such as in iOS Safari.\r\n   *\r\n   * @method Html5#playsinline\r\n   * @return {boolean}\r\n   *         - The value of `playsinline` from the media element.\r\n   *         - True indicates that the media should play inline.\r\n   *         - False indicates that the media should not play inline.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\r\n   */\r\n  'playsinline'].forEach(function (prop) {\r\n    Html5.prototype[prop] = function () {\r\n      return this.el_[prop] || this.el_.hasAttribute(prop);\r\n    };\r\n  }); // Wrap native boolean attributes with setters that set both property and attribute\r\n  // The list is as followed:\r\n  // setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\r\n  // setControls is special-cased above\r\n\r\n  [\r\n  /**\r\n   * Set the value of `muted` on the media element. `muted` indicates that the current\r\n   * audio level should be silent.\r\n   *\r\n   * @method Html5#setMuted\r\n   * @param {boolean} muted\r\n   *        - True if the audio should be set to silent\r\n   *        - False otherwise\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\r\n   */\r\n  'muted',\r\n  /**\r\n   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\r\n   * audio level should be silent, but will only effect the muted level on initial playback..\r\n   *\r\n   * @method Html5.prototype.setDefaultMuted\r\n   * @param {boolean} defaultMuted\r\n   *        - True if the audio should be set to silent\r\n   *        - False otherwise\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\r\n   */\r\n  'defaultMuted',\r\n  /**\r\n   * Set the value of `autoplay` on the media element. `autoplay` indicates\r\n   * that the media should start to play as soon as the page is ready.\r\n   *\r\n   * @method Html5#setAutoplay\r\n   * @param {boolean} autoplay\r\n   *         - True indicates that the media should start as soon as the page loads.\r\n   *         - False indicates that the media should not start as soon as the page loads.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\r\n   */\r\n  'autoplay',\r\n  /**\r\n   * Set the value of `loop` on the media element. `loop` indicates\r\n   * that the media should return to the start of the media and continue playing once\r\n   * it reaches the end.\r\n   *\r\n   * @method Html5#setLoop\r\n   * @param {boolean} loop\r\n   *         - True indicates that playback should seek back to start once\r\n   *           the end of a media is reached.\r\n   *         - False indicates that playback should not loop back to the start when the\r\n   *           end of the media is reached.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\r\n   */\r\n  'loop',\r\n  /**\r\n   * Set the value of `playsinline` from the media element. `playsinline` indicates\r\n   * to the browser that non-fullscreen playback is preferred when fullscreen\r\n   * playback is the native default, such as in iOS Safari.\r\n   *\r\n   * @method Html5#setPlaysinline\r\n   * @param {boolean} playsinline\r\n   *         - True indicates that the media should play inline.\r\n   *         - False indicates that the media should not play inline.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\r\n   */\r\n  'playsinline'].forEach(function (prop) {\r\n    Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\r\n      this.el_[prop] = v;\r\n\r\n      if (v) {\r\n        this.el_.setAttribute(prop, prop);\r\n      } else {\r\n        this.el_.removeAttribute(prop);\r\n      }\r\n    };\r\n  }); // Wrap native properties with a getter\r\n  // The list is as followed\r\n  // paused, currentTime, buffered, volume, poster, preload, error, seeking\r\n  // seekable, ended, playbackRate, defaultPlaybackRate, disablePictureInPicture\r\n  // played, networkState, readyState, videoWidth, videoHeight, crossOrigin\r\n\r\n  [\r\n  /**\r\n   * Get the value of `paused` from the media element. `paused` indicates whether the media element\r\n   * is currently paused or not.\r\n   *\r\n   * @method Html5#paused\r\n   * @return {boolean}\r\n   *         The value of `paused` from the media element.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\r\n   */\r\n  'paused',\r\n  /**\r\n   * Get the value of `currentTime` from the media element. `currentTime` indicates\r\n   * the current second that the media is at in playback.\r\n   *\r\n   * @method Html5#currentTime\r\n   * @return {number}\r\n   *         The value of `currentTime` from the media element.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\r\n   */\r\n  'currentTime',\r\n  /**\r\n   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\r\n   * object that represents the parts of the media that are already downloaded and\r\n   * available for playback.\r\n   *\r\n   * @method Html5#buffered\r\n   * @return {TimeRange}\r\n   *         The value of `buffered` from the media element.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\r\n   */\r\n  'buffered',\r\n  /**\r\n   * Get the value of `volume` from the media element. `volume` indicates\r\n   * the current playback volume of audio for a media. `volume` will be a value from 0\r\n   * (silent) to 1 (loudest and default).\r\n   *\r\n   * @method Html5#volume\r\n   * @return {number}\r\n   *         The value of `volume` from the media element. Value will be between 0-1.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\r\n   */\r\n  'volume',\r\n  /**\r\n   * Get the value of `poster` from the media element. `poster` indicates\r\n   * that the url of an image file that can/will be shown when no media data is available.\r\n   *\r\n   * @method Html5#poster\r\n   * @return {string}\r\n   *         The value of `poster` from the media element. Value will be a url to an\r\n   *         image.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\r\n   */\r\n  'poster',\r\n  /**\r\n   * Get the value of `preload` from the media element. `preload` indicates\r\n   * what should download before the media is interacted with. It can have the following\r\n   * values:\r\n   * - none: nothing should be downloaded\r\n   * - metadata: poster and the first few frames of the media may be downloaded to get\r\n   *   media dimensions and other metadata\r\n   * - auto: allow the media and metadata for the media to be downloaded before\r\n   *    interaction\r\n   *\r\n   * @method Html5#preload\r\n   * @return {string}\r\n   *         The value of `preload` from the media element. Will be 'none', 'metadata',\r\n   *         or 'auto'.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\r\n   */\r\n  'preload',\r\n  /**\r\n   * Get the value of the `error` from the media element. `error` indicates any\r\n   * MediaError that may have occurred during playback. If error returns null there is no\r\n   * current error.\r\n   *\r\n   * @method Html5#error\r\n   * @return {MediaError|null}\r\n   *         The value of `error` from the media element. Will be `MediaError` if there\r\n   *         is a current error and null otherwise.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\r\n   */\r\n  'error',\r\n  /**\r\n   * Get the value of `seeking` from the media element. `seeking` indicates whether the\r\n   * media is currently seeking to a new position or not.\r\n   *\r\n   * @method Html5#seeking\r\n   * @return {boolean}\r\n   *         - The value of `seeking` from the media element.\r\n   *         - True indicates that the media is currently seeking to a new position.\r\n   *         - False indicates that the media is not seeking to a new position at this time.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\r\n   */\r\n  'seeking',\r\n  /**\r\n   * Get the value of `seekable` from the media element. `seekable` returns a\r\n   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\r\n   *\r\n   * @method Html5#seekable\r\n   * @return {TimeRange}\r\n   *         The value of `seekable` from the media element. A `TimeRange` object\r\n   *         indicating the current ranges of time that can be seeked to.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\r\n   */\r\n  'seekable',\r\n  /**\r\n   * Get the value of `ended` from the media element. `ended` indicates whether\r\n   * the media has reached the end or not.\r\n   *\r\n   * @method Html5#ended\r\n   * @return {boolean}\r\n   *         - The value of `ended` from the media element.\r\n   *         - True indicates that the media has ended.\r\n   *         - False indicates that the media has not ended.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\r\n   */\r\n  'ended',\r\n  /**\r\n   * Get the value of `playbackRate` from the media element. `playbackRate` indicates\r\n   * the rate at which the media is currently playing back. Examples:\r\n   *   - if playbackRate is set to 2, media will play twice as fast.\r\n   *   - if playbackRate is set to 0.5, media will play half as fast.\r\n   *\r\n   * @method Html5#playbackRate\r\n   * @return {number}\r\n   *         The value of `playbackRate` from the media element. A number indicating\r\n   *         the current playback speed of the media, where 1 is normal speed.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\r\n   */\r\n  'playbackRate',\r\n  /**\r\n   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\r\n   * the rate at which the media is currently playing back. This value will not indicate the current\r\n   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\r\n   *\r\n   * Examples:\r\n   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\r\n   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\r\n   *\r\n   * @method Html5.prototype.defaultPlaybackRate\r\n   * @return {number}\r\n   *         The value of `defaultPlaybackRate` from the media element. A number indicating\r\n   *         the current playback speed of the media, where 1 is normal speed.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\r\n   */\r\n  'defaultPlaybackRate',\r\n  /**\r\n   * Get the value of 'disablePictureInPicture' from the video element.\r\n   *\r\n   * @method Html5#disablePictureInPicture\r\n   * @return {boolean} value\r\n   *         - The value of `disablePictureInPicture` from the video element.\r\n   *         - True indicates that the video can't be played in Picture-In-Picture mode\r\n   *         - False indicates that the video can be played in Picture-In-Picture mode\r\n   *\r\n   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\r\n   */\r\n  'disablePictureInPicture',\r\n  /**\r\n   * Get the value of `played` from the media element. `played` returns a `TimeRange`\r\n   * object representing points in the media timeline that have been played.\r\n   *\r\n   * @method Html5#played\r\n   * @return {TimeRange}\r\n   *         The value of `played` from the media element. A `TimeRange` object indicating\r\n   *         the ranges of time that have been played.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\r\n   */\r\n  'played',\r\n  /**\r\n   * Get the value of `networkState` from the media element. `networkState` indicates\r\n   * the current network state. It returns an enumeration from the following list:\r\n   * - 0: NETWORK_EMPTY\r\n   * - 1: NETWORK_IDLE\r\n   * - 2: NETWORK_LOADING\r\n   * - 3: NETWORK_NO_SOURCE\r\n   *\r\n   * @method Html5#networkState\r\n   * @return {number}\r\n   *         The value of `networkState` from the media element. This will be a number\r\n   *         from the list in the description.\r\n   *\r\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\r\n   */\r\n  'networkState',\r\n  /**\r\n   * Get the value of `readyState` from the media element. `readyState` indicates\r\n   * the current state of the media element. It returns an enumeration from the\r\n   * following list:\r\n   * - 0: HAVE_NOTHING\r\n   * - 1: HAVE_METADATA\r\n   * - 2: HAVE_CURRENT_DATA\r\n   * - 3: HAVE_FUTURE_DATA\r\n   * - 4: HAVE_ENOUGH_DATA\r\n   *\r\n   * @method Html5#readyState\r\n   * @return {number}\r\n   *         The value of `readyState` from the media element. This will be a number\r\n   *         from the list in the description.\r\n   *\r\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\r\n   */\r\n  'readyState',\r\n  /**\r\n   * Get the value of `videoWidth` from the video element. `videoWidth` indicates\r\n   * the current width of the video in css pixels.\r\n   *\r\n   * @method Html5#videoWidth\r\n   * @return {number}\r\n   *         The value of `videoWidth` from the video element. This will be a number\r\n   *         in css pixels.\r\n   *\r\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\r\n   */\r\n  'videoWidth',\r\n  /**\r\n   * Get the value of `videoHeight` from the video element. `videoHeight` indicates\r\n   * the current height of the video in css pixels.\r\n   *\r\n   * @method Html5#videoHeight\r\n   * @return {number}\r\n   *         The value of `videoHeight` from the video element. This will be a number\r\n   *         in css pixels.\r\n   *\r\n   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\r\n   */\r\n  'videoHeight',\r\n  /**\r\n   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates\r\n   * to the browser that should sent the cookies along with the requests for the\r\n   * different assets/playlists\r\n   *\r\n   * @method Html5#crossOrigin\r\n   * @return {string}\r\n   *         - anonymous indicates that the media should not sent cookies.\r\n   *         - use-credentials indicates that the media should sent cookies along the requests.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\r\n   */\r\n  'crossOrigin'].forEach(function (prop) {\r\n    Html5.prototype[prop] = function () {\r\n      return this.el_[prop];\r\n    };\r\n  }); // Wrap native properties with a setter in this format:\r\n  // set + toTitleCase(name)\r\n  // The list is as follows:\r\n  // setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate,\r\n  // setDisablePictureInPicture, setCrossOrigin\r\n\r\n  [\r\n  /**\r\n   * Set the value of `volume` on the media element. `volume` indicates the current\r\n   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\r\n   * so on.\r\n   *\r\n   * @method Html5#setVolume\r\n   * @param {number} percentAsDecimal\r\n   *        The volume percent as a decimal. Valid range is from 0-1.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\r\n   */\r\n  'volume',\r\n  /**\r\n   * Set the value of `src` on the media element. `src` indicates the current\r\n   * {@link Tech~SourceObject} for the media.\r\n   *\r\n   * @method Html5#setSrc\r\n   * @param {Tech~SourceObject} src\r\n   *        The source object to set as the current source.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\r\n   */\r\n  'src',\r\n  /**\r\n   * Set the value of `poster` on the media element. `poster` is the url to\r\n   * an image file that can/will be shown when no media data is available.\r\n   *\r\n   * @method Html5#setPoster\r\n   * @param {string} poster\r\n   *        The url to an image that should be used as the `poster` for the media\r\n   *        element.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\r\n   */\r\n  'poster',\r\n  /**\r\n   * Set the value of `preload` on the media element. `preload` indicates\r\n   * what should download before the media is interacted with. It can have the following\r\n   * values:\r\n   * - none: nothing should be downloaded\r\n   * - metadata: poster and the first few frames of the media may be downloaded to get\r\n   *   media dimensions and other metadata\r\n   * - auto: allow the media and metadata for the media to be downloaded before\r\n   *    interaction\r\n   *\r\n   * @method Html5#setPreload\r\n   * @param {string} preload\r\n   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\r\n   *         or 'auto'.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\r\n   */\r\n  'preload',\r\n  /**\r\n   * Set the value of `playbackRate` on the media element. `playbackRate` indicates\r\n   * the rate at which the media should play back. Examples:\r\n   *   - if playbackRate is set to 2, media will play twice as fast.\r\n   *   - if playbackRate is set to 0.5, media will play half as fast.\r\n   *\r\n   * @method Html5#setPlaybackRate\r\n   * @return {number}\r\n   *         The value of `playbackRate` from the media element. A number indicating\r\n   *         the current playback speed of the media, where 1 is normal speed.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\r\n   */\r\n  'playbackRate',\r\n  /**\r\n   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\r\n   * the rate at which the media should play back upon initial startup. Changing this value\r\n   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\r\n   *\r\n   * Example Values:\r\n   *   - if playbackRate is set to 2, media will play twice as fast.\r\n   *   - if playbackRate is set to 0.5, media will play half as fast.\r\n   *\r\n   * @method Html5.prototype.setDefaultPlaybackRate\r\n   * @return {number}\r\n   *         The value of `defaultPlaybackRate` from the media element. A number indicating\r\n   *         the current playback speed of the media, where 1 is normal speed.\r\n   *\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\r\n   */\r\n  'defaultPlaybackRate',\r\n  /**\r\n   * Prevents the browser from suggesting a Picture-in-Picture context menu\r\n   * or to request Picture-in-Picture automatically in some cases.\r\n   *\r\n   * @method Html5#setDisablePictureInPicture\r\n   * @param {boolean} value\r\n   *         The true value will disable Picture-in-Picture mode.\r\n   *\r\n   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\r\n   */\r\n  'disablePictureInPicture',\r\n  /**\r\n   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates\r\n   * to the browser that should sent the cookies along with the requests for the\r\n   * different assets/playlists\r\n   *\r\n   * @method Html5#setCrossOrigin\r\n   * @param {string} crossOrigin\r\n   *         - anonymous indicates that the media should not sent cookies.\r\n   *         - use-credentials indicates that the media should sent cookies along the requests.\r\n   *\r\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\r\n   */\r\n  'crossOrigin'].forEach(function (prop) {\r\n    Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\r\n      this.el_[prop] = v;\r\n    };\r\n  }); // wrap native functions with a function\r\n  // The list is as follows:\r\n  // pause, load, play\r\n\r\n  [\r\n  /**\r\n   * A wrapper around the media elements `pause` function. This will call the `HTML5`\r\n   * media elements `pause` function.\r\n   *\r\n   * @method Html5#pause\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\r\n   */\r\n  'pause',\r\n  /**\r\n   * A wrapper around the media elements `load` function. This will call the `HTML5`s\r\n   * media element `load` function.\r\n   *\r\n   * @method Html5#load\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\r\n   */\r\n  'load',\r\n  /**\r\n   * A wrapper around the media elements `play` function. This will call the `HTML5`s\r\n   * media element `play` function.\r\n   *\r\n   * @method Html5#play\r\n   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\r\n   */\r\n  'play'].forEach(function (prop) {\r\n    Html5.prototype[prop] = function () {\r\n      return this.el_[prop]();\r\n    };\r\n  });\r\n  Tech.withSourceHandlers(Html5);\r\n  /**\r\n   * Native source handler for Html5, simply passes the source to the media element.\r\n   *\r\n   * @property {Tech~SourceObject} source\r\n   *        The source object\r\n   *\r\n   * @property {Html5} tech\r\n   *        The instance of the HTML5 tech.\r\n   */\r\n\r\n  Html5.nativeSourceHandler = {};\r\n  /**\r\n   * Check if the media element can play the given mime type.\r\n   *\r\n   * @param {string} type\r\n   *        The mimetype to check\r\n   *\r\n   * @return {string}\r\n   *         'probably', 'maybe', or '' (empty string)\r\n   */\r\n\r\n  Html5.nativeSourceHandler.canPlayType = function (type) {\r\n    // IE without MediaPlayer throws an error (#519)\r\n    try {\r\n      return Html5.TEST_VID.canPlayType(type);\r\n    } catch (e) {\r\n      return '';\r\n    }\r\n  };\r\n  /**\r\n   * Check if the media element can handle a source natively.\r\n   *\r\n   * @param {Tech~SourceObject} source\r\n   *         The source object\r\n   *\r\n   * @param {Object} [options]\r\n   *         Options to be passed to the tech.\r\n   *\r\n   * @return {string}\r\n   *         'probably', 'maybe', or '' (empty string).\r\n   */\r\n\r\n\r\n  Html5.nativeSourceHandler.canHandleSource = function (source, options) {\r\n    // If a type was provided we should rely on that\r\n    if (source.type) {\r\n      return Html5.nativeSourceHandler.canPlayType(source.type); // If no type, fall back to checking 'video/[EXTENSION]'\r\n    } else if (source.src) {\r\n      var ext = getFileExtension(source.src);\r\n      return Html5.nativeSourceHandler.canPlayType(\"video/\" + ext);\r\n    }\r\n\r\n    return '';\r\n  };\r\n  /**\r\n   * Pass the source to the native media element.\r\n   *\r\n   * @param {Tech~SourceObject} source\r\n   *        The source object\r\n   *\r\n   * @param {Html5} tech\r\n   *        The instance of the Html5 tech\r\n   *\r\n   * @param {Object} [options]\r\n   *        The options to pass to the source\r\n   */\r\n\r\n\r\n  Html5.nativeSourceHandler.handleSource = function (source, tech, options) {\r\n    tech.setSrc(source.src);\r\n  };\r\n  /**\r\n   * A noop for the native dispose function, as cleanup is not needed.\r\n   */\r\n\r\n\r\n  Html5.nativeSourceHandler.dispose = function () {}; // Register the native source handler\r\n\r\n\r\n  Html5.registerSourceHandler(Html5.nativeSourceHandler);\r\n  Tech.registerTech('Html5', Html5);\r\n\r\n  // on the player when they happen\r\n\r\n  var TECH_EVENTS_RETRIGGER = [\r\n  /**\r\n   * Fired while the user agent is downloading media data.\r\n   *\r\n   * @event Player#progress\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `progress` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechProgress_\r\n   * @fires Player#progress\r\n   * @listens Tech#progress\r\n   */\r\n  'progress',\r\n  /**\r\n   * Fires when the loading of an audio/video is aborted.\r\n   *\r\n   * @event Player#abort\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `abort` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechAbort_\r\n   * @fires Player#abort\r\n   * @listens Tech#abort\r\n   */\r\n  'abort',\r\n  /**\r\n   * Fires when the browser is intentionally not getting media data.\r\n   *\r\n   * @event Player#suspend\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `suspend` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechSuspend_\r\n   * @fires Player#suspend\r\n   * @listens Tech#suspend\r\n   */\r\n  'suspend',\r\n  /**\r\n   * Fires when the current playlist is empty.\r\n   *\r\n   * @event Player#emptied\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `emptied` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechEmptied_\r\n   * @fires Player#emptied\r\n   * @listens Tech#emptied\r\n   */\r\n  'emptied',\r\n  /**\r\n   * Fires when the browser is trying to get media data, but data is not available.\r\n   *\r\n   * @event Player#stalled\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `stalled` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechStalled_\r\n   * @fires Player#stalled\r\n   * @listens Tech#stalled\r\n   */\r\n  'stalled',\r\n  /**\r\n   * Fires when the browser has loaded meta data for the audio/video.\r\n   *\r\n   * @event Player#loadedmetadata\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechLoadedmetadata_\r\n   * @fires Player#loadedmetadata\r\n   * @listens Tech#loadedmetadata\r\n   */\r\n  'loadedmetadata',\r\n  /**\r\n   * Fires when the browser has loaded the current frame of the audio/video.\r\n   *\r\n   * @event Player#loadeddata\r\n   * @type {event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechLoaddeddata_\r\n   * @fires Player#loadeddata\r\n   * @listens Tech#loadeddata\r\n   */\r\n  'loadeddata',\r\n  /**\r\n   * Fires when the current playback position has changed.\r\n   *\r\n   * @event Player#timeupdate\r\n   * @type {event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechTimeUpdate_\r\n   * @fires Player#timeupdate\r\n   * @listens Tech#timeupdate\r\n   */\r\n  'timeupdate',\r\n  /**\r\n   * Fires when the video's intrinsic dimensions change\r\n   *\r\n   * @event Player#resize\r\n   * @type {event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `resize` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechResize_\r\n   * @fires Player#resize\r\n   * @listens Tech#resize\r\n   */\r\n  'resize',\r\n  /**\r\n   * Fires when the volume has been changed\r\n   *\r\n   * @event Player#volumechange\r\n   * @type {event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechVolumechange_\r\n   * @fires Player#volumechange\r\n   * @listens Tech#volumechange\r\n   */\r\n  'volumechange',\r\n  /**\r\n   * Fires when the text track has been changed\r\n   *\r\n   * @event Player#texttrackchange\r\n   * @type {event}\r\n   */\r\n\r\n  /**\r\n   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\r\n   *\r\n   * @private\r\n   * @method Player#handleTechTexttrackchange_\r\n   * @fires Player#texttrackchange\r\n   * @listens Tech#texttrackchange\r\n   */\r\n  'texttrackchange']; // events to queue when playback rate is zero\r\n  // this is a hash for the sole purpose of mapping non-camel-cased event names\r\n  // to camel-cased function names\r\n\r\n  var TECH_EVENTS_QUEUE = {\r\n    canplay: 'CanPlay',\r\n    canplaythrough: 'CanPlayThrough',\r\n    playing: 'Playing',\r\n    seeked: 'Seeked'\r\n  };\r\n  var BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];\r\n  var BREAKPOINT_CLASSES = {}; // grep: vjs-layout-tiny\r\n  // grep: vjs-layout-x-small\r\n  // grep: vjs-layout-small\r\n  // grep: vjs-layout-medium\r\n  // grep: vjs-layout-large\r\n  // grep: vjs-layout-x-large\r\n  // grep: vjs-layout-huge\r\n\r\n  BREAKPOINT_ORDER.forEach(function (k) {\r\n    var v = k.charAt(0) === 'x' ? \"x-\" + k.substring(1) : k;\r\n    BREAKPOINT_CLASSES[k] = \"vjs-layout-\" + v;\r\n  });\r\n  var DEFAULT_BREAKPOINTS = {\r\n    tiny: 210,\r\n    xsmall: 320,\r\n    small: 425,\r\n    medium: 768,\r\n    large: 1440,\r\n    xlarge: 2560,\r\n    huge: Infinity\r\n  };\r\n  /**\r\n   * An instance of the `Player` class is created when any of the Video.js setup methods\r\n   * are used to initialize a video.\r\n   *\r\n   * After an instance has been created it can be accessed globally in two ways:\r\n   * 1. By calling `videojs('example_video_1');`\r\n   * 2. By using it directly via  `videojs.players.example_video_1;`\r\n   *\r\n   * @extends Component\r\n   */\r\n\r\n  var Player = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(Player, _Component);\r\n\r\n    /**\r\n     * Create an instance of this class.\r\n     *\r\n     * @param {Element} tag\r\n     *        The original video DOM element used for configuring options.\r\n     *\r\n     * @param {Object} [options]\r\n     *        Object of option names and values.\r\n     *\r\n     * @param {Component~ReadyCallback} [ready]\r\n     *        Ready callback function.\r\n     */\r\n    function Player(tag, options, ready) {\r\n      var _this;\r\n\r\n      // Make sure tag ID exists\r\n      tag.id = tag.id || options.id || \"vjs_video_\" + newGUID(); // Set Options\r\n      // The options argument overrides options set in the video tag\r\n      // which overrides globally set options.\r\n      // This latter part coincides with the load order\r\n      // (tag must exist before Player)\r\n\r\n      options = assign(Player.getTagSettings(tag), options); // Delay the initialization of children because we need to set up\r\n      // player properties first, and can't use `this` before `super()`\r\n\r\n      options.initChildren = false; // Same with creating the element\r\n\r\n      options.createEl = false; // don't auto mixin the evented mixin\r\n\r\n      options.evented = false; // we don't want the player to report touch activity on itself\r\n      // see enableTouchActivity in Component\r\n\r\n      options.reportTouchActivity = false; // If language is not set, get the closest lang attribute\r\n\r\n      if (!options.language) {\r\n        if (typeof tag.closest === 'function') {\r\n          var closest = tag.closest('[lang]');\r\n\r\n          if (closest && closest.getAttribute) {\r\n            options.language = closest.getAttribute('lang');\r\n          }\r\n        } else {\r\n          var element = tag;\r\n\r\n          while (element && element.nodeType === 1) {\r\n            if (getAttributes(element).hasOwnProperty('lang')) {\r\n              options.language = element.getAttribute('lang');\r\n              break;\r\n            }\r\n\r\n            element = element.parentNode;\r\n          }\r\n        }\r\n      } // Run base component initializing with new options\r\n\r\n\r\n      _this = _Component.call(this, null, options, ready) || this; // Create bound methods for document listeners.\r\n\r\n      _this.boundDocumentFullscreenChange_ = function (e) {\r\n        return _this.documentFullscreenChange_(e);\r\n      };\r\n\r\n      _this.boundFullWindowOnEscKey_ = function (e) {\r\n        return _this.fullWindowOnEscKey(e);\r\n      };\r\n\r\n      _this.boundUpdateStyleEl_ = function (e) {\r\n        return _this.updateStyleEl_(e);\r\n      };\r\n\r\n      _this.boundApplyInitTime_ = function (e) {\r\n        return _this.applyInitTime_(e);\r\n      };\r\n\r\n      _this.boundUpdateCurrentBreakpoint_ = function (e) {\r\n        return _this.updateCurrentBreakpoint_(e);\r\n      };\r\n\r\n      _this.boundHandleTechClick_ = function (e) {\r\n        return _this.handleTechClick_(e);\r\n      };\r\n\r\n      _this.boundHandleTechDoubleClick_ = function (e) {\r\n        return _this.handleTechDoubleClick_(e);\r\n      };\r\n\r\n      _this.boundHandleTechTouchStart_ = function (e) {\r\n        return _this.handleTechTouchStart_(e);\r\n      };\r\n\r\n      _this.boundHandleTechTouchMove_ = function (e) {\r\n        return _this.handleTechTouchMove_(e);\r\n      };\r\n\r\n      _this.boundHandleTechTouchEnd_ = function (e) {\r\n        return _this.handleTechTouchEnd_(e);\r\n      };\r\n\r\n      _this.boundHandleTechTap_ = function (e) {\r\n        return _this.handleTechTap_(e);\r\n      }; // default isFullscreen_ to false\r\n\r\n\r\n      _this.isFullscreen_ = false; // create logger\r\n\r\n      _this.log = createLogger(_this.id_); // Hold our own reference to fullscreen api so it can be mocked in tests\r\n\r\n      _this.fsApi_ = FullscreenApi; // Tracks when a tech changes the poster\r\n\r\n      _this.isPosterFromTech_ = false; // Holds callback info that gets queued when playback rate is zero\r\n      // and a seek is happening\r\n\r\n      _this.queuedCallbacks_ = []; // Turn off API access because we're loading a new tech that might load asynchronously\r\n\r\n      _this.isReady_ = false; // Init state hasStarted_\r\n\r\n      _this.hasStarted_ = false; // Init state userActive_\r\n\r\n      _this.userActive_ = false; // Init debugEnabled_\r\n\r\n      _this.debugEnabled_ = false; // Init state audioOnlyMode_\r\n\r\n      _this.audioOnlyMode_ = false; // Init state audioPosterMode_\r\n\r\n      _this.audioPosterMode_ = false; // Init state audioOnlyCache_\r\n\r\n      _this.audioOnlyCache_ = {\r\n        playerHeight: null,\r\n        hiddenChildren: []\r\n      }; // if the global option object was accidentally blown away by\r\n      // someone, bail early with an informative error\r\n\r\n      if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {\r\n        throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\r\n      } // Store the original tag used to set options\r\n\r\n\r\n      _this.tag = tag; // Store the tag attributes used to restore html5 element\r\n\r\n      _this.tagAttributes = tag && getAttributes(tag); // Update current language\r\n\r\n      _this.language(_this.options_.language); // Update Supported Languages\r\n\r\n\r\n      if (options.languages) {\r\n        // Normalise player option languages to lowercase\r\n        var languagesToLower = {};\r\n        Object.getOwnPropertyNames(options.languages).forEach(function (name) {\r\n          languagesToLower[name.toLowerCase()] = options.languages[name];\r\n        });\r\n        _this.languages_ = languagesToLower;\r\n      } else {\r\n        _this.languages_ = Player.prototype.options_.languages;\r\n      }\r\n\r\n      _this.resetCache_(); // Set poster\r\n\r\n\r\n      _this.poster_ = options.poster || ''; // Set controls\r\n\r\n      _this.controls_ = !!options.controls; // Original tag settings stored in options\r\n      // now remove immediately so native controls don't flash.\r\n      // May be turned back on by HTML5 tech if nativeControlsForTouch is true\r\n\r\n      tag.controls = false;\r\n      tag.removeAttribute('controls');\r\n      _this.changingSrc_ = false;\r\n      _this.playCallbacks_ = [];\r\n      _this.playTerminatedQueue_ = []; // the attribute overrides the option\r\n\r\n      if (tag.hasAttribute('autoplay')) {\r\n        _this.autoplay(true);\r\n      } else {\r\n        // otherwise use the setter to validate and\r\n        // set the correct value.\r\n        _this.autoplay(_this.options_.autoplay);\r\n      } // check plugins\r\n\r\n\r\n      if (options.plugins) {\r\n        Object.keys(options.plugins).forEach(function (name) {\r\n          if (typeof _this[name] !== 'function') {\r\n            throw new Error(\"plugin \\\"\" + name + \"\\\" does not exist\");\r\n          }\r\n        });\r\n      }\r\n      /*\r\n       * Store the internal state of scrubbing\r\n       *\r\n       * @private\r\n       * @return {Boolean} True if the user is scrubbing\r\n       */\r\n\r\n\r\n      _this.scrubbing_ = false;\r\n      _this.el_ = _this.createEl(); // Make this an evented object and use `el_` as its event bus.\r\n\r\n      evented(assertThisInitialized(_this), {\r\n        eventBusKey: 'el_'\r\n      }); // listen to document and player fullscreenchange handlers so we receive those events\r\n      // before a user can receive them so we can update isFullscreen appropriately.\r\n      // make sure that we listen to fullscreenchange events before everything else to make sure that\r\n      // our isFullscreen method is updated properly for internal components as well as external.\r\n\r\n      if (_this.fsApi_.requestFullscreen) {\r\n        on(document, _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);\r\n\r\n        _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);\r\n      }\r\n\r\n      if (_this.fluid_) {\r\n        _this.on(['playerreset', 'resize'], _this.boundUpdateStyleEl_);\r\n      } // We also want to pass the original player options to each component and plugin\r\n      // as well so they don't need to reach back into the player for options later.\r\n      // We also need to do another copy of this.options_ so we don't end up with\r\n      // an infinite loop.\r\n\r\n\r\n      var playerOptionsCopy = mergeOptions$3(_this.options_); // Load plugins\r\n\r\n      if (options.plugins) {\r\n        Object.keys(options.plugins).forEach(function (name) {\r\n          _this[name](options.plugins[name]);\r\n        });\r\n      } // Enable debug mode to fire debugon event for all plugins.\r\n\r\n\r\n      if (options.debug) {\r\n        _this.debug(true);\r\n      }\r\n\r\n      _this.options_.playerOptions = playerOptionsCopy;\r\n      _this.middleware_ = [];\r\n\r\n      _this.playbackRates(options.playbackRates);\r\n\r\n      _this.initChildren(); // Set isAudio based on whether or not an audio tag was used\r\n\r\n\r\n      _this.isAudio(tag.nodeName.toLowerCase() === 'audio'); // Update controls className. Can't do this when the controls are initially\r\n      // set because the element doesn't exist yet.\r\n\r\n\r\n      if (_this.controls()) {\r\n        _this.addClass('vjs-controls-enabled');\r\n      } else {\r\n        _this.addClass('vjs-controls-disabled');\r\n      } // Set ARIA label and region role depending on player type\r\n\r\n\r\n      _this.el_.setAttribute('role', 'region');\r\n\r\n      if (_this.isAudio()) {\r\n        _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));\r\n      } else {\r\n        _this.el_.setAttribute('aria-label', _this.localize('Video Player'));\r\n      }\r\n\r\n      if (_this.isAudio()) {\r\n        _this.addClass('vjs-audio');\r\n      }\r\n\r\n      if (_this.flexNotSupported_()) {\r\n        _this.addClass('vjs-no-flex');\r\n      } // TODO: Make this smarter. Toggle user state between touching/mousing\r\n      // using events, since devices can have both touch and mouse events.\r\n      // TODO: Make this check be performed again when the window switches between monitors\r\n      // (See https://github.com/videojs/video.js/issues/5683)\r\n\r\n\r\n      if (TOUCH_ENABLED) {\r\n        _this.addClass('vjs-touch-enabled');\r\n      } // iOS Safari has broken hover handling\r\n\r\n\r\n      if (!IS_IOS) {\r\n        _this.addClass('vjs-workinghover');\r\n      } // Make player easily findable by ID\r\n\r\n\r\n      Player.players[_this.id_] = assertThisInitialized(_this); // Add a major version class to aid css in plugins\r\n\r\n      var majorVersion = version$5.split('.')[0];\r\n\r\n      _this.addClass(\"vjs-v\" + majorVersion); // When the player is first initialized, trigger activity so components\r\n      // like the control bar show themselves if needed\r\n\r\n\r\n      _this.userActive(true);\r\n\r\n      _this.reportUserActivity();\r\n\r\n      _this.one('play', function (e) {\r\n        return _this.listenForUserActivity_(e);\r\n      });\r\n\r\n      _this.on('stageclick', function (e) {\r\n        return _this.handleStageClick_(e);\r\n      });\r\n\r\n      _this.on('keydown', function (e) {\r\n        return _this.handleKeyDown(e);\r\n      });\r\n\r\n      _this.on('languagechange', function (e) {\r\n        return _this.handleLanguagechange(e);\r\n      });\r\n\r\n      _this.breakpoints(_this.options_.breakpoints);\r\n\r\n      _this.responsive(_this.options_.responsive); // Calling both the audio mode methods after the player is fully\r\n      // setup to be able to listen to the events triggered by them\r\n\r\n\r\n      _this.on('ready', function () {\r\n        // Calling the audioPosterMode method first so that\r\n        // the audioOnlyMode can take precedence when both options are set to true\r\n        _this.audioPosterMode(_this.options_.audioPosterMode);\r\n\r\n        _this.audioOnlyMode(_this.options_.audioOnlyMode);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n    /**\r\n     * Destroys the video player and does any necessary cleanup.\r\n     *\r\n     * This is especially helpful if you are dynamically adding and removing videos\r\n     * to/from the DOM.\r\n     *\r\n     * @fires Player#dispose\r\n     */\r\n\r\n\r\n    var _proto = Player.prototype;\r\n\r\n    _proto.dispose = function dispose() {\r\n      var _this2 = this;\r\n\r\n      /**\r\n       * Called when the player is being disposed of.\r\n       *\r\n       * @event Player#dispose\r\n       * @type {EventTarget~Event}\r\n       */\r\n      this.trigger('dispose'); // prevent dispose from being called twice\r\n\r\n      this.off('dispose'); // Make sure all player-specific document listeners are unbound. This is\r\n\r\n      off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\r\n      off(document, 'keydown', this.boundFullWindowOnEscKey_);\r\n\r\n      if (this.styleEl_ && this.styleEl_.parentNode) {\r\n        this.styleEl_.parentNode.removeChild(this.styleEl_);\r\n        this.styleEl_ = null;\r\n      } // Kill reference to this player\r\n\r\n\r\n      Player.players[this.id_] = null;\r\n\r\n      if (this.tag && this.tag.player) {\r\n        this.tag.player = null;\r\n      }\r\n\r\n      if (this.el_ && this.el_.player) {\r\n        this.el_.player = null;\r\n      }\r\n\r\n      if (this.tech_) {\r\n        this.tech_.dispose();\r\n        this.isPosterFromTech_ = false;\r\n        this.poster_ = '';\r\n      }\r\n\r\n      if (this.playerElIngest_) {\r\n        this.playerElIngest_ = null;\r\n      }\r\n\r\n      if (this.tag) {\r\n        this.tag = null;\r\n      }\r\n\r\n      clearCacheForPlayer(this); // remove all event handlers for track lists\r\n      // all tracks and track listeners are removed on\r\n      // tech dispose\r\n\r\n      ALL.names.forEach(function (name) {\r\n        var props = ALL[name];\r\n\r\n        var list = _this2[props.getterName](); // if it is not a native list\r\n        // we have to manually remove event listeners\r\n\r\n\r\n        if (list && list.off) {\r\n          list.off();\r\n        }\r\n      }); // the actual .el_ is removed here, or replaced if\r\n\r\n      _Component.prototype.dispose.call(this, {\r\n        restoreEl: this.options_.restoreEl\r\n      });\r\n    }\r\n    /**\r\n     * Create the `Player`'s DOM element.\r\n     *\r\n     * @return {Element}\r\n     *         The DOM element that gets created.\r\n     */\r\n    ;\r\n\r\n    _proto.createEl = function createEl() {\r\n      var tag = this.tag;\r\n      var el;\r\n      var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\r\n      var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\r\n\r\n      if (playerElIngest) {\r\n        el = this.el_ = tag.parentNode;\r\n      } else if (!divEmbed) {\r\n        el = this.el_ = _Component.prototype.createEl.call(this, 'div');\r\n      } // Copy over all the attributes from the tag, including ID and class\r\n      // ID will now reference player box, not the video tag\r\n\r\n\r\n      var attrs = getAttributes(tag);\r\n\r\n      if (divEmbed) {\r\n        el = this.el_ = tag;\r\n        tag = this.tag = document.createElement('video');\r\n\r\n        while (el.children.length) {\r\n          tag.appendChild(el.firstChild);\r\n        }\r\n\r\n        if (!hasClass(el, 'video-js')) {\r\n          addClass(el, 'video-js');\r\n        }\r\n\r\n        el.appendChild(tag);\r\n        playerElIngest = this.playerElIngest_ = el; // move properties over from our custom `video-js` element\r\n        // to our new `video` element. This will move things like\r\n        // `src` or `controls` that were set via js before the player\r\n        // was initialized.\r\n\r\n        Object.keys(el).forEach(function (k) {\r\n          try {\r\n            tag[k] = el[k];\r\n          } catch (e) {// we got a a property like outerHTML which we can't actually copy, ignore it\r\n          }\r\n        });\r\n      } // set tabindex to -1 to remove the video element from the focus order\r\n\r\n\r\n      tag.setAttribute('tabindex', '-1');\r\n      attrs.tabindex = '-1'; // Workaround for #4583 (JAWS+IE doesn't announce BPB or play button), and\r\n      // for the same issue with Chrome (on Windows) with JAWS.\r\n      // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\r\n      // Note that we can't detect if JAWS is being used, but this ARIA attribute\r\n      //  doesn't change behavior of IE11 or Chrome if JAWS is not being used\r\n\r\n      if (IE_VERSION || IS_CHROME && IS_WINDOWS) {\r\n        tag.setAttribute('role', 'application');\r\n        attrs.role = 'application';\r\n      } // Remove width/height attrs from tag so CSS can make it 100% width/height\r\n\r\n\r\n      tag.removeAttribute('width');\r\n      tag.removeAttribute('height');\r\n\r\n      if ('width' in attrs) {\r\n        delete attrs.width;\r\n      }\r\n\r\n      if ('height' in attrs) {\r\n        delete attrs.height;\r\n      }\r\n\r\n      Object.getOwnPropertyNames(attrs).forEach(function (attr) {\r\n        // don't copy over the class attribute to the player element when we're in a div embed\r\n        // the class is already set up properly in the divEmbed case\r\n        // and we want to make sure that the `video-js` class doesn't get lost\r\n        if (!(divEmbed && attr === 'class')) {\r\n          el.setAttribute(attr, attrs[attr]);\r\n        }\r\n\r\n        if (divEmbed) {\r\n          tag.setAttribute(attr, attrs[attr]);\r\n        }\r\n      }); // Update tag id/class for use as HTML5 playback tech\r\n      // Might think we should do this after embedding in container so .vjs-tech class\r\n      // doesn't flash 100% width/height, but class only applies with .video-js parent\r\n\r\n      tag.playerId = tag.id;\r\n      tag.id += '_html5_api';\r\n      tag.className = 'vjs-tech'; // Make player findable on elements\r\n\r\n      tag.player = el.player = this; // Default state of video is paused\r\n\r\n      this.addClass('vjs-paused'); // Add a style element in the player that we'll use to set the width/height\r\n      // of the player in a way that's still overrideable by CSS, just like the\r\n      // video element\r\n\r\n      if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\r\n        this.styleEl_ = createStyleElement('vjs-styles-dimensions');\r\n        var defaultsStyleEl = $('.vjs-styles-defaults');\r\n        var head = $('head');\r\n        head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\r\n      }\r\n\r\n      this.fill_ = false;\r\n      this.fluid_ = false; // Pass in the width/height/aspectRatio options which will update the style el\r\n\r\n      this.width(this.options_.width);\r\n      this.height(this.options_.height);\r\n      this.fill(this.options_.fill);\r\n      this.fluid(this.options_.fluid);\r\n      this.aspectRatio(this.options_.aspectRatio); // support both crossOrigin and crossorigin to reduce confusion and issues around the name\r\n\r\n      this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin); // Hide any links within the video/audio tag,\r\n      // because IE doesn't hide them completely from screen readers.\r\n\r\n      var links = tag.getElementsByTagName('a');\r\n\r\n      for (var i = 0; i < links.length; i++) {\r\n        var linkEl = links.item(i);\r\n        addClass(linkEl, 'vjs-hidden');\r\n        linkEl.setAttribute('hidden', 'hidden');\r\n      } // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\r\n      // keep track of the original for later so we can know if the source originally failed\r\n\r\n\r\n      tag.initNetworkState_ = tag.networkState; // Wrap video tag in div (el/box) container\r\n\r\n      if (tag.parentNode && !playerElIngest) {\r\n        tag.parentNode.insertBefore(el, tag);\r\n      } // insert the tag as the first child of the player element\r\n      // then manually add it to the children array so that this.addChild\r\n      // will work properly for other components\r\n      //\r\n      // Breaks iPhone, fixed in HTML5 setup.\r\n\r\n\r\n      prependTo(tag, el);\r\n      this.children_.unshift(tag); // Set lang attr on player to ensure CSS :lang() in consistent with player\r\n      // if it's been set to something different to the doc\r\n\r\n      this.el_.setAttribute('lang', this.language_);\r\n      this.el_.setAttribute('translate', 'no');\r\n      this.el_ = el;\r\n      return el;\r\n    }\r\n    /**\r\n     * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this\r\n     * sets the `crossOrigin` property on the `<video>` tag to control the CORS\r\n     * behavior.\r\n     *\r\n     * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\r\n     *\r\n     * @param {string} [value]\r\n     *        The value to set the `Player`'s crossOrigin to. If an argument is\r\n     *        given, must be one of `anonymous` or `use-credentials`.\r\n     *\r\n     * @return {string|undefined}\r\n     *         - The current crossOrigin value of the `Player` when getting.\r\n     *         - undefined when setting\r\n     */\r\n    ;\r\n\r\n    _proto.crossOrigin = function crossOrigin(value) {\r\n      if (!value) {\r\n        return this.techGet_('crossOrigin');\r\n      }\r\n\r\n      if (value !== 'anonymous' && value !== 'use-credentials') {\r\n        log$1.warn(\"crossOrigin must be \\\"anonymous\\\" or \\\"use-credentials\\\", given \\\"\" + value + \"\\\"\");\r\n        return;\r\n      }\r\n\r\n      this.techCall_('setCrossOrigin', value);\r\n      return;\r\n    }\r\n    /**\r\n     * A getter/setter for the `Player`'s width. Returns the player's configured value.\r\n     * To get the current width use `currentWidth()`.\r\n     *\r\n     * @param {number} [value]\r\n     *        The value to set the `Player`'s width to.\r\n     *\r\n     * @return {number}\r\n     *         The current width of the `Player` when getting.\r\n     */\r\n    ;\r\n\r\n    _proto.width = function width(value) {\r\n      return this.dimension('width', value);\r\n    }\r\n    /**\r\n     * A getter/setter for the `Player`'s height. Returns the player's configured value.\r\n     * To get the current height use `currentheight()`.\r\n     *\r\n     * @param {number} [value]\r\n     *        The value to set the `Player`'s heigth to.\r\n     *\r\n     * @return {number}\r\n     *         The current height of the `Player` when getting.\r\n     */\r\n    ;\r\n\r\n    _proto.height = function height(value) {\r\n      return this.dimension('height', value);\r\n    }\r\n    /**\r\n     * A getter/setter for the `Player`'s width & height.\r\n     *\r\n     * @param {string} dimension\r\n     *        This string can be:\r\n     *        - 'width'\r\n     *        - 'height'\r\n     *\r\n     * @param {number} [value]\r\n     *        Value for dimension specified in the first argument.\r\n     *\r\n     * @return {number}\r\n     *         The dimension arguments value when getting (width/height).\r\n     */\r\n    ;\r\n\r\n    _proto.dimension = function dimension(_dimension, value) {\r\n      var privDimension = _dimension + '_';\r\n\r\n      if (value === undefined) {\r\n        return this[privDimension] || 0;\r\n      }\r\n\r\n      if (value === '' || value === 'auto') {\r\n        // If an empty string is given, reset the dimension to be automatic\r\n        this[privDimension] = undefined;\r\n        this.updateStyleEl_();\r\n        return;\r\n      }\r\n\r\n      var parsedVal = parseFloat(value);\r\n\r\n      if (isNaN(parsedVal)) {\r\n        log$1.error(\"Improper value \\\"\" + value + \"\\\" supplied for for \" + _dimension);\r\n        return;\r\n      }\r\n\r\n      this[privDimension] = parsedVal;\r\n      this.updateStyleEl_();\r\n    }\r\n    /**\r\n     * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\r\n     *\r\n     * Turning this on will turn off fill mode.\r\n     *\r\n     * @param {boolean} [bool]\r\n     *        - A value of true adds the class.\r\n     *        - A value of false removes the class.\r\n     *        - No value will be a getter.\r\n     *\r\n     * @return {boolean|undefined}\r\n     *         - The value of fluid when getting.\r\n     *         - `undefined` when setting.\r\n     */\r\n    ;\r\n\r\n    _proto.fluid = function fluid(bool) {\r\n      var _this3 = this;\r\n\r\n      if (bool === undefined) {\r\n        return !!this.fluid_;\r\n      }\r\n\r\n      this.fluid_ = !!bool;\r\n\r\n      if (isEvented(this)) {\r\n        this.off(['playerreset', 'resize'], this.boundUpdateStyleEl_);\r\n      }\r\n\r\n      if (bool) {\r\n        this.addClass('vjs-fluid');\r\n        this.fill(false);\r\n        addEventedCallback(this, function () {\r\n          _this3.on(['playerreset', 'resize'], _this3.boundUpdateStyleEl_);\r\n        });\r\n      } else {\r\n        this.removeClass('vjs-fluid');\r\n      }\r\n\r\n      this.updateStyleEl_();\r\n    }\r\n    /**\r\n     * A getter/setter/toggler for the vjs-fill `className` on the `Player`.\r\n     *\r\n     * Turning this on will turn off fluid mode.\r\n     *\r\n     * @param {boolean} [bool]\r\n     *        - A value of true adds the class.\r\n     *        - A value of false removes the class.\r\n     *        - No value will be a getter.\r\n     *\r\n     * @return {boolean|undefined}\r\n     *         - The value of fluid when getting.\r\n     *         - `undefined` when setting.\r\n     */\r\n    ;\r\n\r\n    _proto.fill = function fill(bool) {\r\n      if (bool === undefined) {\r\n        return !!this.fill_;\r\n      }\r\n\r\n      this.fill_ = !!bool;\r\n\r\n      if (bool) {\r\n        this.addClass('vjs-fill');\r\n        this.fluid(false);\r\n      } else {\r\n        this.removeClass('vjs-fill');\r\n      }\r\n    }\r\n    /**\r\n     * Get/Set the aspect ratio\r\n     *\r\n     * @param {string} [ratio]\r\n     *        Aspect ratio for player\r\n     *\r\n     * @return {string|undefined}\r\n     *         returns the current aspect ratio when getting\r\n     */\r\n\r\n    /**\r\n     * A getter/setter for the `Player`'s aspect ratio.\r\n     *\r\n     * @param {string} [ratio]\r\n     *        The value to set the `Player`'s aspect ratio to.\r\n     *\r\n     * @return {string|undefined}\r\n     *         - The current aspect ratio of the `Player` when getting.\r\n     *         - undefined when setting\r\n     */\r\n    ;\r\n\r\n    _proto.aspectRatio = function aspectRatio(ratio) {\r\n      if (ratio === undefined) {\r\n        return this.aspectRatio_;\r\n      } // Check for width:height format\r\n\r\n\r\n      if (!/^\\d+\\:\\d+$/.test(ratio)) {\r\n        throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\r\n      }\r\n\r\n      this.aspectRatio_ = ratio; // We're assuming if you set an aspect ratio you want fluid mode,\r\n      // because in fixed mode you could calculate width and height yourself.\r\n\r\n      this.fluid(true);\r\n      this.updateStyleEl_();\r\n    }\r\n    /**\r\n     * Update styles of the `Player` element (height, width and aspect ratio).\r\n     *\r\n     * @private\r\n     * @listens Tech#loadedmetadata\r\n     */\r\n    ;\r\n\r\n    _proto.updateStyleEl_ = function updateStyleEl_() {\r\n      if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {\r\n        var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\r\n\r\n        var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\r\n\r\n        var techEl = this.tech_ && this.tech_.el();\r\n\r\n        if (techEl) {\r\n          if (_width >= 0) {\r\n            techEl.width = _width;\r\n          }\r\n\r\n          if (_height >= 0) {\r\n            techEl.height = _height;\r\n          }\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      var width;\r\n      var height;\r\n      var aspectRatio;\r\n      var idClass; // The aspect ratio is either used directly or to calculate width and height.\r\n\r\n      if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\r\n        // Use any aspectRatio that's been specifically set\r\n        aspectRatio = this.aspectRatio_;\r\n      } else if (this.videoWidth() > 0) {\r\n        // Otherwise try to get the aspect ratio from the video metadata\r\n        aspectRatio = this.videoWidth() + ':' + this.videoHeight();\r\n      } else {\r\n        // Or use a default. The video element's is 2:1, but 16:9 is more common.\r\n        aspectRatio = '16:9';\r\n      } // Get the ratio as a decimal we can use to calculate dimensions\r\n\r\n\r\n      var ratioParts = aspectRatio.split(':');\r\n      var ratioMultiplier = ratioParts[1] / ratioParts[0];\r\n\r\n      if (this.width_ !== undefined) {\r\n        // Use any width that's been specifically set\r\n        width = this.width_;\r\n      } else if (this.height_ !== undefined) {\r\n        // Or calulate the width from the aspect ratio if a height has been set\r\n        width = this.height_ / ratioMultiplier;\r\n      } else {\r\n        // Or use the video's metadata, or use the video el's default of 300\r\n        width = this.videoWidth() || 300;\r\n      }\r\n\r\n      if (this.height_ !== undefined) {\r\n        // Use any height that's been specifically set\r\n        height = this.height_;\r\n      } else {\r\n        // Otherwise calculate the height from the ratio and the width\r\n        height = width * ratioMultiplier;\r\n      } // Ensure the CSS class is valid by starting with an alpha character\r\n\r\n\r\n      if (/^[^a-zA-Z]/.test(this.id())) {\r\n        idClass = 'dimensions-' + this.id();\r\n      } else {\r\n        idClass = this.id() + '-dimensions';\r\n      } // Ensure the right class is still on the player for the style element\r\n\r\n\r\n      this.addClass(idClass);\r\n      setTextContent(this.styleEl_, \"\\n      .\" + idClass + \" {\\n        width: \" + width + \"px;\\n        height: \" + height + \"px;\\n      }\\n\\n      .\" + idClass + \".vjs-fluid:not(.vjs-audio-only-mode) {\\n        padding-top: \" + ratioMultiplier * 100 + \"%;\\n      }\\n    \");\r\n    }\r\n    /**\r\n     * Load/Create an instance of playback {@link Tech} including element\r\n     * and API methods. Then append the `Tech` element in `Player` as a child.\r\n     *\r\n     * @param {string} techName\r\n     *        name of the playback technology\r\n     *\r\n     * @param {string} source\r\n     *        video source\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.loadTech_ = function loadTech_(techName, source) {\r\n      var _this4 = this;\r\n\r\n      // Pause and remove current playback technology\r\n      if (this.tech_) {\r\n        this.unloadTech_();\r\n      }\r\n\r\n      var titleTechName = toTitleCase$1(techName);\r\n      var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1); // get rid of the HTML5 video tag as soon as we are using another tech\r\n\r\n      if (titleTechName !== 'Html5' && this.tag) {\r\n        Tech.getTech('Html5').disposeMediaElement(this.tag);\r\n        this.tag.player = null;\r\n        this.tag = null;\r\n      }\r\n\r\n      this.techName_ = titleTechName; // Turn off API access because we're loading a new tech that might load asynchronously\r\n\r\n      this.isReady_ = false;\r\n      var autoplay = this.autoplay(); // if autoplay is a string (or `true` with normalizeAutoplay: true) we pass false to the tech\r\n      // because the player is going to handle autoplay on `loadstart`\r\n\r\n      if (typeof this.autoplay() === 'string' || this.autoplay() === true && this.options_.normalizeAutoplay) {\r\n        autoplay = false;\r\n      } // Grab tech-specific options from player options and add source and parent element to use.\r\n\r\n\r\n      var techOptions = {\r\n        source: source,\r\n        autoplay: autoplay,\r\n        'nativeControlsForTouch': this.options_.nativeControlsForTouch,\r\n        'playerId': this.id(),\r\n        'techId': this.id() + \"_\" + camelTechName + \"_api\",\r\n        'playsinline': this.options_.playsinline,\r\n        'preload': this.options_.preload,\r\n        'loop': this.options_.loop,\r\n        'disablePictureInPicture': this.options_.disablePictureInPicture,\r\n        'muted': this.options_.muted,\r\n        'poster': this.poster(),\r\n        'language': this.language(),\r\n        'playerElIngest': this.playerElIngest_ || false,\r\n        'vtt.js': this.options_['vtt.js'],\r\n        'canOverridePoster': !!this.options_.techCanOverridePoster,\r\n        'enableSourceset': this.options_.enableSourceset,\r\n        'Promise': this.options_.Promise\r\n      };\r\n      ALL.names.forEach(function (name) {\r\n        var props = ALL[name];\r\n        techOptions[props.getterName] = _this4[props.privateName];\r\n      });\r\n      assign(techOptions, this.options_[titleTechName]);\r\n      assign(techOptions, this.options_[camelTechName]);\r\n      assign(techOptions, this.options_[techName.toLowerCase()]);\r\n\r\n      if (this.tag) {\r\n        techOptions.tag = this.tag;\r\n      }\r\n\r\n      if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\r\n        techOptions.startTime = this.cache_.currentTime;\r\n      } // Initialize tech instance\r\n\r\n\r\n      var TechClass = Tech.getTech(techName);\r\n\r\n      if (!TechClass) {\r\n        throw new Error(\"No Tech named '\" + titleTechName + \"' exists! '\" + titleTechName + \"' should be registered using videojs.registerTech()'\");\r\n      }\r\n\r\n      this.tech_ = new TechClass(techOptions); // player.triggerReady is always async, so don't need this to be async\r\n\r\n      this.tech_.ready(bind(this, this.handleTechReady_), true);\r\n      textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_); // Listen to all HTML5-defined events and trigger them on the player\r\n\r\n      TECH_EVENTS_RETRIGGER.forEach(function (event) {\r\n        _this4.on(_this4.tech_, event, function (e) {\r\n          return _this4[\"handleTech\" + toTitleCase$1(event) + \"_\"](e);\r\n        });\r\n      });\r\n      Object.keys(TECH_EVENTS_QUEUE).forEach(function (event) {\r\n        _this4.on(_this4.tech_, event, function (eventObj) {\r\n          if (_this4.tech_.playbackRate() === 0 && _this4.tech_.seeking()) {\r\n            _this4.queuedCallbacks_.push({\r\n              callback: _this4[\"handleTech\" + TECH_EVENTS_QUEUE[event] + \"_\"].bind(_this4),\r\n              event: eventObj\r\n            });\r\n\r\n            return;\r\n          }\r\n\r\n          _this4[\"handleTech\" + TECH_EVENTS_QUEUE[event] + \"_\"](eventObj);\r\n        });\r\n      });\r\n      this.on(this.tech_, 'loadstart', function (e) {\r\n        return _this4.handleTechLoadStart_(e);\r\n      });\r\n      this.on(this.tech_, 'sourceset', function (e) {\r\n        return _this4.handleTechSourceset_(e);\r\n      });\r\n      this.on(this.tech_, 'waiting', function (e) {\r\n        return _this4.handleTechWaiting_(e);\r\n      });\r\n      this.on(this.tech_, 'ended', function (e) {\r\n        return _this4.handleTechEnded_(e);\r\n      });\r\n      this.on(this.tech_, 'seeking', function (e) {\r\n        return _this4.handleTechSeeking_(e);\r\n      });\r\n      this.on(this.tech_, 'play', function (e) {\r\n        return _this4.handleTechPlay_(e);\r\n      });\r\n      this.on(this.tech_, 'firstplay', function (e) {\r\n        return _this4.handleTechFirstPlay_(e);\r\n      });\r\n      this.on(this.tech_, 'pause', function (e) {\r\n        return _this4.handleTechPause_(e);\r\n      });\r\n      this.on(this.tech_, 'durationchange', function (e) {\r\n        return _this4.handleTechDurationChange_(e);\r\n      });\r\n      this.on(this.tech_, 'fullscreenchange', function (e, data) {\r\n        return _this4.handleTechFullscreenChange_(e, data);\r\n      });\r\n      this.on(this.tech_, 'fullscreenerror', function (e, err) {\r\n        return _this4.handleTechFullscreenError_(e, err);\r\n      });\r\n      this.on(this.tech_, 'enterpictureinpicture', function (e) {\r\n        return _this4.handleTechEnterPictureInPicture_(e);\r\n      });\r\n      this.on(this.tech_, 'leavepictureinpicture', function (e) {\r\n        return _this4.handleTechLeavePictureInPicture_(e);\r\n      });\r\n      this.on(this.tech_, 'error', function (e) {\r\n        return _this4.handleTechError_(e);\r\n      });\r\n      this.on(this.tech_, 'posterchange', function (e) {\r\n        return _this4.handleTechPosterChange_(e);\r\n      });\r\n      this.on(this.tech_, 'textdata', function (e) {\r\n        return _this4.handleTechTextData_(e);\r\n      });\r\n      this.on(this.tech_, 'ratechange', function (e) {\r\n        return _this4.handleTechRateChange_(e);\r\n      });\r\n      this.on(this.tech_, 'loadedmetadata', this.boundUpdateStyleEl_);\r\n      this.usingNativeControls(this.techGet_('controls'));\r\n\r\n      if (this.controls() && !this.usingNativeControls()) {\r\n        this.addTechControlsListeners_();\r\n      } // Add the tech element in the DOM if it was not already there\r\n      // Make sure to not insert the original video element if using Html5\r\n\r\n\r\n      if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\r\n        prependTo(this.tech_.el(), this.el());\r\n      } // Get rid of the original video tag reference after the first tech is loaded\r\n\r\n\r\n      if (this.tag) {\r\n        this.tag.player = null;\r\n        this.tag = null;\r\n      }\r\n    }\r\n    /**\r\n     * Unload and dispose of the current playback {@link Tech}.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.unloadTech_ = function unloadTech_() {\r\n      var _this5 = this;\r\n\r\n      // Save the current text tracks so that we can reuse the same text tracks with the next tech\r\n      ALL.names.forEach(function (name) {\r\n        var props = ALL[name];\r\n        _this5[props.privateName] = _this5[props.getterName]();\r\n      });\r\n      this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\r\n      this.isReady_ = false;\r\n      this.tech_.dispose();\r\n      this.tech_ = false;\r\n\r\n      if (this.isPosterFromTech_) {\r\n        this.poster_ = '';\r\n        this.trigger('posterchange');\r\n      }\r\n\r\n      this.isPosterFromTech_ = false;\r\n    }\r\n    /**\r\n     * Return a reference to the current {@link Tech}.\r\n     * It will print a warning by default about the danger of using the tech directly\r\n     * but any argument that is passed in will silence the warning.\r\n     *\r\n     * @param {*} [safety]\r\n     *        Anything passed in to silence the warning\r\n     *\r\n     * @return {Tech}\r\n     *         The Tech\r\n     */\r\n    ;\r\n\r\n    _proto.tech = function tech(safety) {\r\n      if (safety === undefined) {\r\n        log$1.warn('Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\\n');\r\n      }\r\n\r\n      return this.tech_;\r\n    }\r\n    /**\r\n     * Set up click and touch listeners for the playback element\r\n     *\r\n     * - On desktops: a click on the video itself will toggle playback\r\n     * - On mobile devices: a click on the video toggles controls\r\n     *   which is done by toggling the user state between active and\r\n     *   inactive\r\n     * - A tap can signal that a user has become active or has become inactive\r\n     *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\r\n     *   quick tap should hide them again (signaling the user is in an inactive\r\n     *   viewing state)\r\n     * - In addition to this, we still want the user to be considered inactive after\r\n     *   a few seconds of inactivity.\r\n     *\r\n     * > Note: the only part of iOS interaction we can't mimic with this setup\r\n     * is a touch and hold on the video element counting as activity in order to\r\n     * keep the controls showing, but that shouldn't be an issue. A touch and hold\r\n     * on any controls will still keep the user active\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.addTechControlsListeners_ = function addTechControlsListeners_() {\r\n      // Make sure to remove all the previous listeners in case we are called multiple times.\r\n      this.removeTechControlsListeners_();\r\n      this.on(this.tech_, 'click', this.boundHandleTechClick_);\r\n      this.on(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_); // If the controls were hidden we don't want that to change without a tap event\r\n      // so we'll check if the controls were already showing before reporting user\r\n      // activity\r\n\r\n      this.on(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\r\n      this.on(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\r\n      this.on(this.tech_, 'touchend', this.boundHandleTechTouchEnd_); // The tap listener needs to come after the touchend listener because the tap\r\n      // listener cancels out any reportedUserActivity when setting userActive(false)\r\n\r\n      this.on(this.tech_, 'tap', this.boundHandleTechTap_);\r\n    }\r\n    /**\r\n     * Remove the listeners used for click and tap controls. This is needed for\r\n     * toggling to controls disabled, where a tap/touch should do nothing.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {\r\n      // We don't want to just use `this.off()` because there might be other needed\r\n      // listeners added by techs that extend this.\r\n      this.off(this.tech_, 'tap', this.boundHandleTechTap_);\r\n      this.off(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\r\n      this.off(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\r\n      this.off(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\r\n      this.off(this.tech_, 'click', this.boundHandleTechClick_);\r\n      this.off(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\r\n    }\r\n    /**\r\n     * Player waits for the tech to be ready\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechReady_ = function handleTechReady_() {\r\n      this.triggerReady(); // Keep the same volume as before\r\n\r\n      if (this.cache_.volume) {\r\n        this.techCall_('setVolume', this.cache_.volume);\r\n      } // Look if the tech found a higher resolution poster while loading\r\n\r\n\r\n      this.handleTechPosterChange_(); // Update the duration if available\r\n\r\n      this.handleTechDurationChange_();\r\n    }\r\n    /**\r\n     * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\r\n     * function will also trigger {@link Player#firstplay} if it is the first loadstart\r\n     * for a video.\r\n     *\r\n     * @fires Player#loadstart\r\n     * @fires Player#firstplay\r\n     * @listens Tech#loadstart\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechLoadStart_ = function handleTechLoadStart_() {\r\n      // TODO: Update to use `emptied` event instead. See #1277.\r\n      this.removeClass('vjs-ended');\r\n      this.removeClass('vjs-seeking'); // reset the error state\r\n\r\n      this.error(null); // Update the duration\r\n\r\n      this.handleTechDurationChange_(); // If it's already playing we want to trigger a firstplay event now.\r\n      // The firstplay event relies on both the play and loadstart events\r\n      // which can happen in any order for a new source\r\n\r\n      if (!this.paused()) {\r\n        /**\r\n         * Fired when the user agent begins looking for media data\r\n         *\r\n         * @event Player#loadstart\r\n         * @type {EventTarget~Event}\r\n         */\r\n        this.trigger('loadstart');\r\n        this.trigger('firstplay');\r\n      } else {\r\n        // reset the hasStarted state\r\n        this.hasStarted(false);\r\n        this.trigger('loadstart');\r\n      } // autoplay happens after loadstart for the browser,\r\n      // so we mimic that behavior\r\n\r\n\r\n      this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? 'play' : this.autoplay());\r\n    }\r\n    /**\r\n     * Handle autoplay string values, rather than the typical boolean\r\n     * values that should be handled by the tech. Note that this is not\r\n     * part of any specification. Valid values and what they do can be\r\n     * found on the autoplay getter at Player#autoplay()\r\n     */\r\n    ;\r\n\r\n    _proto.manualAutoplay_ = function manualAutoplay_(type) {\r\n      var _this6 = this;\r\n\r\n      if (!this.tech_ || typeof type !== 'string') {\r\n        return;\r\n      } // Save original muted() value, set muted to true, and attempt to play().\r\n      // On promise rejection, restore muted from saved value\r\n\r\n\r\n      var resolveMuted = function resolveMuted() {\r\n        var previouslyMuted = _this6.muted();\r\n\r\n        _this6.muted(true);\r\n\r\n        var restoreMuted = function restoreMuted() {\r\n          _this6.muted(previouslyMuted);\r\n        }; // restore muted on play terminatation\r\n\r\n\r\n        _this6.playTerminatedQueue_.push(restoreMuted);\r\n\r\n        var mutedPromise = _this6.play();\r\n\r\n        if (!isPromise(mutedPromise)) {\r\n          return;\r\n        }\r\n\r\n        return mutedPromise[\"catch\"](function (err) {\r\n          restoreMuted();\r\n          throw new Error(\"Rejection at manualAutoplay. Restoring muted value. \" + (err ? err : ''));\r\n        });\r\n      };\r\n\r\n      var promise; // if muted defaults to true\r\n      // the only thing we can do is call play\r\n\r\n      if (type === 'any' && !this.muted()) {\r\n        promise = this.play();\r\n\r\n        if (isPromise(promise)) {\r\n          promise = promise[\"catch\"](resolveMuted);\r\n        }\r\n      } else if (type === 'muted' && !this.muted()) {\r\n        promise = resolveMuted();\r\n      } else {\r\n        promise = this.play();\r\n      }\r\n\r\n      if (!isPromise(promise)) {\r\n        return;\r\n      }\r\n\r\n      return promise.then(function () {\r\n        _this6.trigger({\r\n          type: 'autoplay-success',\r\n          autoplay: type\r\n        });\r\n      })[\"catch\"](function () {\r\n        _this6.trigger({\r\n          type: 'autoplay-failure',\r\n          autoplay: type\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Update the internal source caches so that we return the correct source from\r\n     * `src()`, `currentSource()`, and `currentSources()`.\r\n     *\r\n     * > Note: `currentSources` will not be updated if the source that is passed in exists\r\n     *         in the current `currentSources` cache.\r\n     *\r\n     *\r\n     * @param {Tech~SourceObject} srcObj\r\n     *        A string or object source to update our caches to.\r\n     */\r\n    ;\r\n\r\n    _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {\r\n      if (srcObj === void 0) {\r\n        srcObj = '';\r\n      }\r\n\r\n      var src = srcObj;\r\n      var type = '';\r\n\r\n      if (typeof src !== 'string') {\r\n        src = srcObj.src;\r\n        type = srcObj.type;\r\n      } // make sure all the caches are set to default values\r\n      // to prevent null checking\r\n\r\n\r\n      this.cache_.source = this.cache_.source || {};\r\n      this.cache_.sources = this.cache_.sources || []; // try to get the type of the src that was passed in\r\n\r\n      if (src && !type) {\r\n        type = findMimetype(this, src);\r\n      } // update `currentSource` cache always\r\n\r\n\r\n      this.cache_.source = mergeOptions$3({}, srcObj, {\r\n        src: src,\r\n        type: type\r\n      });\r\n      var matchingSources = this.cache_.sources.filter(function (s) {\r\n        return s.src && s.src === src;\r\n      });\r\n      var sourceElSources = [];\r\n      var sourceEls = this.$$('source');\r\n      var matchingSourceEls = [];\r\n\r\n      for (var i = 0; i < sourceEls.length; i++) {\r\n        var sourceObj = getAttributes(sourceEls[i]);\r\n        sourceElSources.push(sourceObj);\r\n\r\n        if (sourceObj.src && sourceObj.src === src) {\r\n          matchingSourceEls.push(sourceObj.src);\r\n        }\r\n      } // if we have matching source els but not matching sources\r\n      // the current source cache is not up to date\r\n\r\n\r\n      if (matchingSourceEls.length && !matchingSources.length) {\r\n        this.cache_.sources = sourceElSources; // if we don't have matching source or source els set the\r\n        // sources cache to the `currentSource` cache\r\n      } else if (!matchingSources.length) {\r\n        this.cache_.sources = [this.cache_.source];\r\n      } // update the tech `src` cache\r\n\r\n\r\n      this.cache_.src = src;\r\n    }\r\n    /**\r\n     * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\r\n     * causing the media element to reload.\r\n     *\r\n     * It will fire for the initial source and each subsequent source.\r\n     * This event is a custom event from Video.js and is triggered by the {@link Tech}.\r\n     *\r\n     * The event object for this event contains a `src` property that will contain the source\r\n     * that was available when the event was triggered. This is generally only necessary if Video.js\r\n     * is switching techs while the source was being changed.\r\n     *\r\n     * It is also fired when `load` is called on the player (or media element)\r\n     * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\r\n     * says that the resource selection algorithm needs to be aborted and restarted.\r\n     * In this case, it is very likely that the `src` property will be set to the\r\n     * empty string `\"\"` to indicate we do not know what the source will be but\r\n     * that it is changing.\r\n     *\r\n     * *This event is currently still experimental and may change in minor releases.*\r\n     * __To use this, pass `enableSourceset` option to the player.__\r\n     *\r\n     * @event Player#sourceset\r\n     * @type {EventTarget~Event}\r\n     * @prop {string} src\r\n     *                The source url available when the `sourceset` was triggered.\r\n     *                It will be an empty string if we cannot know what the source is\r\n     *                but know that the source will change.\r\n     */\r\n\r\n    /**\r\n     * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#sourceset\r\n     * @listens Tech#sourceset\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechSourceset_ = function handleTechSourceset_(event) {\r\n      var _this7 = this;\r\n\r\n      // only update the source cache when the source\r\n      // was not updated using the player api\r\n      if (!this.changingSrc_) {\r\n        var updateSourceCaches = function updateSourceCaches(src) {\r\n          return _this7.updateSourceCaches_(src);\r\n        };\r\n\r\n        var playerSrc = this.currentSource().src;\r\n        var eventSrc = event.src; // if we have a playerSrc that is not a blob, and a tech src that is a blob\r\n\r\n        if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {\r\n          // if both the tech source and the player source were updated we assume\r\n          // something like @videojs/http-streaming did the sourceset and skip updating the source cache.\r\n          if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {\r\n            updateSourceCaches = function updateSourceCaches() {};\r\n          }\r\n        } // update the source to the initial source right away\r\n        // in some cases this will be empty string\r\n\r\n\r\n        updateSourceCaches(eventSrc); // if the `sourceset` `src` was an empty string\r\n        // wait for a `loadstart` to update the cache to `currentSrc`.\r\n        // If a sourceset happens before a `loadstart`, we reset the state\r\n\r\n        if (!event.src) {\r\n          this.tech_.any(['sourceset', 'loadstart'], function (e) {\r\n            // if a sourceset happens before a `loadstart` there\r\n            // is nothing to do as this `handleTechSourceset_`\r\n            // will be called again and this will be handled there.\r\n            if (e.type === 'sourceset') {\r\n              return;\r\n            }\r\n\r\n            var techSrc = _this7.techGet('currentSrc');\r\n\r\n            _this7.lastSource_.tech = techSrc;\r\n\r\n            _this7.updateSourceCaches_(techSrc);\r\n          });\r\n        }\r\n      }\r\n\r\n      this.lastSource_ = {\r\n        player: this.currentSource().src,\r\n        tech: event.src\r\n      };\r\n      this.trigger({\r\n        src: event.src,\r\n        type: 'sourceset'\r\n      });\r\n    }\r\n    /**\r\n     * Add/remove the vjs-has-started class\r\n     *\r\n     * @fires Player#firstplay\r\n     *\r\n     * @param {boolean} request\r\n     *        - true: adds the class\r\n     *        - false: remove the class\r\n     *\r\n     * @return {boolean}\r\n     *         the boolean value of hasStarted_\r\n     */\r\n    ;\r\n\r\n    _proto.hasStarted = function hasStarted(request) {\r\n      if (request === undefined) {\r\n        // act as getter, if we have no request to change\r\n        return this.hasStarted_;\r\n      }\r\n\r\n      if (request === this.hasStarted_) {\r\n        return;\r\n      }\r\n\r\n      this.hasStarted_ = request;\r\n\r\n      if (this.hasStarted_) {\r\n        this.addClass('vjs-has-started');\r\n        this.trigger('firstplay');\r\n      } else {\r\n        this.removeClass('vjs-has-started');\r\n      }\r\n    }\r\n    /**\r\n     * Fired whenever the media begins or resumes playback\r\n     *\r\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\r\n     * @fires Player#play\r\n     * @listens Tech#play\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechPlay_ = function handleTechPlay_() {\r\n      this.removeClass('vjs-ended');\r\n      this.removeClass('vjs-paused');\r\n      this.addClass('vjs-playing'); // hide the poster when the user hits play\r\n\r\n      this.hasStarted(true);\r\n      /**\r\n       * Triggered whenever an {@link Tech#play} event happens. Indicates that\r\n       * playback has started or resumed.\r\n       *\r\n       * @event Player#play\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('play');\r\n    }\r\n    /**\r\n     * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\r\n     *\r\n     * If there were any events queued while the playback rate was zero, fire\r\n     * those events now.\r\n     *\r\n     * @private\r\n     * @method Player#handleTechRateChange_\r\n     * @fires Player#ratechange\r\n     * @listens Tech#ratechange\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechRateChange_ = function handleTechRateChange_() {\r\n      if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\r\n        this.queuedCallbacks_.forEach(function (queued) {\r\n          return queued.callback(queued.event);\r\n        });\r\n        this.queuedCallbacks_ = [];\r\n      }\r\n\r\n      this.cache_.lastPlaybackRate = this.tech_.playbackRate();\r\n      /**\r\n       * Fires when the playing speed of the audio/video is changed\r\n       *\r\n       * @event Player#ratechange\r\n       * @type {event}\r\n       */\r\n\r\n      this.trigger('ratechange');\r\n    }\r\n    /**\r\n     * Retrigger the `waiting` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#waiting\r\n     * @listens Tech#waiting\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechWaiting_ = function handleTechWaiting_() {\r\n      var _this8 = this;\r\n\r\n      this.addClass('vjs-waiting');\r\n      /**\r\n       * A readyState change on the DOM element has caused playback to stop.\r\n       *\r\n       * @event Player#waiting\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('waiting'); // Browsers may emit a timeupdate event after a waiting event. In order to prevent\r\n      // premature removal of the waiting class, wait for the time to change.\r\n\r\n      var timeWhenWaiting = this.currentTime();\r\n\r\n      var timeUpdateListener = function timeUpdateListener() {\r\n        if (timeWhenWaiting !== _this8.currentTime()) {\r\n          _this8.removeClass('vjs-waiting');\r\n\r\n          _this8.off('timeupdate', timeUpdateListener);\r\n        }\r\n      };\r\n\r\n      this.on('timeupdate', timeUpdateListener);\r\n    }\r\n    /**\r\n     * Retrigger the `canplay` event that was triggered by the {@link Tech}.\r\n     * > Note: This is not consistent between browsers. See #1351\r\n     *\r\n     * @fires Player#canplay\r\n     * @listens Tech#canplay\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechCanPlay_ = function handleTechCanPlay_() {\r\n      this.removeClass('vjs-waiting');\r\n      /**\r\n       * The media has a readyState of HAVE_FUTURE_DATA or greater.\r\n       *\r\n       * @event Player#canplay\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('canplay');\r\n    }\r\n    /**\r\n     * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#canplaythrough\r\n     * @listens Tech#canplaythrough\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\r\n      this.removeClass('vjs-waiting');\r\n      /**\r\n       * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\r\n       * entire media file can be played without buffering.\r\n       *\r\n       * @event Player#canplaythrough\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('canplaythrough');\r\n    }\r\n    /**\r\n     * Retrigger the `playing` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#playing\r\n     * @listens Tech#playing\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechPlaying_ = function handleTechPlaying_() {\r\n      this.removeClass('vjs-waiting');\r\n      /**\r\n       * The media is no longer blocked from playback, and has started playing.\r\n       *\r\n       * @event Player#playing\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('playing');\r\n    }\r\n    /**\r\n     * Retrigger the `seeking` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#seeking\r\n     * @listens Tech#seeking\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechSeeking_ = function handleTechSeeking_() {\r\n      this.addClass('vjs-seeking');\r\n      /**\r\n       * Fired whenever the player is jumping to a new time\r\n       *\r\n       * @event Player#seeking\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('seeking');\r\n    }\r\n    /**\r\n     * Retrigger the `seeked` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#seeked\r\n     * @listens Tech#seeked\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechSeeked_ = function handleTechSeeked_() {\r\n      this.removeClass('vjs-seeking');\r\n      this.removeClass('vjs-ended');\r\n      /**\r\n       * Fired when the player has finished jumping to a new time\r\n       *\r\n       * @event Player#seeked\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('seeked');\r\n    }\r\n    /**\r\n     * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#firstplay\r\n     * @listens Tech#firstplay\r\n     * @deprecated As of 6.0 firstplay event is deprecated.\r\n     *             As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {\r\n      // If the first starttime attribute is specified\r\n      // then we will start at the given offset in seconds\r\n      if (this.options_.starttime) {\r\n        log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');\r\n        this.currentTime(this.options_.starttime);\r\n      }\r\n\r\n      this.addClass('vjs-has-started');\r\n      /**\r\n       * Fired the first time a video is played. Not part of the HLS spec, and this is\r\n       * probably not the best implementation yet, so use sparingly. If you don't have a\r\n       * reason to prevent playback, use `myPlayer.one('play');` instead.\r\n       *\r\n       * @event Player#firstplay\r\n       * @deprecated As of 6.0 firstplay event is deprecated.\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('firstplay');\r\n    }\r\n    /**\r\n     * Retrigger the `pause` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#pause\r\n     * @listens Tech#pause\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechPause_ = function handleTechPause_() {\r\n      this.removeClass('vjs-playing');\r\n      this.addClass('vjs-paused');\r\n      /**\r\n       * Fired whenever the media has been paused\r\n       *\r\n       * @event Player#pause\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('pause');\r\n    }\r\n    /**\r\n     * Retrigger the `ended` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#ended\r\n     * @listens Tech#ended\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechEnded_ = function handleTechEnded_() {\r\n      this.addClass('vjs-ended');\r\n      this.removeClass('vjs-waiting');\r\n\r\n      if (this.options_.loop) {\r\n        this.currentTime(0);\r\n        this.play();\r\n      } else if (!this.paused()) {\r\n        this.pause();\r\n      }\r\n      /**\r\n       * Fired when the end of the media resource is reached (currentTime == duration)\r\n       *\r\n       * @event Player#ended\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n\r\n      this.trigger('ended');\r\n    }\r\n    /**\r\n     * Fired when the duration of the media resource is first known or changed\r\n     *\r\n     * @listens Tech#durationchange\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechDurationChange_ = function handleTechDurationChange_() {\r\n      this.duration(this.techGet_('duration'));\r\n    }\r\n    /**\r\n     * Handle a click on the media element to play/pause\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the event that caused this function to trigger\r\n     *\r\n     * @listens Tech#click\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechClick_ = function handleTechClick_(event) {\r\n      // When controls are disabled a click should not toggle playback because\r\n      // the click is considered a control\r\n      if (!this.controls_) {\r\n        return;\r\n      }\r\n\r\n      if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.click === undefined || this.options_.userActions.click !== false) {\r\n        if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.click === 'function') {\r\n          this.options_.userActions.click.call(this, event);\r\n        } else if (this.paused()) {\r\n          silencePromise(this.play());\r\n        } else {\r\n          this.pause();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Handle a double-click on the media element to enter/exit fullscreen\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the event that caused this function to trigger\r\n     *\r\n     * @listens Tech#dblclick\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {\r\n      if (!this.controls_) {\r\n        return;\r\n      } // we do not want to toggle fullscreen state\r\n      // when double-clicking inside a control bar or a modal\r\n\r\n\r\n      var inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), function (el) {\r\n        return el.contains(event.target);\r\n      });\r\n\r\n      if (!inAllowedEls) {\r\n        /*\r\n         * options.userActions.doubleClick\r\n         *\r\n         * If `undefined` or `true`, double-click toggles fullscreen if controls are present\r\n         * Set to `false` to disable double-click handling\r\n         * Set to a function to substitute an external double-click handler\r\n         */\r\n        if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {\r\n          if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {\r\n            this.options_.userActions.doubleClick.call(this, event);\r\n          } else if (this.isFullscreen()) {\r\n            this.exitFullscreen();\r\n          } else {\r\n            this.requestFullscreen();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Handle a tap on the media element. It will toggle the user\r\n     * activity state, which hides and shows the controls.\r\n     *\r\n     * @listens Tech#tap\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechTap_ = function handleTechTap_() {\r\n      this.userActive(!this.userActive());\r\n    }\r\n    /**\r\n     * Handle touch to start\r\n     *\r\n     * @listens Tech#touchstart\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechTouchStart_ = function handleTechTouchStart_() {\r\n      this.userWasActive = this.userActive();\r\n    }\r\n    /**\r\n     * Handle touch to move\r\n     *\r\n     * @listens Tech#touchmove\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechTouchMove_ = function handleTechTouchMove_() {\r\n      if (this.userWasActive) {\r\n        this.reportUserActivity();\r\n      }\r\n    }\r\n    /**\r\n     * Handle touch to end\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the touchend event that triggered\r\n     *        this function\r\n     *\r\n     * @listens Tech#touchend\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\r\n      // Stop the mouse events from also happening\r\n      if (event.cancelable) {\r\n        event.preventDefault();\r\n      }\r\n    }\r\n    /**\r\n     * native click events on the SWF aren't triggered on IE11, Win8.1RT\r\n     * use stageclick events triggered from inside the SWF instead\r\n     *\r\n     * @private\r\n     * @listens stageclick\r\n     */\r\n    ;\r\n\r\n    _proto.handleStageClick_ = function handleStageClick_() {\r\n      this.reportUserActivity();\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {\r\n      if (this.isFullscreen()) {\r\n        this.addClass('vjs-fullscreen');\r\n      } else {\r\n        this.removeClass('vjs-fullscreen');\r\n      }\r\n    }\r\n    /**\r\n     * when the document fschange event triggers it calls this\r\n     */\r\n    ;\r\n\r\n    _proto.documentFullscreenChange_ = function documentFullscreenChange_(e) {\r\n      var targetPlayer = e.target.player; // if another player was fullscreen\r\n      // do a null check for targetPlayer because older firefox's would put document as e.target\r\n\r\n      if (targetPlayer && targetPlayer !== this) {\r\n        return;\r\n      }\r\n\r\n      var el = this.el();\r\n      var isFs = document[this.fsApi_.fullscreenElement] === el;\r\n\r\n      if (!isFs && el.matches) {\r\n        isFs = el.matches(':' + this.fsApi_.fullscreen);\r\n      } else if (!isFs && el.msMatchesSelector) {\r\n        isFs = el.msMatchesSelector(':' + this.fsApi_.fullscreen);\r\n      }\r\n\r\n      this.isFullscreen(isFs);\r\n    }\r\n    /**\r\n     * Handle Tech Fullscreen Change\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the fullscreenchange event that triggered this function\r\n     *\r\n     * @param {Object} data\r\n     *        the data that was sent with the event\r\n     *\r\n     * @private\r\n     * @listens Tech#fullscreenchange\r\n     * @fires Player#fullscreenchange\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\r\n      var _this9 = this;\r\n\r\n      if (data) {\r\n        if (data.nativeIOSFullscreen) {\r\n          this.addClass('vjs-ios-native-fs');\r\n          this.tech_.one('webkitendfullscreen', function () {\r\n            _this9.removeClass('vjs-ios-native-fs');\r\n          });\r\n        }\r\n\r\n        this.isFullscreen(data.isFullscreen);\r\n      }\r\n    };\r\n\r\n    _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event, err) {\r\n      this.trigger('fullscreenerror', err);\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {\r\n      if (this.isInPictureInPicture()) {\r\n        this.addClass('vjs-picture-in-picture');\r\n      } else {\r\n        this.removeClass('vjs-picture-in-picture');\r\n      }\r\n    }\r\n    /**\r\n     * Handle Tech Enter Picture-in-Picture.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the enterpictureinpicture event that triggered this function\r\n     *\r\n     * @private\r\n     * @listens Tech#enterpictureinpicture\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event) {\r\n      this.isInPictureInPicture(true);\r\n    }\r\n    /**\r\n     * Handle Tech Leave Picture-in-Picture.\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        the leavepictureinpicture event that triggered this function\r\n     *\r\n     * @private\r\n     * @listens Tech#leavepictureinpicture\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event) {\r\n      this.isInPictureInPicture(false);\r\n    }\r\n    /**\r\n     * Fires when an error occurred during the loading of an audio/video.\r\n     *\r\n     * @private\r\n     * @listens Tech#error\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechError_ = function handleTechError_() {\r\n      var error = this.tech_.error();\r\n      this.error(error);\r\n    }\r\n    /**\r\n     * Retrigger the `textdata` event that was triggered by the {@link Tech}.\r\n     *\r\n     * @fires Player#textdata\r\n     * @listens Tech#textdata\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechTextData_ = function handleTechTextData_() {\r\n      var data = null;\r\n\r\n      if (arguments.length > 1) {\r\n        data = arguments[1];\r\n      }\r\n      /**\r\n       * Fires when we get a textdata event from tech\r\n       *\r\n       * @event Player#textdata\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n\r\n      this.trigger('textdata', data);\r\n    }\r\n    /**\r\n     * Get object for cached values.\r\n     *\r\n     * @return {Object}\r\n     *         get the current object cache\r\n     */\r\n    ;\r\n\r\n    _proto.getCache = function getCache() {\r\n      return this.cache_;\r\n    }\r\n    /**\r\n     * Resets the internal cache object.\r\n     *\r\n     * Using this function outside the player constructor or reset method may\r\n     * have unintended side-effects.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.resetCache_ = function resetCache_() {\r\n      this.cache_ = {\r\n        // Right now, the currentTime is not _really_ cached because it is always\r\n        // retrieved from the tech (see: currentTime). However, for completeness,\r\n        // we set it to zero here to ensure that if we do start actually caching\r\n        // it, we reset it along with everything else.\r\n        currentTime: 0,\r\n        initTime: 0,\r\n        inactivityTimeout: this.options_.inactivityTimeout,\r\n        duration: NaN,\r\n        lastVolume: 1,\r\n        lastPlaybackRate: this.defaultPlaybackRate(),\r\n        media: null,\r\n        src: '',\r\n        source: {},\r\n        sources: [],\r\n        playbackRates: [],\r\n        volume: 1\r\n      };\r\n    }\r\n    /**\r\n     * Pass values to the playback tech\r\n     *\r\n     * @param {string} [method]\r\n     *        the method to call\r\n     *\r\n     * @param {Object} arg\r\n     *        the argument to pass\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.techCall_ = function techCall_(method, arg) {\r\n      // If it's not ready yet, call method when it is\r\n      this.ready(function () {\r\n        if (method in allowedSetters) {\r\n          return set(this.middleware_, this.tech_, method, arg);\r\n        } else if (method in allowedMediators) {\r\n          return mediate(this.middleware_, this.tech_, method, arg);\r\n        }\r\n\r\n        try {\r\n          if (this.tech_) {\r\n            this.tech_[method](arg);\r\n          }\r\n        } catch (e) {\r\n          log$1(e);\r\n          throw e;\r\n        }\r\n      }, true);\r\n    }\r\n    /**\r\n     * Get calls can't wait for the tech, and sometimes don't need to.\r\n     *\r\n     * @param {string} method\r\n     *        Tech method\r\n     *\r\n     * @return {Function|undefined}\r\n     *         the method or undefined\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.techGet_ = function techGet_(method) {\r\n      if (!this.tech_ || !this.tech_.isReady_) {\r\n        return;\r\n      }\r\n\r\n      if (method in allowedGetters) {\r\n        return get(this.middleware_, this.tech_, method);\r\n      } else if (method in allowedMediators) {\r\n        return mediate(this.middleware_, this.tech_, method);\r\n      } // Flash likes to die and reload when you hide or reposition it.\r\n      // In these cases the object methods go away and we get errors.\r\n      // TODO: Is this needed for techs other than Flash?\r\n      // When that happens we'll catch the errors and inform tech that it's not ready any more.\r\n\r\n\r\n      try {\r\n        return this.tech_[method]();\r\n      } catch (e) {\r\n        // When building additional tech libs, an expected method may not be defined yet\r\n        if (this.tech_[method] === undefined) {\r\n          log$1(\"Video.js: \" + method + \" method not defined for \" + this.techName_ + \" playback technology.\", e);\r\n          throw e;\r\n        } // When a method isn't available on the object it throws a TypeError\r\n\r\n\r\n        if (e.name === 'TypeError') {\r\n          log$1(\"Video.js: \" + method + \" unavailable on \" + this.techName_ + \" playback technology element.\", e);\r\n          this.tech_.isReady_ = false;\r\n          throw e;\r\n        } // If error unknown, just log and throw\r\n\r\n\r\n        log$1(e);\r\n        throw e;\r\n      }\r\n    }\r\n    /**\r\n     * Attempt to begin playback at the first opportunity.\r\n     *\r\n     * @return {Promise|undefined}\r\n     *         Returns a promise if the browser supports Promises (or one\r\n     *         was passed in as an option). This promise will be resolved on\r\n     *         the return value of play. If this is undefined it will fulfill the\r\n     *         promise chain otherwise the promise chain will be fulfilled when\r\n     *         the promise from play is fulfilled.\r\n     */\r\n    ;\r\n\r\n    _proto.play = function play() {\r\n      var _this10 = this;\r\n\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (PromiseClass) {\r\n        return new PromiseClass(function (resolve) {\r\n          _this10.play_(resolve);\r\n        });\r\n      }\r\n\r\n      return this.play_();\r\n    }\r\n    /**\r\n     * The actual logic for play, takes a callback that will be resolved on the\r\n     * return value of play. This allows us to resolve to the play promise if there\r\n     * is one on modern browsers.\r\n     *\r\n     * @private\r\n     * @param {Function} [callback]\r\n     *        The callback that should be called when the techs play is actually called\r\n     */\r\n    ;\r\n\r\n    _proto.play_ = function play_(callback) {\r\n      var _this11 = this;\r\n\r\n      if (callback === void 0) {\r\n        callback = silencePromise;\r\n      }\r\n\r\n      this.playCallbacks_.push(callback);\r\n      var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc())); // treat calls to play_ somewhat like the `one` event function\r\n\r\n      if (this.waitToPlay_) {\r\n        this.off(['ready', 'loadstart'], this.waitToPlay_);\r\n        this.waitToPlay_ = null;\r\n      } // if the player/tech is not ready or the src itself is not ready\r\n      // queue up a call to play on `ready` or `loadstart`\r\n\r\n\r\n      if (!this.isReady_ || !isSrcReady) {\r\n        this.waitToPlay_ = function (e) {\r\n          _this11.play_();\r\n        };\r\n\r\n        this.one(['ready', 'loadstart'], this.waitToPlay_); // if we are in Safari, there is a high chance that loadstart will trigger after the gesture timeperiod\r\n        // in that case, we need to prime the video element by calling load so it'll be ready in time\r\n\r\n        if (!isSrcReady && (IS_ANY_SAFARI || IS_IOS)) {\r\n          this.load();\r\n        }\r\n\r\n        return;\r\n      } // If the player/tech is ready and we have a source, we can attempt playback.\r\n\r\n\r\n      var val = this.techGet_('play'); // play was terminated if the returned value is null\r\n\r\n      if (val === null) {\r\n        this.runPlayTerminatedQueue_();\r\n      } else {\r\n        this.runPlayCallbacks_(val);\r\n      }\r\n    }\r\n    /**\r\n     * These functions will be run when if play is terminated. If play\r\n     * runPlayCallbacks_ is run these function will not be run. This allows us\r\n     * to differenciate between a terminated play and an actual call to play.\r\n     */\r\n    ;\r\n\r\n    _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {\r\n      var queue = this.playTerminatedQueue_.slice(0);\r\n      this.playTerminatedQueue_ = [];\r\n      queue.forEach(function (q) {\r\n        q();\r\n      });\r\n    }\r\n    /**\r\n     * When a callback to play is delayed we have to run these\r\n     * callbacks when play is actually called on the tech. This function\r\n     * runs the callbacks that were delayed and accepts the return value\r\n     * from the tech.\r\n     *\r\n     * @param {undefined|Promise} val\r\n     *        The return value from the tech.\r\n     */\r\n    ;\r\n\r\n    _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {\r\n      var callbacks = this.playCallbacks_.slice(0);\r\n      this.playCallbacks_ = []; // clear play terminatedQueue since we finished a real play\r\n\r\n      this.playTerminatedQueue_ = [];\r\n      callbacks.forEach(function (cb) {\r\n        cb(val);\r\n      });\r\n    }\r\n    /**\r\n     * Pause the video playback\r\n     *\r\n     * @return {Player}\r\n     *         A reference to the player object this function was called on\r\n     */\r\n    ;\r\n\r\n    _proto.pause = function pause() {\r\n      this.techCall_('pause');\r\n    }\r\n    /**\r\n     * Check if the player is paused or has yet to play\r\n     *\r\n     * @return {boolean}\r\n     *         - false: if the media is currently playing\r\n     *         - true: if media is not currently playing\r\n     */\r\n    ;\r\n\r\n    _proto.paused = function paused() {\r\n      // The initial state of paused should be true (in Safari it's actually false)\r\n      return this.techGet_('paused') === false ? false : true;\r\n    }\r\n    /**\r\n     * Get a TimeRange object representing the current ranges of time that the user\r\n     * has played.\r\n     *\r\n     * @return {TimeRange}\r\n     *         A time range object that represents all the increments of time that have\r\n     *         been played.\r\n     */\r\n    ;\r\n\r\n    _proto.played = function played() {\r\n      return this.techGet_('played') || createTimeRanges(0, 0);\r\n    }\r\n    /**\r\n     * Returns whether or not the user is \"scrubbing\". Scrubbing is\r\n     * when the user has clicked the progress bar handle and is\r\n     * dragging it along the progress bar.\r\n     *\r\n     * @param {boolean} [isScrubbing]\r\n     *        whether the user is or is not scrubbing\r\n     *\r\n     * @return {boolean}\r\n     *         The value of scrubbing when getting\r\n     */\r\n    ;\r\n\r\n    _proto.scrubbing = function scrubbing(isScrubbing) {\r\n      if (typeof isScrubbing === 'undefined') {\r\n        return this.scrubbing_;\r\n      }\r\n\r\n      this.scrubbing_ = !!isScrubbing;\r\n      this.techCall_('setScrubbing', this.scrubbing_);\r\n\r\n      if (isScrubbing) {\r\n        this.addClass('vjs-scrubbing');\r\n      } else {\r\n        this.removeClass('vjs-scrubbing');\r\n      }\r\n    }\r\n    /**\r\n     * Get or set the current time (in seconds)\r\n     *\r\n     * @param {number|string} [seconds]\r\n     *        The time to seek to in seconds\r\n     *\r\n     * @return {number}\r\n     *         - the current time in seconds when getting\r\n     */\r\n    ;\r\n\r\n    _proto.currentTime = function currentTime(seconds) {\r\n      if (typeof seconds !== 'undefined') {\r\n        if (seconds < 0) {\r\n          seconds = 0;\r\n        }\r\n\r\n        if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {\r\n          this.cache_.initTime = seconds;\r\n          this.off('canplay', this.boundApplyInitTime_);\r\n          this.one('canplay', this.boundApplyInitTime_);\r\n          return;\r\n        }\r\n\r\n        this.techCall_('setCurrentTime', seconds);\r\n        this.cache_.initTime = 0;\r\n        return;\r\n      } // cache last currentTime and return. default to 0 seconds\r\n      //\r\n      // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\r\n      // currentTime when scrubbing, but may not provide much performance benefit afterall.\r\n      // Should be tested. Also something has to read the actual current time or the cache will\r\n      // never get updated.\r\n\r\n\r\n      this.cache_.currentTime = this.techGet_('currentTime') || 0;\r\n      return this.cache_.currentTime;\r\n    }\r\n    /**\r\n     * Apply the value of initTime stored in cache as currentTime.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.applyInitTime_ = function applyInitTime_() {\r\n      this.currentTime(this.cache_.initTime);\r\n    }\r\n    /**\r\n     * Normally gets the length in time of the video in seconds;\r\n     * in all but the rarest use cases an argument will NOT be passed to the method\r\n     *\r\n     * > **NOTE**: The video must have started loading before the duration can be\r\n     * known, and depending on preload behaviour may not be known until the video starts\r\n     * playing.\r\n     *\r\n     * @fires Player#durationchange\r\n     *\r\n     * @param {number} [seconds]\r\n     *        The duration of the video to set in seconds\r\n     *\r\n     * @return {number}\r\n     *         - The duration of the video in seconds when getting\r\n     */\r\n    ;\r\n\r\n    _proto.duration = function duration(seconds) {\r\n      if (seconds === undefined) {\r\n        // return NaN if the duration is not known\r\n        return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\r\n      }\r\n\r\n      seconds = parseFloat(seconds); // Standardize on Infinity for signaling video is live\r\n\r\n      if (seconds < 0) {\r\n        seconds = Infinity;\r\n      }\r\n\r\n      if (seconds !== this.cache_.duration) {\r\n        // Cache the last set value for optimized scrubbing (esp. Flash)\r\n        // TODO: Required for techs other than Flash?\r\n        this.cache_.duration = seconds;\r\n\r\n        if (seconds === Infinity) {\r\n          this.addClass('vjs-live');\r\n        } else {\r\n          this.removeClass('vjs-live');\r\n        }\r\n\r\n        if (!isNaN(seconds)) {\r\n          // Do not fire durationchange unless the duration value is known.\r\n          // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\r\n\r\n          /**\r\n           * @event Player#durationchange\r\n           * @type {EventTarget~Event}\r\n           */\r\n          this.trigger('durationchange');\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Calculates how much time is left in the video. Not part\r\n     * of the native video API.\r\n     *\r\n     * @return {number}\r\n     *         The time remaining in seconds\r\n     */\r\n    ;\r\n\r\n    _proto.remainingTime = function remainingTime() {\r\n      return this.duration() - this.currentTime();\r\n    }\r\n    /**\r\n     * A remaining time function that is intented to be used when\r\n     * the time is to be displayed directly to the user.\r\n     *\r\n     * @return {number}\r\n     *         The rounded time remaining in seconds\r\n     */\r\n    ;\r\n\r\n    _proto.remainingTimeDisplay = function remainingTimeDisplay() {\r\n      return Math.floor(this.duration()) - Math.floor(this.currentTime());\r\n    } //\r\n    // Kind of like an array of portions of the video that have been downloaded.\r\n\r\n    /**\r\n     * Get a TimeRange object with an array of the times of the video\r\n     * that have been downloaded. If you just want the percent of the\r\n     * video that's been downloaded, use bufferedPercent.\r\n     *\r\n     * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\r\n     *\r\n     * @return {TimeRange}\r\n     *         A mock TimeRange object (following HTML spec)\r\n     */\r\n    ;\r\n\r\n    _proto.buffered = function buffered() {\r\n      var buffered = this.techGet_('buffered');\r\n\r\n      if (!buffered || !buffered.length) {\r\n        buffered = createTimeRanges(0, 0);\r\n      }\r\n\r\n      return buffered;\r\n    }\r\n    /**\r\n     * Get the percent (as a decimal) of the video that's been downloaded.\r\n     * This method is not a part of the native HTML video API.\r\n     *\r\n     * @return {number}\r\n     *         A decimal between 0 and 1 representing the percent\r\n     *         that is buffered 0 being 0% and 1 being 100%\r\n     */\r\n    ;\r\n\r\n    _proto.bufferedPercent = function bufferedPercent$1() {\r\n      return bufferedPercent(this.buffered(), this.duration());\r\n    }\r\n    /**\r\n     * Get the ending time of the last buffered time range\r\n     * This is used in the progress bar to encapsulate all time ranges.\r\n     *\r\n     * @return {number}\r\n     *         The end of the last buffered time range\r\n     */\r\n    ;\r\n\r\n    _proto.bufferedEnd = function bufferedEnd() {\r\n      var buffered = this.buffered();\r\n      var duration = this.duration();\r\n      var end = buffered.end(buffered.length - 1);\r\n\r\n      if (end > duration) {\r\n        end = duration;\r\n      }\r\n\r\n      return end;\r\n    }\r\n    /**\r\n     * Get or set the current volume of the media\r\n     *\r\n     * @param  {number} [percentAsDecimal]\r\n     *         The new volume as a decimal percent:\r\n     *         - 0 is muted/0%/off\r\n     *         - 1.0 is 100%/full\r\n     *         - 0.5 is half volume or 50%\r\n     *\r\n     * @return {number}\r\n     *         The current volume as a percent when getting\r\n     */\r\n    ;\r\n\r\n    _proto.volume = function volume(percentAsDecimal) {\r\n      var vol;\r\n\r\n      if (percentAsDecimal !== undefined) {\r\n        // Force value to between 0 and 1\r\n        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\r\n        this.cache_.volume = vol;\r\n        this.techCall_('setVolume', vol);\r\n\r\n        if (vol > 0) {\r\n          this.lastVolume_(vol);\r\n        }\r\n\r\n        return;\r\n      } // Default to 1 when returning current volume.\r\n\r\n\r\n      vol = parseFloat(this.techGet_('volume'));\r\n      return isNaN(vol) ? 1 : vol;\r\n    }\r\n    /**\r\n     * Get the current muted state, or turn mute on or off\r\n     *\r\n     * @param {boolean} [muted]\r\n     *        - true to mute\r\n     *        - false to unmute\r\n     *\r\n     * @return {boolean}\r\n     *         - true if mute is on and getting\r\n     *         - false if mute is off and getting\r\n     */\r\n    ;\r\n\r\n    _proto.muted = function muted(_muted) {\r\n      if (_muted !== undefined) {\r\n        this.techCall_('setMuted', _muted);\r\n        return;\r\n      }\r\n\r\n      return this.techGet_('muted') || false;\r\n    }\r\n    /**\r\n     * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\r\n     * indicates the state of muted on initial playback.\r\n     *\r\n     * ```js\r\n     *   var myPlayer = videojs('some-player-id');\r\n     *\r\n     *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\r\n     *\r\n     *   // get, should be false\r\n     *   console.log(myPlayer.defaultMuted());\r\n     *   // set to true\r\n     *   myPlayer.defaultMuted(true);\r\n     *   // get should be true\r\n     *   console.log(myPlayer.defaultMuted());\r\n     * ```\r\n     *\r\n     * @param {boolean} [defaultMuted]\r\n     *        - true to mute\r\n     *        - false to unmute\r\n     *\r\n     * @return {boolean|Player}\r\n     *         - true if defaultMuted is on and getting\r\n     *         - false if defaultMuted is off and getting\r\n     *         - A reference to the current player when setting\r\n     */\r\n    ;\r\n\r\n    _proto.defaultMuted = function defaultMuted(_defaultMuted) {\r\n      if (_defaultMuted !== undefined) {\r\n        return this.techCall_('setDefaultMuted', _defaultMuted);\r\n      }\r\n\r\n      return this.techGet_('defaultMuted') || false;\r\n    }\r\n    /**\r\n     * Get the last volume, or set it\r\n     *\r\n     * @param  {number} [percentAsDecimal]\r\n     *         The new last volume as a decimal percent:\r\n     *         - 0 is muted/0%/off\r\n     *         - 1.0 is 100%/full\r\n     *         - 0.5 is half volume or 50%\r\n     *\r\n     * @return {number}\r\n     *         the current value of lastVolume as a percent when getting\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {\r\n      if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\r\n        this.cache_.lastVolume = percentAsDecimal;\r\n        return;\r\n      }\r\n\r\n      return this.cache_.lastVolume;\r\n    }\r\n    /**\r\n     * Check if current tech can support native fullscreen\r\n     * (e.g. with built in controls like iOS)\r\n     *\r\n     * @return {boolean}\r\n     *         if native fullscreen is supported\r\n     */\r\n    ;\r\n\r\n    _proto.supportsFullScreen = function supportsFullScreen() {\r\n      return this.techGet_('supportsFullScreen') || false;\r\n    }\r\n    /**\r\n     * Check if the player is in fullscreen mode or tell the player that it\r\n     * is or is not in fullscreen mode.\r\n     *\r\n     * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\r\n     * property and instead document.fullscreenElement is used. But isFullscreen is\r\n     * still a valuable property for internal player workings.\r\n     *\r\n     * @param  {boolean} [isFS]\r\n     *         Set the players current fullscreen state\r\n     *\r\n     * @return {boolean}\r\n     *         - true if fullscreen is on and getting\r\n     *         - false if fullscreen is off and getting\r\n     */\r\n    ;\r\n\r\n    _proto.isFullscreen = function isFullscreen(isFS) {\r\n      if (isFS !== undefined) {\r\n        var oldValue = this.isFullscreen_;\r\n        this.isFullscreen_ = Boolean(isFS); // if we changed fullscreen state and we're in prefixed mode, trigger fullscreenchange\r\n        // this is the only place where we trigger fullscreenchange events for older browsers\r\n        // fullWindow mode is treated as a prefixed event and will get a fullscreenchange event as well\r\n\r\n        if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {\r\n          /**\r\n             * @event Player#fullscreenchange\r\n             * @type {EventTarget~Event}\r\n             */\r\n          this.trigger('fullscreenchange');\r\n        }\r\n\r\n        this.toggleFullscreenClass_();\r\n        return;\r\n      }\r\n\r\n      return this.isFullscreen_;\r\n    }\r\n    /**\r\n     * Increase the size of the video to full screen\r\n     * In some browsers, full screen is not supported natively, so it enters\r\n     * \"full window mode\", where the video fills the browser window.\r\n     * In browsers and devices that support native full screen, sometimes the\r\n     * browser's default controls will be shown, and not the Video.js custom skin.\r\n     * This includes most mobile devices (iOS, Android) and older versions of\r\n     * Safari.\r\n     *\r\n     * @param  {Object} [fullscreenOptions]\r\n     *         Override the player fullscreen options\r\n     *\r\n     * @fires Player#fullscreenchange\r\n     */\r\n    ;\r\n\r\n    _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (PromiseClass) {\r\n        var self = this;\r\n        return new PromiseClass(function (resolve, reject) {\r\n          function offHandler() {\r\n            self.off('fullscreenerror', errorHandler);\r\n            self.off('fullscreenchange', changeHandler);\r\n          }\r\n\r\n          function changeHandler() {\r\n            offHandler();\r\n            resolve();\r\n          }\r\n\r\n          function errorHandler(e, err) {\r\n            offHandler();\r\n            reject(err);\r\n          }\r\n\r\n          self.one('fullscreenchange', changeHandler);\r\n          self.one('fullscreenerror', errorHandler);\r\n          var promise = self.requestFullscreenHelper_(fullscreenOptions);\r\n\r\n          if (promise) {\r\n            promise.then(offHandler, offHandler);\r\n            promise.then(resolve, reject);\r\n          }\r\n        });\r\n      }\r\n\r\n      return this.requestFullscreenHelper_();\r\n    };\r\n\r\n    _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {\r\n      var _this12 = this;\r\n\r\n      var fsOptions; // Only pass fullscreen options to requestFullscreen in spec-compliant browsers.\r\n      // Use defaults or player configured option unless passed directly to this method.\r\n\r\n      if (!this.fsApi_.prefixed) {\r\n        fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};\r\n\r\n        if (fullscreenOptions !== undefined) {\r\n          fsOptions = fullscreenOptions;\r\n        }\r\n      } // This method works as follows:\r\n      // 1. if a fullscreen api is available, use it\r\n      //   1. call requestFullscreen with potential options\r\n      //   2. if we got a promise from above, use it to update isFullscreen()\r\n      // 2. otherwise, if the tech supports fullscreen, call `enterFullScreen` on it.\r\n      //   This is particularly used for iPhone, older iPads, and non-safari browser on iOS.\r\n      // 3. otherwise, use \"fullWindow\" mode\r\n\r\n\r\n      if (this.fsApi_.requestFullscreen) {\r\n        var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);\r\n\r\n        if (promise) {\r\n          promise.then(function () {\r\n            return _this12.isFullscreen(true);\r\n          }, function () {\r\n            return _this12.isFullscreen(false);\r\n          });\r\n        }\r\n\r\n        return promise;\r\n      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\r\n        // we can't take the video.js controls fullscreen but we can go fullscreen\r\n        // with native controls\r\n        this.techCall_('enterFullScreen');\r\n      } else {\r\n        // fullscreen isn't supported so we'll just stretch the video element to\r\n        // fill the viewport\r\n        this.enterFullWindow();\r\n      }\r\n    }\r\n    /**\r\n     * Return the video to its normal size after having been in full screen mode\r\n     *\r\n     * @fires Player#fullscreenchange\r\n     */\r\n    ;\r\n\r\n    _proto.exitFullscreen = function exitFullscreen() {\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (PromiseClass) {\r\n        var self = this;\r\n        return new PromiseClass(function (resolve, reject) {\r\n          function offHandler() {\r\n            self.off('fullscreenerror', errorHandler);\r\n            self.off('fullscreenchange', changeHandler);\r\n          }\r\n\r\n          function changeHandler() {\r\n            offHandler();\r\n            resolve();\r\n          }\r\n\r\n          function errorHandler(e, err) {\r\n            offHandler();\r\n            reject(err);\r\n          }\r\n\r\n          self.one('fullscreenchange', changeHandler);\r\n          self.one('fullscreenerror', errorHandler);\r\n          var promise = self.exitFullscreenHelper_();\r\n\r\n          if (promise) {\r\n            promise.then(offHandler, offHandler); // map the promise to our resolve/reject methods\r\n\r\n            promise.then(resolve, reject);\r\n          }\r\n        });\r\n      }\r\n\r\n      return this.exitFullscreenHelper_();\r\n    };\r\n\r\n    _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {\r\n      var _this13 = this;\r\n\r\n      if (this.fsApi_.requestFullscreen) {\r\n        var promise = document[this.fsApi_.exitFullscreen]();\r\n\r\n        if (promise) {\r\n          // we're splitting the promise here, so, we want to catch the\r\n          // potential error so that this chain doesn't have unhandled errors\r\n          silencePromise(promise.then(function () {\r\n            return _this13.isFullscreen(false);\r\n          }));\r\n        }\r\n\r\n        return promise;\r\n      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\r\n        this.techCall_('exitFullScreen');\r\n      } else {\r\n        this.exitFullWindow();\r\n      }\r\n    }\r\n    /**\r\n     * When fullscreen isn't supported we can stretch the\r\n     * video container to as wide as the browser will let us.\r\n     *\r\n     * @fires Player#enterFullWindow\r\n     */\r\n    ;\r\n\r\n    _proto.enterFullWindow = function enterFullWindow() {\r\n      this.isFullscreen(true);\r\n      this.isFullWindow = true; // Storing original doc overflow value to return to when fullscreen is off\r\n\r\n      this.docOrigOverflow = document.documentElement.style.overflow; // Add listener for esc key to exit fullscreen\r\n\r\n      on(document, 'keydown', this.boundFullWindowOnEscKey_); // Hide any scroll bars\r\n\r\n      document.documentElement.style.overflow = 'hidden'; // Apply fullscreen styles\r\n\r\n      addClass(document.body, 'vjs-full-window');\r\n      /**\r\n       * @event Player#enterFullWindow\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('enterFullWindow');\r\n    }\r\n    /**\r\n     * Check for call to either exit full window or\r\n     * full screen on ESC key\r\n     *\r\n     * @param {string} event\r\n     *        Event to check for key press\r\n     */\r\n    ;\r\n\r\n    _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\r\n      if (keycode.isEventKey(event, 'Esc')) {\r\n        if (this.isFullscreen() === true) {\r\n          if (!this.isFullWindow) {\r\n            this.exitFullscreen();\r\n          } else {\r\n            this.exitFullWindow();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Exit full window\r\n     *\r\n     * @fires Player#exitFullWindow\r\n     */\r\n    ;\r\n\r\n    _proto.exitFullWindow = function exitFullWindow() {\r\n      this.isFullscreen(false);\r\n      this.isFullWindow = false;\r\n      off(document, 'keydown', this.boundFullWindowOnEscKey_); // Unhide scroll bars.\r\n\r\n      document.documentElement.style.overflow = this.docOrigOverflow; // Remove fullscreen styles\r\n\r\n      removeClass(document.body, 'vjs-full-window'); // Resize the box, controller, and poster to original sizes\r\n      // this.positionAll();\r\n\r\n      /**\r\n       * @event Player#exitFullWindow\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('exitFullWindow');\r\n    }\r\n    /**\r\n     * Disable Picture-in-Picture mode.\r\n     *\r\n     * @param {boolean} value\r\n     *                  - true will disable Picture-in-Picture mode\r\n     *                  - false will enable Picture-in-Picture mode\r\n     */\r\n    ;\r\n\r\n    _proto.disablePictureInPicture = function disablePictureInPicture(value) {\r\n      if (value === undefined) {\r\n        return this.techGet_('disablePictureInPicture');\r\n      }\r\n\r\n      this.techCall_('setDisablePictureInPicture', value);\r\n      this.options_.disablePictureInPicture = value;\r\n      this.trigger('disablepictureinpicturechanged');\r\n    }\r\n    /**\r\n     * Check if the player is in Picture-in-Picture mode or tell the player that it\r\n     * is or is not in Picture-in-Picture mode.\r\n     *\r\n     * @param  {boolean} [isPiP]\r\n     *         Set the players current Picture-in-Picture state\r\n     *\r\n     * @return {boolean}\r\n     *         - true if Picture-in-Picture is on and getting\r\n     *         - false if Picture-in-Picture is off and getting\r\n     */\r\n    ;\r\n\r\n    _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {\r\n      if (isPiP !== undefined) {\r\n        this.isInPictureInPicture_ = !!isPiP;\r\n        this.togglePictureInPictureClass_();\r\n        return;\r\n      }\r\n\r\n      return !!this.isInPictureInPicture_;\r\n    }\r\n    /**\r\n     * Create a floating video window always on top of other windows so that users may\r\n     * continue consuming media while they interact with other content sites, or\r\n     * applications on their device.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\r\n     *\r\n     * @fires Player#enterpictureinpicture\r\n     *\r\n     * @return {Promise}\r\n     *         A promise with a Picture-in-Picture window.\r\n     */\r\n    ;\r\n\r\n    _proto.requestPictureInPicture = function requestPictureInPicture() {\r\n      if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {\r\n        /**\r\n         * This event fires when the player enters picture in picture mode\r\n         *\r\n         * @event Player#enterpictureinpicture\r\n         * @type {EventTarget~Event}\r\n         */\r\n        return this.techGet_('requestPictureInPicture');\r\n      }\r\n    }\r\n    /**\r\n     * Exit Picture-in-Picture mode.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\r\n     *\r\n     * @fires Player#leavepictureinpicture\r\n     *\r\n     * @return {Promise}\r\n     *         A promise.\r\n     */\r\n    ;\r\n\r\n    _proto.exitPictureInPicture = function exitPictureInPicture() {\r\n      if ('pictureInPictureEnabled' in document) {\r\n        /**\r\n         * This event fires when the player leaves picture in picture mode\r\n         *\r\n         * @event Player#leavepictureinpicture\r\n         * @type {EventTarget~Event}\r\n         */\r\n        return document.exitPictureInPicture();\r\n      }\r\n    }\r\n    /**\r\n     * Called when this Player has focus and a key gets pressed down, or when\r\n     * any Component of this player receives a key press that it doesn't handle.\r\n     * This allows player-wide hotkeys (either as defined below, or optionally\r\n     * by an external function).\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     *\r\n     * @listens keydown\r\n     */\r\n    ;\r\n\r\n    _proto.handleKeyDown = function handleKeyDown(event) {\r\n      var userActions = this.options_.userActions; // Bail out if hotkeys are not configured.\r\n\r\n      if (!userActions || !userActions.hotkeys) {\r\n        return;\r\n      } // Function that determines whether or not to exclude an element from\r\n      // hotkeys handling.\r\n\r\n\r\n      var excludeElement = function excludeElement(el) {\r\n        var tagName = el.tagName.toLowerCase(); // The first and easiest test is for `contenteditable` elements.\r\n\r\n        if (el.isContentEditable) {\r\n          return true;\r\n        } // Inputs matching these types will still trigger hotkey handling as\r\n        // they are not text inputs.\r\n\r\n\r\n        var allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];\r\n\r\n        if (tagName === 'input') {\r\n          return allowedInputTypes.indexOf(el.type) === -1;\r\n        } // The final test is by tag name. These tags will be excluded entirely.\r\n\r\n\r\n        var excludedTags = ['textarea'];\r\n        return excludedTags.indexOf(tagName) !== -1;\r\n      }; // Bail out if the user is focused on an interactive form element.\r\n\r\n\r\n      if (excludeElement(this.el_.ownerDocument.activeElement)) {\r\n        return;\r\n      }\r\n\r\n      if (typeof userActions.hotkeys === 'function') {\r\n        userActions.hotkeys.call(this, event);\r\n      } else {\r\n        this.handleHotkeys(event);\r\n      }\r\n    }\r\n    /**\r\n     * Called when this Player receives a hotkey keydown event.\r\n     * Supported player-wide hotkeys are:\r\n     *\r\n     *   f          - toggle fullscreen\r\n     *   m          - toggle mute\r\n     *   k or Space - toggle play/pause\r\n     *\r\n     * @param {EventTarget~Event} event\r\n     *        The `keydown` event that caused this function to be called.\r\n     */\r\n    ;\r\n\r\n    _proto.handleHotkeys = function handleHotkeys(event) {\r\n      var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {}; // set fullscreenKey, muteKey, playPauseKey from `hotkeys`, use defaults if not set\r\n\r\n      var _hotkeys$fullscreenKe = hotkeys.fullscreenKey,\r\n          fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function (keydownEvent) {\r\n        return keycode.isEventKey(keydownEvent, 'f');\r\n      } : _hotkeys$fullscreenKe,\r\n          _hotkeys$muteKey = hotkeys.muteKey,\r\n          muteKey = _hotkeys$muteKey === void 0 ? function (keydownEvent) {\r\n        return keycode.isEventKey(keydownEvent, 'm');\r\n      } : _hotkeys$muteKey,\r\n          _hotkeys$playPauseKey = hotkeys.playPauseKey,\r\n          playPauseKey = _hotkeys$playPauseKey === void 0 ? function (keydownEvent) {\r\n        return keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space');\r\n      } : _hotkeys$playPauseKey;\r\n\r\n      if (fullscreenKey.call(this, event)) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        var FSToggle = Component$1.getComponent('FullscreenToggle');\r\n\r\n        if (document[this.fsApi_.fullscreenEnabled] !== false) {\r\n          FSToggle.prototype.handleClick.call(this, event);\r\n        }\r\n      } else if (muteKey.call(this, event)) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        var MuteToggle = Component$1.getComponent('MuteToggle');\r\n        MuteToggle.prototype.handleClick.call(this, event);\r\n      } else if (playPauseKey.call(this, event)) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        var PlayToggle = Component$1.getComponent('PlayToggle');\r\n        PlayToggle.prototype.handleClick.call(this, event);\r\n      }\r\n    }\r\n    /**\r\n     * Check whether the player can play a given mimetype\r\n     *\r\n     * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\r\n     *\r\n     * @param {string} type\r\n     *        The mimetype to check\r\n     *\r\n     * @return {string}\r\n     *         'probably', 'maybe', or '' (empty string)\r\n     */\r\n    ;\r\n\r\n    _proto.canPlayType = function canPlayType(type) {\r\n      var can; // Loop through each playback technology in the options order\r\n\r\n      for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\r\n        var techName = j[i];\r\n        var tech = Tech.getTech(techName); // Support old behavior of techs being registered as components.\r\n        // Remove once that deprecated behavior is removed.\r\n\r\n        if (!tech) {\r\n          tech = Component$1.getComponent(techName);\r\n        } // Check if the current tech is defined before continuing\r\n\r\n\r\n        if (!tech) {\r\n          log$1.error(\"The \\\"\" + techName + \"\\\" tech is undefined. Skipped browser support check for that tech.\");\r\n          continue;\r\n        } // Check if the browser supports this technology\r\n\r\n\r\n        if (tech.isSupported()) {\r\n          can = tech.canPlayType(type);\r\n\r\n          if (can) {\r\n            return can;\r\n          }\r\n        }\r\n      }\r\n\r\n      return '';\r\n    }\r\n    /**\r\n     * Select source based on tech-order or source-order\r\n     * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\r\n     * defaults to tech-order selection\r\n     *\r\n     * @param {Array} sources\r\n     *        The sources for a media asset\r\n     *\r\n     * @return {Object|boolean}\r\n     *         Object of source and tech order or false\r\n     */\r\n    ;\r\n\r\n    _proto.selectSource = function selectSource(sources) {\r\n      var _this14 = this;\r\n\r\n      // Get only the techs specified in `techOrder` that exist and are supported by the\r\n      // current platform\r\n      var techs = this.options_.techOrder.map(function (techName) {\r\n        return [techName, Tech.getTech(techName)];\r\n      }).filter(function (_ref) {\r\n        var techName = _ref[0],\r\n            tech = _ref[1];\r\n\r\n        // Check if the current tech is defined before continuing\r\n        if (tech) {\r\n          // Check if the browser supports this technology\r\n          return tech.isSupported();\r\n        }\r\n\r\n        log$1.error(\"The \\\"\" + techName + \"\\\" tech is undefined. Skipped browser support check for that tech.\");\r\n        return false;\r\n      }); // Iterate over each `innerArray` element once per `outerArray` element and execute\r\n      // `tester` with both. If `tester` returns a non-falsy value, exit early and return\r\n      // that value.\r\n\r\n      var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\r\n        var found;\r\n        outerArray.some(function (outerChoice) {\r\n          return innerArray.some(function (innerChoice) {\r\n            found = tester(outerChoice, innerChoice);\r\n\r\n            if (found) {\r\n              return true;\r\n            }\r\n          });\r\n        });\r\n        return found;\r\n      };\r\n\r\n      var foundSourceAndTech;\r\n\r\n      var flip = function flip(fn) {\r\n        return function (a, b) {\r\n          return fn(b, a);\r\n        };\r\n      };\r\n\r\n      var finder = function finder(_ref2, source) {\r\n        var techName = _ref2[0],\r\n            tech = _ref2[1];\r\n\r\n        if (tech.canPlaySource(source, _this14.options_[techName.toLowerCase()])) {\r\n          return {\r\n            source: source,\r\n            tech: techName\r\n          };\r\n        }\r\n      }; // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\r\n      // to select from them based on their priority.\r\n\r\n\r\n      if (this.options_.sourceOrder) {\r\n        // Source-first ordering\r\n        foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\r\n      } else {\r\n        // Tech-first ordering\r\n        foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\r\n      }\r\n\r\n      return foundSourceAndTech || false;\r\n    }\r\n    /**\r\n     * Executes source setting and getting logic\r\n     *\r\n     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\r\n     *        A SourceObject, an array of SourceObjects, or a string referencing\r\n     *        a URL to a media source. It is _highly recommended_ that an object\r\n     *        or array of objects is used here, so that source selection\r\n     *        algorithms can take the `type` into account.\r\n     *\r\n     *        If not provided, this method acts as a getter.\r\n     * @param {boolean} isRetry\r\n     *        Indicates whether this is being called internally as a result of a retry\r\n     *\r\n     * @return {string|undefined}\r\n     *         If the `source` argument is missing, returns the current source\r\n     *         URL. Otherwise, returns nothing/undefined.\r\n     */\r\n    ;\r\n\r\n    _proto.handleSrc_ = function handleSrc_(source, isRetry) {\r\n      var _this15 = this;\r\n\r\n      // getter usage\r\n      if (typeof source === 'undefined') {\r\n        return this.cache_.src || '';\r\n      } // Reset retry behavior for new source\r\n\r\n\r\n      if (this.resetRetryOnError_) {\r\n        this.resetRetryOnError_();\r\n      } // filter out invalid sources and turn our source into\r\n      // an array of source objects\r\n\r\n\r\n      var sources = filterSource(source); // if a source was passed in then it is invalid because\r\n      // it was filtered to a zero length Array. So we have to\r\n      // show an error\r\n\r\n      if (!sources.length) {\r\n        this.setTimeout(function () {\r\n          this.error({\r\n            code: 4,\r\n            message: this.options_.notSupportedMessage\r\n          });\r\n        }, 0);\r\n        return;\r\n      } // initial sources\r\n\r\n\r\n      this.changingSrc_ = true; // Only update the cached source list if we are not retrying a new source after error,\r\n      // since in that case we want to include the failed source(s) in the cache\r\n\r\n      if (!isRetry) {\r\n        this.cache_.sources = sources;\r\n      }\r\n\r\n      this.updateSourceCaches_(sources[0]); // middlewareSource is the source after it has been changed by middleware\r\n\r\n      setSource(this, sources[0], function (middlewareSource, mws) {\r\n        _this15.middleware_ = mws; // since sourceSet is async we have to update the cache again after we select a source since\r\n        // the source that is selected could be out of order from the cache update above this callback.\r\n\r\n        if (!isRetry) {\r\n          _this15.cache_.sources = sources;\r\n        }\r\n\r\n        _this15.updateSourceCaches_(middlewareSource);\r\n\r\n        var err = _this15.src_(middlewareSource);\r\n\r\n        if (err) {\r\n          if (sources.length > 1) {\r\n            return _this15.handleSrc_(sources.slice(1));\r\n          }\r\n\r\n          _this15.changingSrc_ = false; // We need to wrap this in a timeout to give folks a chance to add error event handlers\r\n\r\n          _this15.setTimeout(function () {\r\n            this.error({\r\n              code: 4,\r\n              message: this.options_.notSupportedMessage\r\n            });\r\n          }, 0); // we could not find an appropriate tech, but let's still notify the delegate that this is it\r\n          // this needs a better comment about why this is needed\r\n\r\n\r\n          _this15.triggerReady();\r\n\r\n          return;\r\n        }\r\n\r\n        setTech(mws, _this15.tech_);\r\n      }); // Try another available source if this one fails before playback.\r\n\r\n      if (this.options_.retryOnError && sources.length > 1) {\r\n        var retry = function retry() {\r\n          // Remove the error modal\r\n          _this15.error(null);\r\n\r\n          _this15.handleSrc_(sources.slice(1), true);\r\n        };\r\n\r\n        var stopListeningForErrors = function stopListeningForErrors() {\r\n          _this15.off('error', retry);\r\n        };\r\n\r\n        this.one('error', retry);\r\n        this.one('playing', stopListeningForErrors);\r\n\r\n        this.resetRetryOnError_ = function () {\r\n          _this15.off('error', retry);\r\n\r\n          _this15.off('playing', stopListeningForErrors);\r\n        };\r\n      }\r\n    }\r\n    /**\r\n     * Get or set the video source.\r\n     *\r\n     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\r\n     *        A SourceObject, an array of SourceObjects, or a string referencing\r\n     *        a URL to a media source. It is _highly recommended_ that an object\r\n     *        or array of objects is used here, so that source selection\r\n     *        algorithms can take the `type` into account.\r\n     *\r\n     *        If not provided, this method acts as a getter.\r\n     *\r\n     * @return {string|undefined}\r\n     *         If the `source` argument is missing, returns the current source\r\n     *         URL. Otherwise, returns nothing/undefined.\r\n     */\r\n    ;\r\n\r\n    _proto.src = function src(source) {\r\n      return this.handleSrc_(source, false);\r\n    }\r\n    /**\r\n     * Set the source object on the tech, returns a boolean that indicates whether\r\n     * there is a tech that can play the source or not\r\n     *\r\n     * @param {Tech~SourceObject} source\r\n     *        The source object to set on the Tech\r\n     *\r\n     * @return {boolean}\r\n     *         - True if there is no Tech to playback this source\r\n     *         - False otherwise\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.src_ = function src_(source) {\r\n      var _this16 = this;\r\n\r\n      var sourceTech = this.selectSource([source]);\r\n\r\n      if (!sourceTech) {\r\n        return true;\r\n      }\r\n\r\n      if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\r\n        this.changingSrc_ = true; // load this technology with the chosen source\r\n\r\n        this.loadTech_(sourceTech.tech, sourceTech.source);\r\n        this.tech_.ready(function () {\r\n          _this16.changingSrc_ = false;\r\n        });\r\n        return false;\r\n      } // wait until the tech is ready to set the source\r\n      // and set it synchronously if possible (#2326)\r\n\r\n\r\n      this.ready(function () {\r\n        // The setSource tech method was added with source handlers\r\n        // so older techs won't support it\r\n        // We need to check the direct prototype for the case where subclasses\r\n        // of the tech do not support source handlers\r\n        if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\r\n          this.techCall_('setSource', source);\r\n        } else {\r\n          this.techCall_('src', source.src);\r\n        }\r\n\r\n        this.changingSrc_ = false;\r\n      }, true);\r\n      return false;\r\n    }\r\n    /**\r\n     * Begin loading the src data.\r\n     */\r\n    ;\r\n\r\n    _proto.load = function load() {\r\n      this.techCall_('load');\r\n    }\r\n    /**\r\n     * Reset the player. Loads the first tech in the techOrder,\r\n     * removes all the text tracks in the existing `tech`,\r\n     * and calls `reset` on the `tech`.\r\n     */\r\n    ;\r\n\r\n    _proto.reset = function reset() {\r\n      var _this17 = this;\r\n\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (this.paused() || !PromiseClass) {\r\n        this.doReset_();\r\n      } else {\r\n        var playPromise = this.play();\r\n        silencePromise(playPromise.then(function () {\r\n          return _this17.doReset_();\r\n        }));\r\n      }\r\n    };\r\n\r\n    _proto.doReset_ = function doReset_() {\r\n      if (this.tech_) {\r\n        this.tech_.clearTracks('text');\r\n      }\r\n\r\n      this.resetCache_();\r\n      this.poster('');\r\n      this.loadTech_(this.options_.techOrder[0], null);\r\n      this.techCall_('reset');\r\n      this.resetControlBarUI_();\r\n\r\n      if (isEvented(this)) {\r\n        this.trigger('playerreset');\r\n      }\r\n    }\r\n    /**\r\n     * Reset Control Bar's UI by calling sub-methods that reset\r\n     * all of Control Bar's components\r\n     */\r\n    ;\r\n\r\n    _proto.resetControlBarUI_ = function resetControlBarUI_() {\r\n      this.resetProgressBar_();\r\n      this.resetPlaybackRate_();\r\n      this.resetVolumeBar_();\r\n    }\r\n    /**\r\n     * Reset tech's progress so progress bar is reset in the UI\r\n     */\r\n    ;\r\n\r\n    _proto.resetProgressBar_ = function resetProgressBar_() {\r\n      this.currentTime(0);\r\n\r\n      var _ref3 = this.controlBar || {},\r\n          durationDisplay = _ref3.durationDisplay,\r\n          remainingTimeDisplay = _ref3.remainingTimeDisplay;\r\n\r\n      if (durationDisplay) {\r\n        durationDisplay.updateContent();\r\n      }\r\n\r\n      if (remainingTimeDisplay) {\r\n        remainingTimeDisplay.updateContent();\r\n      }\r\n    }\r\n    /**\r\n     * Reset Playback ratio\r\n     */\r\n    ;\r\n\r\n    _proto.resetPlaybackRate_ = function resetPlaybackRate_() {\r\n      this.playbackRate(this.defaultPlaybackRate());\r\n      this.handleTechRateChange_();\r\n    }\r\n    /**\r\n     * Reset Volume bar\r\n     */\r\n    ;\r\n\r\n    _proto.resetVolumeBar_ = function resetVolumeBar_() {\r\n      this.volume(1.0);\r\n      this.trigger('volumechange');\r\n    }\r\n    /**\r\n     * Returns all of the current source objects.\r\n     *\r\n     * @return {Tech~SourceObject[]}\r\n     *         The current source objects\r\n     */\r\n    ;\r\n\r\n    _proto.currentSources = function currentSources() {\r\n      var source = this.currentSource();\r\n      var sources = []; // assume `{}` or `{ src }`\r\n\r\n      if (Object.keys(source).length !== 0) {\r\n        sources.push(source);\r\n      }\r\n\r\n      return this.cache_.sources || sources;\r\n    }\r\n    /**\r\n     * Returns the current source object.\r\n     *\r\n     * @return {Tech~SourceObject}\r\n     *         The current source object\r\n     */\r\n    ;\r\n\r\n    _proto.currentSource = function currentSource() {\r\n      return this.cache_.source || {};\r\n    }\r\n    /**\r\n     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\r\n     * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.\r\n     *\r\n     * @return {string}\r\n     *         The current source\r\n     */\r\n    ;\r\n\r\n    _proto.currentSrc = function currentSrc() {\r\n      return this.currentSource() && this.currentSource().src || '';\r\n    }\r\n    /**\r\n     * Get the current source type e.g. video/mp4\r\n     * This can allow you rebuild the current source object so that you could load the same\r\n     * source and tech later\r\n     *\r\n     * @return {string}\r\n     *         The source MIME type\r\n     */\r\n    ;\r\n\r\n    _proto.currentType = function currentType() {\r\n      return this.currentSource() && this.currentSource().type || '';\r\n    }\r\n    /**\r\n     * Get or set the preload attribute\r\n     *\r\n     * @param {boolean} [value]\r\n     *        - true means that we should preload\r\n     *        - false means that we should not preload\r\n     *\r\n     * @return {string}\r\n     *         The preload attribute value when getting\r\n     */\r\n    ;\r\n\r\n    _proto.preload = function preload(value) {\r\n      if (value !== undefined) {\r\n        this.techCall_('setPreload', value);\r\n        this.options_.preload = value;\r\n        return;\r\n      }\r\n\r\n      return this.techGet_('preload');\r\n    }\r\n    /**\r\n     * Get or set the autoplay option. When this is a boolean it will\r\n     * modify the attribute on the tech. When this is a string the attribute on\r\n     * the tech will be removed and `Player` will handle autoplay on loadstarts.\r\n     *\r\n     * @param {boolean|string} [value]\r\n     *        - true: autoplay using the browser behavior\r\n     *        - false: do not autoplay\r\n     *        - 'play': call play() on every loadstart\r\n     *        - 'muted': call muted() then play() on every loadstart\r\n     *        - 'any': call play() on every loadstart. if that fails call muted() then play().\r\n     *        - *: values other than those listed here will be set `autoplay` to true\r\n     *\r\n     * @return {boolean|string}\r\n     *         The current value of autoplay when getting\r\n     */\r\n    ;\r\n\r\n    _proto.autoplay = function autoplay(value) {\r\n      // getter usage\r\n      if (value === undefined) {\r\n        return this.options_.autoplay || false;\r\n      }\r\n\r\n      var techAutoplay; // if the value is a valid string set it to that, or normalize `true` to 'play', if need be\r\n\r\n      if (typeof value === 'string' && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {\r\n        this.options_.autoplay = value;\r\n        this.manualAutoplay_(typeof value === 'string' ? value : 'play');\r\n        techAutoplay = false; // any falsy value sets autoplay to false in the browser,\r\n        // lets do the same\r\n      } else if (!value) {\r\n        this.options_.autoplay = false; // any other value (ie truthy) sets autoplay to true\r\n      } else {\r\n        this.options_.autoplay = true;\r\n      }\r\n\r\n      techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay; // if we don't have a tech then we do not queue up\r\n      // a setAutoplay call on tech ready. We do this because the\r\n      // autoplay option will be passed in the constructor and we\r\n      // do not need to set it twice\r\n\r\n      if (this.tech_) {\r\n        this.techCall_('setAutoplay', techAutoplay);\r\n      }\r\n    }\r\n    /**\r\n     * Set or unset the playsinline attribute.\r\n     * Playsinline tells the browser that non-fullscreen playback is preferred.\r\n     *\r\n     * @param {boolean} [value]\r\n     *        - true means that we should try to play inline by default\r\n     *        - false means that we should use the browser's default playback mode,\r\n     *          which in most cases is inline. iOS Safari is a notable exception\r\n     *          and plays fullscreen by default.\r\n     *\r\n     * @return {string|Player}\r\n     *         - the current value of playsinline\r\n     *         - the player when setting\r\n     *\r\n     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\r\n     */\r\n    ;\r\n\r\n    _proto.playsinline = function playsinline(value) {\r\n      if (value !== undefined) {\r\n        this.techCall_('setPlaysinline', value);\r\n        this.options_.playsinline = value;\r\n        return this;\r\n      }\r\n\r\n      return this.techGet_('playsinline');\r\n    }\r\n    /**\r\n     * Get or set the loop attribute on the video element.\r\n     *\r\n     * @param {boolean} [value]\r\n     *        - true means that we should loop the video\r\n     *        - false means that we should not loop the video\r\n     *\r\n     * @return {boolean}\r\n     *         The current value of loop when getting\r\n     */\r\n    ;\r\n\r\n    _proto.loop = function loop(value) {\r\n      if (value !== undefined) {\r\n        this.techCall_('setLoop', value);\r\n        this.options_.loop = value;\r\n        return;\r\n      }\r\n\r\n      return this.techGet_('loop');\r\n    }\r\n    /**\r\n     * Get or set the poster image source url\r\n     *\r\n     * @fires Player#posterchange\r\n     *\r\n     * @param {string} [src]\r\n     *        Poster image source URL\r\n     *\r\n     * @return {string}\r\n     *         The current value of poster when getting\r\n     */\r\n    ;\r\n\r\n    _proto.poster = function poster(src) {\r\n      if (src === undefined) {\r\n        return this.poster_;\r\n      } // The correct way to remove a poster is to set as an empty string\r\n      // other falsey values will throw errors\r\n\r\n\r\n      if (!src) {\r\n        src = '';\r\n      }\r\n\r\n      if (src === this.poster_) {\r\n        return;\r\n      } // update the internal poster variable\r\n\r\n\r\n      this.poster_ = src; // update the tech's poster\r\n\r\n      this.techCall_('setPoster', src);\r\n      this.isPosterFromTech_ = false; // alert components that the poster has been set\r\n\r\n      /**\r\n       * This event fires when the poster image is changed on the player.\r\n       *\r\n       * @event Player#posterchange\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('posterchange');\r\n    }\r\n    /**\r\n     * Some techs (e.g. YouTube) can provide a poster source in an\r\n     * asynchronous way. We want the poster component to use this\r\n     * poster source so that it covers up the tech's controls.\r\n     * (YouTube's play button). However we only want to use this\r\n     * source if the player user hasn't set a poster through\r\n     * the normal APIs.\r\n     *\r\n     * @fires Player#posterchange\r\n     * @listens Tech#posterchange\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleTechPosterChange_ = function handleTechPosterChange_() {\r\n      if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\r\n        var newPoster = this.tech_.poster() || '';\r\n\r\n        if (newPoster !== this.poster_) {\r\n          this.poster_ = newPoster;\r\n          this.isPosterFromTech_ = true; // Let components know the poster has changed\r\n\r\n          this.trigger('posterchange');\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Get or set whether or not the controls are showing.\r\n     *\r\n     * @fires Player#controlsenabled\r\n     *\r\n     * @param {boolean} [bool]\r\n     *        - true to turn controls on\r\n     *        - false to turn controls off\r\n     *\r\n     * @return {boolean}\r\n     *         The current value of controls when getting\r\n     */\r\n    ;\r\n\r\n    _proto.controls = function controls(bool) {\r\n      if (bool === undefined) {\r\n        return !!this.controls_;\r\n      }\r\n\r\n      bool = !!bool; // Don't trigger a change event unless it actually changed\r\n\r\n      if (this.controls_ === bool) {\r\n        return;\r\n      }\r\n\r\n      this.controls_ = bool;\r\n\r\n      if (this.usingNativeControls()) {\r\n        this.techCall_('setControls', bool);\r\n      }\r\n\r\n      if (this.controls_) {\r\n        this.removeClass('vjs-controls-disabled');\r\n        this.addClass('vjs-controls-enabled');\r\n        /**\r\n         * @event Player#controlsenabled\r\n         * @type {EventTarget~Event}\r\n         */\r\n\r\n        this.trigger('controlsenabled');\r\n\r\n        if (!this.usingNativeControls()) {\r\n          this.addTechControlsListeners_();\r\n        }\r\n      } else {\r\n        this.removeClass('vjs-controls-enabled');\r\n        this.addClass('vjs-controls-disabled');\r\n        /**\r\n         * @event Player#controlsdisabled\r\n         * @type {EventTarget~Event}\r\n         */\r\n\r\n        this.trigger('controlsdisabled');\r\n\r\n        if (!this.usingNativeControls()) {\r\n          this.removeTechControlsListeners_();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Toggle native controls on/off. Native controls are the controls built into\r\n     * devices (e.g. default iPhone controls) or other techs\r\n     * (e.g. Vimeo Controls)\r\n     * **This should only be set by the current tech, because only the tech knows\r\n     * if it can support native controls**\r\n     *\r\n     * @fires Player#usingnativecontrols\r\n     * @fires Player#usingcustomcontrols\r\n     *\r\n     * @param {boolean} [bool]\r\n     *        - true to turn native controls on\r\n     *        - false to turn native controls off\r\n     *\r\n     * @return {boolean}\r\n     *         The current value of native controls when getting\r\n     */\r\n    ;\r\n\r\n    _proto.usingNativeControls = function usingNativeControls(bool) {\r\n      if (bool === undefined) {\r\n        return !!this.usingNativeControls_;\r\n      }\r\n\r\n      bool = !!bool; // Don't trigger a change event unless it actually changed\r\n\r\n      if (this.usingNativeControls_ === bool) {\r\n        return;\r\n      }\r\n\r\n      this.usingNativeControls_ = bool;\r\n\r\n      if (this.usingNativeControls_) {\r\n        this.addClass('vjs-using-native-controls');\r\n        /**\r\n         * player is using the native device controls\r\n         *\r\n         * @event Player#usingnativecontrols\r\n         * @type {EventTarget~Event}\r\n         */\r\n\r\n        this.trigger('usingnativecontrols');\r\n      } else {\r\n        this.removeClass('vjs-using-native-controls');\r\n        /**\r\n         * player is using the custom HTML controls\r\n         *\r\n         * @event Player#usingcustomcontrols\r\n         * @type {EventTarget~Event}\r\n         */\r\n\r\n        this.trigger('usingcustomcontrols');\r\n      }\r\n    }\r\n    /**\r\n     * Set or get the current MediaError\r\n     *\r\n     * @fires Player#error\r\n     *\r\n     * @param  {MediaError|string|number} [err]\r\n     *         A MediaError or a string/number to be turned\r\n     *         into a MediaError\r\n     *\r\n     * @return {MediaError|null}\r\n     *         The current MediaError when getting (or null)\r\n     */\r\n    ;\r\n\r\n    _proto.error = function error(err) {\r\n      var _this18 = this;\r\n\r\n      if (err === undefined) {\r\n        return this.error_ || null;\r\n      } // allow hooks to modify error object\r\n\r\n\r\n      hooks('beforeerror').forEach(function (hookFunction) {\r\n        var newErr = hookFunction(_this18, err);\r\n\r\n        if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === 'string' || typeof newErr === 'number' || newErr === null)) {\r\n          _this18.log.error('please return a value that MediaError expects in beforeerror hooks');\r\n\r\n          return;\r\n        }\r\n\r\n        err = newErr;\r\n      }); // Suppress the first error message for no compatible source until\r\n      // user interaction\r\n\r\n      if (this.options_.suppressNotSupportedError && err && err.code === 4) {\r\n        var triggerSuppressedError = function triggerSuppressedError() {\r\n          this.error(err);\r\n        };\r\n\r\n        this.options_.suppressNotSupportedError = false;\r\n        this.any(['click', 'touchstart'], triggerSuppressedError);\r\n        this.one('loadstart', function () {\r\n          this.off(['click', 'touchstart'], triggerSuppressedError);\r\n        });\r\n        return;\r\n      } // restoring to default\r\n\r\n\r\n      if (err === null) {\r\n        this.error_ = err;\r\n        this.removeClass('vjs-error');\r\n\r\n        if (this.errorDisplay) {\r\n          this.errorDisplay.close();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      this.error_ = new MediaError(err); // add the vjs-error classname to the player\r\n\r\n      this.addClass('vjs-error'); // log the name of the error type and any message\r\n      // IE11 logs \"[object object]\" and required you to expand message to see error object\r\n\r\n      log$1.error(\"(CODE:\" + this.error_.code + \" \" + MediaError.errorTypes[this.error_.code] + \")\", this.error_.message, this.error_);\r\n      /**\r\n       * @event Player#error\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('error'); // notify hooks of the per player error\r\n\r\n      hooks('error').forEach(function (hookFunction) {\r\n        return hookFunction(_this18, _this18.error_);\r\n      });\r\n      return;\r\n    }\r\n    /**\r\n     * Report user activity\r\n     *\r\n     * @param {Object} event\r\n     *        Event object\r\n     */\r\n    ;\r\n\r\n    _proto.reportUserActivity = function reportUserActivity(event) {\r\n      this.userActivity_ = true;\r\n    }\r\n    /**\r\n     * Get/set if user is active\r\n     *\r\n     * @fires Player#useractive\r\n     * @fires Player#userinactive\r\n     *\r\n     * @param {boolean} [bool]\r\n     *        - true if the user is active\r\n     *        - false if the user is inactive\r\n     *\r\n     * @return {boolean}\r\n     *         The current value of userActive when getting\r\n     */\r\n    ;\r\n\r\n    _proto.userActive = function userActive(bool) {\r\n      if (bool === undefined) {\r\n        return this.userActive_;\r\n      }\r\n\r\n      bool = !!bool;\r\n\r\n      if (bool === this.userActive_) {\r\n        return;\r\n      }\r\n\r\n      this.userActive_ = bool;\r\n\r\n      if (this.userActive_) {\r\n        this.userActivity_ = true;\r\n        this.removeClass('vjs-user-inactive');\r\n        this.addClass('vjs-user-active');\r\n        /**\r\n         * @event Player#useractive\r\n         * @type {EventTarget~Event}\r\n         */\r\n\r\n        this.trigger('useractive');\r\n        return;\r\n      } // Chrome/Safari/IE have bugs where when you change the cursor it can\r\n      // trigger a mousemove event. This causes an issue when you're hiding\r\n      // the cursor when the user is inactive, and a mousemove signals user\r\n      // activity. Making it impossible to go into inactive mode. Specifically\r\n      // this happens in fullscreen when we really need to hide the cursor.\r\n      //\r\n      // When this gets resolved in ALL browsers it can be removed\r\n      // https://code.google.com/p/chromium/issues/detail?id=103041\r\n\r\n\r\n      if (this.tech_) {\r\n        this.tech_.one('mousemove', function (e) {\r\n          e.stopPropagation();\r\n          e.preventDefault();\r\n        });\r\n      }\r\n\r\n      this.userActivity_ = false;\r\n      this.removeClass('vjs-user-active');\r\n      this.addClass('vjs-user-inactive');\r\n      /**\r\n       * @event Player#userinactive\r\n       * @type {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('userinactive');\r\n    }\r\n    /**\r\n     * Listen for user activity based on timeout value\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.listenForUserActivity_ = function listenForUserActivity_() {\r\n      var mouseInProgress;\r\n      var lastMoveX;\r\n      var lastMoveY;\r\n      var handleActivity = bind(this, this.reportUserActivity);\r\n\r\n      var handleMouseMove = function handleMouseMove(e) {\r\n        // #1068 - Prevent mousemove spamming\r\n        // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\r\n        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\r\n          lastMoveX = e.screenX;\r\n          lastMoveY = e.screenY;\r\n          handleActivity();\r\n        }\r\n      };\r\n\r\n      var handleMouseDown = function handleMouseDown() {\r\n        handleActivity(); // For as long as the they are touching the device or have their mouse down,\r\n        // we consider them active even if they're not moving their finger or mouse.\r\n        // So we want to continue to update that they are active\r\n\r\n        this.clearInterval(mouseInProgress); // Setting userActivity=true now and setting the interval to the same time\r\n        // as the activityCheck interval (250) should ensure we never miss the\r\n        // next activityCheck\r\n\r\n        mouseInProgress = this.setInterval(handleActivity, 250);\r\n      };\r\n\r\n      var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave(event) {\r\n        handleActivity(); // Stop the interval that maintains activity if the mouse/touch is down\r\n\r\n        this.clearInterval(mouseInProgress);\r\n      }; // Any mouse movement will be considered user activity\r\n\r\n\r\n      this.on('mousedown', handleMouseDown);\r\n      this.on('mousemove', handleMouseMove);\r\n      this.on('mouseup', handleMouseUpAndMouseLeave);\r\n      this.on('mouseleave', handleMouseUpAndMouseLeave);\r\n      var controlBar = this.getChild('controlBar'); // Fixes bug on Android & iOS where when tapping progressBar (when control bar is displayed)\r\n      // controlBar would no longer be hidden by default timeout.\r\n\r\n      if (controlBar && !IS_IOS && !IS_ANDROID) {\r\n        controlBar.on('mouseenter', function (event) {\r\n          if (this.player().options_.inactivityTimeout !== 0) {\r\n            this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;\r\n          }\r\n\r\n          this.player().options_.inactivityTimeout = 0;\r\n        });\r\n        controlBar.on('mouseleave', function (event) {\r\n          this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;\r\n        });\r\n      } // Listen for keyboard navigation\r\n      // Shouldn't need to use inProgress interval because of key repeat\r\n\r\n\r\n      this.on('keydown', handleActivity);\r\n      this.on('keyup', handleActivity); // Run an interval every 250 milliseconds instead of stuffing everything into\r\n      // the mousemove/touchmove function itself, to prevent performance degradation.\r\n      // `this.reportUserActivity` simply sets this.userActivity_ to true, which\r\n      // then gets picked up by this loop\r\n      // http://ejohn.org/blog/learning-from-twitter/\r\n\r\n      var inactivityTimeout;\r\n      this.setInterval(function () {\r\n        // Check to see if mouse/touch activity has happened\r\n        if (!this.userActivity_) {\r\n          return;\r\n        } // Reset the activity tracker\r\n\r\n\r\n        this.userActivity_ = false; // If the user state was inactive, set the state to active\r\n\r\n        this.userActive(true); // Clear any existing inactivity timeout to start the timer over\r\n\r\n        this.clearTimeout(inactivityTimeout);\r\n        var timeout = this.options_.inactivityTimeout;\r\n\r\n        if (timeout <= 0) {\r\n          return;\r\n        } // In <timeout> milliseconds, if no more activity has occurred the\r\n        // user will be considered inactive\r\n\r\n\r\n        inactivityTimeout = this.setTimeout(function () {\r\n          // Protect against the case where the inactivityTimeout can trigger just\r\n          // before the next user activity is picked up by the activity check loop\r\n          // causing a flicker\r\n          if (!this.userActivity_) {\r\n            this.userActive(false);\r\n          }\r\n        }, timeout);\r\n      }, 250);\r\n    }\r\n    /**\r\n     * Gets or sets the current playback rate. A playback rate of\r\n     * 1.0 represents normal speed and 0.5 would indicate half-speed\r\n     * playback, for instance.\r\n     *\r\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\r\n     *\r\n     * @param {number} [rate]\r\n     *       New playback rate to set.\r\n     *\r\n     * @return {number}\r\n     *         The current playback rate when getting or 1.0\r\n     */\r\n    ;\r\n\r\n    _proto.playbackRate = function playbackRate(rate) {\r\n      if (rate !== undefined) {\r\n        // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\r\n        // that is registered above\r\n        this.techCall_('setPlaybackRate', rate);\r\n        return;\r\n      }\r\n\r\n      if (this.tech_ && this.tech_.featuresPlaybackRate) {\r\n        return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\r\n      }\r\n\r\n      return 1.0;\r\n    }\r\n    /**\r\n     * Gets or sets the current default playback rate. A default playback rate of\r\n     * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\r\n     * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not\r\n     * not the current playbackRate.\r\n     *\r\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\r\n     *\r\n     * @param {number} [rate]\r\n     *       New default playback rate to set.\r\n     *\r\n     * @return {number|Player}\r\n     *         - The default playback rate when getting or 1.0\r\n     *         - the player when setting\r\n     */\r\n    ;\r\n\r\n    _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {\r\n      if (rate !== undefined) {\r\n        return this.techCall_('setDefaultPlaybackRate', rate);\r\n      }\r\n\r\n      if (this.tech_ && this.tech_.featuresPlaybackRate) {\r\n        return this.techGet_('defaultPlaybackRate');\r\n      }\r\n\r\n      return 1.0;\r\n    }\r\n    /**\r\n     * Gets or sets the audio flag\r\n     *\r\n     * @param {boolean} bool\r\n     *        - true signals that this is an audio player\r\n     *        - false signals that this is not an audio player\r\n     *\r\n     * @return {boolean}\r\n     *         The current value of isAudio when getting\r\n     */\r\n    ;\r\n\r\n    _proto.isAudio = function isAudio(bool) {\r\n      if (bool !== undefined) {\r\n        this.isAudio_ = !!bool;\r\n        return;\r\n      }\r\n\r\n      return !!this.isAudio_;\r\n    };\r\n\r\n    _proto.enableAudioOnlyUI_ = function enableAudioOnlyUI_() {\r\n      var _this19 = this;\r\n\r\n      // Update styling immediately to show the control bar so we can get its height\r\n      this.addClass('vjs-audio-only-mode');\r\n      var playerChildren = this.children();\r\n      var controlBar = this.getChild('ControlBar');\r\n      var controlBarHeight = controlBar && controlBar.currentHeight(); // Hide all player components except the control bar. Control bar components\r\n      // needed only for video are hidden with CSS\r\n\r\n      playerChildren.forEach(function (child) {\r\n        if (child === controlBar) {\r\n          return;\r\n        }\r\n\r\n        if (child.el_ && !child.hasClass('vjs-hidden')) {\r\n          child.hide();\r\n\r\n          _this19.audioOnlyCache_.hiddenChildren.push(child);\r\n        }\r\n      });\r\n      this.audioOnlyCache_.playerHeight = this.currentHeight(); // Set the player height the same as the control bar\r\n\r\n      this.height(controlBarHeight);\r\n      this.trigger('audioonlymodechange');\r\n    };\r\n\r\n    _proto.disableAudioOnlyUI_ = function disableAudioOnlyUI_() {\r\n      this.removeClass('vjs-audio-only-mode'); // Show player components that were previously hidden\r\n\r\n      this.audioOnlyCache_.hiddenChildren.forEach(function (child) {\r\n        return child.show();\r\n      }); // Reset player height\r\n\r\n      this.height(this.audioOnlyCache_.playerHeight);\r\n      this.trigger('audioonlymodechange');\r\n    }\r\n    /**\r\n     * Get the current audioOnlyMode state or set audioOnlyMode to true or false.\r\n     *\r\n     * Setting this to `true` will hide all player components except the control bar,\r\n     * as well as control bar components needed only for video.\r\n     *\r\n     * @param {boolean} [value]\r\n     *         The value to set audioOnlyMode to.\r\n     *\r\n     * @return {Promise|boolean}\r\n     *        A Promise is returned when setting the state, and a boolean when getting\r\n     *        the present state\r\n     */\r\n    ;\r\n\r\n    _proto.audioOnlyMode = function audioOnlyMode(value) {\r\n      var _this20 = this;\r\n\r\n      if (typeof value !== 'boolean' || value === this.audioOnlyMode_) {\r\n        return this.audioOnlyMode_;\r\n      }\r\n\r\n      this.audioOnlyMode_ = value;\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (PromiseClass) {\r\n        // Enable Audio Only Mode\r\n        if (value) {\r\n          var exitPromises = []; // Fullscreen and PiP are not supported in audioOnlyMode, so exit if we need to.\r\n\r\n          if (this.isInPictureInPicture()) {\r\n            exitPromises.push(this.exitPictureInPicture());\r\n          }\r\n\r\n          if (this.isFullscreen()) {\r\n            exitPromises.push(this.exitFullscreen());\r\n          }\r\n\r\n          if (this.audioPosterMode()) {\r\n            exitPromises.push(this.audioPosterMode(false));\r\n          }\r\n\r\n          return PromiseClass.all(exitPromises).then(function () {\r\n            return _this20.enableAudioOnlyUI_();\r\n          });\r\n        } // Disable Audio Only Mode\r\n\r\n\r\n        return PromiseClass.resolve().then(function () {\r\n          return _this20.disableAudioOnlyUI_();\r\n        });\r\n      }\r\n\r\n      if (value) {\r\n        if (this.isInPictureInPicture()) {\r\n          this.exitPictureInPicture();\r\n        }\r\n\r\n        if (this.isFullscreen()) {\r\n          this.exitFullscreen();\r\n        }\r\n\r\n        this.enableAudioOnlyUI_();\r\n      } else {\r\n        this.disableAudioOnlyUI_();\r\n      }\r\n    };\r\n\r\n    _proto.enablePosterModeUI_ = function enablePosterModeUI_() {\r\n      // Hide the video element and show the poster image to enable posterModeUI\r\n      var tech = this.tech_ && this.tech_;\r\n      tech.hide();\r\n      this.addClass('vjs-audio-poster-mode');\r\n      this.trigger('audiopostermodechange');\r\n    };\r\n\r\n    _proto.disablePosterModeUI_ = function disablePosterModeUI_() {\r\n      // Show the video element and hide the poster image to disable posterModeUI\r\n      var tech = this.tech_ && this.tech_;\r\n      tech.show();\r\n      this.removeClass('vjs-audio-poster-mode');\r\n      this.trigger('audiopostermodechange');\r\n    }\r\n    /**\r\n     * Get the current audioPosterMode state or set audioPosterMode to true or false\r\n     *\r\n     * @param {boolean} [value]\r\n     *         The value to set audioPosterMode to.\r\n     *\r\n     * @return {Promise|boolean}\r\n     *         A Promise is returned when setting the state, and a boolean when getting\r\n     *        the present state\r\n     */\r\n    ;\r\n\r\n    _proto.audioPosterMode = function audioPosterMode(value) {\r\n      var _this21 = this;\r\n\r\n      if (typeof value !== 'boolean' || value === this.audioPosterMode_) {\r\n        return this.audioPosterMode_;\r\n      }\r\n\r\n      this.audioPosterMode_ = value;\r\n      var PromiseClass = this.options_.Promise || window.Promise;\r\n\r\n      if (PromiseClass) {\r\n        if (value) {\r\n          if (this.audioOnlyMode()) {\r\n            var audioOnlyModePromise = this.audioOnlyMode(false);\r\n            return audioOnlyModePromise.then(function () {\r\n              // enable audio poster mode after audio only mode is disabled\r\n              _this21.enablePosterModeUI_();\r\n            });\r\n          }\r\n\r\n          return PromiseClass.resolve().then(function () {\r\n            // enable audio poster mode\r\n            _this21.enablePosterModeUI_();\r\n          });\r\n        }\r\n\r\n        return PromiseClass.resolve().then(function () {\r\n          // disable audio poster mode\r\n          _this21.disablePosterModeUI_();\r\n        });\r\n      }\r\n\r\n      if (value) {\r\n        if (this.audioOnlyMode()) {\r\n          this.audioOnlyMode(false);\r\n        }\r\n\r\n        this.enablePosterModeUI_();\r\n        return;\r\n      }\r\n\r\n      this.disablePosterModeUI_();\r\n    }\r\n    /**\r\n     * A helper method for adding a {@link TextTrack} to our\r\n     * {@link TextTrackList}.\r\n     *\r\n     * In addition to the W3C settings we allow adding additional info through options.\r\n     *\r\n     * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\r\n     *\r\n     * @param {string} [kind]\r\n     *        the kind of TextTrack you are adding\r\n     *\r\n     * @param {string} [label]\r\n     *        the label to give the TextTrack label\r\n     *\r\n     * @param {string} [language]\r\n     *        the language to set on the TextTrack\r\n     *\r\n     * @return {TextTrack|undefined}\r\n     *         the TextTrack that was added or undefined\r\n     *         if there is no tech\r\n     */\r\n    ;\r\n\r\n    _proto.addTextTrack = function addTextTrack(kind, label, language) {\r\n      if (this.tech_) {\r\n        return this.tech_.addTextTrack(kind, label, language);\r\n      }\r\n    }\r\n    /**\r\n     * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.\r\n     * When manualCleanup is set to false, the track will be automatically removed\r\n     * on source changes.\r\n     *\r\n     * @param {Object} options\r\n     *        Options to pass to {@link HTMLTrackElement} during creation. See\r\n     *        {@link HTMLTrackElement} for object properties that you should use.\r\n     *\r\n     * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\r\n     *                                       removed on a source change\r\n     *\r\n     * @return {HtmlTrackElement}\r\n     *         the HTMLTrackElement that was created and added\r\n     *         to the HtmlTrackElementList and the remote\r\n     *         TextTrackList\r\n     *\r\n     * @deprecated The default value of the \"manualCleanup\" parameter will default\r\n     *             to \"false\" in upcoming versions of Video.js\r\n     */\r\n    ;\r\n\r\n    _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\r\n      if (this.tech_) {\r\n        return this.tech_.addRemoteTextTrack(options, manualCleanup);\r\n      }\r\n    }\r\n    /**\r\n     * Remove a remote {@link TextTrack} from the respective\r\n     * {@link TextTrackList} and {@link HtmlTrackElementList}.\r\n     *\r\n     * @param {Object} track\r\n     *        Remote {@link TextTrack} to remove\r\n     *\r\n     * @return {undefined}\r\n     *         does not return anything\r\n     */\r\n    ;\r\n\r\n    _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj) {\r\n      if (obj === void 0) {\r\n        obj = {};\r\n      }\r\n\r\n      var _obj = obj,\r\n          track = _obj.track;\r\n\r\n      if (!track) {\r\n        track = obj;\r\n      } // destructure the input into an object with a track argument, defaulting to arguments[0]\r\n      // default the whole argument to an empty object if nothing was passed in\r\n\r\n\r\n      if (this.tech_) {\r\n        return this.tech_.removeRemoteTextTrack(track);\r\n      }\r\n    }\r\n    /**\r\n     * Gets available media playback quality metrics as specified by the W3C's Media\r\n     * Playback Quality API.\r\n     *\r\n     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\r\n     *\r\n     * @return {Object|undefined}\r\n     *         An object with supported media playback quality metrics or undefined if there\r\n     *         is no tech or the tech does not support it.\r\n     */\r\n    ;\r\n\r\n    _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\r\n      return this.techGet_('getVideoPlaybackQuality');\r\n    }\r\n    /**\r\n     * Get video width\r\n     *\r\n     * @return {number}\r\n     *         current video width\r\n     */\r\n    ;\r\n\r\n    _proto.videoWidth = function videoWidth() {\r\n      return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\r\n    }\r\n    /**\r\n     * Get video height\r\n     *\r\n     * @return {number}\r\n     *         current video height\r\n     */\r\n    ;\r\n\r\n    _proto.videoHeight = function videoHeight() {\r\n      return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\r\n    }\r\n    /**\r\n     * The player's language code.\r\n     *\r\n     * Changing the language will trigger\r\n     * [languagechange]{@link Player#event:languagechange}\r\n     * which Components can use to update control text.\r\n     * ClickableComponent will update its control text by default on\r\n     * [languagechange]{@link Player#event:languagechange}.\r\n     *\r\n     * @fires Player#languagechange\r\n     *\r\n     * @param {string} [code]\r\n     *        the language code to set the player to\r\n     *\r\n     * @return {string}\r\n     *         The current language code when getting\r\n     */\r\n    ;\r\n\r\n    _proto.language = function language(code) {\r\n      if (code === undefined) {\r\n        return this.language_;\r\n      }\r\n\r\n      if (this.language_ !== String(code).toLowerCase()) {\r\n        this.language_ = String(code).toLowerCase(); // during first init, it's possible some things won't be evented\r\n\r\n        if (isEvented(this)) {\r\n          /**\r\n          * fires when the player language change\r\n          *\r\n          * @event Player#languagechange\r\n          * @type {EventTarget~Event}\r\n          */\r\n          this.trigger('languagechange');\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Get the player's language dictionary\r\n     * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\r\n     * Languages specified directly in the player options have precedence\r\n     *\r\n     * @return {Array}\r\n     *         An array of of supported languages\r\n     */\r\n    ;\r\n\r\n    _proto.languages = function languages() {\r\n      return mergeOptions$3(Player.prototype.options_.languages, this.languages_);\r\n    }\r\n    /**\r\n     * returns a JavaScript object reperesenting the current track\r\n     * information. **DOES not return it as JSON**\r\n     *\r\n     * @return {Object}\r\n     *         Object representing the current of track info\r\n     */\r\n    ;\r\n\r\n    _proto.toJSON = function toJSON() {\r\n      var options = mergeOptions$3(this.options_);\r\n      var tracks = options.tracks;\r\n      options.tracks = [];\r\n\r\n      for (var i = 0; i < tracks.length; i++) {\r\n        var track = tracks[i]; // deep merge tracks and null out player so no circular references\r\n\r\n        track = mergeOptions$3(track);\r\n        track.player = undefined;\r\n        options.tracks[i] = track;\r\n      }\r\n\r\n      return options;\r\n    }\r\n    /**\r\n     * Creates a simple modal dialog (an instance of the {@link ModalDialog}\r\n     * component) that immediately overlays the player with arbitrary\r\n     * content and removes itself when closed.\r\n     *\r\n     * @param {string|Function|Element|Array|null} content\r\n     *        Same as {@link ModalDialog#content}'s param of the same name.\r\n     *        The most straight-forward usage is to provide a string or DOM\r\n     *        element.\r\n     *\r\n     * @param {Object} [options]\r\n     *        Extra options which will be passed on to the {@link ModalDialog}.\r\n     *\r\n     * @return {ModalDialog}\r\n     *         the {@link ModalDialog} that was created\r\n     */\r\n    ;\r\n\r\n    _proto.createModal = function createModal(content, options) {\r\n      var _this22 = this;\r\n\r\n      options = options || {};\r\n      options.content = content || '';\r\n      var modal = new ModalDialog(this, options);\r\n      this.addChild(modal);\r\n      modal.on('dispose', function () {\r\n        _this22.removeChild(modal);\r\n      });\r\n      modal.open();\r\n      return modal;\r\n    }\r\n    /**\r\n     * Change breakpoint classes when the player resizes.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {\r\n      if (!this.responsive()) {\r\n        return;\r\n      }\r\n\r\n      var currentBreakpoint = this.currentBreakpoint();\r\n      var currentWidth = this.currentWidth();\r\n\r\n      for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {\r\n        var candidateBreakpoint = BREAKPOINT_ORDER[i];\r\n        var maxWidth = this.breakpoints_[candidateBreakpoint];\r\n\r\n        if (currentWidth <= maxWidth) {\r\n          // The current breakpoint did not change, nothing to do.\r\n          if (currentBreakpoint === candidateBreakpoint) {\r\n            return;\r\n          } // Only remove a class if there is a current breakpoint.\r\n\r\n\r\n          if (currentBreakpoint) {\r\n            this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);\r\n          }\r\n\r\n          this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);\r\n          this.breakpoint_ = candidateBreakpoint;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Removes the current breakpoint.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {\r\n      var className = this.currentBreakpointClass();\r\n      this.breakpoint_ = '';\r\n\r\n      if (className) {\r\n        this.removeClass(className);\r\n      }\r\n    }\r\n    /**\r\n     * Get or set breakpoints on the player.\r\n     *\r\n     * Calling this method with an object or `true` will remove any previous\r\n     * custom breakpoints and start from the defaults again.\r\n     *\r\n     * @param  {Object|boolean} [breakpoints]\r\n     *         If an object is given, it can be used to provide custom\r\n     *         breakpoints. If `true` is given, will set default breakpoints.\r\n     *         If this argument is not given, will simply return the current\r\n     *         breakpoints.\r\n     *\r\n     * @param  {number} [breakpoints.tiny]\r\n     *         The maximum width for the \"vjs-layout-tiny\" class.\r\n     *\r\n     * @param  {number} [breakpoints.xsmall]\r\n     *         The maximum width for the \"vjs-layout-x-small\" class.\r\n     *\r\n     * @param  {number} [breakpoints.small]\r\n     *         The maximum width for the \"vjs-layout-small\" class.\r\n     *\r\n     * @param  {number} [breakpoints.medium]\r\n     *         The maximum width for the \"vjs-layout-medium\" class.\r\n     *\r\n     * @param  {number} [breakpoints.large]\r\n     *         The maximum width for the \"vjs-layout-large\" class.\r\n     *\r\n     * @param  {number} [breakpoints.xlarge]\r\n     *         The maximum width for the \"vjs-layout-x-large\" class.\r\n     *\r\n     * @param  {number} [breakpoints.huge]\r\n     *         The maximum width for the \"vjs-layout-huge\" class.\r\n     *\r\n     * @return {Object}\r\n     *         An object mapping breakpoint names to maximum width values.\r\n     */\r\n    ;\r\n\r\n    _proto.breakpoints = function breakpoints(_breakpoints) {\r\n      // Used as a getter.\r\n      if (_breakpoints === undefined) {\r\n        return assign(this.breakpoints_);\r\n      }\r\n\r\n      this.breakpoint_ = '';\r\n      this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints); // When breakpoint definitions change, we need to update the currently\r\n      // selected breakpoint.\r\n\r\n      this.updateCurrentBreakpoint_(); // Clone the breakpoints before returning.\r\n\r\n      return assign(this.breakpoints_);\r\n    }\r\n    /**\r\n     * Get or set a flag indicating whether or not this player should adjust\r\n     * its UI based on its dimensions.\r\n     *\r\n     * @param  {boolean} value\r\n     *         Should be `true` if the player should adjust its UI based on its\r\n     *         dimensions; otherwise, should be `false`.\r\n     *\r\n     * @return {boolean}\r\n     *         Will be `true` if this player should adjust its UI based on its\r\n     *         dimensions; otherwise, will be `false`.\r\n     */\r\n    ;\r\n\r\n    _proto.responsive = function responsive(value) {\r\n      // Used as a getter.\r\n      if (value === undefined) {\r\n        return this.responsive_;\r\n      }\r\n\r\n      value = Boolean(value);\r\n      var current = this.responsive_; // Nothing changed.\r\n\r\n      if (value === current) {\r\n        return;\r\n      } // The value actually changed, set it.\r\n\r\n\r\n      this.responsive_ = value; // Start listening for breakpoints and set the initial breakpoint if the\r\n      // player is now responsive.\r\n\r\n      if (value) {\r\n        this.on('playerresize', this.boundUpdateCurrentBreakpoint_);\r\n        this.updateCurrentBreakpoint_(); // Stop listening for breakpoints if the player is no longer responsive.\r\n      } else {\r\n        this.off('playerresize', this.boundUpdateCurrentBreakpoint_);\r\n        this.removeCurrentBreakpoint_();\r\n      }\r\n\r\n      return value;\r\n    }\r\n    /**\r\n     * Get current breakpoint name, if any.\r\n     *\r\n     * @return {string}\r\n     *         If there is currently a breakpoint set, returns a the key from the\r\n     *         breakpoints object matching it. Otherwise, returns an empty string.\r\n     */\r\n    ;\r\n\r\n    _proto.currentBreakpoint = function currentBreakpoint() {\r\n      return this.breakpoint_;\r\n    }\r\n    /**\r\n     * Get the current breakpoint class name.\r\n     *\r\n     * @return {string}\r\n     *         The matching class name (e.g. `\"vjs-layout-tiny\"` or\r\n     *         `\"vjs-layout-large\"`) for the current breakpoint. Empty string if\r\n     *         there is no current breakpoint.\r\n     */\r\n    ;\r\n\r\n    _proto.currentBreakpointClass = function currentBreakpointClass() {\r\n      return BREAKPOINT_CLASSES[this.breakpoint_] || '';\r\n    }\r\n    /**\r\n     * An object that describes a single piece of media.\r\n     *\r\n     * Properties that are not part of this type description will be retained; so,\r\n     * this can be viewed as a generic metadata storage mechanism as well.\r\n     *\r\n     * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}\r\n     * @typedef  {Object} Player~MediaObject\r\n     *\r\n     * @property {string} [album]\r\n     *           Unused, except if this object is passed to the `MediaSession`\r\n     *           API.\r\n     *\r\n     * @property {string} [artist]\r\n     *           Unused, except if this object is passed to the `MediaSession`\r\n     *           API.\r\n     *\r\n     * @property {Object[]} [artwork]\r\n     *           Unused, except if this object is passed to the `MediaSession`\r\n     *           API. If not specified, will be populated via the `poster`, if\r\n     *           available.\r\n     *\r\n     * @property {string} [poster]\r\n     *           URL to an image that will display before playback.\r\n     *\r\n     * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]\r\n     *           A single source object, an array of source objects, or a string\r\n     *           referencing a URL to a media source. It is _highly recommended_\r\n     *           that an object or array of objects is used here, so that source\r\n     *           selection algorithms can take the `type` into account.\r\n     *\r\n     * @property {string} [title]\r\n     *           Unused, except if this object is passed to the `MediaSession`\r\n     *           API.\r\n     *\r\n     * @property {Object[]} [textTracks]\r\n     *           An array of objects to be used to create text tracks, following\r\n     *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.\r\n     *           For ease of removal, these will be created as \"remote\" text\r\n     *           tracks and set to automatically clean up on source changes.\r\n     *\r\n     *           These objects may have properties like `src`, `kind`, `label`,\r\n     *           and `language`, see {@link Tech#createRemoteTextTrack}.\r\n     */\r\n\r\n    /**\r\n     * Populate the player using a {@link Player~MediaObject|MediaObject}.\r\n     *\r\n     * @param  {Player~MediaObject} media\r\n     *         A media object.\r\n     *\r\n     * @param  {Function} ready\r\n     *         A callback to be called when the player is ready.\r\n     */\r\n    ;\r\n\r\n    _proto.loadMedia = function loadMedia(media, ready) {\r\n      var _this23 = this;\r\n\r\n      if (!media || typeof media !== 'object') {\r\n        return;\r\n      }\r\n\r\n      this.reset(); // Clone the media object so it cannot be mutated from outside.\r\n\r\n      this.cache_.media = mergeOptions$3(media);\r\n      var _this$cache_$media = this.cache_.media,\r\n          artwork = _this$cache_$media.artwork,\r\n          poster = _this$cache_$media.poster,\r\n          src = _this$cache_$media.src,\r\n          textTracks = _this$cache_$media.textTracks; // If `artwork` is not given, create it using `poster`.\r\n\r\n      if (!artwork && poster) {\r\n        this.cache_.media.artwork = [{\r\n          src: poster,\r\n          type: getMimetype(poster)\r\n        }];\r\n      }\r\n\r\n      if (src) {\r\n        this.src(src);\r\n      }\r\n\r\n      if (poster) {\r\n        this.poster(poster);\r\n      }\r\n\r\n      if (Array.isArray(textTracks)) {\r\n        textTracks.forEach(function (tt) {\r\n          return _this23.addRemoteTextTrack(tt, false);\r\n        });\r\n      }\r\n\r\n      this.ready(ready);\r\n    }\r\n    /**\r\n     * Get a clone of the current {@link Player~MediaObject} for this player.\r\n     *\r\n     * If the `loadMedia` method has not been used, will attempt to return a\r\n     * {@link Player~MediaObject} based on the current state of the player.\r\n     *\r\n     * @return {Player~MediaObject}\r\n     */\r\n    ;\r\n\r\n    _proto.getMedia = function getMedia() {\r\n      if (!this.cache_.media) {\r\n        var poster = this.poster();\r\n        var src = this.currentSources();\r\n        var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function (tt) {\r\n          return {\r\n            kind: tt.kind,\r\n            label: tt.label,\r\n            language: tt.language,\r\n            src: tt.src\r\n          };\r\n        });\r\n        var media = {\r\n          src: src,\r\n          textTracks: textTracks\r\n        };\r\n\r\n        if (poster) {\r\n          media.poster = poster;\r\n          media.artwork = [{\r\n            src: media.poster,\r\n            type: getMimetype(media.poster)\r\n          }];\r\n        }\r\n\r\n        return media;\r\n      }\r\n\r\n      return mergeOptions$3(this.cache_.media);\r\n    }\r\n    /**\r\n     * Gets tag settings\r\n     *\r\n     * @param {Element} tag\r\n     *        The player tag\r\n     *\r\n     * @return {Object}\r\n     *         An object containing all of the settings\r\n     *         for a player tag\r\n     */\r\n    ;\r\n\r\n    Player.getTagSettings = function getTagSettings(tag) {\r\n      var baseOptions = {\r\n        sources: [],\r\n        tracks: []\r\n      };\r\n      var tagOptions = getAttributes(tag);\r\n      var dataSetup = tagOptions['data-setup'];\r\n\r\n      if (hasClass(tag, 'vjs-fill')) {\r\n        tagOptions.fill = true;\r\n      }\r\n\r\n      if (hasClass(tag, 'vjs-fluid')) {\r\n        tagOptions.fluid = true;\r\n      } // Check if data-setup attr exists.\r\n\r\n\r\n      if (dataSetup !== null) {\r\n        // Parse options JSON\r\n        // If empty string, make it a parsable json object.\r\n        var _safeParseTuple = tuple(dataSetup || '{}'),\r\n            err = _safeParseTuple[0],\r\n            data = _safeParseTuple[1];\r\n\r\n        if (err) {\r\n          log$1.error(err);\r\n        }\r\n\r\n        assign(tagOptions, data);\r\n      }\r\n\r\n      assign(baseOptions, tagOptions); // Get tag children settings\r\n\r\n      if (tag.hasChildNodes()) {\r\n        var children = tag.childNodes;\r\n\r\n        for (var i = 0, j = children.length; i < j; i++) {\r\n          var child = children[i]; // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\r\n\r\n          var childName = child.nodeName.toLowerCase();\r\n\r\n          if (childName === 'source') {\r\n            baseOptions.sources.push(getAttributes(child));\r\n          } else if (childName === 'track') {\r\n            baseOptions.tracks.push(getAttributes(child));\r\n          }\r\n        }\r\n      }\r\n\r\n      return baseOptions;\r\n    }\r\n    /**\r\n     * Determine whether or not flexbox is supported\r\n     *\r\n     * @return {boolean}\r\n     *         - true if flexbox is supported\r\n     *         - false if flexbox is not supported\r\n     */\r\n    ;\r\n\r\n    _proto.flexNotSupported_ = function flexNotSupported_() {\r\n      var elem = document.createElement('i'); // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\r\n      // common flex features that we can rely on when checking for flex support.\r\n\r\n      return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style || // IE10-specific (2012 flex spec), available for completeness\r\n      'msFlexOrder' in elem.style);\r\n    }\r\n    /**\r\n     * Set debug mode to enable/disable logs at info level.\r\n     *\r\n     * @param {boolean} enabled\r\n     * @fires Player#debugon\r\n     * @fires Player#debugoff\r\n     */\r\n    ;\r\n\r\n    _proto.debug = function debug(enabled) {\r\n      if (enabled === undefined) {\r\n        return this.debugEnabled_;\r\n      }\r\n\r\n      if (enabled) {\r\n        this.trigger('debugon');\r\n        this.previousLogLevel_ = this.log.level;\r\n        this.log.level('debug');\r\n        this.debugEnabled_ = true;\r\n      } else {\r\n        this.trigger('debugoff');\r\n        this.log.level(this.previousLogLevel_);\r\n        this.previousLogLevel_ = undefined;\r\n        this.debugEnabled_ = false;\r\n      }\r\n    }\r\n    /**\r\n     * Set or get current playback rates.\r\n     * Takes an array and updates the playback rates menu with the new items.\r\n     * Pass in an empty array to hide the menu.\r\n     * Values other than arrays are ignored.\r\n     *\r\n     * @fires Player#playbackrateschange\r\n     * @param {number[]} newRates\r\n     *                   The new rates that the playback rates menu should update to.\r\n     *                   An empty array will hide the menu\r\n     * @return {number[]} When used as a getter will return the current playback rates\r\n     */\r\n    ;\r\n\r\n    _proto.playbackRates = function playbackRates(newRates) {\r\n      if (newRates === undefined) {\r\n        return this.cache_.playbackRates;\r\n      } // ignore any value that isn't an array\r\n\r\n\r\n      if (!Array.isArray(newRates)) {\r\n        return;\r\n      } // ignore any arrays that don't only contain numbers\r\n\r\n\r\n      if (!newRates.every(function (rate) {\r\n        return typeof rate === 'number';\r\n      })) {\r\n        return;\r\n      }\r\n\r\n      this.cache_.playbackRates = newRates;\r\n      /**\r\n      * fires when the playback rates in a player are changed\r\n      *\r\n      * @event Player#playbackrateschange\r\n      * @type {EventTarget~Event}\r\n      */\r\n\r\n      this.trigger('playbackrateschange');\r\n    };\r\n\r\n    return Player;\r\n  }(Component$1);\r\n  /**\r\n   * Get the {@link VideoTrackList}\r\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\r\n   *\r\n   * @return {VideoTrackList}\r\n   *         the current video track list\r\n   *\r\n   * @method Player.prototype.videoTracks\r\n   */\r\n\r\n  /**\r\n   * Get the {@link AudioTrackList}\r\n   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\r\n   *\r\n   * @return {AudioTrackList}\r\n   *         the current audio track list\r\n   *\r\n   * @method Player.prototype.audioTracks\r\n   */\r\n\r\n  /**\r\n   * Get the {@link TextTrackList}\r\n   *\r\n   * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\r\n   *\r\n   * @return {TextTrackList}\r\n   *         the current text track list\r\n   *\r\n   * @method Player.prototype.textTracks\r\n   */\r\n\r\n  /**\r\n   * Get the remote {@link TextTrackList}\r\n   *\r\n   * @return {TextTrackList}\r\n   *         The current remote text track list\r\n   *\r\n   * @method Player.prototype.remoteTextTracks\r\n   */\r\n\r\n  /**\r\n   * Get the remote {@link HtmlTrackElementList} tracks.\r\n   *\r\n   * @return {HtmlTrackElementList}\r\n   *         The current remote text track element list\r\n   *\r\n   * @method Player.prototype.remoteTextTrackEls\r\n   */\r\n\r\n\r\n  ALL.names.forEach(function (name) {\r\n    var props = ALL[name];\r\n\r\n    Player.prototype[props.getterName] = function () {\r\n      if (this.tech_) {\r\n        return this.tech_[props.getterName]();\r\n      } // if we have not yet loadTech_, we create {video,audio,text}Tracks_\r\n      // these will be passed to the tech during loading\r\n\r\n\r\n      this[props.privateName] = this[props.privateName] || new props.ListClass();\r\n      return this[props.privateName];\r\n    };\r\n  });\r\n  /**\r\n   * Get or set the `Player`'s crossorigin option. For the HTML5 player, this\r\n   * sets the `crossOrigin` property on the `<video>` tag to control the CORS\r\n   * behavior.\r\n   *\r\n   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\r\n   *\r\n   * @param {string} [value]\r\n   *        The value to set the `Player`'s crossorigin to. If an argument is\r\n   *        given, must be one of `anonymous` or `use-credentials`.\r\n   *\r\n   * @return {string|undefined}\r\n   *         - The current crossorigin value of the `Player` when getting.\r\n   *         - undefined when setting\r\n   */\r\n\r\n  Player.prototype.crossorigin = Player.prototype.crossOrigin;\r\n  /**\r\n   * Global enumeration of players.\r\n   *\r\n   * The keys are the player IDs and the values are either the {@link Player}\r\n   * instance or `null` for disposed players.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  Player.players = {};\r\n  var navigator = window.navigator;\r\n  /*\r\n   * Player instance options, surfaced using options\r\n   * options = Player.prototype.options_\r\n   * Make changes in options, not here.\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n\r\n  Player.prototype.options_ = {\r\n    // Default order of fallback technology\r\n    techOrder: Tech.defaultTechOrder_,\r\n    html5: {},\r\n    // default inactivity timeout\r\n    inactivityTimeout: 2000,\r\n    // default playback rates\r\n    playbackRates: [],\r\n    // Add playback rate selection by adding rates\r\n    // 'playbackRates': [0.5, 1, 1.5, 2],\r\n    liveui: false,\r\n    // Included control sets\r\n    children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],\r\n    language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\r\n    // locales and their language translations\r\n    languages: {},\r\n    // Default message to show when a video cannot be played.\r\n    notSupportedMessage: 'No compatible source was found for this media.',\r\n    normalizeAutoplay: false,\r\n    fullscreen: {\r\n      options: {\r\n        navigationUI: 'hide'\r\n      }\r\n    },\r\n    breakpoints: {},\r\n    responsive: false,\r\n    audioOnlyMode: false,\r\n    audioPosterMode: false\r\n  };\r\n  [\r\n  /**\r\n   * Returns whether or not the player is in the \"ended\" state.\r\n   *\r\n   * @return {Boolean} True if the player is in the ended state, false if not.\r\n   * @method Player#ended\r\n   */\r\n  'ended',\r\n  /**\r\n   * Returns whether or not the player is in the \"seeking\" state.\r\n   *\r\n   * @return {Boolean} True if the player is in the seeking state, false if not.\r\n   * @method Player#seeking\r\n   */\r\n  'seeking',\r\n  /**\r\n   * Returns the TimeRanges of the media that are currently available\r\n   * for seeking to.\r\n   *\r\n   * @return {TimeRanges} the seekable intervals of the media timeline\r\n   * @method Player#seekable\r\n   */\r\n  'seekable',\r\n  /**\r\n   * Returns the current state of network activity for the element, from\r\n   * the codes in the list below.\r\n   * - NETWORK_EMPTY (numeric value 0)\r\n   *   The element has not yet been initialised. All attributes are in\r\n   *   their initial states.\r\n   * - NETWORK_IDLE (numeric value 1)\r\n   *   The element's resource selection algorithm is active and has\r\n   *   selected a resource, but it is not actually using the network at\r\n   *   this time.\r\n   * - NETWORK_LOADING (numeric value 2)\r\n   *   The user agent is actively trying to download data.\r\n   * - NETWORK_NO_SOURCE (numeric value 3)\r\n   *   The element's resource selection algorithm is active, but it has\r\n   *   not yet found a resource to use.\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\r\n   * @return {number} the current network activity state\r\n   * @method Player#networkState\r\n   */\r\n  'networkState',\r\n  /**\r\n   * Returns a value that expresses the current state of the element\r\n   * with respect to rendering the current playback position, from the\r\n   * codes in the list below.\r\n   * - HAVE_NOTHING (numeric value 0)\r\n   *   No information regarding the media resource is available.\r\n   * - HAVE_METADATA (numeric value 1)\r\n   *   Enough of the resource has been obtained that the duration of the\r\n   *   resource is available.\r\n   * - HAVE_CURRENT_DATA (numeric value 2)\r\n   *   Data for the immediate current playback position is available.\r\n   * - HAVE_FUTURE_DATA (numeric value 3)\r\n   *   Data for the immediate current playback position is available, as\r\n   *   well as enough data for the user agent to advance the current\r\n   *   playback position in the direction of playback.\r\n   * - HAVE_ENOUGH_DATA (numeric value 4)\r\n   *   The user agent estimates that enough data is available for\r\n   *   playback to proceed uninterrupted.\r\n   *\r\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\r\n   * @return {number} the current playback rendering state\r\n   * @method Player#readyState\r\n   */\r\n  'readyState'].forEach(function (fn) {\r\n    Player.prototype[fn] = function () {\r\n      return this.techGet_(fn);\r\n    };\r\n  });\r\n  TECH_EVENTS_RETRIGGER.forEach(function (event) {\r\n    Player.prototype[\"handleTech\" + toTitleCase$1(event) + \"_\"] = function () {\r\n      return this.trigger(event);\r\n    };\r\n  });\r\n  /**\r\n   * Fired when the player has initial duration and dimension information\r\n   *\r\n   * @event Player#loadedmetadata\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Fired when the player has downloaded data at the current playback position\r\n   *\r\n   * @event Player#loadeddata\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Fired when the current playback position has changed *\r\n   * During playback this is fired every 15-250 milliseconds, depending on the\r\n   * playback technology in use.\r\n   *\r\n   * @event Player#timeupdate\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Fired when the volume changes\r\n   *\r\n   * @event Player#volumechange\r\n   * @type {EventTarget~Event}\r\n   */\r\n\r\n  /**\r\n   * Reports whether or not a player has a plugin available.\r\n   *\r\n   * This does not report whether or not the plugin has ever been initialized\r\n   * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\r\n   *\r\n   * @method Player#hasPlugin\r\n   * @param  {string}  name\r\n   *         The name of a plugin.\r\n   *\r\n   * @return {boolean}\r\n   *         Whether or not this player has the requested plugin available.\r\n   */\r\n\r\n  /**\r\n   * Reports whether or not a player is using a plugin by name.\r\n   *\r\n   * For basic plugins, this only reports whether the plugin has _ever_ been\r\n   * initialized on this player.\r\n   *\r\n   * @method Player#usingPlugin\r\n   * @param  {string} name\r\n   *         The name of a plugin.\r\n   *\r\n   * @return {boolean}\r\n   *         Whether or not this player is using the requested plugin.\r\n   */\r\n\r\n  Component$1.registerComponent('Player', Player);\r\n\r\n  var setPrototypeOf = createCommonjsModule(function (module) {\r\n    function _setPrototypeOf(o, p) {\r\n      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\r\n        o.__proto__ = p;\r\n        return o;\r\n      };\r\n\r\n      return _setPrototypeOf(o, p);\r\n    }\r\n\r\n    module.exports = _setPrototypeOf;\r\n  });\r\n\r\n  function _isNativeReflectConstruct() {\r\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\r\n    if (Reflect.construct.sham) return false;\r\n    if (typeof Proxy === \"function\") return true;\r\n\r\n    try {\r\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  var isNativeReflectConstruct = _isNativeReflectConstruct;\r\n\r\n  var construct = createCommonjsModule(function (module) {\r\n    function _construct(Parent, args, Class) {\r\n      if (isNativeReflectConstruct()) {\r\n        module.exports = _construct = Reflect.construct;\r\n      } else {\r\n        module.exports = _construct = function _construct(Parent, args, Class) {\r\n          var a = [null];\r\n          a.push.apply(a, args);\r\n          var Constructor = Function.bind.apply(Parent, a);\r\n          var instance = new Constructor();\r\n          if (Class) setPrototypeOf(instance, Class.prototype);\r\n          return instance;\r\n        };\r\n      }\r\n\r\n      return _construct.apply(null, arguments);\r\n    }\r\n\r\n    module.exports = _construct;\r\n  });\r\n\r\n  /**\r\n   * The base plugin name.\r\n   *\r\n   * @private\r\n   * @constant\r\n   * @type {string}\r\n   */\r\n\r\n  var BASE_PLUGIN_NAME = 'plugin';\r\n  /**\r\n   * The key on which a player's active plugins cache is stored.\r\n   *\r\n   * @private\r\n   * @constant\r\n   * @type     {string}\r\n   */\r\n\r\n  var PLUGIN_CACHE_KEY = 'activePlugins_';\r\n  /**\r\n   * Stores registered plugins in a private space.\r\n   *\r\n   * @private\r\n   * @type    {Object}\r\n   */\r\n\r\n  var pluginStorage = {};\r\n  /**\r\n   * Reports whether or not a plugin has been registered.\r\n   *\r\n   * @private\r\n   * @param   {string} name\r\n   *          The name of a plugin.\r\n   *\r\n   * @return {boolean}\r\n   *          Whether or not the plugin has been registered.\r\n   */\r\n\r\n  var pluginExists = function pluginExists(name) {\r\n    return pluginStorage.hasOwnProperty(name);\r\n  };\r\n  /**\r\n   * Get a single registered plugin by name.\r\n   *\r\n   * @private\r\n   * @param   {string} name\r\n   *          The name of a plugin.\r\n   *\r\n   * @return {Function|undefined}\r\n   *          The plugin (or undefined).\r\n   */\r\n\r\n\r\n  var getPlugin = function getPlugin(name) {\r\n    return pluginExists(name) ? pluginStorage[name] : undefined;\r\n  };\r\n  /**\r\n   * Marks a plugin as \"active\" on a player.\r\n   *\r\n   * Also, ensures that the player has an object for tracking active plugins.\r\n   *\r\n   * @private\r\n   * @param   {Player} player\r\n   *          A Video.js player instance.\r\n   *\r\n   * @param   {string} name\r\n   *          The name of a plugin.\r\n   */\r\n\r\n\r\n  var markPluginAsActive = function markPluginAsActive(player, name) {\r\n    player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\r\n    player[PLUGIN_CACHE_KEY][name] = true;\r\n  };\r\n  /**\r\n   * Triggers a pair of plugin setup events.\r\n   *\r\n   * @private\r\n   * @param  {Player} player\r\n   *         A Video.js player instance.\r\n   *\r\n   * @param  {Plugin~PluginEventHash} hash\r\n   *         A plugin event hash.\r\n   *\r\n   * @param  {boolean} [before]\r\n   *         If true, prefixes the event name with \"before\". In other words,\r\n   *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\r\n   */\r\n\r\n\r\n  var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {\r\n    var eventName = (before ? 'before' : '') + 'pluginsetup';\r\n    player.trigger(eventName, hash);\r\n    player.trigger(eventName + ':' + hash.name, hash);\r\n  };\r\n  /**\r\n   * Takes a basic plugin function and returns a wrapper function which marks\r\n   * on the player that the plugin has been activated.\r\n   *\r\n   * @private\r\n   * @param   {string} name\r\n   *          The name of the plugin.\r\n   *\r\n   * @param   {Function} plugin\r\n   *          The basic plugin.\r\n   *\r\n   * @return {Function}\r\n   *          A wrapper function for the given plugin.\r\n   */\r\n\r\n\r\n  var createBasicPlugin = function createBasicPlugin(name, plugin) {\r\n    var basicPluginWrapper = function basicPluginWrapper() {\r\n      // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\r\n      // regardless, but we want the hash to be consistent with the hash provided\r\n      // for advanced plugins.\r\n      //\r\n      // The only potentially counter-intuitive thing here is the `instance` in\r\n      // the \"pluginsetup\" event is the value returned by the `plugin` function.\r\n      triggerSetupEvent(this, {\r\n        name: name,\r\n        plugin: plugin,\r\n        instance: null\r\n      }, true);\r\n      var instance = plugin.apply(this, arguments);\r\n      markPluginAsActive(this, name);\r\n      triggerSetupEvent(this, {\r\n        name: name,\r\n        plugin: plugin,\r\n        instance: instance\r\n      });\r\n      return instance;\r\n    };\r\n\r\n    Object.keys(plugin).forEach(function (prop) {\r\n      basicPluginWrapper[prop] = plugin[prop];\r\n    });\r\n    return basicPluginWrapper;\r\n  };\r\n  /**\r\n   * Takes a plugin sub-class and returns a factory function for generating\r\n   * instances of it.\r\n   *\r\n   * This factory function will replace itself with an instance of the requested\r\n   * sub-class of Plugin.\r\n   *\r\n   * @private\r\n   * @param   {string} name\r\n   *          The name of the plugin.\r\n   *\r\n   * @param   {Plugin} PluginSubClass\r\n   *          The advanced plugin.\r\n   *\r\n   * @return {Function}\r\n   */\r\n\r\n\r\n  var createPluginFactory = function createPluginFactory(name, PluginSubClass) {\r\n    // Add a `name` property to the plugin prototype so that each plugin can\r\n    // refer to itself by name.\r\n    PluginSubClass.prototype.name = name;\r\n    return function () {\r\n      triggerSetupEvent(this, {\r\n        name: name,\r\n        plugin: PluginSubClass,\r\n        instance: null\r\n      }, true);\r\n\r\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args[_key] = arguments[_key];\r\n      }\r\n\r\n      var instance = construct(PluginSubClass, [this].concat(args)); // The plugin is replaced by a function that returns the current instance.\r\n\r\n\r\n      this[name] = function () {\r\n        return instance;\r\n      };\r\n\r\n      triggerSetupEvent(this, instance.getEventHash());\r\n      return instance;\r\n    };\r\n  };\r\n  /**\r\n   * Parent class for all advanced plugins.\r\n   *\r\n   * @mixes   module:evented~EventedMixin\r\n   * @mixes   module:stateful~StatefulMixin\r\n   * @fires   Player#beforepluginsetup\r\n   * @fires   Player#beforepluginsetup:$name\r\n   * @fires   Player#pluginsetup\r\n   * @fires   Player#pluginsetup:$name\r\n   * @listens Player#dispose\r\n   * @throws  {Error}\r\n   *          If attempting to instantiate the base {@link Plugin} class\r\n   *          directly instead of via a sub-class.\r\n   */\r\n\r\n\r\n  var Plugin = /*#__PURE__*/function () {\r\n    /**\r\n     * Creates an instance of this class.\r\n     *\r\n     * Sub-classes should call `super` to ensure plugins are properly initialized.\r\n     *\r\n     * @param {Player} player\r\n     *        A Video.js player instance.\r\n     */\r\n    function Plugin(player) {\r\n      if (this.constructor === Plugin) {\r\n        throw new Error('Plugin must be sub-classed; not directly instantiated.');\r\n      }\r\n\r\n      this.player = player;\r\n\r\n      if (!this.log) {\r\n        this.log = this.player.log.createLogger(this.name);\r\n      } // Make this object evented, but remove the added `trigger` method so we\r\n      // use the prototype version instead.\r\n\r\n\r\n      evented(this);\r\n      delete this.trigger;\r\n      stateful(this, this.constructor.defaultState);\r\n      markPluginAsActive(player, this.name); // Auto-bind the dispose method so we can use it as a listener and unbind\r\n      // it later easily.\r\n\r\n      this.dispose = this.dispose.bind(this); // If the player is disposed, dispose the plugin.\r\n\r\n      player.on('dispose', this.dispose);\r\n    }\r\n    /**\r\n     * Get the version of the plugin that was set on <pluginName>.VERSION\r\n     */\r\n\r\n\r\n    var _proto = Plugin.prototype;\r\n\r\n    _proto.version = function version() {\r\n      return this.constructor.VERSION;\r\n    }\r\n    /**\r\n     * Each event triggered by plugins includes a hash of additional data with\r\n     * conventional properties.\r\n     *\r\n     * This returns that object or mutates an existing hash.\r\n     *\r\n     * @param   {Object} [hash={}]\r\n     *          An object to be used as event an event hash.\r\n     *\r\n     * @return {Plugin~PluginEventHash}\r\n     *          An event hash object with provided properties mixed-in.\r\n     */\r\n    ;\r\n\r\n    _proto.getEventHash = function getEventHash(hash) {\r\n      if (hash === void 0) {\r\n        hash = {};\r\n      }\r\n\r\n      hash.name = this.name;\r\n      hash.plugin = this.constructor;\r\n      hash.instance = this;\r\n      return hash;\r\n    }\r\n    /**\r\n     * Triggers an event on the plugin object and overrides\r\n     * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\r\n     *\r\n     * @param   {string|Object} event\r\n     *          An event type or an object with a type property.\r\n     *\r\n     * @param   {Object} [hash={}]\r\n     *          Additional data hash to merge with a\r\n     *          {@link Plugin~PluginEventHash|PluginEventHash}.\r\n     *\r\n     * @return {boolean}\r\n     *          Whether or not default was prevented.\r\n     */\r\n    ;\r\n\r\n    _proto.trigger = function trigger$1(event, hash) {\r\n      if (hash === void 0) {\r\n        hash = {};\r\n      }\r\n\r\n      return trigger(this.eventBusEl_, event, this.getEventHash(hash));\r\n    }\r\n    /**\r\n     * Handles \"statechanged\" events on the plugin. No-op by default, override by\r\n     * subclassing.\r\n     *\r\n     * @abstract\r\n     * @param    {Event} e\r\n     *           An event object provided by a \"statechanged\" event.\r\n     *\r\n     * @param    {Object} e.changes\r\n     *           An object describing changes that occurred with the \"statechanged\"\r\n     *           event.\r\n     */\r\n    ;\r\n\r\n    _proto.handleStateChanged = function handleStateChanged(e) {}\r\n    /**\r\n     * Disposes a plugin.\r\n     *\r\n     * Subclasses can override this if they want, but for the sake of safety,\r\n     * it's probably best to subscribe the \"dispose\" event.\r\n     *\r\n     * @fires Plugin#dispose\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      var name = this.name,\r\n          player = this.player;\r\n      /**\r\n       * Signals that a advanced plugin is about to be disposed.\r\n       *\r\n       * @event Plugin#dispose\r\n       * @type  {EventTarget~Event}\r\n       */\r\n\r\n      this.trigger('dispose');\r\n      this.off();\r\n      player.off('dispose', this.dispose); // Eliminate any possible sources of leaking memory by clearing up\r\n      // references between the player and the plugin instance and nulling out\r\n      // the plugin's state and replacing methods with a function that throws.\r\n\r\n      player[PLUGIN_CACHE_KEY][name] = false;\r\n      this.player = this.state = null; // Finally, replace the plugin name on the player with a new factory\r\n      // function, so that the plugin is ready to be set up again.\r\n\r\n      player[name] = createPluginFactory(name, pluginStorage[name]);\r\n    }\r\n    /**\r\n     * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\r\n     *\r\n     * @param   {string|Function} plugin\r\n     *          If a string, matches the name of a plugin. If a function, will be\r\n     *          tested directly.\r\n     *\r\n     * @return {boolean}\r\n     *          Whether or not a plugin is a basic plugin.\r\n     */\r\n    ;\r\n\r\n    Plugin.isBasic = function isBasic(plugin) {\r\n      var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\r\n      return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\r\n    }\r\n    /**\r\n     * Register a Video.js plugin.\r\n     *\r\n     * @param   {string} name\r\n     *          The name of the plugin to be registered. Must be a string and\r\n     *          must not match an existing plugin or a method on the `Player`\r\n     *          prototype.\r\n     *\r\n     * @param   {Function} plugin\r\n     *          A sub-class of `Plugin` or a function for basic plugins.\r\n     *\r\n     * @return {Function}\r\n     *          For advanced plugins, a factory function for that plugin. For\r\n     *          basic plugins, a wrapper function that initializes the plugin.\r\n     */\r\n    ;\r\n\r\n    Plugin.registerPlugin = function registerPlugin(name, plugin) {\r\n      if (typeof name !== 'string') {\r\n        throw new Error(\"Illegal plugin name, \\\"\" + name + \"\\\", must be a string, was \" + typeof name + \".\");\r\n      }\r\n\r\n      if (pluginExists(name)) {\r\n        log$1.warn(\"A plugin named \\\"\" + name + \"\\\" already exists. You may want to avoid re-registering plugins!\");\r\n      } else if (Player.prototype.hasOwnProperty(name)) {\r\n        throw new Error(\"Illegal plugin name, \\\"\" + name + \"\\\", cannot share a name with an existing player method!\");\r\n      }\r\n\r\n      if (typeof plugin !== 'function') {\r\n        throw new Error(\"Illegal plugin for \\\"\" + name + \"\\\", must be a function, was \" + typeof plugin + \".\");\r\n      }\r\n\r\n      pluginStorage[name] = plugin; // Add a player prototype method for all sub-classed plugins (but not for\r\n      // the base Plugin class).\r\n\r\n      if (name !== BASE_PLUGIN_NAME) {\r\n        if (Plugin.isBasic(plugin)) {\r\n          Player.prototype[name] = createBasicPlugin(name, plugin);\r\n        } else {\r\n          Player.prototype[name] = createPluginFactory(name, plugin);\r\n        }\r\n      }\r\n\r\n      return plugin;\r\n    }\r\n    /**\r\n     * De-register a Video.js plugin.\r\n     *\r\n     * @param  {string} name\r\n     *         The name of the plugin to be de-registered. Must be a string that\r\n     *         matches an existing plugin.\r\n     *\r\n     * @throws {Error}\r\n     *         If an attempt is made to de-register the base plugin.\r\n     */\r\n    ;\r\n\r\n    Plugin.deregisterPlugin = function deregisterPlugin(name) {\r\n      if (name === BASE_PLUGIN_NAME) {\r\n        throw new Error('Cannot de-register base plugin.');\r\n      }\r\n\r\n      if (pluginExists(name)) {\r\n        delete pluginStorage[name];\r\n        delete Player.prototype[name];\r\n      }\r\n    }\r\n    /**\r\n     * Gets an object containing multiple Video.js plugins.\r\n     *\r\n     * @param   {Array} [names]\r\n     *          If provided, should be an array of plugin names. Defaults to _all_\r\n     *          plugin names.\r\n     *\r\n     * @return {Object|undefined}\r\n     *          An object containing plugin(s) associated with their name(s) or\r\n     *          `undefined` if no matching plugins exist).\r\n     */\r\n    ;\r\n\r\n    Plugin.getPlugins = function getPlugins(names) {\r\n      if (names === void 0) {\r\n        names = Object.keys(pluginStorage);\r\n      }\r\n\r\n      var result;\r\n      names.forEach(function (name) {\r\n        var plugin = getPlugin(name);\r\n\r\n        if (plugin) {\r\n          result = result || {};\r\n          result[name] = plugin;\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n    /**\r\n     * Gets a plugin's version, if available\r\n     *\r\n     * @param   {string} name\r\n     *          The name of a plugin.\r\n     *\r\n     * @return {string}\r\n     *          The plugin's version or an empty string.\r\n     */\r\n    ;\r\n\r\n    Plugin.getPluginVersion = function getPluginVersion(name) {\r\n      var plugin = getPlugin(name);\r\n      return plugin && plugin.VERSION || '';\r\n    };\r\n\r\n    return Plugin;\r\n  }();\r\n  /**\r\n   * Gets a plugin by name if it exists.\r\n   *\r\n   * @static\r\n   * @method   getPlugin\r\n   * @memberOf Plugin\r\n   * @param    {string} name\r\n   *           The name of a plugin.\r\n   *\r\n   * @returns  {Function|undefined}\r\n   *           The plugin (or `undefined`).\r\n   */\r\n\r\n\r\n  Plugin.getPlugin = getPlugin;\r\n  /**\r\n   * The name of the base plugin class as it is registered.\r\n   *\r\n   * @type {string}\r\n   */\r\n\r\n  Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\r\n  Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\r\n  /**\r\n   * Documented in player.js\r\n   *\r\n   * @ignore\r\n   */\r\n\r\n  Player.prototype.usingPlugin = function (name) {\r\n    return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\r\n  };\r\n  /**\r\n   * Documented in player.js\r\n   *\r\n   * @ignore\r\n   */\r\n\r\n\r\n  Player.prototype.hasPlugin = function (name) {\r\n    return !!pluginExists(name);\r\n  };\r\n  /**\r\n   * Signals that a plugin is about to be set up on a player.\r\n   *\r\n   * @event    Player#beforepluginsetup\r\n   * @type     {Plugin~PluginEventHash}\r\n   */\r\n\r\n  /**\r\n   * Signals that a plugin is about to be set up on a player - by name. The name\r\n   * is the name of the plugin.\r\n   *\r\n   * @event    Player#beforepluginsetup:$name\r\n   * @type     {Plugin~PluginEventHash}\r\n   */\r\n\r\n  /**\r\n   * Signals that a plugin has just been set up on a player.\r\n   *\r\n   * @event    Player#pluginsetup\r\n   * @type     {Plugin~PluginEventHash}\r\n   */\r\n\r\n  /**\r\n   * Signals that a plugin has just been set up on a player - by name. The name\r\n   * is the name of the plugin.\r\n   *\r\n   * @event    Player#pluginsetup:$name\r\n   * @type     {Plugin~PluginEventHash}\r\n   */\r\n\r\n  /**\r\n   * @typedef  {Object} Plugin~PluginEventHash\r\n   *\r\n   * @property {string} instance\r\n   *           For basic plugins, the return value of the plugin function. For\r\n   *           advanced plugins, the plugin instance on which the event is fired.\r\n   *\r\n   * @property {string} name\r\n   *           The name of the plugin.\r\n   *\r\n   * @property {string} plugin\r\n   *           For basic plugins, the plugin function. For advanced plugins, the\r\n   *           plugin class/constructor.\r\n   */\r\n\r\n  function _inherits(subClass, superClass) {\r\n    if (typeof superClass !== \"function\" && superClass !== null) {\r\n      throw new TypeError(\"Super expression must either be null or a function\");\r\n    }\r\n\r\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n      constructor: {\r\n        value: subClass,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n    if (superClass) setPrototypeOf(subClass, superClass);\r\n  }\r\n\r\n  var inherits = _inherits;\r\n\r\n  /**\r\n   * @file extend.js\r\n   * @module extend\r\n   */\r\n  /**\r\n   * Used to subclass an existing class by emulating ES subclassing using the\r\n   * `extends` keyword.\r\n   *\r\n   * @function\r\n   * @example\r\n   * var MyComponent = videojs.extend(videojs.getComponent('Component'), {\r\n   *   myCustomMethod: function() {\r\n   *     // Do things in my method.\r\n   *   }\r\n   * });\r\n   *\r\n   * @param    {Function} superClass\r\n   *           The class to inherit from\r\n   *\r\n   * @param    {Object}   [subClassMethods={}]\r\n   *           Methods of the new class\r\n   *\r\n   * @return   {Function}\r\n   *           The new class with subClassMethods that inherited superClass.\r\n   */\r\n\r\n  var extend = function extend(superClass, subClassMethods) {\r\n    if (subClassMethods === void 0) {\r\n      subClassMethods = {};\r\n    }\r\n\r\n    var subClass = function subClass() {\r\n      superClass.apply(this, arguments);\r\n    };\r\n\r\n    var methods = {};\r\n\r\n    if (typeof subClassMethods === 'object') {\r\n      if (subClassMethods.constructor !== Object.prototype.constructor) {\r\n        subClass = subClassMethods.constructor;\r\n      }\r\n\r\n      methods = subClassMethods;\r\n    } else if (typeof subClassMethods === 'function') {\r\n      subClass = subClassMethods;\r\n    }\r\n\r\n    inherits(subClass, superClass); // this is needed for backward-compatibility and node compatibility.\r\n\r\n\r\n    if (superClass) {\r\n      subClass.super_ = superClass;\r\n    } // Extend subObj's prototype with functions and other properties from props\r\n\r\n\r\n    for (var name in methods) {\r\n      if (methods.hasOwnProperty(name)) {\r\n        subClass.prototype[name] = methods[name];\r\n      }\r\n    }\r\n\r\n    return subClass;\r\n  };\r\n\r\n  /**\r\n   * @file video.js\r\n   * @module videojs\r\n   */\r\n  /**\r\n   * Normalize an `id` value by trimming off a leading `#`\r\n   *\r\n   * @private\r\n   * @param   {string} id\r\n   *          A string, maybe with a leading `#`.\r\n   *\r\n   * @return {string}\r\n   *          The string, without any leading `#`.\r\n   */\r\n\r\n  var normalizeId = function normalizeId(id) {\r\n    return id.indexOf('#') === 0 ? id.slice(1) : id;\r\n  };\r\n  /**\r\n   * The `videojs()` function doubles as the main function for users to create a\r\n   * {@link Player} instance as well as the main library namespace.\r\n   *\r\n   * It can also be used as a getter for a pre-existing {@link Player} instance.\r\n   * However, we _strongly_ recommend using `videojs.getPlayer()` for this\r\n   * purpose because it avoids any potential for unintended initialization.\r\n   *\r\n   * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\r\n   * of our JSDoc template, we cannot properly document this as both a function\r\n   * and a namespace, so its function signature is documented here.\r\n   *\r\n   * #### Arguments\r\n   * ##### id\r\n   * string|Element, **required**\r\n   *\r\n   * Video element or video element ID.\r\n   *\r\n   * ##### options\r\n   * Object, optional\r\n   *\r\n   * Options object for providing settings.\r\n   * See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\r\n   *\r\n   * ##### ready\r\n   * {@link Component~ReadyCallback}, optional\r\n   *\r\n   * A function to be called when the {@link Player} and {@link Tech} are ready.\r\n   *\r\n   * #### Return Value\r\n   *\r\n   * The `videojs()` function returns a {@link Player} instance.\r\n   *\r\n   * @namespace\r\n   *\r\n   * @borrows AudioTrack as AudioTrack\r\n   * @borrows Component.getComponent as getComponent\r\n   * @borrows module:computed-style~computedStyle as computedStyle\r\n   * @borrows module:events.on as on\r\n   * @borrows module:events.one as one\r\n   * @borrows module:events.off as off\r\n   * @borrows module:events.trigger as trigger\r\n   * @borrows EventTarget as EventTarget\r\n   * @borrows module:extend~extend as extend\r\n   * @borrows module:fn.bind as bind\r\n   * @borrows module:format-time.formatTime as formatTime\r\n   * @borrows module:format-time.resetFormatTime as resetFormatTime\r\n   * @borrows module:format-time.setFormatTime as setFormatTime\r\n   * @borrows module:merge-options.mergeOptions as mergeOptions\r\n   * @borrows module:middleware.use as use\r\n   * @borrows Player.players as players\r\n   * @borrows Plugin.registerPlugin as registerPlugin\r\n   * @borrows Plugin.deregisterPlugin as deregisterPlugin\r\n   * @borrows Plugin.getPlugins as getPlugins\r\n   * @borrows Plugin.getPlugin as getPlugin\r\n   * @borrows Plugin.getPluginVersion as getPluginVersion\r\n   * @borrows Tech.getTech as getTech\r\n   * @borrows Tech.registerTech as registerTech\r\n   * @borrows TextTrack as TextTrack\r\n   * @borrows module:time-ranges.createTimeRanges as createTimeRange\r\n   * @borrows module:time-ranges.createTimeRanges as createTimeRanges\r\n   * @borrows module:url.isCrossOrigin as isCrossOrigin\r\n   * @borrows module:url.parseUrl as parseUrl\r\n   * @borrows VideoTrack as VideoTrack\r\n   *\r\n   * @param  {string|Element} id\r\n   *         Video element or video element ID.\r\n   *\r\n   * @param  {Object} [options]\r\n   *         Options object for providing settings.\r\n   *         See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\r\n   *\r\n   * @param  {Component~ReadyCallback} [ready]\r\n   *         A function to be called when the {@link Player} and {@link Tech} are\r\n   *         ready.\r\n   *\r\n   * @return {Player}\r\n   *         The `videojs()` function returns a {@link Player|Player} instance.\r\n   */\r\n\r\n\r\n  function videojs(id, options, ready) {\r\n    var player = videojs.getPlayer(id);\r\n\r\n    if (player) {\r\n      if (options) {\r\n        log$1.warn(\"Player \\\"\" + id + \"\\\" is already initialised. Options will not be applied.\");\r\n      }\r\n\r\n      if (ready) {\r\n        player.ready(ready);\r\n      }\r\n\r\n      return player;\r\n    }\r\n\r\n    var el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\r\n\r\n    if (!isEl(el)) {\r\n      throw new TypeError('The element or ID supplied is not valid. (videojs)');\r\n    } // document.body.contains(el) will only check if el is contained within that one document.\r\n    // This causes problems for elements in iframes.\r\n    // Instead, use the element's ownerDocument instead of the global document.\r\n    // This will make sure that the element is indeed in the dom of that document.\r\n    // Additionally, check that the document in question has a default view.\r\n    // If the document is no longer attached to the dom, the defaultView of the document will be null.\r\n\r\n\r\n    if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {\r\n      log$1.warn('The element supplied is not included in the DOM');\r\n    }\r\n\r\n    options = options || {}; // Store a copy of the el before modification, if it is to be restored in destroy()\r\n    // If div ingest, store the parent div\r\n\r\n    if (options.restoreEl === true) {\r\n      options.restoreEl = (el.parentNode && el.parentNode.hasAttribute('data-vjs-player') ? el.parentNode : el).cloneNode(true);\r\n    }\r\n\r\n    hooks('beforesetup').forEach(function (hookFunction) {\r\n      var opts = hookFunction(el, mergeOptions$3(options));\r\n\r\n      if (!isObject$1(opts) || Array.isArray(opts)) {\r\n        log$1.error('please return an object in beforesetup hooks');\r\n        return;\r\n      }\r\n\r\n      options = mergeOptions$3(options, opts);\r\n    }); // We get the current \"Player\" component here in case an integration has\r\n    // replaced it with a custom player.\r\n\r\n    var PlayerComponent = Component$1.getComponent('Player');\r\n    player = new PlayerComponent(el, options, ready);\r\n    hooks('setup').forEach(function (hookFunction) {\r\n      return hookFunction(player);\r\n    });\r\n    return player;\r\n  }\r\n\r\n  videojs.hooks_ = hooks_;\r\n  videojs.hooks = hooks;\r\n  videojs.hook = hook;\r\n  videojs.hookOnce = hookOnce;\r\n  videojs.removeHook = removeHook; // Add default styles\r\n\r\n  if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\r\n    var style = $('.vjs-styles-defaults');\r\n\r\n    if (!style) {\r\n      style = createStyleElement('vjs-styles-defaults');\r\n      var head = $('head');\r\n\r\n      if (head) {\r\n        head.insertBefore(style, head.firstChild);\r\n      }\r\n\r\n      setTextContent(style, \"\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid:not(.vjs-audio-only-mode) {\\n        padding-top: 56.25%\\n      }\\n    \");\r\n    }\r\n  } // Run Auto-load players\r\n  // You have to wait at least once in case this script is loaded after your\r\n  // video in the DOM (weird behavior only with minified version)\r\n\r\n\r\n  autoSetupTimeout(1, videojs);\r\n  /**\r\n   * Current Video.js version. Follows [semantic versioning](https://semver.org/).\r\n   *\r\n   * @type {string}\r\n   */\r\n\r\n  videojs.VERSION = version$5;\r\n  /**\r\n   * The global options object. These are the settings that take effect\r\n   * if no overrides are specified when the player is created.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  videojs.options = Player.prototype.options_;\r\n  /**\r\n   * Get an object with the currently created players, keyed by player ID\r\n   *\r\n   * @return {Object}\r\n   *         The created players\r\n   */\r\n\r\n  videojs.getPlayers = function () {\r\n    return Player.players;\r\n  };\r\n  /**\r\n   * Get a single player based on an ID or DOM element.\r\n   *\r\n   * This is useful if you want to check if an element or ID has an associated\r\n   * Video.js player, but not create one if it doesn't.\r\n   *\r\n   * @param   {string|Element} id\r\n   *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\r\n   *          or a string matching the `id` of such an element.\r\n   *\r\n   * @return {Player|undefined}\r\n   *          A player instance or `undefined` if there is no player instance\r\n   *          matching the argument.\r\n   */\r\n\r\n\r\n  videojs.getPlayer = function (id) {\r\n    var players = Player.players;\r\n    var tag;\r\n\r\n    if (typeof id === 'string') {\r\n      var nId = normalizeId(id);\r\n      var player = players[nId];\r\n\r\n      if (player) {\r\n        return player;\r\n      }\r\n\r\n      tag = $('#' + nId);\r\n    } else {\r\n      tag = id;\r\n    }\r\n\r\n    if (isEl(tag)) {\r\n      var _tag = tag,\r\n          _player = _tag.player,\r\n          playerId = _tag.playerId; // Element may have a `player` property referring to an already created\r\n      // player instance. If so, return that.\r\n\r\n      if (_player || players[playerId]) {\r\n        return _player || players[playerId];\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Returns an array of all current players.\r\n   *\r\n   * @return {Array}\r\n   *         An array of all players. The array will be in the order that\r\n   *         `Object.keys` provides, which could potentially vary between\r\n   *         JavaScript engines.\r\n   *\r\n   */\r\n\r\n\r\n  videojs.getAllPlayers = function () {\r\n    return (// Disposed players leave a key with a `null` value, so we need to make sure\r\n      // we filter those out.\r\n      Object.keys(Player.players).map(function (k) {\r\n        return Player.players[k];\r\n      }).filter(Boolean)\r\n    );\r\n  };\r\n\r\n  videojs.players = Player.players;\r\n  videojs.getComponent = Component$1.getComponent;\r\n  /**\r\n   * Register a component so it can referred to by name. Used when adding to other\r\n   * components, either through addChild `component.addChild('myComponent')` or through\r\n   * default children options  `{ children: ['myComponent'] }`.\r\n   *\r\n   * > NOTE: You could also just initialize the component before adding.\r\n   * `component.addChild(new MyComponent());`\r\n   *\r\n   * @param {string} name\r\n   *        The class name of the component\r\n   *\r\n   * @param {Component} comp\r\n   *        The component class\r\n   *\r\n   * @return {Component}\r\n   *         The newly registered component\r\n   */\r\n\r\n  videojs.registerComponent = function (name, comp) {\r\n    if (Tech.isTech(comp)) {\r\n      log$1.warn(\"The \" + name + \" tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)\");\r\n    }\r\n\r\n    Component$1.registerComponent.call(Component$1, name, comp);\r\n  };\r\n\r\n  videojs.getTech = Tech.getTech;\r\n  videojs.registerTech = Tech.registerTech;\r\n  videojs.use = use;\r\n  /**\r\n   * An object that can be returned by a middleware to signify\r\n   * that the middleware is being terminated.\r\n   *\r\n   * @type {object}\r\n   * @property {object} middleware.TERMINATOR\r\n   */\r\n\r\n  Object.defineProperty(videojs, 'middleware', {\r\n    value: {},\r\n    writeable: false,\r\n    enumerable: true\r\n  });\r\n  Object.defineProperty(videojs.middleware, 'TERMINATOR', {\r\n    value: TERMINATOR,\r\n    writeable: false,\r\n    enumerable: true\r\n  });\r\n  /**\r\n   * A reference to the {@link module:browser|browser utility module} as an object.\r\n   *\r\n   * @type {Object}\r\n   * @see  {@link module:browser|browser}\r\n   */\r\n\r\n  videojs.browser = browser;\r\n  /**\r\n   * Use {@link module:browser.TOUCH_ENABLED|browser.TOUCH_ENABLED} instead; only\r\n   * included for backward-compatibility with 4.x.\r\n   *\r\n   * @deprecated Since version 5.0, use {@link module:browser.TOUCH_ENABLED|browser.TOUCH_ENABLED instead.\r\n   * @type {boolean}\r\n   */\r\n\r\n  videojs.TOUCH_ENABLED = TOUCH_ENABLED;\r\n  videojs.extend = extend;\r\n  videojs.mergeOptions = mergeOptions$3;\r\n  videojs.bind = bind;\r\n  videojs.registerPlugin = Plugin.registerPlugin;\r\n  videojs.deregisterPlugin = Plugin.deregisterPlugin;\r\n  /**\r\n   * Deprecated method to register a plugin with Video.js\r\n   *\r\n   * @deprecated videojs.plugin() is deprecated; use videojs.registerPlugin() instead\r\n   *\r\n   * @param {string} name\r\n   *        The plugin name\r\n   *\r\n   * @param {Plugin|Function} plugin\r\n   *         The plugin sub-class or function\r\n   */\r\n\r\n  videojs.plugin = function (name, plugin) {\r\n    log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\r\n    return Plugin.registerPlugin(name, plugin);\r\n  };\r\n\r\n  videojs.getPlugins = Plugin.getPlugins;\r\n  videojs.getPlugin = Plugin.getPlugin;\r\n  videojs.getPluginVersion = Plugin.getPluginVersion;\r\n  /**\r\n   * Adding languages so that they're available to all players.\r\n   * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\r\n   *\r\n   * @param {string} code\r\n   *        The language code or dictionary property\r\n   *\r\n   * @param {Object} data\r\n   *        The data values to be translated\r\n   *\r\n   * @return {Object}\r\n   *         The resulting language dictionary object\r\n   */\r\n\r\n  videojs.addLanguage = function (code, data) {\r\n    var _mergeOptions;\r\n\r\n    code = ('' + code).toLowerCase();\r\n    videojs.options.languages = mergeOptions$3(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));\r\n    return videojs.options.languages[code];\r\n  };\r\n  /**\r\n   * A reference to the {@link module:log|log utility module} as an object.\r\n   *\r\n   * @type {Function}\r\n   * @see  {@link module:log|log}\r\n   */\r\n\r\n\r\n  videojs.log = log$1;\r\n  videojs.createLogger = createLogger;\r\n  videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;\r\n  videojs.formatTime = formatTime;\r\n  videojs.setFormatTime = setFormatTime;\r\n  videojs.resetFormatTime = resetFormatTime;\r\n  videojs.parseUrl = parseUrl;\r\n  videojs.isCrossOrigin = isCrossOrigin;\r\n  videojs.EventTarget = EventTarget$2;\r\n  videojs.on = on;\r\n  videojs.one = one;\r\n  videojs.off = off;\r\n  videojs.trigger = trigger;\r\n  /**\r\n   * A cross-browser XMLHttpRequest wrapper.\r\n   *\r\n   * @function\r\n   * @param    {Object} options\r\n   *           Settings for the request.\r\n   *\r\n   * @return   {XMLHttpRequest|XDomainRequest}\r\n   *           The request object.\r\n   *\r\n   * @see      https://github.com/Raynos/xhr\r\n   */\r\n\r\n  videojs.xhr = lib;\r\n  videojs.TextTrack = TextTrack;\r\n  videojs.AudioTrack = AudioTrack;\r\n  videojs.VideoTrack = VideoTrack;\r\n  ['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {\r\n    videojs[k] = function () {\r\n      log$1.warn(\"videojs.\" + k + \"() is deprecated; use videojs.dom.\" + k + \"() instead\");\r\n      return Dom[k].apply(null, arguments);\r\n    };\r\n  });\r\n  videojs.computedStyle = computedStyle;\r\n  /**\r\n   * A reference to the {@link module:dom|DOM utility module} as an object.\r\n   *\r\n   * @type {Object}\r\n   * @see  {@link module:dom|dom}\r\n   */\r\n\r\n  videojs.dom = Dom;\r\n  /**\r\n   * A reference to the {@link module:url|URL utility module} as an object.\r\n   *\r\n   * @type {Object}\r\n   * @see  {@link module:url|url}\r\n   */\r\n\r\n  videojs.url = Url;\r\n  videojs.defineLazyProperty = defineLazyProperty; // Adding less ambiguous text for fullscreen button.\r\n  // In a major update this could become the default text and key.\r\n\r\n  videojs.addLanguage('en', {\r\n    'Non-Fullscreen': 'Exit Fullscreen'\r\n  });\r\n\r\n  var urlToolkit = createCommonjsModule(function (module, exports) {\r\n    // see https://tools.ietf.org/html/rfc1808\r\n    (function (root) {\r\n      var URL_REGEX = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/?#]*\\/)*[^;?#]*)?(;[^?#]*)?(\\?[^#]*)?(#[^]*)?$/;\r\n      var FIRST_SEGMENT_REGEX = /^([^\\/?#]*)([^]*)$/;\r\n      var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\r\n      var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\r\n      var URLToolkit = {\r\n        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\r\n        // E.g\r\n        // With opts.alwaysNormalize = false (default, spec compliant)\r\n        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\r\n        // With opts.alwaysNormalize = true (not spec compliant)\r\n        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\r\n        buildAbsoluteURL: function buildAbsoluteURL(baseURL, relativeURL, opts) {\r\n          opts = opts || {}; // remove any remaining space and CRLF\r\n\r\n          baseURL = baseURL.trim();\r\n          relativeURL = relativeURL.trim();\r\n\r\n          if (!relativeURL) {\r\n            // 2a) If the embedded URL is entirely empty, it inherits the\r\n            // entire base URL (i.e., is set equal to the base URL)\r\n            // and we are done.\r\n            if (!opts.alwaysNormalize) {\r\n              return baseURL;\r\n            }\r\n\r\n            var basePartsForNormalise = URLToolkit.parseURL(baseURL);\r\n\r\n            if (!basePartsForNormalise) {\r\n              throw new Error('Error trying to parse base URL.');\r\n            }\r\n\r\n            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\r\n            return URLToolkit.buildURLFromParts(basePartsForNormalise);\r\n          }\r\n\r\n          var relativeParts = URLToolkit.parseURL(relativeURL);\r\n\r\n          if (!relativeParts) {\r\n            throw new Error('Error trying to parse relative URL.');\r\n          }\r\n\r\n          if (relativeParts.scheme) {\r\n            // 2b) If the embedded URL starts with a scheme name, it is\r\n            // interpreted as an absolute URL and we are done.\r\n            if (!opts.alwaysNormalize) {\r\n              return relativeURL;\r\n            }\r\n\r\n            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\r\n            return URLToolkit.buildURLFromParts(relativeParts);\r\n          }\r\n\r\n          var baseParts = URLToolkit.parseURL(baseURL);\r\n\r\n          if (!baseParts) {\r\n            throw new Error('Error trying to parse base URL.');\r\n          }\r\n\r\n          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\r\n            // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\r\n            // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\r\n            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\r\n            baseParts.netLoc = pathParts[1];\r\n            baseParts.path = pathParts[2];\r\n          }\r\n\r\n          if (baseParts.netLoc && !baseParts.path) {\r\n            baseParts.path = '/';\r\n          }\r\n\r\n          var builtParts = {\r\n            // 2c) Otherwise, the embedded URL inherits the scheme of\r\n            // the base URL.\r\n            scheme: baseParts.scheme,\r\n            netLoc: relativeParts.netLoc,\r\n            path: null,\r\n            params: relativeParts.params,\r\n            query: relativeParts.query,\r\n            fragment: relativeParts.fragment\r\n          };\r\n\r\n          if (!relativeParts.netLoc) {\r\n            // 3) If the embedded URL's <net_loc> is non-empty, we skip to\r\n            // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\r\n            // (if any) of the base URL.\r\n            builtParts.netLoc = baseParts.netLoc; // 4) If the embedded URL path is preceded by a slash \"/\", the\r\n            // path is not relative and we skip to Step 7.\r\n\r\n            if (relativeParts.path[0] !== '/') {\r\n              if (!relativeParts.path) {\r\n                // 5) If the embedded URL path is empty (and not preceded by a\r\n                // slash), then the embedded URL inherits the base URL path\r\n                builtParts.path = baseParts.path; // 5a) if the embedded URL's <params> is non-empty, we skip to\r\n                // step 7; otherwise, it inherits the <params> of the base\r\n                // URL (if any) and\r\n\r\n                if (!relativeParts.params) {\r\n                  builtParts.params = baseParts.params; // 5b) if the embedded URL's <query> is non-empty, we skip to\r\n                  // step 7; otherwise, it inherits the <query> of the base\r\n                  // URL (if any) and we skip to step 7.\r\n\r\n                  if (!relativeParts.query) {\r\n                    builtParts.query = baseParts.query;\r\n                  }\r\n                }\r\n              } else {\r\n                // 6) The last segment of the base URL's path (anything\r\n                // following the rightmost slash \"/\", or the entire path if no\r\n                // slash is present) is removed and the embedded URL's path is\r\n                // appended in its place.\r\n                var baseURLPath = baseParts.path;\r\n                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\r\n                builtParts.path = URLToolkit.normalizePath(newPath);\r\n              }\r\n            }\r\n          }\r\n\r\n          if (builtParts.path === null) {\r\n            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\r\n          }\r\n\r\n          return URLToolkit.buildURLFromParts(builtParts);\r\n        },\r\n        parseURL: function parseURL(url) {\r\n          var parts = URL_REGEX.exec(url);\r\n\r\n          if (!parts) {\r\n            return null;\r\n          }\r\n\r\n          return {\r\n            scheme: parts[1] || '',\r\n            netLoc: parts[2] || '',\r\n            path: parts[3] || '',\r\n            params: parts[4] || '',\r\n            query: parts[5] || '',\r\n            fragment: parts[6] || ''\r\n          };\r\n        },\r\n        normalizePath: function normalizePath(path) {\r\n          // The following operations are\r\n          // then applied, in order, to the new path:\r\n          // 6a) All occurrences of \"./\", where \".\" is a complete path\r\n          // segment, are removed.\r\n          // 6b) If the path ends with \".\" as a complete path segment,\r\n          // that \".\" is removed.\r\n          path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, ''); // 6c) All occurrences of \"<segment>/../\", where <segment> is a\r\n          // complete path segment not equal to \"..\", are removed.\r\n          // Removal of these path segments is performed iteratively,\r\n          // removing the leftmost matching pattern on each iteration,\r\n          // until no matching pattern remains.\r\n          // 6d) If the path ends with \"<segment>/..\", where <segment> is a\r\n          // complete path segment not equal to \"..\", that\r\n          // \"<segment>/..\" is removed.\r\n\r\n          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\r\n\r\n          return path.split('').reverse().join('');\r\n        },\r\n        buildURLFromParts: function buildURLFromParts(parts) {\r\n          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\r\n        }\r\n      };\r\n      module.exports = URLToolkit;\r\n    })();\r\n  });\r\n\r\n  var DEFAULT_LOCATION$1 = 'http://example.com';\r\n\r\n  var resolveUrl$2 = function resolveUrl(baseUrl, relativeUrl) {\r\n    // return early if we don't need to resolve\r\n    if (/^[a-z]+:/i.test(relativeUrl)) {\r\n      return relativeUrl;\r\n    } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\r\n\r\n\r\n    if (/^data:/.test(baseUrl)) {\r\n      baseUrl = window.location && window.location.href || '';\r\n    } // IE11 supports URL but not the URL constructor\r\n    // feature detect the behavior we want\r\n\r\n\r\n    var nativeURL = typeof window.URL === 'function';\r\n    var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\r\n    // and if baseUrl isn't an absolute url\r\n\r\n    var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\r\n\r\n    if (nativeURL) {\r\n      baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION$1);\r\n    } else if (!/\\/\\//i.test(baseUrl)) {\r\n      baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\r\n    }\r\n\r\n    if (nativeURL) {\r\n      var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\r\n      // and if we're location-less, remove the location\r\n      // otherwise, return the url unmodified\r\n\r\n      if (removeLocation) {\r\n        return newUrl.href.slice(DEFAULT_LOCATION$1.length);\r\n      } else if (protocolLess) {\r\n        return newUrl.href.slice(newUrl.protocol.length);\r\n      }\r\n\r\n      return newUrl.href;\r\n    }\r\n\r\n    return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\r\n  };\r\n\r\n  /**\r\n   * @file stream.js\r\n   */\r\n\r\n  /**\r\n   * A lightweight readable stream implemention that handles event dispatching.\r\n   *\r\n   * @class Stream\r\n   */\r\n  var Stream = /*#__PURE__*/function () {\r\n    function Stream() {\r\n      this.listeners = {};\r\n    }\r\n    /**\r\n     * Add a listener for a specified event type.\r\n     *\r\n     * @param {string} type the event name\r\n     * @param {Function} listener the callback to be invoked when an event of\r\n     * the specified type occurs\r\n     */\r\n\r\n\r\n    var _proto = Stream.prototype;\r\n\r\n    _proto.on = function on(type, listener) {\r\n      if (!this.listeners[type]) {\r\n        this.listeners[type] = [];\r\n      }\r\n\r\n      this.listeners[type].push(listener);\r\n    }\r\n    /**\r\n     * Remove a listener for a specified event type.\r\n     *\r\n     * @param {string} type the event name\r\n     * @param {Function} listener  a function previously registered for this\r\n     * type of event through `on`\r\n     * @return {boolean} if we could turn it off or not\r\n     */\r\n    ;\r\n\r\n    _proto.off = function off(type, listener) {\r\n      if (!this.listeners[type]) {\r\n        return false;\r\n      }\r\n\r\n      var index = this.listeners[type].indexOf(listener); // TODO: which is better?\r\n      // In Video.js we slice listener functions\r\n      // on trigger so that it does not mess up the order\r\n      // while we loop through.\r\n      //\r\n      // Here we slice on off so that the loop in trigger\r\n      // can continue using it's old reference to loop without\r\n      // messing up the order.\r\n\r\n      this.listeners[type] = this.listeners[type].slice(0);\r\n      this.listeners[type].splice(index, 1);\r\n      return index > -1;\r\n    }\r\n    /**\r\n     * Trigger an event of the specified type on this stream. Any additional\r\n     * arguments to this function are passed as parameters to event listeners.\r\n     *\r\n     * @param {string} type the event name\r\n     */\r\n    ;\r\n\r\n    _proto.trigger = function trigger(type) {\r\n      var callbacks = this.listeners[type];\r\n\r\n      if (!callbacks) {\r\n        return;\r\n      } // Slicing the arguments on every invocation of this method\r\n      // can add a significant amount of overhead. Avoid the\r\n      // intermediate object creation for the common case of a\r\n      // single callback argument\r\n\r\n\r\n      if (arguments.length === 2) {\r\n        var length = callbacks.length;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n          callbacks[i].call(this, arguments[1]);\r\n        }\r\n      } else {\r\n        var args = Array.prototype.slice.call(arguments, 1);\r\n        var _length = callbacks.length;\r\n\r\n        for (var _i = 0; _i < _length; ++_i) {\r\n          callbacks[_i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Destroys the stream and cleans up.\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.listeners = {};\r\n    }\r\n    /**\r\n     * Forwards all `data` events on this stream to the destination stream. The\r\n     * destination stream should provide a method `push` to receive the data\r\n     * events as they arrive.\r\n     *\r\n     * @param {Stream} destination the stream that will receive all `data` events\r\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n     */\r\n    ;\r\n\r\n    _proto.pipe = function pipe(destination) {\r\n      this.on('data', function (data) {\r\n        destination.push(data);\r\n      });\r\n    };\r\n\r\n    return Stream;\r\n  }();\r\n\r\n  var atob$1 = function atob(s) {\r\n    return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\r\n  };\r\n\r\n  function decodeB64ToUint8Array$1(b64Text) {\r\n    var decodedString = atob$1(b64Text);\r\n    var array = new Uint8Array(decodedString.length);\r\n\r\n    for (var i = 0; i < decodedString.length; i++) {\r\n      array[i] = decodedString.charCodeAt(i);\r\n    }\r\n\r\n    return array;\r\n  }\r\n\r\n  /*! @name m3u8-parser @version 4.7.1 @license Apache-2.0 */\r\n  /**\r\n   * A stream that buffers string input and generates a `data` event for each\r\n   * line.\r\n   *\r\n   * @class LineStream\r\n   * @extends Stream\r\n   */\r\n\r\n  var LineStream = /*#__PURE__*/function (_Stream) {\r\n    inheritsLoose(LineStream, _Stream);\r\n\r\n    function LineStream() {\r\n      var _this;\r\n\r\n      _this = _Stream.call(this) || this;\r\n      _this.buffer = '';\r\n      return _this;\r\n    }\r\n    /**\r\n     * Add new data to be parsed.\r\n     *\r\n     * @param {string} data the text to process\r\n     */\r\n\r\n\r\n    var _proto = LineStream.prototype;\r\n\r\n    _proto.push = function push(data) {\r\n      var nextNewline;\r\n      this.buffer += data;\r\n      nextNewline = this.buffer.indexOf('\\n');\r\n\r\n      for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\r\n        this.trigger('data', this.buffer.substring(0, nextNewline));\r\n        this.buffer = this.buffer.substring(nextNewline + 1);\r\n      }\r\n    };\r\n\r\n    return LineStream;\r\n  }(Stream);\r\n\r\n  var TAB = String.fromCharCode(0x09);\r\n\r\n  var parseByterange = function parseByterange(byterangeString) {\r\n    // optionally match and capture 0+ digits before `@`\r\n    // optionally match and capture 0+ digits after `@`\r\n    var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\r\n    var result = {};\r\n\r\n    if (match[1]) {\r\n      result.length = parseInt(match[1], 10);\r\n    }\r\n\r\n    if (match[2]) {\r\n      result.offset = parseInt(match[2], 10);\r\n    }\r\n\r\n    return result;\r\n  };\r\n  /**\r\n   * \"forgiving\" attribute list psuedo-grammar:\r\n   * attributes -> keyvalue (',' keyvalue)*\r\n   * keyvalue   -> key '=' value\r\n   * key        -> [^=]*\r\n   * value      -> '\"' [^\"]* '\"' | [^,]*\r\n   */\r\n\r\n\r\n  var attributeSeparator = function attributeSeparator() {\r\n    var key = '[^=]*';\r\n    var value = '\"[^\"]*\"|[^,]*';\r\n    var keyvalue = '(?:' + key + ')=(?:' + value + ')';\r\n    return new RegExp('(?:^|,)(' + keyvalue + ')');\r\n  };\r\n  /**\r\n   * Parse attributes from a line given the separator\r\n   *\r\n   * @param {string} attributes the attribute line to parse\r\n   */\r\n\r\n\r\n  var parseAttributes$1 = function parseAttributes(attributes) {\r\n    // split the string using attributes as the separator\r\n    var attrs = attributes.split(attributeSeparator());\r\n    var result = {};\r\n    var i = attrs.length;\r\n    var attr;\r\n\r\n    while (i--) {\r\n      // filter out unmatched portions of the string\r\n      if (attrs[i] === '') {\r\n        continue;\r\n      } // split the key and value\r\n\r\n\r\n      attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\r\n\r\n      attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\r\n      attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\r\n      attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\r\n      result[attr[0]] = attr[1];\r\n    }\r\n\r\n    return result;\r\n  };\r\n  /**\r\n   * A line-level M3U8 parser event stream. It expects to receive input one\r\n   * line at a time and performs a context-free parse of its contents. A stream\r\n   * interpretation of a manifest can be useful if the manifest is expected to\r\n   * be too large to fit comfortably into memory or the entirety of the input\r\n   * is not immediately available. Otherwise, it's probably much easier to work\r\n   * with a regular `Parser` object.\r\n   *\r\n   * Produces `data` events with an object that captures the parser's\r\n   * interpretation of the input. That object has a property `tag` that is one\r\n   * of `uri`, `comment`, or `tag`. URIs only have a single additional\r\n   * property, `line`, which captures the entirety of the input without\r\n   * interpretation. Comments similarly have a single additional property\r\n   * `text` which is the input without the leading `#`.\r\n   *\r\n   * Tags always have a property `tagType` which is the lower-cased version of\r\n   * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\r\n   * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\r\n   * tags are given the tag type `unknown` and a single additional property\r\n   * `data` with the remainder of the input.\r\n   *\r\n   * @class ParseStream\r\n   * @extends Stream\r\n   */\r\n\r\n\r\n  var ParseStream = /*#__PURE__*/function (_Stream) {\r\n    inheritsLoose(ParseStream, _Stream);\r\n\r\n    function ParseStream() {\r\n      var _this;\r\n\r\n      _this = _Stream.call(this) || this;\r\n      _this.customParsers = [];\r\n      _this.tagMappers = [];\r\n      return _this;\r\n    }\r\n    /**\r\n     * Parses an additional line of input.\r\n     *\r\n     * @param {string} line a single line of an M3U8 file to parse\r\n     */\r\n\r\n\r\n    var _proto = ParseStream.prototype;\r\n\r\n    _proto.push = function push(line) {\r\n      var _this2 = this;\r\n\r\n      var match;\r\n      var event; // strip whitespace\r\n\r\n      line = line.trim();\r\n\r\n      if (line.length === 0) {\r\n        // ignore empty lines\r\n        return;\r\n      } // URIs\r\n\r\n\r\n      if (line[0] !== '#') {\r\n        this.trigger('data', {\r\n          type: 'uri',\r\n          uri: line\r\n        });\r\n        return;\r\n      } // map tags\r\n\r\n\r\n      var newLines = this.tagMappers.reduce(function (acc, mapper) {\r\n        var mappedLine = mapper(line); // skip if unchanged\r\n\r\n        if (mappedLine === line) {\r\n          return acc;\r\n        }\r\n\r\n        return acc.concat([mappedLine]);\r\n      }, [line]);\r\n      newLines.forEach(function (newLine) {\r\n        for (var i = 0; i < _this2.customParsers.length; i++) {\r\n          if (_this2.customParsers[i].call(_this2, newLine)) {\r\n            return;\r\n          }\r\n        } // Comments\r\n\r\n\r\n        if (newLine.indexOf('#EXT') !== 0) {\r\n          _this2.trigger('data', {\r\n            type: 'comment',\r\n            text: newLine.slice(1)\r\n          });\r\n\r\n          return;\r\n        } // strip off any carriage returns here so the regex matching\r\n        // doesn't have to account for them.\r\n\r\n\r\n        newLine = newLine.replace('\\r', ''); // Tags\r\n\r\n        match = /^#EXTM3U/.exec(newLine);\r\n\r\n        if (match) {\r\n          _this2.trigger('data', {\r\n            type: 'tag',\r\n            tagType: 'm3u'\r\n          });\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'inf'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.duration = parseFloat(match[1]);\r\n          }\r\n\r\n          if (match[2]) {\r\n            event.title = match[2];\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'targetduration'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.duration = parseInt(match[1], 10);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'version'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.version = parseInt(match[1], 10);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'media-sequence'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.number = parseInt(match[1], 10);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'discontinuity-sequence'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.number = parseInt(match[1], 10);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'playlist-type'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.playlistType = match[1];\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = _extends_1(parseByterange(match[1]), {\r\n            type: 'tag',\r\n            tagType: 'byterange'\r\n          });\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'allow-cache'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.allowed = !/NO/.test(match[1]);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'map'\r\n          };\r\n\r\n          if (match[1]) {\r\n            var attributes = parseAttributes$1(match[1]);\r\n\r\n            if (attributes.URI) {\r\n              event.uri = attributes.URI;\r\n            }\r\n\r\n            if (attributes.BYTERANGE) {\r\n              event.byterange = parseByterange(attributes.BYTERANGE);\r\n            }\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'stream-inf'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.attributes = parseAttributes$1(match[1]);\r\n\r\n            if (event.attributes.RESOLUTION) {\r\n              var split = event.attributes.RESOLUTION.split('x');\r\n              var resolution = {};\r\n\r\n              if (split[0]) {\r\n                resolution.width = parseInt(split[0], 10);\r\n              }\r\n\r\n              if (split[1]) {\r\n                resolution.height = parseInt(split[1], 10);\r\n              }\r\n\r\n              event.attributes.RESOLUTION = resolution;\r\n            }\r\n\r\n            if (event.attributes.BANDWIDTH) {\r\n              event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\r\n            }\r\n\r\n            if (event.attributes['PROGRAM-ID']) {\r\n              event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\r\n            }\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'media'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.attributes = parseAttributes$1(match[1]);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-ENDLIST/.exec(newLine);\r\n\r\n        if (match) {\r\n          _this2.trigger('data', {\r\n            type: 'tag',\r\n            tagType: 'endlist'\r\n          });\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\r\n\r\n        if (match) {\r\n          _this2.trigger('data', {\r\n            type: 'tag',\r\n            tagType: 'discontinuity'\r\n          });\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'program-date-time'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.dateTimeString = match[1];\r\n            event.dateTimeObject = new Date(match[1]);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'key'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.attributes = parseAttributes$1(match[1]); // parse the IV string into a Uint32Array\r\n\r\n            if (event.attributes.IV) {\r\n              if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\r\n                event.attributes.IV = event.attributes.IV.substring(2);\r\n              }\r\n\r\n              event.attributes.IV = event.attributes.IV.match(/.{8}/g);\r\n              event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\r\n              event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\r\n              event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\r\n              event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\r\n              event.attributes.IV = new Uint32Array(event.attributes.IV);\r\n            }\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-START:?(.*)$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'start'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.attributes = parseAttributes$1(match[1]);\r\n            event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\r\n            event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'cue-out-cont'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.data = match[1];\r\n          } else {\r\n            event.data = '';\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'cue-out'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.data = match[1];\r\n          } else {\r\n            event.data = '';\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\r\n\r\n        if (match) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'cue-in'\r\n          };\r\n\r\n          if (match[1]) {\r\n            event.data = match[1];\r\n          } else {\r\n            event.data = '';\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\r\n\r\n        if (match && match[1]) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'skip'\r\n          };\r\n          event.attributes = parseAttributes$1(match[1]);\r\n\r\n          if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\r\n            event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\r\n          }\r\n\r\n          if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\r\n            event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-PART:(.*)$/.exec(newLine);\r\n\r\n        if (match && match[1]) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'part'\r\n          };\r\n          event.attributes = parseAttributes$1(match[1]);\r\n          ['DURATION'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = parseFloat(event.attributes[key]);\r\n            }\r\n          });\r\n          ['INDEPENDENT', 'GAP'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = /YES/.test(event.attributes[key]);\r\n            }\r\n          });\r\n\r\n          if (event.attributes.hasOwnProperty('BYTERANGE')) {\r\n            event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\r\n          }\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\r\n\r\n        if (match && match[1]) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'server-control'\r\n          };\r\n          event.attributes = parseAttributes$1(match[1]);\r\n          ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = parseFloat(event.attributes[key]);\r\n            }\r\n          });\r\n          ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = /YES/.test(event.attributes[key]);\r\n            }\r\n          });\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\r\n\r\n        if (match && match[1]) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'part-inf'\r\n          };\r\n          event.attributes = parseAttributes$1(match[1]);\r\n          ['PART-TARGET'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = parseFloat(event.attributes[key]);\r\n            }\r\n          });\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\r\n\r\n        if (match && match[1]) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'preload-hint'\r\n          };\r\n          event.attributes = parseAttributes$1(match[1]);\r\n          ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = parseInt(event.attributes[key], 10);\r\n              var subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\r\n              event.attributes.byterange = event.attributes.byterange || {};\r\n              event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\r\n\r\n              delete event.attributes[key];\r\n            }\r\n          });\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        }\r\n\r\n        match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\r\n\r\n        if (match && match[1]) {\r\n          event = {\r\n            type: 'tag',\r\n            tagType: 'rendition-report'\r\n          };\r\n          event.attributes = parseAttributes$1(match[1]);\r\n          ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\r\n            if (event.attributes.hasOwnProperty(key)) {\r\n              event.attributes[key] = parseInt(event.attributes[key], 10);\r\n            }\r\n          });\r\n\r\n          _this2.trigger('data', event);\r\n\r\n          return;\r\n        } // unknown tag type\r\n\r\n\r\n        _this2.trigger('data', {\r\n          type: 'tag',\r\n          data: newLine.slice(4)\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Add a parser for custom headers\r\n     *\r\n     * @param {Object}   options              a map of options for the added parser\r\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\r\n     * @param {string}   options.customType   the custom type to register to the output\r\n     * @param {Function} [options.dataParser] function to parse the line into an object\r\n     * @param {boolean}  [options.segment]    should tag data be attached to the segment object\r\n     */\r\n    ;\r\n\r\n    _proto.addParser = function addParser(_ref) {\r\n      var _this3 = this;\r\n\r\n      var expression = _ref.expression,\r\n          customType = _ref.customType,\r\n          dataParser = _ref.dataParser,\r\n          segment = _ref.segment;\r\n\r\n      if (typeof dataParser !== 'function') {\r\n        dataParser = function dataParser(line) {\r\n          return line;\r\n        };\r\n      }\r\n\r\n      this.customParsers.push(function (line) {\r\n        var match = expression.exec(line);\r\n\r\n        if (match) {\r\n          _this3.trigger('data', {\r\n            type: 'custom',\r\n            data: dataParser(line),\r\n            customType: customType,\r\n            segment: segment\r\n          });\r\n\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Add a custom header mapper\r\n     *\r\n     * @param {Object}   options\r\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\r\n     * @param {Function} options.map          function to translate tag into a different tag\r\n     */\r\n    ;\r\n\r\n    _proto.addTagMapper = function addTagMapper(_ref2) {\r\n      var expression = _ref2.expression,\r\n          map = _ref2.map;\r\n\r\n      var mapFn = function mapFn(line) {\r\n        if (expression.test(line)) {\r\n          return map(line);\r\n        }\r\n\r\n        return line;\r\n      };\r\n\r\n      this.tagMappers.push(mapFn);\r\n    };\r\n\r\n    return ParseStream;\r\n  }(Stream);\r\n\r\n  var camelCase = function camelCase(str) {\r\n    return str.toLowerCase().replace(/-(\\w)/g, function (a) {\r\n      return a[1].toUpperCase();\r\n    });\r\n  };\r\n\r\n  var camelCaseKeys = function camelCaseKeys(attributes) {\r\n    var result = {};\r\n    Object.keys(attributes).forEach(function (key) {\r\n      result[camelCase(key)] = attributes[key];\r\n    });\r\n    return result;\r\n  }; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\r\n  // we need this helper because defaults are based upon targetDuration and\r\n  // partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\r\n  // target durations are set.\r\n\r\n\r\n  var setHoldBack = function setHoldBack(manifest) {\r\n    var serverControl = manifest.serverControl,\r\n        targetDuration = manifest.targetDuration,\r\n        partTargetDuration = manifest.partTargetDuration;\r\n\r\n    if (!serverControl) {\r\n      return;\r\n    }\r\n\r\n    var tag = '#EXT-X-SERVER-CONTROL';\r\n    var hb = 'holdBack';\r\n    var phb = 'partHoldBack';\r\n    var minTargetDuration = targetDuration && targetDuration * 3;\r\n    var minPartDuration = partTargetDuration && partTargetDuration * 2;\r\n\r\n    if (targetDuration && !serverControl.hasOwnProperty(hb)) {\r\n      serverControl[hb] = minTargetDuration;\r\n      this.trigger('info', {\r\n        message: tag + \" defaulting HOLD-BACK to targetDuration * 3 (\" + minTargetDuration + \").\"\r\n      });\r\n    }\r\n\r\n    if (minTargetDuration && serverControl[hb] < minTargetDuration) {\r\n      this.trigger('warn', {\r\n        message: tag + \" clamping HOLD-BACK (\" + serverControl[hb] + \") to targetDuration * 3 (\" + minTargetDuration + \")\"\r\n      });\r\n      serverControl[hb] = minTargetDuration;\r\n    } // default no part hold back to part target duration * 3\r\n\r\n\r\n    if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\r\n      serverControl[phb] = partTargetDuration * 3;\r\n      this.trigger('info', {\r\n        message: tag + \" defaulting PART-HOLD-BACK to partTargetDuration * 3 (\" + serverControl[phb] + \").\"\r\n      });\r\n    } // if part hold back is too small default it to part target duration * 2\r\n\r\n\r\n    if (partTargetDuration && serverControl[phb] < minPartDuration) {\r\n      this.trigger('warn', {\r\n        message: tag + \" clamping PART-HOLD-BACK (\" + serverControl[phb] + \") to partTargetDuration * 2 (\" + minPartDuration + \").\"\r\n      });\r\n      serverControl[phb] = minPartDuration;\r\n    }\r\n  };\r\n  /**\r\n   * A parser for M3U8 files. The current interpretation of the input is\r\n   * exposed as a property `manifest` on parser objects. It's just two lines to\r\n   * create and parse a manifest once you have the contents available as a string:\r\n   *\r\n   * ```js\r\n   * var parser = new m3u8.Parser();\r\n   * parser.push(xhr.responseText);\r\n   * ```\r\n   *\r\n   * New input can later be applied to update the manifest object by calling\r\n   * `push` again.\r\n   *\r\n   * The parser attempts to create a usable manifest object even if the\r\n   * underlying input is somewhat nonsensical. It emits `info` and `warning`\r\n   * events during the parse if it encounters input that seems invalid or\r\n   * requires some property of the manifest object to be defaulted.\r\n   *\r\n   * @class Parser\r\n   * @extends Stream\r\n   */\r\n\r\n\r\n  var Parser = /*#__PURE__*/function (_Stream) {\r\n    inheritsLoose(Parser, _Stream);\r\n\r\n    function Parser() {\r\n      var _this;\r\n\r\n      _this = _Stream.call(this) || this;\r\n      _this.lineStream = new LineStream();\r\n      _this.parseStream = new ParseStream();\r\n\r\n      _this.lineStream.pipe(_this.parseStream);\r\n      /* eslint-disable consistent-this */\r\n\r\n\r\n      var self = assertThisInitialized(_this);\r\n      /* eslint-enable consistent-this */\r\n\r\n\r\n      var uris = [];\r\n      var currentUri = {}; // if specified, the active EXT-X-MAP definition\r\n\r\n      var currentMap; // if specified, the active decryption key\r\n\r\n      var _key;\r\n\r\n      var hasParts = false;\r\n\r\n      var noop = function noop() {};\r\n\r\n      var defaultMediaGroups = {\r\n        'AUDIO': {},\r\n        'VIDEO': {},\r\n        'CLOSED-CAPTIONS': {},\r\n        'SUBTITLES': {}\r\n      }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\r\n      // used in MPDs with Widevine encrypted streams.\r\n\r\n      var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\r\n\r\n      var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\r\n\r\n      _this.manifest = {\r\n        allowCache: true,\r\n        discontinuityStarts: [],\r\n        segments: []\r\n      }; // keep track of the last seen segment's byte range end, as segments are not required\r\n      // to provide the offset, in which case it defaults to the next byte after the\r\n      // previous segment\r\n\r\n      var lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\r\n\r\n      var lastPartByterangeEnd = 0;\r\n\r\n      _this.on('end', function () {\r\n        // only add preloadSegment if we don't yet have a uri for it.\r\n        // and we actually have parts/preloadHints\r\n        if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\r\n          return;\r\n        }\r\n\r\n        if (!currentUri.map && currentMap) {\r\n          currentUri.map = currentMap;\r\n        }\r\n\r\n        if (!currentUri.key && _key) {\r\n          currentUri.key = _key;\r\n        }\r\n\r\n        if (!currentUri.timeline && typeof currentTimeline === 'number') {\r\n          currentUri.timeline = currentTimeline;\r\n        }\r\n\r\n        _this.manifest.preloadSegment = currentUri;\r\n      }); // update the manifest with the m3u8 entry from the parse stream\r\n\r\n\r\n      _this.parseStream.on('data', function (entry) {\r\n        var mediaGroup;\r\n        var rendition;\r\n        ({\r\n          tag: function tag() {\r\n            // switch based on the tag type\r\n            (({\r\n              version: function version() {\r\n                if (entry.version) {\r\n                  this.manifest.version = entry.version;\r\n                }\r\n              },\r\n              'allow-cache': function allowCache() {\r\n                this.manifest.allowCache = entry.allowed;\r\n\r\n                if (!('allowed' in entry)) {\r\n                  this.trigger('info', {\r\n                    message: 'defaulting allowCache to YES'\r\n                  });\r\n                  this.manifest.allowCache = true;\r\n                }\r\n              },\r\n              byterange: function byterange() {\r\n                var byterange = {};\r\n\r\n                if ('length' in entry) {\r\n                  currentUri.byterange = byterange;\r\n                  byterange.length = entry.length;\r\n\r\n                  if (!('offset' in entry)) {\r\n                    /*\r\n                     * From the latest spec (as of this writing):\r\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\r\n                     *\r\n                     * Same text since EXT-X-BYTERANGE's introduction in draft 7:\r\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\r\n                     *\r\n                     * \"If o [offset] is not present, the sub-range begins at the next byte\r\n                     * following the sub-range of the previous media segment.\"\r\n                     */\r\n                    entry.offset = lastByterangeEnd;\r\n                  }\r\n                }\r\n\r\n                if ('offset' in entry) {\r\n                  currentUri.byterange = byterange;\r\n                  byterange.offset = entry.offset;\r\n                }\r\n\r\n                lastByterangeEnd = byterange.offset + byterange.length;\r\n              },\r\n              endlist: function endlist() {\r\n                this.manifest.endList = true;\r\n              },\r\n              inf: function inf() {\r\n                if (!('mediaSequence' in this.manifest)) {\r\n                  this.manifest.mediaSequence = 0;\r\n                  this.trigger('info', {\r\n                    message: 'defaulting media sequence to zero'\r\n                  });\r\n                }\r\n\r\n                if (!('discontinuitySequence' in this.manifest)) {\r\n                  this.manifest.discontinuitySequence = 0;\r\n                  this.trigger('info', {\r\n                    message: 'defaulting discontinuity sequence to zero'\r\n                  });\r\n                }\r\n\r\n                if (entry.duration > 0) {\r\n                  currentUri.duration = entry.duration;\r\n                }\r\n\r\n                if (entry.duration === 0) {\r\n                  currentUri.duration = 0.01;\r\n                  this.trigger('info', {\r\n                    message: 'updating zero segment duration to a small value'\r\n                  });\r\n                }\r\n\r\n                this.manifest.segments = uris;\r\n              },\r\n              key: function key() {\r\n                if (!entry.attributes) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring key declaration without attribute list'\r\n                  });\r\n                  return;\r\n                } // clear the active encryption key\r\n\r\n\r\n                if (entry.attributes.METHOD === 'NONE') {\r\n                  _key = null;\r\n                  return;\r\n                }\r\n\r\n                if (!entry.attributes.URI) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring key declaration without URI'\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\r\n                  this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\r\n\r\n                  this.manifest.contentProtection['com.apple.fps.1_0'] = {\r\n                    attributes: entry.attributes\r\n                  };\r\n                  return;\r\n                }\r\n\r\n                if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\r\n                  this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\r\n\r\n                  this.manifest.contentProtection['com.microsoft.playready'] = {\r\n                    uri: entry.attributes.URI\r\n                  };\r\n                  return;\r\n                } // check if the content is encrypted for Widevine\r\n                // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\r\n\r\n\r\n                if (entry.attributes.KEYFORMAT === widevineUuid) {\r\n                  var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\r\n\r\n                  if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\r\n                    this.trigger('warn', {\r\n                      message: 'invalid key method provided for Widevine'\r\n                    });\r\n                    return;\r\n                  }\r\n\r\n                  if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\r\n                    this.trigger('warn', {\r\n                      message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\r\n                    });\r\n                  }\r\n\r\n                  if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\r\n                    this.trigger('warn', {\r\n                      message: 'invalid key URI provided for Widevine'\r\n                    });\r\n                    return;\r\n                  }\r\n\r\n                  if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\r\n                    this.trigger('warn', {\r\n                      message: 'invalid key ID provided for Widevine'\r\n                    });\r\n                    return;\r\n                  } // if Widevine key attributes are valid, store them as `contentProtection`\r\n                  // on the manifest to emulate Widevine tag structure in a DASH mpd\r\n\r\n\r\n                  this.manifest.contentProtection = this.manifest.contentProtection || {};\r\n                  this.manifest.contentProtection['com.widevine.alpha'] = {\r\n                    attributes: {\r\n                      schemeIdUri: entry.attributes.KEYFORMAT,\r\n                      // remove '0x' from the key id string\r\n                      keyId: entry.attributes.KEYID.substring(2)\r\n                    },\r\n                    // decode the base64-encoded PSSH box\r\n                    pssh: decodeB64ToUint8Array$1(entry.attributes.URI.split(',')[1])\r\n                  };\r\n                  return;\r\n                }\r\n\r\n                if (!entry.attributes.METHOD) {\r\n                  this.trigger('warn', {\r\n                    message: 'defaulting key method to AES-128'\r\n                  });\r\n                } // setup an encryption key for upcoming segments\r\n\r\n\r\n                _key = {\r\n                  method: entry.attributes.METHOD || 'AES-128',\r\n                  uri: entry.attributes.URI\r\n                };\r\n\r\n                if (typeof entry.attributes.IV !== 'undefined') {\r\n                  _key.iv = entry.attributes.IV;\r\n                }\r\n              },\r\n              'media-sequence': function mediaSequence() {\r\n                if (!isFinite(entry.number)) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring invalid media sequence: ' + entry.number\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                this.manifest.mediaSequence = entry.number;\r\n              },\r\n              'discontinuity-sequence': function discontinuitySequence() {\r\n                if (!isFinite(entry.number)) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring invalid discontinuity sequence: ' + entry.number\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                this.manifest.discontinuitySequence = entry.number;\r\n                currentTimeline = entry.number;\r\n              },\r\n              'playlist-type': function playlistType() {\r\n                if (!/VOD|EVENT/.test(entry.playlistType)) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring unknown playlist type: ' + entry.playlist\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                this.manifest.playlistType = entry.playlistType;\r\n              },\r\n              map: function map() {\r\n                currentMap = {};\r\n\r\n                if (entry.uri) {\r\n                  currentMap.uri = entry.uri;\r\n                }\r\n\r\n                if (entry.byterange) {\r\n                  currentMap.byterange = entry.byterange;\r\n                }\r\n\r\n                if (_key) {\r\n                  currentMap.key = _key;\r\n                }\r\n              },\r\n              'stream-inf': function streamInf() {\r\n                this.manifest.playlists = uris;\r\n                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\r\n\r\n                if (!entry.attributes) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring empty stream-inf attributes'\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                if (!currentUri.attributes) {\r\n                  currentUri.attributes = {};\r\n                }\r\n\r\n                _extends_1(currentUri.attributes, entry.attributes);\r\n              },\r\n              media: function media() {\r\n                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\r\n\r\n                if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring incomplete or missing media group'\r\n                  });\r\n                  return;\r\n                } // find the media group, creating defaults as necessary\r\n\r\n\r\n                var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\r\n                mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\r\n                mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\r\n\r\n                rendition = {\r\n                  \"default\": /yes/i.test(entry.attributes.DEFAULT)\r\n                };\r\n\r\n                if (rendition[\"default\"]) {\r\n                  rendition.autoselect = true;\r\n                } else {\r\n                  rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\r\n                }\r\n\r\n                if (entry.attributes.LANGUAGE) {\r\n                  rendition.language = entry.attributes.LANGUAGE;\r\n                }\r\n\r\n                if (entry.attributes.URI) {\r\n                  rendition.uri = entry.attributes.URI;\r\n                }\r\n\r\n                if (entry.attributes['INSTREAM-ID']) {\r\n                  rendition.instreamId = entry.attributes['INSTREAM-ID'];\r\n                }\r\n\r\n                if (entry.attributes.CHARACTERISTICS) {\r\n                  rendition.characteristics = entry.attributes.CHARACTERISTICS;\r\n                }\r\n\r\n                if (entry.attributes.FORCED) {\r\n                  rendition.forced = /yes/i.test(entry.attributes.FORCED);\r\n                } // insert the new rendition\r\n\r\n\r\n                mediaGroup[entry.attributes.NAME] = rendition;\r\n              },\r\n              discontinuity: function discontinuity() {\r\n                currentTimeline += 1;\r\n                currentUri.discontinuity = true;\r\n                this.manifest.discontinuityStarts.push(uris.length);\r\n              },\r\n              'program-date-time': function programDateTime() {\r\n                if (typeof this.manifest.dateTimeString === 'undefined') {\r\n                  // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\r\n                  // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\r\n                  // to the manifest object\r\n                  // TODO: Consider removing this in future major version\r\n                  this.manifest.dateTimeString = entry.dateTimeString;\r\n                  this.manifest.dateTimeObject = entry.dateTimeObject;\r\n                }\r\n\r\n                currentUri.dateTimeString = entry.dateTimeString;\r\n                currentUri.dateTimeObject = entry.dateTimeObject;\r\n              },\r\n              targetduration: function targetduration() {\r\n                if (!isFinite(entry.duration) || entry.duration < 0) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring invalid target duration: ' + entry.duration\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                this.manifest.targetDuration = entry.duration;\r\n                setHoldBack.call(this, this.manifest);\r\n              },\r\n              start: function start() {\r\n                if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\r\n                  this.trigger('warn', {\r\n                    message: 'ignoring start declaration without appropriate attribute list'\r\n                  });\r\n                  return;\r\n                }\r\n\r\n                this.manifest.start = {\r\n                  timeOffset: entry.attributes['TIME-OFFSET'],\r\n                  precise: entry.attributes.PRECISE\r\n                };\r\n              },\r\n              'cue-out': function cueOut() {\r\n                currentUri.cueOut = entry.data;\r\n              },\r\n              'cue-out-cont': function cueOutCont() {\r\n                currentUri.cueOutCont = entry.data;\r\n              },\r\n              'cue-in': function cueIn() {\r\n                currentUri.cueIn = entry.data;\r\n              },\r\n              'skip': function skip() {\r\n                this.manifest.skip = camelCaseKeys(entry.attributes);\r\n                this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\r\n              },\r\n              'part': function part() {\r\n                var _this2 = this;\r\n\r\n                hasParts = true; // parts are always specifed before a segment\r\n\r\n                var segmentIndex = this.manifest.segments.length;\r\n                var part = camelCaseKeys(entry.attributes);\r\n                currentUri.parts = currentUri.parts || [];\r\n                currentUri.parts.push(part);\r\n\r\n                if (part.byterange) {\r\n                  if (!part.byterange.hasOwnProperty('offset')) {\r\n                    part.byterange.offset = lastPartByterangeEnd;\r\n                  }\r\n\r\n                  lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\r\n                }\r\n\r\n                var partIndex = currentUri.parts.length - 1;\r\n                this.warnOnMissingAttributes_(\"#EXT-X-PART #\" + partIndex + \" for segment #\" + segmentIndex, entry.attributes, ['URI', 'DURATION']);\r\n\r\n                if (this.manifest.renditionReports) {\r\n                  this.manifest.renditionReports.forEach(function (r, i) {\r\n                    if (!r.hasOwnProperty('lastPart')) {\r\n                      _this2.trigger('warn', {\r\n                        message: \"#EXT-X-RENDITION-REPORT #\" + i + \" lacks required attribute(s): LAST-PART\"\r\n                      });\r\n                    }\r\n                  });\r\n                }\r\n              },\r\n              'server-control': function serverControl() {\r\n                var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\r\n\r\n                if (!attrs.hasOwnProperty('canBlockReload')) {\r\n                  attrs.canBlockReload = false;\r\n                  this.trigger('info', {\r\n                    message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\r\n                  });\r\n                }\r\n\r\n                setHoldBack.call(this, this.manifest);\r\n\r\n                if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\r\n                  this.trigger('warn', {\r\n                    message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\r\n                  });\r\n                }\r\n              },\r\n              'preload-hint': function preloadHint() {\r\n                // parts are always specifed before a segment\r\n                var segmentIndex = this.manifest.segments.length;\r\n                var hint = camelCaseKeys(entry.attributes);\r\n                var isPart = hint.type && hint.type === 'PART';\r\n                currentUri.preloadHints = currentUri.preloadHints || [];\r\n                currentUri.preloadHints.push(hint);\r\n\r\n                if (hint.byterange) {\r\n                  if (!hint.byterange.hasOwnProperty('offset')) {\r\n                    // use last part byterange end or zero if not a part.\r\n                    hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\r\n\r\n                    if (isPart) {\r\n                      lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                var index = currentUri.preloadHints.length - 1;\r\n                this.warnOnMissingAttributes_(\"#EXT-X-PRELOAD-HINT #\" + index + \" for segment #\" + segmentIndex, entry.attributes, ['TYPE', 'URI']);\r\n\r\n                if (!hint.type) {\r\n                  return;\r\n                } // search through all preload hints except for the current one for\r\n                // a duplicate type.\r\n\r\n\r\n                for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {\r\n                  var otherHint = currentUri.preloadHints[i];\r\n\r\n                  if (!otherHint.type) {\r\n                    continue;\r\n                  }\r\n\r\n                  if (otherHint.type === hint.type) {\r\n                    this.trigger('warn', {\r\n                      message: \"#EXT-X-PRELOAD-HINT #\" + index + \" for segment #\" + segmentIndex + \" has the same TYPE \" + hint.type + \" as preload hint #\" + i\r\n                    });\r\n                  }\r\n                }\r\n              },\r\n              'rendition-report': function renditionReport() {\r\n                var report = camelCaseKeys(entry.attributes);\r\n                this.manifest.renditionReports = this.manifest.renditionReports || [];\r\n                this.manifest.renditionReports.push(report);\r\n                var index = this.manifest.renditionReports.length - 1;\r\n                var required = ['LAST-MSN', 'URI'];\r\n\r\n                if (hasParts) {\r\n                  required.push('LAST-PART');\r\n                }\r\n\r\n                this.warnOnMissingAttributes_(\"#EXT-X-RENDITION-REPORT #\" + index, entry.attributes, required);\r\n              },\r\n              'part-inf': function partInf() {\r\n                this.manifest.partInf = camelCaseKeys(entry.attributes);\r\n                this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\r\n\r\n                if (this.manifest.partInf.partTarget) {\r\n                  this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\r\n                }\r\n\r\n                setHoldBack.call(this, this.manifest);\r\n              }\r\n            })[entry.tagType] || noop).call(self);\r\n          },\r\n          uri: function uri() {\r\n            currentUri.uri = entry.uri;\r\n            uris.push(currentUri); // if no explicit duration was declared, use the target duration\r\n\r\n            if (this.manifest.targetDuration && !('duration' in currentUri)) {\r\n              this.trigger('warn', {\r\n                message: 'defaulting segment duration to the target duration'\r\n              });\r\n              currentUri.duration = this.manifest.targetDuration;\r\n            } // annotate with encryption information, if necessary\r\n\r\n\r\n            if (_key) {\r\n              currentUri.key = _key;\r\n            }\r\n\r\n            currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\r\n\r\n            if (currentMap) {\r\n              currentUri.map = currentMap;\r\n            } // reset the last byterange end as it needs to be 0 between parts\r\n\r\n\r\n            lastPartByterangeEnd = 0; // prepare for the next URI\r\n\r\n            currentUri = {};\r\n          },\r\n          comment: function comment() {// comments are not important for playback\r\n          },\r\n          custom: function custom() {\r\n            // if this is segment-level data attach the output to the segment\r\n            if (entry.segment) {\r\n              currentUri.custom = currentUri.custom || {};\r\n              currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\r\n            } else {\r\n              this.manifest.custom = this.manifest.custom || {};\r\n              this.manifest.custom[entry.customType] = entry.data;\r\n            }\r\n          }\r\n        })[entry.type].call(self);\r\n      });\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = Parser.prototype;\r\n\r\n    _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {\r\n      var missing = [];\r\n      required.forEach(function (key) {\r\n        if (!attributes.hasOwnProperty(key)) {\r\n          missing.push(key);\r\n        }\r\n      });\r\n\r\n      if (missing.length) {\r\n        this.trigger('warn', {\r\n          message: identifier + \" lacks required attribute(s): \" + missing.join(', ')\r\n        });\r\n      }\r\n    }\r\n    /**\r\n     * Parse the input string and update the manifest object.\r\n     *\r\n     * @param {string} chunk a potentially incomplete portion of the manifest\r\n     */\r\n    ;\r\n\r\n    _proto.push = function push(chunk) {\r\n      this.lineStream.push(chunk);\r\n    }\r\n    /**\r\n     * Flush any remaining input. This can be handy if the last line of an M3U8\r\n     * manifest did not contain a trailing newline but the file has been\r\n     * completely received.\r\n     */\r\n    ;\r\n\r\n    _proto.end = function end() {\r\n      // flush any buffered input\r\n      this.lineStream.push('\\n');\r\n      this.trigger('end');\r\n    }\r\n    /**\r\n     * Add an additional parser for non-standard tags\r\n     *\r\n     * @param {Object}   options              a map of options for the added parser\r\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\r\n     * @param {string}   options.type         the type to register to the output\r\n     * @param {Function} [options.dataParser] function to parse the line into an object\r\n     * @param {boolean}  [options.segment]    should tag data be attached to the segment object\r\n     */\r\n    ;\r\n\r\n    _proto.addParser = function addParser(options) {\r\n      this.parseStream.addParser(options);\r\n    }\r\n    /**\r\n     * Add a custom header mapper\r\n     *\r\n     * @param {Object}   options\r\n     * @param {RegExp}   options.expression   a regular expression to match the custom header\r\n     * @param {Function} options.map          function to translate tag into a different tag\r\n     */\r\n    ;\r\n\r\n    _proto.addTagMapper = function addTagMapper(options) {\r\n      this.parseStream.addTagMapper(options);\r\n    };\r\n\r\n    return Parser;\r\n  }(Stream);\r\n\r\n  var regexs = {\r\n    // to determine mime types\r\n    mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\r\n    webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\r\n    ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\r\n    // to determine if a codec is audio or video\r\n    video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\r\n    audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\r\n    text: /^(stpp.ttml.im1t)/,\r\n    // mux.js support regex\r\n    muxerVideo: /^(avc0?1)/,\r\n    muxerAudio: /^(mp4a)/,\r\n    // match nothing as muxer does not support text right now.\r\n    // there cannot never be a character before the start of a string\r\n    // so this matches nothing.\r\n    muxerText: /a^/\r\n  };\r\n  var mediaTypes = ['video', 'audio', 'text'];\r\n  var upperMediaTypes = ['Video', 'Audio', 'Text'];\r\n  /**\r\n   * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\r\n   * `avc1.<hhhhhh>`\r\n   *\r\n   * @param {string} codec\r\n   *        Codec string to translate\r\n   * @return {string}\r\n   *         The translated codec string\r\n   */\r\n\r\n  var translateLegacyCodec = function translateLegacyCodec(codec) {\r\n    if (!codec) {\r\n      return codec;\r\n    }\r\n\r\n    return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\r\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\r\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\r\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\r\n    });\r\n  };\r\n  /**\r\n   * @typedef {Object} ParsedCodecInfo\r\n   * @property {number} codecCount\r\n   *           Number of codecs parsed\r\n   * @property {string} [videoCodec]\r\n   *           Parsed video codec (if found)\r\n   * @property {string} [videoObjectTypeIndicator]\r\n   *           Video object type indicator (if found)\r\n   * @property {string|null} audioProfile\r\n   *           Audio profile\r\n   */\r\n\r\n  /**\r\n   * Parses a codec string to retrieve the number of codecs specified, the video codec and\r\n   * object type indicator, and the audio profile.\r\n   *\r\n   * @param {string} [codecString]\r\n   *        The codec string to parse\r\n   * @return {ParsedCodecInfo}\r\n   *         Parsed codec info\r\n   */\r\n\r\n  var parseCodecs = function parseCodecs(codecString) {\r\n    if (codecString === void 0) {\r\n      codecString = '';\r\n    }\r\n\r\n    var codecs = codecString.split(',');\r\n    var result = [];\r\n    codecs.forEach(function (codec) {\r\n      codec = codec.trim();\r\n      var codecType;\r\n      mediaTypes.forEach(function (name) {\r\n        var match = regexs[name].exec(codec.toLowerCase());\r\n\r\n        if (!match || match.length <= 1) {\r\n          return;\r\n        }\r\n\r\n        codecType = name; // maintain codec case\r\n\r\n        var type = codec.substring(0, match[1].length);\r\n        var details = codec.replace(type, '');\r\n        result.push({\r\n          type: type,\r\n          details: details,\r\n          mediaType: name\r\n        });\r\n      });\r\n\r\n      if (!codecType) {\r\n        result.push({\r\n          type: codec,\r\n          details: '',\r\n          mediaType: 'unknown'\r\n        });\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n  /**\r\n   * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\r\n   * a default alternate audio playlist for the provided audio group.\r\n   *\r\n   * @param {Object} master\r\n   *        The master playlist\r\n   * @param {string} audioGroupId\r\n   *        ID of the audio group for which to find the default codec info\r\n   * @return {ParsedCodecInfo}\r\n   *         Parsed codec info\r\n   */\r\n\r\n  var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\r\n    if (!master.mediaGroups.AUDIO || !audioGroupId) {\r\n      return null;\r\n    }\r\n\r\n    var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\r\n\r\n    if (!audioGroup) {\r\n      return null;\r\n    }\r\n\r\n    for (var name in audioGroup) {\r\n      var audioType = audioGroup[name];\r\n\r\n      if (audioType[\"default\"] && audioType.playlists) {\r\n        // codec should be the same for all playlists within the audio type\r\n        return parseCodecs(audioType.playlists[0].attributes.CODECS);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n  var isAudioCodec = function isAudioCodec(codec) {\r\n    if (codec === void 0) {\r\n      codec = '';\r\n    }\r\n\r\n    return regexs.audio.test(codec.trim().toLowerCase());\r\n  };\r\n  var isTextCodec = function isTextCodec(codec) {\r\n    if (codec === void 0) {\r\n      codec = '';\r\n    }\r\n\r\n    return regexs.text.test(codec.trim().toLowerCase());\r\n  };\r\n  var getMimeForCodec = function getMimeForCodec(codecString) {\r\n    if (!codecString || typeof codecString !== 'string') {\r\n      return;\r\n    }\r\n\r\n    var codecs = codecString.toLowerCase().split(',').map(function (c) {\r\n      return translateLegacyCodec(c.trim());\r\n    }); // default to video type\r\n\r\n    var type = 'video'; // only change to audio type if the only codec we have is\r\n    // audio\r\n\r\n    if (codecs.length === 1 && isAudioCodec(codecs[0])) {\r\n      type = 'audio';\r\n    } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\r\n      // text uses application/<container> for now\r\n      type = 'application';\r\n    } // default the container to mp4\r\n\r\n\r\n    var container = 'mp4'; // every codec must be able to go into the container\r\n    // for that container to be the correct one\r\n\r\n    if (codecs.every(function (c) {\r\n      return regexs.mp4.test(c);\r\n    })) {\r\n      container = 'mp4';\r\n    } else if (codecs.every(function (c) {\r\n      return regexs.webm.test(c);\r\n    })) {\r\n      container = 'webm';\r\n    } else if (codecs.every(function (c) {\r\n      return regexs.ogg.test(c);\r\n    })) {\r\n      container = 'ogg';\r\n    }\r\n\r\n    return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\r\n  };\r\n  var browserSupportsCodec = function browserSupportsCodec(codecString) {\r\n    if (codecString === void 0) {\r\n      codecString = '';\r\n    }\r\n\r\n    return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\r\n  };\r\n  var muxerSupportsCodec = function muxerSupportsCodec(codecString) {\r\n    if (codecString === void 0) {\r\n      codecString = '';\r\n    }\r\n\r\n    return codecString.toLowerCase().split(',').every(function (codec) {\r\n      codec = codec.trim(); // any match is supported.\r\n\r\n      for (var i = 0; i < upperMediaTypes.length; i++) {\r\n        var type = upperMediaTypes[i];\r\n\r\n        if (regexs[\"muxer\" + type].test(codec)) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    });\r\n  };\r\n  var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\r\n  var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\r\n\r\n  var MPEGURL_REGEX = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\r\n  var DASH_REGEX = /^application\\/dash\\+xml/i;\r\n  /**\r\n   * Returns a string that describes the type of source based on a video source object's\r\n   * media type.\r\n   *\r\n   * @see {@link https://dev.w3.org/html5/pf-summary/video.html#dom-source-type|Source Type}\r\n   *\r\n   * @param {string} type\r\n   *        Video source object media type\r\n   * @return {('hls'|'dash'|'vhs-json'|null)}\r\n   *         VHS source type string\r\n   */\r\n\r\n  var simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\r\n    if (MPEGURL_REGEX.test(type)) {\r\n      return 'hls';\r\n    }\r\n\r\n    if (DASH_REGEX.test(type)) {\r\n      return 'dash';\r\n    } // Denotes the special case of a manifest object passed to http-streaming instead of a\r\n    // source URL.\r\n    //\r\n    // See https://en.wikipedia.org/wiki/Media_type for details on specifying media types.\r\n    //\r\n    // In this case, vnd stands for vendor, video.js for the organization, VHS for this\r\n    // project, and the +json suffix identifies the structure of the media type.\r\n\r\n\r\n    if (type === 'application/vnd.videojs.vhs+json') {\r\n      return 'vhs-json';\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\r\n  // we used to do this with log2 but BigInt does not support builtin math\r\n  // Math.ceil(log2(x));\r\n\r\n\r\n  var countBits = function countBits(x) {\r\n    return x.toString(2).length;\r\n  }; // count the number of whole bytes it would take to represent a number\r\n\r\n  var countBytes = function countBytes(x) {\r\n    return Math.ceil(countBits(x) / 8);\r\n  };\r\n  var isArrayBufferView = function isArrayBufferView(obj) {\r\n    if (ArrayBuffer.isView === 'function') {\r\n      return ArrayBuffer.isView(obj);\r\n    }\r\n\r\n    return obj && obj.buffer instanceof ArrayBuffer;\r\n  };\r\n  var isTypedArray = function isTypedArray(obj) {\r\n    return isArrayBufferView(obj);\r\n  };\r\n  var toUint8 = function toUint8(bytes) {\r\n    if (bytes instanceof Uint8Array) {\r\n      return bytes;\r\n    }\r\n\r\n    if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\r\n      // any non-number or NaN leads to empty uint8array\r\n      // eslint-disable-next-line\r\n      if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\r\n        bytes = 0;\r\n      } else {\r\n        bytes = [bytes];\r\n      }\r\n    }\r\n\r\n    return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\r\n  };\r\n  var BigInt = window.BigInt || Number;\r\n  var BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\r\n  var bytesToNumber = function bytesToNumber(bytes, _temp) {\r\n    var _ref = _temp === void 0 ? {} : _temp,\r\n        _ref$signed = _ref.signed,\r\n        signed = _ref$signed === void 0 ? false : _ref$signed,\r\n        _ref$le = _ref.le,\r\n        le = _ref$le === void 0 ? false : _ref$le;\r\n\r\n    bytes = toUint8(bytes);\r\n    var fn = le ? 'reduce' : 'reduceRight';\r\n    var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\r\n    var number = obj.call(bytes, function (total, _byte, i) {\r\n      var exponent = le ? i : Math.abs(i + 1 - bytes.length);\r\n      return total + BigInt(_byte) * BYTE_TABLE[exponent];\r\n    }, BigInt(0));\r\n\r\n    if (signed) {\r\n      var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\r\n      number = BigInt(number);\r\n\r\n      if (number > max) {\r\n        number -= max;\r\n        number -= max;\r\n        number -= BigInt(2);\r\n      }\r\n    }\r\n\r\n    return Number(number);\r\n  };\r\n  var numberToBytes = function numberToBytes(number, _temp2) {\r\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\r\n        _ref2$le = _ref2.le,\r\n        le = _ref2$le === void 0 ? false : _ref2$le; // eslint-disable-next-line\r\n\r\n\r\n    if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\r\n      number = 0;\r\n    }\r\n\r\n    number = BigInt(number);\r\n    var byteCount = countBytes(number);\r\n    var bytes = new Uint8Array(new ArrayBuffer(byteCount));\r\n\r\n    for (var i = 0; i < byteCount; i++) {\r\n      var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\r\n      bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\r\n\r\n      if (number < 0) {\r\n        bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\r\n        bytes[byteIndex] -= i === 0 ? 1 : 2;\r\n      }\r\n    }\r\n\r\n    return bytes;\r\n  };\r\n  var stringToBytes = function stringToBytes(string, stringIsBytes) {\r\n    if (typeof string !== 'string' && string && typeof string.toString === 'function') {\r\n      string = string.toString();\r\n    }\r\n\r\n    if (typeof string !== 'string') {\r\n      return new Uint8Array();\r\n    } // If the string already is bytes, we don't have to do this\r\n    // otherwise we do this so that we split multi length characters\r\n    // into individual bytes\r\n\r\n\r\n    if (!stringIsBytes) {\r\n      string = unescape(encodeURIComponent(string));\r\n    }\r\n\r\n    var view = new Uint8Array(string.length);\r\n\r\n    for (var i = 0; i < string.length; i++) {\r\n      view[i] = string.charCodeAt(i);\r\n    }\r\n\r\n    return view;\r\n  };\r\n  var concatTypedArrays = function concatTypedArrays() {\r\n    for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      buffers[_key] = arguments[_key];\r\n    }\r\n\r\n    buffers = buffers.filter(function (b) {\r\n      return b && (b.byteLength || b.length) && typeof b !== 'string';\r\n    });\r\n\r\n    if (buffers.length <= 1) {\r\n      // for 0 length we will return empty uint8\r\n      // for 1 length we return the first uint8\r\n      return toUint8(buffers[0]);\r\n    }\r\n\r\n    var totalLen = buffers.reduce(function (total, buf, i) {\r\n      return total + (buf.byteLength || buf.length);\r\n    }, 0);\r\n    var tempBuffer = new Uint8Array(totalLen);\r\n    var offset = 0;\r\n    buffers.forEach(function (buf) {\r\n      buf = toUint8(buf);\r\n      tempBuffer.set(buf, offset);\r\n      offset += buf.byteLength;\r\n    });\r\n    return tempBuffer;\r\n  };\r\n  /**\r\n   * Check if the bytes \"b\" are contained within bytes \"a\".\r\n   *\r\n   * @param {Uint8Array|Array} a\r\n   *        Bytes to check in\r\n   *\r\n   * @param {Uint8Array|Array} b\r\n   *        Bytes to check for\r\n   *\r\n   * @param {Object} options\r\n   *        options\r\n   *\r\n   * @param {Array|Uint8Array} [offset=0]\r\n   *        offset to use when looking at bytes in a\r\n   *\r\n   * @param {Array|Uint8Array} [mask=[]]\r\n   *        mask to use on bytes before comparison.\r\n   *\r\n   * @return {boolean}\r\n   *         If all bytes in b are inside of a, taking into account\r\n   *         bit masks.\r\n   */\r\n\r\n  var bytesMatch = function bytesMatch(a, b, _temp3) {\r\n    var _ref3 = _temp3 === void 0 ? {} : _temp3,\r\n        _ref3$offset = _ref3.offset,\r\n        offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\r\n        _ref3$mask = _ref3.mask,\r\n        mask = _ref3$mask === void 0 ? [] : _ref3$mask;\r\n\r\n    a = toUint8(a);\r\n    b = toUint8(b); // ie 11 does not support uint8 every\r\n\r\n    var fn = b.every ? b.every : Array.prototype.every;\r\n    return b.length && a.length - offset >= b.length && // ie 11 doesn't support every on uin8\r\n    fn.call(b, function (bByte, i) {\r\n      var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\r\n      return bByte === aByte;\r\n    });\r\n  };\r\n\r\n  var DEFAULT_LOCATION = 'http://example.com';\r\n\r\n  var resolveUrl$1 = function resolveUrl(baseUrl, relativeUrl) {\r\n    // return early if we don't need to resolve\r\n    if (/^[a-z]+:/i.test(relativeUrl)) {\r\n      return relativeUrl;\r\n    } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\r\n\r\n\r\n    if (/^data:/.test(baseUrl)) {\r\n      baseUrl = window.location && window.location.href || '';\r\n    } // IE11 supports URL but not the URL constructor\r\n    // feature detect the behavior we want\r\n\r\n\r\n    var nativeURL = typeof window.URL === 'function';\r\n    var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\r\n    // and if baseUrl isn't an absolute url\r\n\r\n    var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\r\n\r\n    if (nativeURL) {\r\n      baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION);\r\n    } else if (!/\\/\\//i.test(baseUrl)) {\r\n      baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\r\n    }\r\n\r\n    if (nativeURL) {\r\n      var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\r\n      // and if we're location-less, remove the location\r\n      // otherwise, return the url unmodified\r\n\r\n      if (removeLocation) {\r\n        return newUrl.href.slice(DEFAULT_LOCATION.length);\r\n      } else if (protocolLess) {\r\n        return newUrl.href.slice(newUrl.protocol.length);\r\n      }\r\n\r\n      return newUrl.href;\r\n    }\r\n\r\n    return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\r\n  };\r\n\r\n  /**\r\n   * Loops through all supported media groups in master and calls the provided\r\n   * callback for each group\r\n   *\r\n   * @param {Object} master\r\n   *        The parsed master manifest object\r\n   * @param {string[]} groups\r\n   *        The media groups to call the callback for\r\n   * @param {Function} callback\r\n   *        Callback to call for each media group\r\n   */\r\n  var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback) {\r\n    groups.forEach(function (mediaType) {\r\n      for (var groupKey in master.mediaGroups[mediaType]) {\r\n        for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\r\n          var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\r\n          callback(mediaProperties, mediaType, groupKey, labelKey);\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  var atob = function atob(s) {\r\n    return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\r\n  };\r\n\r\n  function decodeB64ToUint8Array(b64Text) {\r\n    var decodedString = atob(b64Text);\r\n    var array = new Uint8Array(decodedString.length);\r\n\r\n    for (var i = 0; i < decodedString.length; i++) {\r\n      array[i] = decodedString.charCodeAt(i);\r\n    }\r\n\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * \"Shallow freezes\" an object to render it immutable.\r\n   * Uses `Object.freeze` if available,\r\n   * otherwise the immutability is only in the type.\r\n   *\r\n   * Is used to create \"enum like\" objects.\r\n   *\r\n   * @template T\r\n   * @param {T} object the object to freeze\r\n   * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,\r\n   * \t\t\t\tallows to inject custom object constructor for tests\r\n   * @returns {Readonly<T>}\r\n   *\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\r\n   */\r\n\r\n  function freeze(object, oc) {\r\n    if (oc === undefined) {\r\n      oc = Object;\r\n    }\r\n\r\n    return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;\r\n  }\r\n  /**\r\n   * All mime types that are allowed as input to `DOMParser.parseFromString`\r\n   *\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN\r\n   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec\r\n   * @see DOMParser.prototype.parseFromString\r\n   */\r\n\r\n\r\n  var MIME_TYPE = freeze({\r\n    /**\r\n     * `text/html`, the only mime type that triggers treating an XML document as HTML.\r\n     *\r\n     * @see DOMParser.SupportedType.isHTML\r\n     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\r\n     * @see https://en.wikipedia.org/wiki/HTML Wikipedia\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\r\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec\r\n     */\r\n    HTML: 'text/html',\r\n\r\n    /**\r\n     * Helper method to check a mime type if it indicates an HTML document\r\n     *\r\n     * @param {string} [value]\r\n     * @returns {boolean}\r\n     *\r\n     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\r\n     * @see https://en.wikipedia.org/wiki/HTML Wikipedia\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\r\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring \t */\r\n    isHTML: function isHTML(value) {\r\n      return value === MIME_TYPE.HTML;\r\n    },\r\n\r\n    /**\r\n     * `application/xml`, the standard mime type for XML documents.\r\n     *\r\n     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration\r\n     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303\r\n     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\r\n     */\r\n    XML_APPLICATION: 'application/xml',\r\n\r\n    /**\r\n     * `text/html`, an alias for `application/xml`.\r\n     *\r\n     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303\r\n     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration\r\n     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\r\n     */\r\n    XML_TEXT: 'text/xml',\r\n\r\n    /**\r\n     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,\r\n     * but is parsed as an XML document.\r\n     *\r\n     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration\r\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec\r\n     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia\r\n     */\r\n    XML_XHTML_APPLICATION: 'application/xhtml+xml',\r\n\r\n    /**\r\n     * `image/svg+xml`,\r\n     *\r\n     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration\r\n     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1\r\n     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia\r\n     */\r\n    XML_SVG_IMAGE: 'image/svg+xml'\r\n  });\r\n  /**\r\n   * Namespaces that are used in this code base.\r\n   *\r\n   * @see http://www.w3.org/TR/REC-xml-names\r\n   */\r\n\r\n  var NAMESPACE$3 = freeze({\r\n    /**\r\n     * The XHTML namespace.\r\n     *\r\n     * @see http://www.w3.org/1999/xhtml\r\n     */\r\n    HTML: 'http://www.w3.org/1999/xhtml',\r\n\r\n    /**\r\n     * Checks if `uri` equals `NAMESPACE.HTML`.\r\n     *\r\n     * @param {string} [uri]\r\n     *\r\n     * @see NAMESPACE.HTML\r\n     */\r\n    isHTML: function isHTML(uri) {\r\n      return uri === NAMESPACE$3.HTML;\r\n    },\r\n\r\n    /**\r\n     * The SVG namespace.\r\n     *\r\n     * @see http://www.w3.org/2000/svg\r\n     */\r\n    SVG: 'http://www.w3.org/2000/svg',\r\n\r\n    /**\r\n     * The `xml:` namespace.\r\n     *\r\n     * @see http://www.w3.org/XML/1998/namespace\r\n     */\r\n    XML: 'http://www.w3.org/XML/1998/namespace',\r\n\r\n    /**\r\n     * The `xmlns:` namespace\r\n     *\r\n     * @see https://www.w3.org/2000/xmlns/\r\n     */\r\n    XMLNS: 'http://www.w3.org/2000/xmlns/'\r\n  });\r\n  var freeze_1 = freeze;\r\n  var MIME_TYPE_1 = MIME_TYPE;\r\n  var NAMESPACE_1 = NAMESPACE$3;\r\n  var conventions = {\r\n    freeze: freeze_1,\r\n    MIME_TYPE: MIME_TYPE_1,\r\n    NAMESPACE: NAMESPACE_1\r\n  };\r\n\r\n  var NAMESPACE$2 = conventions.NAMESPACE;\r\n  /**\r\n   * A prerequisite for `[].filter`, to drop elements that are empty\r\n   * @param {string} input\r\n   * @returns {boolean}\r\n   */\r\n\r\n  function notEmptyString(input) {\r\n    return input !== '';\r\n  }\r\n  /**\r\n   * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace\r\n   * @see https://infra.spec.whatwg.org/#ascii-whitespace\r\n   *\r\n   * @param {string} input\r\n   * @returns {string[]} (can be empty)\r\n   */\r\n\r\n\r\n  function splitOnASCIIWhitespace(input) {\r\n    // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\r\n    return input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : [];\r\n  }\r\n  /**\r\n   * Adds element as a key to current if it is not already present.\r\n   *\r\n   * @param {Record<string, boolean | undefined>} current\r\n   * @param {string} element\r\n   * @returns {Record<string, boolean | undefined>}\r\n   */\r\n\r\n\r\n  function orderedSetReducer(current, element) {\r\n    if (!current.hasOwnProperty(element)) {\r\n      current[element] = true;\r\n    }\r\n\r\n    return current;\r\n  }\r\n  /**\r\n   * @see https://infra.spec.whatwg.org/#ordered-set\r\n   * @param {string} input\r\n   * @returns {string[]}\r\n   */\r\n\r\n\r\n  function toOrderedSet(input) {\r\n    if (!input) return [];\r\n    var list = splitOnASCIIWhitespace(input);\r\n    return Object.keys(list.reduce(orderedSetReducer, {}));\r\n  }\r\n  /**\r\n   * Uses `list.indexOf` to implement something like `Array.prototype.includes`,\r\n   * which we can not rely on being available.\r\n   *\r\n   * @param {any[]} list\r\n   * @returns {function(any): boolean}\r\n   */\r\n\r\n\r\n  function arrayIncludes(list) {\r\n    return function (element) {\r\n      return list && list.indexOf(element) !== -1;\r\n    };\r\n  }\r\n\r\n  function copy(src, dest) {\r\n    for (var p in src) {\r\n      dest[p] = src[p];\r\n    }\r\n  }\r\n  /**\r\n  ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\r\n  ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\r\n   */\r\n\r\n\r\n  function _extends(Class, Super) {\r\n    var pt = Class.prototype;\r\n\r\n    if (!(pt instanceof Super)) {\r\n      var t = function t() {};\r\n      t.prototype = Super.prototype;\r\n      t = new t();\r\n      copy(pt, t);\r\n      Class.prototype = pt = t;\r\n    }\r\n\r\n    if (pt.constructor != Class) {\r\n      if (typeof Class != 'function') {\r\n        console.error(\"unknown Class:\" + Class);\r\n      }\r\n\r\n      pt.constructor = Class;\r\n    }\r\n  } // Node Types\r\n\r\n\r\n  var NodeType = {};\r\n  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\r\n  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\r\n  var TEXT_NODE = NodeType.TEXT_NODE = 3;\r\n  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\r\n  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\r\n  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;\r\n  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\r\n  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;\r\n  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\r\n  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\r\n  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\r\n  var NOTATION_NODE = NodeType.NOTATION_NODE = 12; // ExceptionCode\r\n\r\n  var ExceptionCode = {};\r\n  var ExceptionMessage = {};\r\n  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = \"Index size error\", 1);\r\n  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = \"DOMString size error\", 2);\r\n  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = \"Hierarchy request error\", 3);\r\n  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = \"Wrong document\", 4);\r\n  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = \"Invalid character\", 5);\r\n  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = \"No data allowed\", 6);\r\n  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = \"No modification allowed\", 7);\r\n  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = \"Not found\", 8);\r\n  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = \"Not supported\", 9);\r\n  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = \"Attribute in use\", 10); //level2\r\n\r\n  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = \"Invalid state\", 11);\r\n  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = \"Syntax error\", 12);\r\n  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = \"Invalid modification\", 13);\r\n  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = \"Invalid namespace\", 14);\r\n  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = \"Invalid access\", 15);\r\n  /**\r\n   * DOM Level 2\r\n   * Object DOMException\r\n   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\r\n   * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\r\n   */\r\n\r\n  function DOMException(code, message) {\r\n    if (message instanceof Error) {\r\n      var error = message;\r\n    } else {\r\n      error = this;\r\n      Error.call(this, ExceptionMessage[code]);\r\n      this.message = ExceptionMessage[code];\r\n      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\r\n    }\r\n\r\n    error.code = code;\r\n    if (message) this.message = this.message + \": \" + message;\r\n    return error;\r\n  }\r\n  DOMException.prototype = Error.prototype;\r\n  copy(ExceptionCode, DOMException);\r\n  /**\r\n   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\r\n   * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\r\n   * The items in the NodeList are accessible via an integral index, starting from 0.\r\n   */\r\n\r\n  function NodeList() {}\r\n  NodeList.prototype = {\r\n    /**\r\n     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\r\n     * @standard level1\r\n     */\r\n    length: 0,\r\n\r\n    /**\r\n     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\r\n     * @standard level1\r\n     * @param index  unsigned long \r\n     *   Index into the collection.\r\n     * @return Node\r\n     * \tThe node at the indexth position in the NodeList, or null if that is not a valid index. \r\n     */\r\n    item: function item(index) {\r\n      return this[index] || null;\r\n    },\r\n    toString: function toString(isHTML, nodeFilter) {\r\n      for (var buf = [], i = 0; i < this.length; i++) {\r\n        serializeToString(this[i], buf, isHTML, nodeFilter);\r\n      }\r\n\r\n      return buf.join('');\r\n    }\r\n  };\r\n\r\n  function LiveNodeList(node, refresh) {\r\n    this._node = node;\r\n    this._refresh = refresh;\r\n\r\n    _updateLiveList(this);\r\n  }\r\n\r\n  function _updateLiveList(list) {\r\n    var inc = list._node._inc || list._node.ownerDocument._inc;\r\n\r\n    if (list._inc != inc) {\r\n      var ls = list._refresh(list._node); //console.log(ls.length)\r\n\r\n\r\n      __set__(list, 'length', ls.length);\r\n\r\n      copy(ls, list);\r\n      list._inc = inc;\r\n    }\r\n  }\r\n\r\n  LiveNodeList.prototype.item = function (i) {\r\n    _updateLiveList(this);\r\n\r\n    return this[i];\r\n  };\r\n\r\n  _extends(LiveNodeList, NodeList);\r\n  /**\r\n   * Objects implementing the NamedNodeMap interface are used\r\n   * to represent collections of nodes that can be accessed by name.\r\n   * Note that NamedNodeMap does not inherit from NodeList;\r\n   * NamedNodeMaps are not maintained in any particular order.\r\n   * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,\r\n   * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\r\n   * and does not imply that the DOM specifies an order to these Nodes.\r\n   * NamedNodeMap objects in the DOM are live.\r\n   * used for attributes or DocumentType entities \r\n   */\r\n\r\n\r\n  function NamedNodeMap() {}\r\n\r\n  function _findNodeIndex(list, node) {\r\n    var i = list.length;\r\n\r\n    while (i--) {\r\n      if (list[i] === node) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _addNamedNode(el, list, newAttr, oldAttr) {\r\n    if (oldAttr) {\r\n      list[_findNodeIndex(list, oldAttr)] = newAttr;\r\n    } else {\r\n      list[list.length++] = newAttr;\r\n    }\r\n\r\n    if (el) {\r\n      newAttr.ownerElement = el;\r\n      var doc = el.ownerDocument;\r\n\r\n      if (doc) {\r\n        oldAttr && _onRemoveAttribute(doc, el, oldAttr);\r\n\r\n        _onAddAttribute(doc, el, newAttr);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _removeNamedNode(el, list, attr) {\r\n    //console.log('remove attr:'+attr)\r\n    var i = _findNodeIndex(list, attr);\r\n\r\n    if (i >= 0) {\r\n      var lastIndex = list.length - 1;\r\n\r\n      while (i < lastIndex) {\r\n        list[i] = list[++i];\r\n      }\r\n\r\n      list.length = lastIndex;\r\n\r\n      if (el) {\r\n        var doc = el.ownerDocument;\r\n\r\n        if (doc) {\r\n          _onRemoveAttribute(doc, el, attr);\r\n\r\n          attr.ownerElement = null;\r\n        }\r\n      }\r\n    } else {\r\n      throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));\r\n    }\r\n  }\r\n\r\n  NamedNodeMap.prototype = {\r\n    length: 0,\r\n    item: NodeList.prototype.item,\r\n    getNamedItem: function getNamedItem(key) {\r\n      //\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\r\n      //\t\t\treturn null;\r\n      //\t\t}\r\n      //console.log()\r\n      var i = this.length;\r\n\r\n      while (i--) {\r\n        var attr = this[i]; //console.log(attr.nodeName,key)\r\n\r\n        if (attr.nodeName == key) {\r\n          return attr;\r\n        }\r\n      }\r\n    },\r\n    setNamedItem: function setNamedItem(attr) {\r\n      var el = attr.ownerElement;\r\n\r\n      if (el && el != this._ownerElement) {\r\n        throw new DOMException(INUSE_ATTRIBUTE_ERR);\r\n      }\r\n\r\n      var oldAttr = this.getNamedItem(attr.nodeName);\r\n\r\n      _addNamedNode(this._ownerElement, this, attr, oldAttr);\r\n\r\n      return oldAttr;\r\n    },\r\n\r\n    /* returns Node */\r\n    setNamedItemNS: function setNamedItemNS(attr) {\r\n      // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\r\n      var el = attr.ownerElement,\r\n          oldAttr;\r\n\r\n      if (el && el != this._ownerElement) {\r\n        throw new DOMException(INUSE_ATTRIBUTE_ERR);\r\n      }\r\n\r\n      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\r\n\r\n      _addNamedNode(this._ownerElement, this, attr, oldAttr);\r\n\r\n      return oldAttr;\r\n    },\r\n\r\n    /* returns Node */\r\n    removeNamedItem: function removeNamedItem(key) {\r\n      var attr = this.getNamedItem(key);\r\n\r\n      _removeNamedNode(this._ownerElement, this, attr);\r\n\r\n      return attr;\r\n    },\r\n    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\r\n    //for level2\r\n    removeNamedItemNS: function removeNamedItemNS(namespaceURI, localName) {\r\n      var attr = this.getNamedItemNS(namespaceURI, localName);\r\n\r\n      _removeNamedNode(this._ownerElement, this, attr);\r\n\r\n      return attr;\r\n    },\r\n    getNamedItemNS: function getNamedItemNS(namespaceURI, localName) {\r\n      var i = this.length;\r\n\r\n      while (i--) {\r\n        var node = this[i];\r\n\r\n        if (node.localName == localName && node.namespaceURI == namespaceURI) {\r\n          return node;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  };\r\n  /**\r\n   * The DOMImplementation interface represents an object providing methods\r\n   * which are not dependent on any particular document.\r\n   * Such an object is returned by the `Document.implementation` property.\r\n   *\r\n   * __The individual methods describe the differences compared to the specs.__\r\n   *\r\n   * @constructor\r\n   *\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\r\n   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)\r\n   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\r\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\r\n   * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\r\n   */\r\n\r\n  function DOMImplementation$1() {}\r\n\r\n  DOMImplementation$1.prototype = {\r\n    /**\r\n     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.\r\n     * The different implementations fairly diverged in what kind of features were reported.\r\n     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.\r\n     *\r\n     * @deprecated It is deprecated and modern browsers return true in all cases.\r\n     *\r\n     * @param {string} feature\r\n     * @param {string} [version]\r\n     * @returns {boolean} always true\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\r\n     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\r\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\r\n     */\r\n    hasFeature: function hasFeature(feature, version) {\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Creates an XML Document object of the specified type with its document element.\r\n     *\r\n     * __It behaves slightly different from the description in the living standard__:\r\n     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.\r\n     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.\r\n     * - this implementation is not validating names or qualified names\r\n     *   (when parsing XML strings, the SAX parser takes care of that)\r\n     *\r\n     * @param {string|null} namespaceURI\r\n     * @param {string} qualifiedName\r\n     * @param {DocumentType=null} doctype\r\n     * @returns {Document}\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\r\n     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)\r\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core\r\n     *\r\n     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\r\n     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\r\n     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\r\n     */\r\n    createDocument: function createDocument(namespaceURI, qualifiedName, doctype) {\r\n      var doc = new Document();\r\n      doc.implementation = this;\r\n      doc.childNodes = new NodeList();\r\n      doc.doctype = doctype || null;\r\n\r\n      if (doctype) {\r\n        doc.appendChild(doctype);\r\n      }\r\n\r\n      if (qualifiedName) {\r\n        var root = doc.createElementNS(namespaceURI, qualifiedName);\r\n        doc.appendChild(root);\r\n      }\r\n\r\n      return doc;\r\n    },\r\n\r\n    /**\r\n     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.\r\n     *\r\n     * __This behavior is slightly different from the in the specs__:\r\n     * - this implementation is not validating names or qualified names\r\n     *   (when parsing XML strings, the SAX parser takes care of that)\r\n     *\r\n     * @param {string} qualifiedName\r\n     * @param {string} [publicId]\r\n     * @param {string} [systemId]\r\n     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation\r\n     * \t\t\t\t  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN\r\n     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core\r\n     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard\r\n     *\r\n     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\r\n     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\r\n     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\r\n     */\r\n    createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {\r\n      var node = new DocumentType();\r\n      node.name = qualifiedName;\r\n      node.nodeName = qualifiedName;\r\n      node.publicId = publicId || '';\r\n      node.systemId = systemId || '';\r\n      return node;\r\n    }\r\n  };\r\n  /**\r\n   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\r\n   */\r\n\r\n  function Node() {}\r\n  Node.prototype = {\r\n    firstChild: null,\r\n    lastChild: null,\r\n    previousSibling: null,\r\n    nextSibling: null,\r\n    attributes: null,\r\n    parentNode: null,\r\n    childNodes: null,\r\n    ownerDocument: null,\r\n    nodeValue: null,\r\n    namespaceURI: null,\r\n    prefix: null,\r\n    localName: null,\r\n    // Modified in DOM Level 2:\r\n    insertBefore: function insertBefore(newChild, refChild) {\r\n      //raises \r\n      return _insertBefore(this, newChild, refChild);\r\n    },\r\n    replaceChild: function replaceChild(newChild, oldChild) {\r\n      //raises \r\n      this.insertBefore(newChild, oldChild);\r\n\r\n      if (oldChild) {\r\n        this.removeChild(oldChild);\r\n      }\r\n    },\r\n    removeChild: function removeChild(oldChild) {\r\n      return _removeChild(this, oldChild);\r\n    },\r\n    appendChild: function appendChild(newChild) {\r\n      return this.insertBefore(newChild, null);\r\n    },\r\n    hasChildNodes: function hasChildNodes() {\r\n      return this.firstChild != null;\r\n    },\r\n    cloneNode: function cloneNode(deep) {\r\n      return _cloneNode(this.ownerDocument || this, this, deep);\r\n    },\r\n    // Modified in DOM Level 2:\r\n    normalize: function normalize() {\r\n      var child = this.firstChild;\r\n\r\n      while (child) {\r\n        var next = child.nextSibling;\r\n\r\n        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\r\n          this.removeChild(next);\r\n          child.appendData(next.data);\r\n        } else {\r\n          child.normalize();\r\n          child = next;\r\n        }\r\n      }\r\n    },\r\n    // Introduced in DOM Level 2:\r\n    isSupported: function isSupported(feature, version) {\r\n      return this.ownerDocument.implementation.hasFeature(feature, version);\r\n    },\r\n    // Introduced in DOM Level 2:\r\n    hasAttributes: function hasAttributes() {\r\n      return this.attributes.length > 0;\r\n    },\r\n\r\n    /**\r\n     * Look up the prefix associated to the given namespace URI, starting from this node.\r\n     * **The default namespace declarations are ignored by this method.**\r\n     * See Namespace Prefix Lookup for details on the algorithm used by this method.\r\n     *\r\n     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._\r\n     *\r\n     * @param {string | null} namespaceURI\r\n     * @returns {string | null}\r\n     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\r\n     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\r\n     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\r\n     * @see https://github.com/xmldom/xmldom/issues/322\r\n     */\r\n    lookupPrefix: function lookupPrefix(namespaceURI) {\r\n      var el = this;\r\n\r\n      while (el) {\r\n        var map = el._nsMap; //console.dir(map)\r\n\r\n        if (map) {\r\n          for (var n in map) {\r\n            if (map[n] == namespaceURI) {\r\n              return n;\r\n            }\r\n          }\r\n        }\r\n\r\n        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\r\n      }\r\n\r\n      return null;\r\n    },\r\n    // Introduced in DOM Level 3:\r\n    lookupNamespaceURI: function lookupNamespaceURI(prefix) {\r\n      var el = this;\r\n\r\n      while (el) {\r\n        var map = el._nsMap; //console.dir(map)\r\n\r\n        if (map) {\r\n          if (prefix in map) {\r\n            return map[prefix];\r\n          }\r\n        }\r\n\r\n        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\r\n      }\r\n\r\n      return null;\r\n    },\r\n    // Introduced in DOM Level 3:\r\n    isDefaultNamespace: function isDefaultNamespace(namespaceURI) {\r\n      var prefix = this.lookupPrefix(namespaceURI);\r\n      return prefix == null;\r\n    }\r\n  };\r\n\r\n  function _xmlEncoder(c) {\r\n    return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\r\n  }\r\n\r\n  copy(NodeType, Node);\r\n  copy(NodeType, Node.prototype);\r\n  /**\r\n   * @param callback return true for continue,false for break\r\n   * @return boolean true: break visit;\r\n   */\r\n\r\n  function _visitNode(node, callback) {\r\n    if (callback(node)) {\r\n      return true;\r\n    }\r\n\r\n    if (node = node.firstChild) {\r\n      do {\r\n        if (_visitNode(node, callback)) {\r\n          return true;\r\n        }\r\n      } while (node = node.nextSibling);\r\n    }\r\n  }\r\n\r\n  function Document() {}\r\n\r\n  function _onAddAttribute(doc, el, newAttr) {\r\n    doc && doc._inc++;\r\n    var ns = newAttr.namespaceURI;\r\n\r\n    if (ns === NAMESPACE$2.XMLNS) {\r\n      //update namespace\r\n      el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\r\n    }\r\n  }\r\n\r\n  function _onRemoveAttribute(doc, el, newAttr, remove) {\r\n    doc && doc._inc++;\r\n    var ns = newAttr.namespaceURI;\r\n\r\n    if (ns === NAMESPACE$2.XMLNS) {\r\n      //update namespace\r\n      delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\r\n    }\r\n  }\r\n\r\n  function _onUpdateChild(doc, el, newChild) {\r\n    if (doc && doc._inc) {\r\n      doc._inc++; //update childNodes\r\n\r\n      var cs = el.childNodes;\r\n\r\n      if (newChild) {\r\n        cs[cs.length++] = newChild;\r\n      } else {\r\n        //console.log(1)\r\n        var child = el.firstChild;\r\n        var i = 0;\r\n\r\n        while (child) {\r\n          cs[i++] = child;\r\n          child = child.nextSibling;\r\n        }\r\n\r\n        cs.length = i;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * attributes;\r\n   * children;\r\n   * \r\n   * writeable properties:\r\n   * nodeValue,Attr:value,CharacterData:data\r\n   * prefix\r\n   */\r\n\r\n\r\n  function _removeChild(parentNode, child) {\r\n    var previous = child.previousSibling;\r\n    var next = child.nextSibling;\r\n\r\n    if (previous) {\r\n      previous.nextSibling = next;\r\n    } else {\r\n      parentNode.firstChild = next;\r\n    }\r\n\r\n    if (next) {\r\n      next.previousSibling = previous;\r\n    } else {\r\n      parentNode.lastChild = previous;\r\n    }\r\n\r\n    _onUpdateChild(parentNode.ownerDocument, parentNode);\r\n\r\n    return child;\r\n  }\r\n  /**\r\n   * preformance key(refChild == null)\r\n   */\r\n\r\n\r\n  function _insertBefore(parentNode, newChild, nextChild) {\r\n    var cp = newChild.parentNode;\r\n\r\n    if (cp) {\r\n      cp.removeChild(newChild); //remove and update\r\n    }\r\n\r\n    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\r\n      var newFirst = newChild.firstChild;\r\n\r\n      if (newFirst == null) {\r\n        return newChild;\r\n      }\r\n\r\n      var newLast = newChild.lastChild;\r\n    } else {\r\n      newFirst = newLast = newChild;\r\n    }\r\n\r\n    var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;\r\n    newFirst.previousSibling = pre;\r\n    newLast.nextSibling = nextChild;\r\n\r\n    if (pre) {\r\n      pre.nextSibling = newFirst;\r\n    } else {\r\n      parentNode.firstChild = newFirst;\r\n    }\r\n\r\n    if (nextChild == null) {\r\n      parentNode.lastChild = newLast;\r\n    } else {\r\n      nextChild.previousSibling = newLast;\r\n    }\r\n\r\n    do {\r\n      newFirst.parentNode = parentNode;\r\n    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\r\n\r\n    _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode); //console.log(parentNode.lastChild.nextSibling == null)\r\n\r\n\r\n    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\r\n      newChild.firstChild = newChild.lastChild = null;\r\n    }\r\n\r\n    return newChild;\r\n  }\r\n\r\n  function _appendSingleChild(parentNode, newChild) {\r\n    var cp = newChild.parentNode;\r\n\r\n    if (cp) {\r\n      var pre = parentNode.lastChild;\r\n      cp.removeChild(newChild); //remove and update\r\n\r\n      var pre = parentNode.lastChild;\r\n    }\r\n\r\n    var pre = parentNode.lastChild;\r\n    newChild.parentNode = parentNode;\r\n    newChild.previousSibling = pre;\r\n    newChild.nextSibling = null;\r\n\r\n    if (pre) {\r\n      pre.nextSibling = newChild;\r\n    } else {\r\n      parentNode.firstChild = newChild;\r\n    }\r\n\r\n    parentNode.lastChild = newChild;\r\n\r\n    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\r\n\r\n    return newChild; //console.log(\"__aa\",parentNode.lastChild.nextSibling == null)\r\n  }\r\n\r\n  Document.prototype = {\r\n    //implementation : null,\r\n    nodeName: '#document',\r\n    nodeType: DOCUMENT_NODE,\r\n\r\n    /**\r\n     * The DocumentType node of the document.\r\n     *\r\n     * @readonly\r\n     * @type DocumentType\r\n     */\r\n    doctype: null,\r\n    documentElement: null,\r\n    _inc: 1,\r\n    insertBefore: function insertBefore(newChild, refChild) {\r\n      //raises\r\n      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\r\n        var child = newChild.firstChild;\r\n\r\n        while (child) {\r\n          var next = child.nextSibling;\r\n          this.insertBefore(child, refChild);\r\n          child = next;\r\n        }\r\n\r\n        return newChild;\r\n      }\r\n\r\n      if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {\r\n        this.documentElement = newChild;\r\n      }\r\n\r\n      return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;\r\n    },\r\n    removeChild: function removeChild(oldChild) {\r\n      if (this.documentElement == oldChild) {\r\n        this.documentElement = null;\r\n      }\r\n\r\n      return _removeChild(this, oldChild);\r\n    },\r\n    // Introduced in DOM Level 2:\r\n    importNode: function importNode(importedNode, deep) {\r\n      return _importNode(this, importedNode, deep);\r\n    },\r\n    // Introduced in DOM Level 2:\r\n    getElementById: function getElementById(id) {\r\n      var rtv = null;\r\n\r\n      _visitNode(this.documentElement, function (node) {\r\n        if (node.nodeType == ELEMENT_NODE) {\r\n          if (node.getAttribute('id') == id) {\r\n            rtv = node;\r\n            return true;\r\n          }\r\n        }\r\n      });\r\n\r\n      return rtv;\r\n    },\r\n\r\n    /**\r\n     * The `getElementsByClassName` method of `Document` interface returns an array-like object\r\n     * of all child elements which have **all** of the given class name(s).\r\n     *\r\n     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.\r\n     *\r\n     *\r\n     * Warning: This is a live LiveNodeList.\r\n     * Changes in the DOM will reflect in the array as the changes occur.\r\n     * If an element selected by this array no longer qualifies for the selector,\r\n     * it will automatically be removed. Be aware of this for iteration purposes.\r\n     *\r\n     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\r\n     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\r\n     */\r\n    getElementsByClassName: function getElementsByClassName(classNames) {\r\n      var classNamesSet = toOrderedSet(classNames);\r\n      return new LiveNodeList(this, function (base) {\r\n        var ls = [];\r\n\r\n        if (classNamesSet.length > 0) {\r\n          _visitNode(base.documentElement, function (node) {\r\n            if (node !== base && node.nodeType === ELEMENT_NODE) {\r\n              var nodeClassNames = node.getAttribute('class'); // can be null if the attribute does not exist\r\n\r\n              if (nodeClassNames) {\r\n                // before splitting and iterating just compare them for the most common case\r\n                var matches = classNames === nodeClassNames;\r\n\r\n                if (!matches) {\r\n                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);\r\n                  matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));\r\n                }\r\n\r\n                if (matches) {\r\n                  ls.push(node);\r\n                }\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        return ls;\r\n      });\r\n    },\r\n    //document factory method:\r\n    createElement: function createElement(tagName) {\r\n      var node = new Element();\r\n      node.ownerDocument = this;\r\n      node.nodeName = tagName;\r\n      node.tagName = tagName;\r\n      node.localName = tagName;\r\n      node.childNodes = new NodeList();\r\n      var attrs = node.attributes = new NamedNodeMap();\r\n      attrs._ownerElement = node;\r\n      return node;\r\n    },\r\n    createDocumentFragment: function createDocumentFragment() {\r\n      var node = new DocumentFragment();\r\n      node.ownerDocument = this;\r\n      node.childNodes = new NodeList();\r\n      return node;\r\n    },\r\n    createTextNode: function createTextNode(data) {\r\n      var node = new Text();\r\n      node.ownerDocument = this;\r\n      node.appendData(data);\r\n      return node;\r\n    },\r\n    createComment: function createComment(data) {\r\n      var node = new Comment();\r\n      node.ownerDocument = this;\r\n      node.appendData(data);\r\n      return node;\r\n    },\r\n    createCDATASection: function createCDATASection(data) {\r\n      var node = new CDATASection();\r\n      node.ownerDocument = this;\r\n      node.appendData(data);\r\n      return node;\r\n    },\r\n    createProcessingInstruction: function createProcessingInstruction(target, data) {\r\n      var node = new ProcessingInstruction();\r\n      node.ownerDocument = this;\r\n      node.tagName = node.target = target;\r\n      node.nodeValue = node.data = data;\r\n      return node;\r\n    },\r\n    createAttribute: function createAttribute(name) {\r\n      var node = new Attr();\r\n      node.ownerDocument = this;\r\n      node.name = name;\r\n      node.nodeName = name;\r\n      node.localName = name;\r\n      node.specified = true;\r\n      return node;\r\n    },\r\n    createEntityReference: function createEntityReference(name) {\r\n      var node = new EntityReference();\r\n      node.ownerDocument = this;\r\n      node.nodeName = name;\r\n      return node;\r\n    },\r\n    // Introduced in DOM Level 2:\r\n    createElementNS: function createElementNS(namespaceURI, qualifiedName) {\r\n      var node = new Element();\r\n      var pl = qualifiedName.split(':');\r\n      var attrs = node.attributes = new NamedNodeMap();\r\n      node.childNodes = new NodeList();\r\n      node.ownerDocument = this;\r\n      node.nodeName = qualifiedName;\r\n      node.tagName = qualifiedName;\r\n      node.namespaceURI = namespaceURI;\r\n\r\n      if (pl.length == 2) {\r\n        node.prefix = pl[0];\r\n        node.localName = pl[1];\r\n      } else {\r\n        //el.prefix = null;\r\n        node.localName = qualifiedName;\r\n      }\r\n\r\n      attrs._ownerElement = node;\r\n      return node;\r\n    },\r\n    // Introduced in DOM Level 2:\r\n    createAttributeNS: function createAttributeNS(namespaceURI, qualifiedName) {\r\n      var node = new Attr();\r\n      var pl = qualifiedName.split(':');\r\n      node.ownerDocument = this;\r\n      node.nodeName = qualifiedName;\r\n      node.name = qualifiedName;\r\n      node.namespaceURI = namespaceURI;\r\n      node.specified = true;\r\n\r\n      if (pl.length == 2) {\r\n        node.prefix = pl[0];\r\n        node.localName = pl[1];\r\n      } else {\r\n        //el.prefix = null;\r\n        node.localName = qualifiedName;\r\n      }\r\n\r\n      return node;\r\n    }\r\n  };\r\n\r\n  _extends(Document, Node);\r\n\r\n  function Element() {\r\n    this._nsMap = {};\r\n  }\r\n  Element.prototype = {\r\n    nodeType: ELEMENT_NODE,\r\n    hasAttribute: function hasAttribute(name) {\r\n      return this.getAttributeNode(name) != null;\r\n    },\r\n    getAttribute: function getAttribute(name) {\r\n      var attr = this.getAttributeNode(name);\r\n      return attr && attr.value || '';\r\n    },\r\n    getAttributeNode: function getAttributeNode(name) {\r\n      return this.attributes.getNamedItem(name);\r\n    },\r\n    setAttribute: function setAttribute(name, value) {\r\n      var attr = this.ownerDocument.createAttribute(name);\r\n      attr.value = attr.nodeValue = \"\" + value;\r\n      this.setAttributeNode(attr);\r\n    },\r\n    removeAttribute: function removeAttribute(name) {\r\n      var attr = this.getAttributeNode(name);\r\n      attr && this.removeAttributeNode(attr);\r\n    },\r\n    //four real opeartion method\r\n    appendChild: function appendChild(newChild) {\r\n      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\r\n        return this.insertBefore(newChild, null);\r\n      } else {\r\n        return _appendSingleChild(this, newChild);\r\n      }\r\n    },\r\n    setAttributeNode: function setAttributeNode(newAttr) {\r\n      return this.attributes.setNamedItem(newAttr);\r\n    },\r\n    setAttributeNodeNS: function setAttributeNodeNS(newAttr) {\r\n      return this.attributes.setNamedItemNS(newAttr);\r\n    },\r\n    removeAttributeNode: function removeAttributeNode(oldAttr) {\r\n      //console.log(this == oldAttr.ownerElement)\r\n      return this.attributes.removeNamedItem(oldAttr.nodeName);\r\n    },\r\n    //get real attribute name,and remove it by removeAttributeNode\r\n    removeAttributeNS: function removeAttributeNS(namespaceURI, localName) {\r\n      var old = this.getAttributeNodeNS(namespaceURI, localName);\r\n      old && this.removeAttributeNode(old);\r\n    },\r\n    hasAttributeNS: function hasAttributeNS(namespaceURI, localName) {\r\n      return this.getAttributeNodeNS(namespaceURI, localName) != null;\r\n    },\r\n    getAttributeNS: function getAttributeNS(namespaceURI, localName) {\r\n      var attr = this.getAttributeNodeNS(namespaceURI, localName);\r\n      return attr && attr.value || '';\r\n    },\r\n    setAttributeNS: function setAttributeNS(namespaceURI, qualifiedName, value) {\r\n      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\r\n      attr.value = attr.nodeValue = \"\" + value;\r\n      this.setAttributeNode(attr);\r\n    },\r\n    getAttributeNodeNS: function getAttributeNodeNS(namespaceURI, localName) {\r\n      return this.attributes.getNamedItemNS(namespaceURI, localName);\r\n    },\r\n    getElementsByTagName: function getElementsByTagName(tagName) {\r\n      return new LiveNodeList(this, function (base) {\r\n        var ls = [];\r\n\r\n        _visitNode(base, function (node) {\r\n          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {\r\n            ls.push(node);\r\n          }\r\n        });\r\n\r\n        return ls;\r\n      });\r\n    },\r\n    getElementsByTagNameNS: function getElementsByTagNameNS(namespaceURI, localName) {\r\n      return new LiveNodeList(this, function (base) {\r\n        var ls = [];\r\n\r\n        _visitNode(base, function (node) {\r\n          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\r\n            ls.push(node);\r\n          }\r\n        });\r\n\r\n        return ls;\r\n      });\r\n    }\r\n  };\r\n  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\r\n  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\r\n\r\n  _extends(Element, Node);\r\n\r\n  function Attr() {}\r\n  Attr.prototype.nodeType = ATTRIBUTE_NODE;\r\n\r\n  _extends(Attr, Node);\r\n\r\n  function CharacterData() {}\r\n  CharacterData.prototype = {\r\n    data: '',\r\n    substringData: function substringData(offset, count) {\r\n      return this.data.substring(offset, offset + count);\r\n    },\r\n    appendData: function appendData(text) {\r\n      text = this.data + text;\r\n      this.nodeValue = this.data = text;\r\n      this.length = text.length;\r\n    },\r\n    insertData: function insertData(offset, text) {\r\n      this.replaceData(offset, 0, text);\r\n    },\r\n    appendChild: function appendChild(newChild) {\r\n      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);\r\n    },\r\n    deleteData: function deleteData(offset, count) {\r\n      this.replaceData(offset, count, \"\");\r\n    },\r\n    replaceData: function replaceData(offset, count, text) {\r\n      var start = this.data.substring(0, offset);\r\n      var end = this.data.substring(offset + count);\r\n      text = start + text + end;\r\n      this.nodeValue = this.data = text;\r\n      this.length = text.length;\r\n    }\r\n  };\r\n\r\n  _extends(CharacterData, Node);\r\n\r\n  function Text() {}\r\n  Text.prototype = {\r\n    nodeName: \"#text\",\r\n    nodeType: TEXT_NODE,\r\n    splitText: function splitText(offset) {\r\n      var text = this.data;\r\n      var newText = text.substring(offset);\r\n      text = text.substring(0, offset);\r\n      this.data = this.nodeValue = text;\r\n      this.length = text.length;\r\n      var newNode = this.ownerDocument.createTextNode(newText);\r\n\r\n      if (this.parentNode) {\r\n        this.parentNode.insertBefore(newNode, this.nextSibling);\r\n      }\r\n\r\n      return newNode;\r\n    }\r\n  };\r\n\r\n  _extends(Text, CharacterData);\r\n\r\n  function Comment() {}\r\n  Comment.prototype = {\r\n    nodeName: \"#comment\",\r\n    nodeType: COMMENT_NODE\r\n  };\r\n\r\n  _extends(Comment, CharacterData);\r\n\r\n  function CDATASection() {}\r\n  CDATASection.prototype = {\r\n    nodeName: \"#cdata-section\",\r\n    nodeType: CDATA_SECTION_NODE\r\n  };\r\n\r\n  _extends(CDATASection, CharacterData);\r\n\r\n  function DocumentType() {}\r\n  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\r\n\r\n  _extends(DocumentType, Node);\r\n\r\n  function Notation() {}\r\n  Notation.prototype.nodeType = NOTATION_NODE;\r\n\r\n  _extends(Notation, Node);\r\n\r\n  function Entity() {}\r\n  Entity.prototype.nodeType = ENTITY_NODE;\r\n\r\n  _extends(Entity, Node);\r\n\r\n  function EntityReference() {}\r\n  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\r\n\r\n  _extends(EntityReference, Node);\r\n\r\n  function DocumentFragment() {}\r\n  DocumentFragment.prototype.nodeName = \"#document-fragment\";\r\n  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\r\n\r\n  _extends(DocumentFragment, Node);\r\n\r\n  function ProcessingInstruction() {}\r\n\r\n  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\r\n\r\n  _extends(ProcessingInstruction, Node);\r\n\r\n  function XMLSerializer$1() {}\r\n\r\n  XMLSerializer$1.prototype.serializeToString = function (node, isHtml, nodeFilter) {\r\n    return nodeSerializeToString.call(node, isHtml, nodeFilter);\r\n  };\r\n\r\n  Node.prototype.toString = nodeSerializeToString;\r\n\r\n  function nodeSerializeToString(isHtml, nodeFilter) {\r\n    var buf = [];\r\n    var refNode = this.nodeType == 9 && this.documentElement || this;\r\n    var prefix = refNode.prefix;\r\n    var uri = refNode.namespaceURI;\r\n\r\n    if (uri && prefix == null) {\r\n      //console.log(prefix)\r\n      var prefix = refNode.lookupPrefix(uri);\r\n\r\n      if (prefix == null) {\r\n        //isHTML = true;\r\n        var visibleNamespaces = [{\r\n          namespace: uri,\r\n          prefix: null\r\n        } //{namespace:uri,prefix:''}\r\n        ];\r\n      }\r\n    }\r\n\r\n    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces); //console.log('###',this.nodeType,uri,prefix,buf.join(''))\r\n\r\n    return buf.join('');\r\n  }\r\n\r\n  function needNamespaceDefine(node, isHTML, visibleNamespaces) {\r\n    var prefix = node.prefix || '';\r\n    var uri = node.namespaceURI; // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\r\n    // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\r\n    // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\r\n    // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\r\n    // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\r\n    // > [...] Furthermore, the attribute value [...] must not be an empty string.\r\n    // so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\r\n\r\n    if (!uri) {\r\n      return false;\r\n    }\r\n\r\n    if (prefix === \"xml\" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {\r\n      return false;\r\n    }\r\n\r\n    var i = visibleNamespaces.length;\r\n\r\n    while (i--) {\r\n      var ns = visibleNamespaces[i]; // get namespace prefix\r\n\r\n      if (ns.prefix === prefix) {\r\n        return ns.namespace !== uri;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * Well-formed constraint: No < in Attribute Values\r\n   * The replacement text of any entity referred to directly or indirectly in an attribute value must not contain a <.\r\n   * @see https://www.w3.org/TR/xml/#CleanAttrVals\r\n   * @see https://www.w3.org/TR/xml/#NT-AttValue\r\n   */\r\n\r\n\r\n  function addSerializedAttribute(buf, qualifiedName, value) {\r\n    buf.push(' ', qualifiedName, '=\"', value.replace(/[<&\"]/g, _xmlEncoder), '\"');\r\n  }\r\n\r\n  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {\r\n    if (!visibleNamespaces) {\r\n      visibleNamespaces = [];\r\n    }\r\n\r\n    if (nodeFilter) {\r\n      node = nodeFilter(node);\r\n\r\n      if (node) {\r\n        if (typeof node == 'string') {\r\n          buf.push(node);\r\n          return;\r\n        }\r\n      } else {\r\n        return;\r\n      } //buf.sort.apply(attrs, attributeSorter);\r\n\r\n    }\r\n\r\n    switch (node.nodeType) {\r\n      case ELEMENT_NODE:\r\n        var attrs = node.attributes;\r\n        var len = attrs.length;\r\n        var child = node.firstChild;\r\n        var nodeName = node.tagName;\r\n        isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;\r\n        var prefixedNodeName = nodeName;\r\n\r\n        if (!isHTML && !node.prefix && node.namespaceURI) {\r\n          var defaultNS; // lookup current default ns from `xmlns` attribute\r\n\r\n          for (var ai = 0; ai < attrs.length; ai++) {\r\n            if (attrs.item(ai).name === 'xmlns') {\r\n              defaultNS = attrs.item(ai).value;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (!defaultNS) {\r\n            // lookup current default ns in visibleNamespaces\r\n            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\r\n              var namespace = visibleNamespaces[nsi];\r\n\r\n              if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\r\n                defaultNS = namespace.namespace;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (defaultNS !== node.namespaceURI) {\r\n            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\r\n              var namespace = visibleNamespaces[nsi];\r\n\r\n              if (namespace.namespace === node.namespaceURI) {\r\n                if (namespace.prefix) {\r\n                  prefixedNodeName = namespace.prefix + ':' + nodeName;\r\n                }\r\n\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        buf.push('<', prefixedNodeName);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          // add namespaces for attributes\r\n          var attr = attrs.item(i);\r\n\r\n          if (attr.prefix == 'xmlns') {\r\n            visibleNamespaces.push({\r\n              prefix: attr.localName,\r\n              namespace: attr.value\r\n            });\r\n          } else if (attr.nodeName == 'xmlns') {\r\n            visibleNamespaces.push({\r\n              prefix: '',\r\n              namespace: attr.value\r\n            });\r\n          }\r\n        }\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          var attr = attrs.item(i);\r\n\r\n          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\r\n            var prefix = attr.prefix || '';\r\n            var uri = attr.namespaceURI;\r\n            addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\r\n            visibleNamespaces.push({\r\n              prefix: prefix,\r\n              namespace: uri\r\n            });\r\n          }\r\n\r\n          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);\r\n        } // add namespace for current node\t\t\r\n\r\n\r\n        if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\r\n          var prefix = node.prefix || '';\r\n          var uri = node.namespaceURI;\r\n          addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\r\n          visibleNamespaces.push({\r\n            prefix: prefix,\r\n            namespace: uri\r\n          });\r\n        }\r\n\r\n        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {\r\n          buf.push('>'); //if is cdata child node\r\n\r\n          if (isHTML && /^script$/i.test(nodeName)) {\r\n            while (child) {\r\n              if (child.data) {\r\n                buf.push(child.data);\r\n              } else {\r\n                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\r\n              }\r\n\r\n              child = child.nextSibling;\r\n            }\r\n          } else {\r\n            while (child) {\r\n              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\r\n              child = child.nextSibling;\r\n            }\r\n          }\r\n\r\n          buf.push('</', prefixedNodeName, '>');\r\n        } else {\r\n          buf.push('/>');\r\n        } // remove added visible namespaces\r\n        //visibleNamespaces.length = startVisibleNamespaces;\r\n\r\n\r\n        return;\r\n\r\n      case DOCUMENT_NODE:\r\n      case DOCUMENT_FRAGMENT_NODE:\r\n        var child = node.firstChild;\r\n\r\n        while (child) {\r\n          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\r\n          child = child.nextSibling;\r\n        }\r\n\r\n        return;\r\n\r\n      case ATTRIBUTE_NODE:\r\n        return addSerializedAttribute(buf, node.name, node.value);\r\n\r\n      case TEXT_NODE:\r\n        /**\r\n         * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\r\n         * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.\r\n         * If they are needed elsewhere, they must be escaped using either numeric character references or the strings\r\n         * `&amp;` and `&lt;` respectively.\r\n         * The right angle bracket (>) may be represented using the string \" &gt; \", and must, for compatibility,\r\n         * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,\r\n         * when that string is not marking the end of a CDATA section.\r\n         *\r\n         * In the content of elements, character data is any string of characters\r\n         * which does not contain the start-delimiter of any markup\r\n         * and does not include the CDATA-section-close delimiter, `]]>`.\r\n         *\r\n         * @see https://www.w3.org/TR/xml/#NT-CharData\r\n         */\r\n        return buf.push(node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, ']]&gt;'));\r\n\r\n      case CDATA_SECTION_NODE:\r\n        return buf.push('<![CDATA[', node.data, ']]>');\r\n\r\n      case COMMENT_NODE:\r\n        return buf.push(\"<!--\", node.data, \"-->\");\r\n\r\n      case DOCUMENT_TYPE_NODE:\r\n        var pubid = node.publicId;\r\n        var sysid = node.systemId;\r\n        buf.push('<!DOCTYPE ', node.name);\r\n\r\n        if (pubid) {\r\n          buf.push(' PUBLIC ', pubid);\r\n\r\n          if (sysid && sysid != '.') {\r\n            buf.push(' ', sysid);\r\n          }\r\n\r\n          buf.push('>');\r\n        } else if (sysid && sysid != '.') {\r\n          buf.push(' SYSTEM ', sysid, '>');\r\n        } else {\r\n          var sub = node.internalSubset;\r\n\r\n          if (sub) {\r\n            buf.push(\" [\", sub, \"]\");\r\n          }\r\n\r\n          buf.push(\">\");\r\n        }\r\n\r\n        return;\r\n\r\n      case PROCESSING_INSTRUCTION_NODE:\r\n        return buf.push(\"<?\", node.target, \" \", node.data, \"?>\");\r\n\r\n      case ENTITY_REFERENCE_NODE:\r\n        return buf.push('&', node.nodeName, ';');\r\n      //case ENTITY_NODE:\r\n      //case NOTATION_NODE:\r\n\r\n      default:\r\n        buf.push('??', node.nodeName);\r\n    }\r\n  }\r\n\r\n  function _importNode(doc, node, deep) {\r\n    var node2;\r\n\r\n    switch (node.nodeType) {\r\n      case ELEMENT_NODE:\r\n        node2 = node.cloneNode(false);\r\n        node2.ownerDocument = doc;\r\n      //var attrs = node2.attributes;\r\n      //var len = attrs.length;\r\n      //for(var i=0;i<len;i++){\r\n      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\r\n      //}\r\n\r\n      case DOCUMENT_FRAGMENT_NODE:\r\n        break;\r\n\r\n      case ATTRIBUTE_NODE:\r\n        deep = true;\r\n        break;\r\n      //case ENTITY_REFERENCE_NODE:\r\n      //case PROCESSING_INSTRUCTION_NODE:\r\n      ////case TEXT_NODE:\r\n      //case CDATA_SECTION_NODE:\r\n      //case COMMENT_NODE:\r\n      //\tdeep = false;\r\n      //\tbreak;\r\n      //case DOCUMENT_NODE:\r\n      //case DOCUMENT_TYPE_NODE:\r\n      //cannot be imported.\r\n      //case ENTITY_NODE:\r\n      //case NOTATION_NODE\r\n      //can not hit in level3\r\n      //default:throw e;\r\n    }\r\n\r\n    if (!node2) {\r\n      node2 = node.cloneNode(false); //false\r\n    }\r\n\r\n    node2.ownerDocument = doc;\r\n    node2.parentNode = null;\r\n\r\n    if (deep) {\r\n      var child = node.firstChild;\r\n\r\n      while (child) {\r\n        node2.appendChild(_importNode(doc, child, deep));\r\n        child = child.nextSibling;\r\n      }\r\n    }\r\n\r\n    return node2;\r\n  } //\r\n  //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\r\n  //\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\r\n\r\n\r\n  function _cloneNode(doc, node, deep) {\r\n    var node2 = new node.constructor();\r\n\r\n    for (var n in node) {\r\n      var v = node[n];\r\n\r\n      if (typeof v != 'object') {\r\n        if (v != node2[n]) {\r\n          node2[n] = v;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (node.childNodes) {\r\n      node2.childNodes = new NodeList();\r\n    }\r\n\r\n    node2.ownerDocument = doc;\r\n\r\n    switch (node2.nodeType) {\r\n      case ELEMENT_NODE:\r\n        var attrs = node.attributes;\r\n        var attrs2 = node2.attributes = new NamedNodeMap();\r\n        var len = attrs.length;\r\n        attrs2._ownerElement = node2;\r\n\r\n        for (var i = 0; i < len; i++) {\r\n          node2.setAttributeNode(_cloneNode(doc, attrs.item(i), true));\r\n        }\r\n\r\n        break;\r\n\r\n      case ATTRIBUTE_NODE:\r\n        deep = true;\r\n    }\r\n\r\n    if (deep) {\r\n      var child = node.firstChild;\r\n\r\n      while (child) {\r\n        node2.appendChild(_cloneNode(doc, child, deep));\r\n        child = child.nextSibling;\r\n      }\r\n    }\r\n\r\n    return node2;\r\n  }\r\n\r\n  function __set__(object, key, value) {\r\n    object[key] = value;\r\n  } //do dynamic\r\n\r\n\r\n  try {\r\n    if (Object.defineProperty) {\r\n      var getTextContent = function getTextContent(node) {\r\n        switch (node.nodeType) {\r\n          case ELEMENT_NODE:\r\n          case DOCUMENT_FRAGMENT_NODE:\r\n            var buf = [];\r\n            node = node.firstChild;\r\n\r\n            while (node) {\r\n              if (node.nodeType !== 7 && node.nodeType !== 8) {\r\n                buf.push(getTextContent(node));\r\n              }\r\n\r\n              node = node.nextSibling;\r\n            }\r\n\r\n            return buf.join('');\r\n\r\n          default:\r\n            return node.nodeValue;\r\n        }\r\n      };\r\n\r\n      Object.defineProperty(LiveNodeList.prototype, 'length', {\r\n        get: function get() {\r\n          _updateLiveList(this);\r\n\r\n          return this.$$length;\r\n        }\r\n      });\r\n      Object.defineProperty(Node.prototype, 'textContent', {\r\n        get: function get() {\r\n          return getTextContent(this);\r\n        },\r\n        set: function set(data) {\r\n          switch (this.nodeType) {\r\n            case ELEMENT_NODE:\r\n            case DOCUMENT_FRAGMENT_NODE:\r\n              while (this.firstChild) {\r\n                this.removeChild(this.firstChild);\r\n              }\r\n\r\n              if (data || String(data)) {\r\n                this.appendChild(this.ownerDocument.createTextNode(data));\r\n              }\r\n\r\n              break;\r\n\r\n            default:\r\n              this.data = data;\r\n              this.value = data;\r\n              this.nodeValue = data;\r\n          }\r\n        }\r\n      });\r\n\r\n      __set__ = function __set__(object, key, value) {\r\n        //console.log(value)\r\n        object['$$' + key] = value;\r\n      };\r\n    }\r\n  } catch (e) {//ie8\r\n  } //if(typeof require == 'function'){\r\n\r\n\r\n  var DocumentType_1 = DocumentType;\r\n  var DOMException_1 = DOMException;\r\n  var DOMImplementation_1$1 = DOMImplementation$1;\r\n  var Element_1 = Element;\r\n  var Node_1 = Node;\r\n  var NodeList_1 = NodeList;\r\n  var XMLSerializer_1 = XMLSerializer$1; //}\r\n\r\n  var dom = {\r\n    DocumentType: DocumentType_1,\r\n    DOMException: DOMException_1,\r\n    DOMImplementation: DOMImplementation_1$1,\r\n    Element: Element_1,\r\n    Node: Node_1,\r\n    NodeList: NodeList_1,\r\n    XMLSerializer: XMLSerializer_1\r\n  };\r\n\r\n  var entities = createCommonjsModule(function (module, exports) {\r\n    var freeze = conventions.freeze;\r\n    /**\r\n     * The entities that are predefined in every XML document.\r\n     *\r\n     * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1\r\n     * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0\r\n     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia\r\n     */\r\n\r\n    exports.XML_ENTITIES = freeze({\r\n      amp: '&',\r\n      apos: \"'\",\r\n      gt: '>',\r\n      lt: '<',\r\n      quot: '\"'\r\n    });\r\n    /**\r\n     * A map of currently 241 entities that are detected in an HTML document.\r\n     * They contain all entries from `XML_ENTITIES`.\r\n     *\r\n     * @see XML_ENTITIES\r\n     * @see DOMParser.parseFromString\r\n     * @see DOMImplementation.prototype.createHTMLDocument\r\n     * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec\r\n     * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names\r\n     * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML\r\n     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)\r\n     * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)\r\n     */\r\n\r\n    exports.HTML_ENTITIES = freeze({\r\n      lt: '<',\r\n      gt: '>',\r\n      amp: '&',\r\n      quot: '\"',\r\n      apos: \"'\",\r\n      Agrave: \"\",\r\n      Aacute: \"\",\r\n      Acirc: \"\",\r\n      Atilde: \"\",\r\n      Auml: \"\",\r\n      Aring: \"\",\r\n      AElig: \"\",\r\n      Ccedil: \"\",\r\n      Egrave: \"\",\r\n      Eacute: \"\",\r\n      Ecirc: \"\",\r\n      Euml: \"\",\r\n      Igrave: \"\",\r\n      Iacute: \"\",\r\n      Icirc: \"\",\r\n      Iuml: \"\",\r\n      ETH: \"\",\r\n      Ntilde: \"\",\r\n      Ograve: \"\",\r\n      Oacute: \"\",\r\n      Ocirc: \"\",\r\n      Otilde: \"\",\r\n      Ouml: \"\",\r\n      Oslash: \"\",\r\n      Ugrave: \"\",\r\n      Uacute: \"\",\r\n      Ucirc: \"\",\r\n      Uuml: \"\",\r\n      Yacute: \"\",\r\n      THORN: \"\",\r\n      szlig: \"\",\r\n      agrave: \"\",\r\n      aacute: \"\",\r\n      acirc: \"\",\r\n      atilde: \"\",\r\n      auml: \"\",\r\n      aring: \"\",\r\n      aelig: \"\",\r\n      ccedil: \"\",\r\n      egrave: \"\",\r\n      eacute: \"\",\r\n      ecirc: \"\",\r\n      euml: \"\",\r\n      igrave: \"\",\r\n      iacute: \"\",\r\n      icirc: \"\",\r\n      iuml: \"\",\r\n      eth: \"\",\r\n      ntilde: \"\",\r\n      ograve: \"\",\r\n      oacute: \"\",\r\n      ocirc: \"\",\r\n      otilde: \"\",\r\n      ouml: \"\",\r\n      oslash: \"\",\r\n      ugrave: \"\",\r\n      uacute: \"\",\r\n      ucirc: \"\",\r\n      uuml: \"\",\r\n      yacute: \"\",\r\n      thorn: \"\",\r\n      yuml: \"\",\r\n      nbsp: \"\\xA0\",\r\n      iexcl: \"\",\r\n      cent: \"\",\r\n      pound: \"\",\r\n      curren: \"\",\r\n      yen: \"\",\r\n      brvbar: \"\",\r\n      sect: \"\",\r\n      uml: \"\",\r\n      copy: \"\",\r\n      ordf: \"\",\r\n      laquo: \"\",\r\n      not: \"\",\r\n      shy: \"\",\r\n      reg: \"\",\r\n      macr: \"\",\r\n      deg: \"\",\r\n      plusmn: \"\",\r\n      sup2: \"\",\r\n      sup3: \"\",\r\n      acute: \"\",\r\n      micro: \"\",\r\n      para: \"\",\r\n      middot: \"\",\r\n      cedil: \"\",\r\n      sup1: \"\",\r\n      ordm: \"\",\r\n      raquo: \"\",\r\n      frac14: \"\",\r\n      frac12: \"\",\r\n      frac34: \"\",\r\n      iquest: \"\",\r\n      times: \"\",\r\n      divide: \"\",\r\n      forall: \"\",\r\n      part: \"\",\r\n      exist: \"\",\r\n      empty: \"\",\r\n      nabla: \"\",\r\n      isin: \"\",\r\n      notin: \"\",\r\n      ni: \"\",\r\n      prod: \"\",\r\n      sum: \"\",\r\n      minus: \"\",\r\n      lowast: \"\",\r\n      radic: \"\",\r\n      prop: \"\",\r\n      infin: \"\",\r\n      ang: \"\",\r\n      and: \"\",\r\n      or: \"\",\r\n      cap: \"\",\r\n      cup: \"\",\r\n      'int': \"\",\r\n      there4: \"\",\r\n      sim: \"\",\r\n      cong: \"\",\r\n      asymp: \"\",\r\n      ne: \"\",\r\n      equiv: \"\",\r\n      le: \"\",\r\n      ge: \"\",\r\n      sub: \"\",\r\n      sup: \"\",\r\n      nsub: \"\",\r\n      sube: \"\",\r\n      supe: \"\",\r\n      oplus: \"\",\r\n      otimes: \"\",\r\n      perp: \"\",\r\n      sdot: \"\",\r\n      Alpha: \"\",\r\n      Beta: \"\",\r\n      Gamma: \"\",\r\n      Delta: \"\",\r\n      Epsilon: \"\",\r\n      Zeta: \"\",\r\n      Eta: \"\",\r\n      Theta: \"\",\r\n      Iota: \"\",\r\n      Kappa: \"\",\r\n      Lambda: \"\",\r\n      Mu: \"\",\r\n      Nu: \"\",\r\n      Xi: \"\",\r\n      Omicron: \"\",\r\n      Pi: \"\",\r\n      Rho: \"\",\r\n      Sigma: \"\",\r\n      Tau: \"\",\r\n      Upsilon: \"\",\r\n      Phi: \"\",\r\n      Chi: \"\",\r\n      Psi: \"\",\r\n      Omega: \"\",\r\n      alpha: \"\",\r\n      beta: \"\",\r\n      gamma: \"\",\r\n      delta: \"\",\r\n      epsilon: \"\",\r\n      zeta: \"\",\r\n      eta: \"\",\r\n      theta: \"\",\r\n      iota: \"\",\r\n      kappa: \"\",\r\n      lambda: \"\",\r\n      mu: \"\",\r\n      nu: \"\",\r\n      xi: \"\",\r\n      omicron: \"\",\r\n      pi: \"\",\r\n      rho: \"\",\r\n      sigmaf: \"\",\r\n      sigma: \"\",\r\n      tau: \"\",\r\n      upsilon: \"\",\r\n      phi: \"\",\r\n      chi: \"\",\r\n      psi: \"\",\r\n      omega: \"\",\r\n      thetasym: \"\",\r\n      upsih: \"\",\r\n      piv: \"\",\r\n      OElig: \"\",\r\n      oelig: \"\",\r\n      Scaron: \"\",\r\n      scaron: \"\",\r\n      Yuml: \"\",\r\n      fnof: \"\",\r\n      circ: \"\",\r\n      tilde: \"\",\r\n      ensp: \"\",\r\n      emsp: \"\",\r\n      thinsp: \"\",\r\n      zwnj: \"\",\r\n      zwj: \"\",\r\n      lrm: \"\",\r\n      rlm: \"\",\r\n      ndash: \"\",\r\n      mdash: \"\",\r\n      lsquo: \"\",\r\n      rsquo: \"\",\r\n      sbquo: \"\",\r\n      ldquo: \"\",\r\n      rdquo: \"\",\r\n      bdquo: \"\",\r\n      dagger: \"\",\r\n      Dagger: \"\",\r\n      bull: \"\",\r\n      hellip: \"\",\r\n      permil: \"\",\r\n      prime: \"\",\r\n      Prime: \"\",\r\n      lsaquo: \"\",\r\n      rsaquo: \"\",\r\n      oline: \"\",\r\n      euro: \"\",\r\n      trade: \"\",\r\n      larr: \"\",\r\n      uarr: \"\",\r\n      rarr: \"\",\r\n      darr: \"\",\r\n      harr: \"\",\r\n      crarr: \"\",\r\n      lceil: \"\",\r\n      rceil: \"\",\r\n      lfloor: \"\",\r\n      rfloor: \"\",\r\n      loz: \"\",\r\n      spades: \"\",\r\n      clubs: \"\",\r\n      hearts: \"\",\r\n      diams: \"\"\r\n    });\r\n    /**\r\n     * @deprecated use `HTML_ENTITIES` instead\r\n     * @see HTML_ENTITIES\r\n     */\r\n\r\n    exports.entityMap = exports.HTML_ENTITIES;\r\n  });\r\n  entities.XML_ENTITIES;\r\n  entities.HTML_ENTITIES;\r\n  entities.entityMap;\r\n\r\n  var NAMESPACE$1 = conventions.NAMESPACE; //[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n  //[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\r\n  //[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\r\n\r\n  var nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\r\n\r\n  var nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\r\n  var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$'); //var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\r\n  //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\r\n  //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\r\n  //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\r\n\r\n  var S_TAG = 0; //tag name offerring\r\n\r\n  var S_ATTR = 1; //attr name offerring \r\n\r\n  var S_ATTR_SPACE = 2; //attr name end and space offer\r\n\r\n  var S_EQ = 3; //=space?\r\n\r\n  var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\r\n\r\n  var S_ATTR_END = 5; //attr value end and no space(quot end)\r\n\r\n  var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\r\n\r\n  var S_TAG_CLOSE = 7; //closed el<el />\r\n\r\n  /**\r\n   * Creates an error that will not be caught by XMLReader aka the SAX parser.\r\n   *\r\n   * @param {string} message\r\n   * @param {any?} locator Optional, can provide details about the location in the source\r\n   * @constructor\r\n   */\r\n\r\n  function ParseError$1(message, locator) {\r\n    this.message = message;\r\n    this.locator = locator;\r\n    if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError$1);\r\n  }\r\n\r\n  ParseError$1.prototype = new Error();\r\n  ParseError$1.prototype.name = ParseError$1.name;\r\n\r\n  function XMLReader$1() {}\r\n\r\n  XMLReader$1.prototype = {\r\n    parse: function parse(source, defaultNSMap, entityMap) {\r\n      var domBuilder = this.domBuilder;\r\n      domBuilder.startDocument();\r\n\r\n      _copy(defaultNSMap, defaultNSMap = {});\r\n\r\n      _parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\r\n\r\n      domBuilder.endDocument();\r\n    }\r\n  };\r\n\r\n  function _parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\r\n    function fixedFromCharCode(code) {\r\n      // String.prototype.fromCharCode does not supports\r\n      // > 2 bytes unicode chars directly\r\n      if (code > 0xffff) {\r\n        code -= 0x10000;\r\n        var surrogate1 = 0xd800 + (code >> 10),\r\n            surrogate2 = 0xdc00 + (code & 0x3ff);\r\n        return String.fromCharCode(surrogate1, surrogate2);\r\n      } else {\r\n        return String.fromCharCode(code);\r\n      }\r\n    }\r\n\r\n    function entityReplacer(a) {\r\n      var k = a.slice(1, -1);\r\n\r\n      if (k in entityMap) {\r\n        return entityMap[k];\r\n      } else if (k.charAt(0) === '#') {\r\n        return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\r\n      } else {\r\n        errorHandler.error('entity not found:' + a);\r\n        return a;\r\n      }\r\n    }\r\n\r\n    function appendText(end) {\r\n      //has some bugs\r\n      if (end > start) {\r\n        var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\r\n        locator && position(start);\r\n        domBuilder.characters(xt, 0, end - start);\r\n        start = end;\r\n      }\r\n    }\r\n\r\n    function position(p, m) {\r\n      while (p >= lineEnd && (m = linePattern.exec(source))) {\r\n        lineStart = m.index;\r\n        lineEnd = lineStart + m[0].length;\r\n        locator.lineNumber++; //console.log('line++:',locator,startPos,endPos)\r\n      }\r\n\r\n      locator.columnNumber = p - lineStart + 1;\r\n    }\r\n\r\n    var lineStart = 0;\r\n    var lineEnd = 0;\r\n    var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g;\r\n    var locator = domBuilder.locator;\r\n    var parseStack = [{\r\n      currentNSMap: defaultNSMapCopy\r\n    }];\r\n    var closeMap = {};\r\n    var start = 0;\r\n\r\n    while (true) {\r\n      try {\r\n        var tagStart = source.indexOf('<', start);\r\n\r\n        if (tagStart < 0) {\r\n          if (!source.substr(start).match(/^\\s*$/)) {\r\n            var doc = domBuilder.doc;\r\n            var text = doc.createTextNode(source.substr(start));\r\n            doc.appendChild(text);\r\n            domBuilder.currentElement = text;\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if (tagStart > start) {\r\n          appendText(tagStart);\r\n        }\r\n\r\n        switch (source.charAt(tagStart + 1)) {\r\n          case '/':\r\n            var end = source.indexOf('>', tagStart + 3);\r\n            var tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\r\n            var config = parseStack.pop();\r\n\r\n            if (end < 0) {\r\n              tagName = source.substring(tagStart + 2).replace(/[\\s<].*/, '');\r\n              errorHandler.error(\"end tag name: \" + tagName + ' is not complete:' + config.tagName);\r\n              end = tagStart + 1 + tagName.length;\r\n            } else if (tagName.match(/\\s</)) {\r\n              tagName = tagName.replace(/[\\s<].*/, '');\r\n              errorHandler.error(\"end tag name: \" + tagName + ' maybe not complete');\r\n              end = tagStart + 1 + tagName.length;\r\n            }\r\n\r\n            var localNSMap = config.localNSMap;\r\n            var endMatch = config.tagName == tagName;\r\n            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();\r\n\r\n            if (endIgnoreCaseMach) {\r\n              domBuilder.endElement(config.uri, config.localName, tagName);\r\n\r\n              if (localNSMap) {\r\n                for (var prefix in localNSMap) {\r\n                  domBuilder.endPrefixMapping(prefix);\r\n                }\r\n              }\r\n\r\n              if (!endMatch) {\r\n                errorHandler.fatalError(\"end tag name: \" + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case\r\n              }\r\n            } else {\r\n              parseStack.push(config);\r\n            }\r\n\r\n            end++;\r\n            break;\r\n          // end elment\r\n\r\n          case '?':\r\n            // <?...?>\r\n            locator && position(tagStart);\r\n            end = parseInstruction(source, tagStart, domBuilder);\r\n            break;\r\n\r\n          case '!':\r\n            // <!doctype,<![CDATA,<!--\r\n            locator && position(tagStart);\r\n            end = parseDCC(source, tagStart, domBuilder, errorHandler);\r\n            break;\r\n\r\n          default:\r\n            locator && position(tagStart);\r\n            var el = new ElementAttributes();\r\n            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap; //elStartEnd\r\n\r\n            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);\r\n            var len = el.length;\r\n\r\n            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\r\n              el.closed = true;\r\n\r\n              if (!entityMap.nbsp) {\r\n                errorHandler.warning('unclosed xml attribute');\r\n              }\r\n            }\r\n\r\n            if (locator && len) {\r\n              var locator2 = copyLocator(locator, {}); //try{//attribute position fixed\r\n\r\n              for (var i = 0; i < len; i++) {\r\n                var a = el[i];\r\n                position(a.offset);\r\n                a.locator = copyLocator(locator, {});\r\n              }\r\n\r\n              domBuilder.locator = locator2;\r\n\r\n              if (appendElement$1(el, domBuilder, currentNSMap)) {\r\n                parseStack.push(el);\r\n              }\r\n\r\n              domBuilder.locator = locator;\r\n            } else {\r\n              if (appendElement$1(el, domBuilder, currentNSMap)) {\r\n                parseStack.push(el);\r\n              }\r\n            }\r\n\r\n            if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {\r\n              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\r\n            } else {\r\n              end++;\r\n            }\r\n\r\n        }\r\n      } catch (e) {\r\n        if (e instanceof ParseError$1) {\r\n          throw e;\r\n        }\r\n\r\n        errorHandler.error('element parse error: ' + e);\r\n        end = -1;\r\n      }\r\n\r\n      if (end > start) {\r\n        start = end;\r\n      } else {\r\n        //TODO: sax\r\n        appendText(Math.max(tagStart, start) + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  function copyLocator(f, t) {\r\n    t.lineNumber = f.lineNumber;\r\n    t.columnNumber = f.columnNumber;\r\n    return t;\r\n  }\r\n  /**\r\n   * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\r\n   * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\r\n   */\r\n\r\n\r\n  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {\r\n    /**\r\n     * @param {string} qname\r\n     * @param {string} value\r\n     * @param {number} startIndex\r\n     */\r\n    function addAttribute(qname, value, startIndex) {\r\n      if (el.attributeNames.hasOwnProperty(qname)) {\r\n        errorHandler.fatalError('Attribute ' + qname + ' redefined');\r\n      }\r\n\r\n      el.addValue(qname, value, startIndex);\r\n    }\r\n\r\n    var attrName;\r\n    var value;\r\n    var p = ++start;\r\n    var s = S_TAG; //status\r\n\r\n    while (true) {\r\n      var c = source.charAt(p);\r\n\r\n      switch (c) {\r\n        case '=':\r\n          if (s === S_ATTR) {\r\n            //attrName\r\n            attrName = source.slice(start, p);\r\n            s = S_EQ;\r\n          } else if (s === S_ATTR_SPACE) {\r\n            s = S_EQ;\r\n          } else {\r\n            //fatalError: equal must after attrName or space after attrName\r\n            throw new Error('attribute equal must after attrName'); // No known test case\r\n          }\r\n\r\n          break;\r\n\r\n        case '\\'':\r\n        case '\"':\r\n          if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\r\n          ) {\r\n              //equal\r\n              if (s === S_ATTR) {\r\n                errorHandler.warning('attribute value must after \"=\"');\r\n                attrName = source.slice(start, p);\r\n              }\r\n\r\n              start = p + 1;\r\n              p = source.indexOf(c, start);\r\n\r\n              if (p > 0) {\r\n                value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\r\n                addAttribute(attrName, value, start - 1);\r\n                s = S_ATTR_END;\r\n              } else {\r\n                //fatalError: no end quot match\r\n                throw new Error('attribute value no end \\'' + c + '\\' match');\r\n              }\r\n            } else if (s == S_ATTR_NOQUOT_VALUE) {\r\n            value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer); //console.log(attrName,value,start,p)\r\n\r\n            addAttribute(attrName, value, start); //console.dir(el)\r\n\r\n            errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\r\n            start = p + 1;\r\n            s = S_ATTR_END;\r\n          } else {\r\n            //fatalError: no equal before\r\n            throw new Error('attribute value must after \"=\"'); // No known test case\r\n          }\r\n\r\n          break;\r\n\r\n        case '/':\r\n          switch (s) {\r\n            case S_TAG:\r\n              el.setTagName(source.slice(start, p));\r\n\r\n            case S_ATTR_END:\r\n            case S_TAG_SPACE:\r\n            case S_TAG_CLOSE:\r\n              s = S_TAG_CLOSE;\r\n              el.closed = true;\r\n\r\n            case S_ATTR_NOQUOT_VALUE:\r\n            case S_ATTR:\r\n            case S_ATTR_SPACE:\r\n              break;\r\n            //case S_EQ:\r\n\r\n            default:\r\n              throw new Error(\"attribute invalid close char('/')\");\r\n            // No known test case\r\n          }\r\n\r\n          break;\r\n\r\n        case '':\r\n          //end document\r\n          errorHandler.error('unexpected end of input');\r\n\r\n          if (s == S_TAG) {\r\n            el.setTagName(source.slice(start, p));\r\n          }\r\n\r\n          return p;\r\n\r\n        case '>':\r\n          switch (s) {\r\n            case S_TAG:\r\n              el.setTagName(source.slice(start, p));\r\n\r\n            case S_ATTR_END:\r\n            case S_TAG_SPACE:\r\n            case S_TAG_CLOSE:\r\n              break;\r\n            //normal\r\n\r\n            case S_ATTR_NOQUOT_VALUE: //Compatible state\r\n\r\n            case S_ATTR:\r\n              value = source.slice(start, p);\r\n\r\n              if (value.slice(-1) === '/') {\r\n                el.closed = true;\r\n                value = value.slice(0, -1);\r\n              }\r\n\r\n            case S_ATTR_SPACE:\r\n              if (s === S_ATTR_SPACE) {\r\n                value = attrName;\r\n              }\r\n\r\n              if (s == S_ATTR_NOQUOT_VALUE) {\r\n                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\r\n                addAttribute(attrName, value.replace(/&#?\\w+;/g, entityReplacer), start);\r\n              } else {\r\n                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {\r\n                  errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\r\n                }\r\n\r\n                addAttribute(value, value, start);\r\n              }\r\n\r\n              break;\r\n\r\n            case S_EQ:\r\n              throw new Error('attribute value missed!!');\r\n          } //\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\r\n\r\n\r\n          return p;\r\n\r\n        /*xml space '\\x20' | #x9 | #xD | #xA; */\r\n\r\n        case \"\\x80\":\r\n          c = ' ';\r\n\r\n        default:\r\n          if (c <= ' ') {\r\n            //space\r\n            switch (s) {\r\n              case S_TAG:\r\n                el.setTagName(source.slice(start, p)); //tagName\r\n\r\n                s = S_TAG_SPACE;\r\n                break;\r\n\r\n              case S_ATTR:\r\n                attrName = source.slice(start, p);\r\n                s = S_ATTR_SPACE;\r\n                break;\r\n\r\n              case S_ATTR_NOQUOT_VALUE:\r\n                var value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\r\n                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\r\n                addAttribute(attrName, value, start);\r\n\r\n              case S_ATTR_END:\r\n                s = S_TAG_SPACE;\r\n                break;\r\n              //case S_TAG_SPACE:\r\n              //case S_EQ:\r\n              //case S_ATTR_SPACE:\r\n              //\tvoid();break;\r\n              //case S_TAG_CLOSE:\r\n              //ignore warning\r\n            }\r\n          } else {\r\n            //not space\r\n            //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\r\n            //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\r\n            switch (s) {\r\n              //case S_TAG:void();break;\r\n              //case S_ATTR:void();break;\r\n              //case S_ATTR_NOQUOT_VALUE:void();break;\r\n              case S_ATTR_SPACE:\r\n                el.tagName;\r\n\r\n                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\r\n                  errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\r\n                }\r\n\r\n                addAttribute(attrName, attrName, start);\r\n                start = p;\r\n                s = S_ATTR;\r\n                break;\r\n\r\n              case S_ATTR_END:\r\n                errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\r\n\r\n              case S_TAG_SPACE:\r\n                s = S_ATTR;\r\n                start = p;\r\n                break;\r\n\r\n              case S_EQ:\r\n                s = S_ATTR_NOQUOT_VALUE;\r\n                start = p;\r\n                break;\r\n\r\n              case S_TAG_CLOSE:\r\n                throw new Error(\"elements closed character '/' and '>' must be connected to\");\r\n            }\r\n          }\r\n\r\n      } //end outer switch\r\n      //console.log('p++',p)\r\n\r\n\r\n      p++;\r\n    }\r\n  }\r\n  /**\r\n   * @return true if has new namespace define\r\n   */\r\n\r\n\r\n  function appendElement$1(el, domBuilder, currentNSMap) {\r\n    var tagName = el.tagName;\r\n    var localNSMap = null; //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\r\n\r\n    var i = el.length;\r\n\r\n    while (i--) {\r\n      var a = el[i];\r\n      var qName = a.qName;\r\n      var value = a.value;\r\n      var nsp = qName.indexOf(':');\r\n\r\n      if (nsp > 0) {\r\n        var prefix = a.prefix = qName.slice(0, nsp);\r\n        var localName = qName.slice(nsp + 1);\r\n        var nsPrefix = prefix === 'xmlns' && localName;\r\n      } else {\r\n        localName = qName;\r\n        prefix = null;\r\n        nsPrefix = qName === 'xmlns' && '';\r\n      } //can not set prefix,because prefix !== ''\r\n\r\n\r\n      a.localName = localName; //prefix == null for no ns prefix attribute \r\n\r\n      if (nsPrefix !== false) {\r\n        //hack!!\r\n        if (localNSMap == null) {\r\n          localNSMap = {}; //console.log(currentNSMap,0)\r\n\r\n          _copy(currentNSMap, currentNSMap = {}); //console.log(currentNSMap,1)\r\n\r\n        }\r\n\r\n        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\r\n        a.uri = NAMESPACE$1.XMLNS;\r\n        domBuilder.startPrefixMapping(nsPrefix, value);\r\n      }\r\n    }\r\n\r\n    var i = el.length;\r\n\r\n    while (i--) {\r\n      a = el[i];\r\n      var prefix = a.prefix;\r\n\r\n      if (prefix) {\r\n        //no prefix attribute has no namespace\r\n        if (prefix === 'xml') {\r\n          a.uri = NAMESPACE$1.XML;\r\n        }\r\n\r\n        if (prefix !== 'xmlns') {\r\n          a.uri = currentNSMap[prefix || '']; //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\r\n        }\r\n      }\r\n    }\r\n\r\n    var nsp = tagName.indexOf(':');\r\n\r\n    if (nsp > 0) {\r\n      prefix = el.prefix = tagName.slice(0, nsp);\r\n      localName = el.localName = tagName.slice(nsp + 1);\r\n    } else {\r\n      prefix = null; //important!!\r\n\r\n      localName = el.localName = tagName;\r\n    } //no prefix element has default namespace\r\n\r\n\r\n    var ns = el.uri = currentNSMap[prefix || ''];\r\n    domBuilder.startElement(ns, localName, tagName, el); //endPrefixMapping and startPrefixMapping have not any help for dom builder\r\n    //localNSMap = null\r\n\r\n    if (el.closed) {\r\n      domBuilder.endElement(ns, localName, tagName);\r\n\r\n      if (localNSMap) {\r\n        for (prefix in localNSMap) {\r\n          domBuilder.endPrefixMapping(prefix);\r\n        }\r\n      }\r\n    } else {\r\n      el.currentNSMap = currentNSMap;\r\n      el.localNSMap = localNSMap; //parseStack.push(el);\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\r\n    if (/^(?:script|textarea)$/i.test(tagName)) {\r\n      var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\r\n      var text = source.substring(elStartEnd + 1, elEndStart);\r\n\r\n      if (/[&<]/.test(text)) {\r\n        if (/^script$/i.test(tagName)) {\r\n          //if(!/\\]\\]>/.test(text)){\r\n          //lexHandler.startCDATA();\r\n          domBuilder.characters(text, 0, text.length); //lexHandler.endCDATA();\r\n\r\n          return elEndStart; //}\r\n        } //}else{//text area\r\n\r\n\r\n        text = text.replace(/&#?\\w+;/g, entityReplacer);\r\n        domBuilder.characters(text, 0, text.length);\r\n        return elEndStart; //}\r\n      }\r\n    }\r\n\r\n    return elStartEnd + 1;\r\n  }\r\n\r\n  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {\r\n    //if(tagName in closeMap){\r\n    var pos = closeMap[tagName];\r\n\r\n    if (pos == null) {\r\n      //console.log(tagName)\r\n      pos = source.lastIndexOf('</' + tagName + '>');\r\n\r\n      if (pos < elStartEnd) {\r\n        //\r\n        pos = source.lastIndexOf('</' + tagName);\r\n      }\r\n\r\n      closeMap[tagName] = pos;\r\n    }\r\n\r\n    return pos < elStartEnd; //} \r\n  }\r\n\r\n  function _copy(source, target) {\r\n    for (var n in source) {\r\n      target[n] = source[n];\r\n    }\r\n  }\r\n\r\n  function parseDCC(source, start, domBuilder, errorHandler) {\r\n    //sure start with '<!'\r\n    var next = source.charAt(start + 2);\r\n\r\n    switch (next) {\r\n      case '-':\r\n        if (source.charAt(start + 3) === '-') {\r\n          var end = source.indexOf('-->', start + 4); //append comment source.substring(4,end)//<!--\r\n\r\n          if (end > start) {\r\n            domBuilder.comment(source, start + 4, end - start - 4);\r\n            return end + 3;\r\n          } else {\r\n            errorHandler.error(\"Unclosed comment\");\r\n            return -1;\r\n          }\r\n        } else {\r\n          //error\r\n          return -1;\r\n        }\r\n\r\n      default:\r\n        if (source.substr(start + 3, 6) == 'CDATA[') {\r\n          var end = source.indexOf(']]>', start + 9);\r\n          domBuilder.startCDATA();\r\n          domBuilder.characters(source, start + 9, end - start - 9);\r\n          domBuilder.endCDATA();\r\n          return end + 3;\r\n        } //<!DOCTYPE\r\n        //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \r\n\r\n\r\n        var matchs = split(source, start);\r\n        var len = matchs.length;\r\n\r\n        if (len > 1 && /!doctype/i.test(matchs[0][0])) {\r\n          var name = matchs[1][0];\r\n          var pubid = false;\r\n          var sysid = false;\r\n\r\n          if (len > 3) {\r\n            if (/^public$/i.test(matchs[2][0])) {\r\n              pubid = matchs[3][0];\r\n              sysid = len > 4 && matchs[4][0];\r\n            } else if (/^system$/i.test(matchs[2][0])) {\r\n              sysid = matchs[3][0];\r\n            }\r\n          }\r\n\r\n          var lastMatch = matchs[len - 1];\r\n          domBuilder.startDTD(name, pubid, sysid);\r\n          domBuilder.endDTD();\r\n          return lastMatch.index + lastMatch[0].length;\r\n        }\r\n\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  function parseInstruction(source, start, domBuilder) {\r\n    var end = source.indexOf('?>', start);\r\n\r\n    if (end) {\r\n      var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\r\n\r\n      if (match) {\r\n        match[0].length;\r\n        domBuilder.processingInstruction(match[1], match[2]);\r\n        return end + 2;\r\n      } else {\r\n        //error\r\n        return -1;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  function ElementAttributes() {\r\n    this.attributeNames = {};\r\n  }\r\n\r\n  ElementAttributes.prototype = {\r\n    setTagName: function setTagName(tagName) {\r\n      if (!tagNamePattern.test(tagName)) {\r\n        throw new Error('invalid tagName:' + tagName);\r\n      }\r\n\r\n      this.tagName = tagName;\r\n    },\r\n    addValue: function addValue(qName, value, offset) {\r\n      if (!tagNamePattern.test(qName)) {\r\n        throw new Error('invalid attribute:' + qName);\r\n      }\r\n\r\n      this.attributeNames[qName] = this.length;\r\n      this[this.length++] = {\r\n        qName: qName,\r\n        value: value,\r\n        offset: offset\r\n      };\r\n    },\r\n    length: 0,\r\n    getLocalName: function getLocalName(i) {\r\n      return this[i].localName;\r\n    },\r\n    getLocator: function getLocator(i) {\r\n      return this[i].locator;\r\n    },\r\n    getQName: function getQName(i) {\r\n      return this[i].qName;\r\n    },\r\n    getURI: function getURI(i) {\r\n      return this[i].uri;\r\n    },\r\n    getValue: function getValue(i) {\r\n      return this[i].value;\r\n    } //\t,getIndex:function(uri, localName)){\r\n    //\t\tif(localName){\r\n    //\t\t\t\r\n    //\t\t}else{\r\n    //\t\t\tvar qName = uri\r\n    //\t\t}\r\n    //\t},\r\n    //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\r\n    //\tgetType:function(uri,localName){}\r\n    //\tgetType:function(i){},\r\n\r\n  };\r\n\r\n  function split(source, start) {\r\n    var match;\r\n    var buf = [];\r\n    var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\r\n    reg.lastIndex = start;\r\n    reg.exec(source); //skip <\r\n\r\n    while (match = reg.exec(source)) {\r\n      buf.push(match);\r\n      if (match[1]) return buf;\r\n    }\r\n  }\r\n\r\n  var XMLReader_1 = XMLReader$1;\r\n  var ParseError_1 = ParseError$1;\r\n  var sax = {\r\n    XMLReader: XMLReader_1,\r\n    ParseError: ParseError_1\r\n  };\r\n\r\n  var DOMImplementation = dom.DOMImplementation;\r\n  var NAMESPACE = conventions.NAMESPACE;\r\n  var ParseError = sax.ParseError;\r\n  var XMLReader = sax.XMLReader;\r\n\r\n  function DOMParser$1(options) {\r\n    this.options = options || {\r\n      locator: {}\r\n    };\r\n  }\r\n\r\n  DOMParser$1.prototype.parseFromString = function (source, mimeType) {\r\n    var options = this.options;\r\n    var sax = new XMLReader();\r\n    var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\r\n\r\n    var errorHandler = options.errorHandler;\r\n    var locator = options.locator;\r\n    var defaultNSMap = options.xmlns || {};\r\n    var isHTML = /\\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;\r\n\r\n    var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;\r\n\r\n    if (locator) {\r\n      domBuilder.setDocumentLocator(locator);\r\n    }\r\n\r\n    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\r\n    sax.domBuilder = options.domBuilder || domBuilder;\r\n\r\n    if (isHTML) {\r\n      defaultNSMap[''] = NAMESPACE.HTML;\r\n    }\r\n\r\n    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\r\n\r\n    if (source && typeof source === 'string') {\r\n      sax.parse(source, defaultNSMap, entityMap);\r\n    } else {\r\n      sax.errorHandler.error(\"invalid doc source\");\r\n    }\r\n\r\n    return domBuilder.doc;\r\n  };\r\n\r\n  function buildErrorHandler(errorImpl, domBuilder, locator) {\r\n    if (!errorImpl) {\r\n      if (domBuilder instanceof DOMHandler) {\r\n        return domBuilder;\r\n      }\r\n\r\n      errorImpl = domBuilder;\r\n    }\r\n\r\n    var errorHandler = {};\r\n    var isCallback = errorImpl instanceof Function;\r\n    locator = locator || {};\r\n\r\n    function build(key) {\r\n      var fn = errorImpl[key];\r\n\r\n      if (!fn && isCallback) {\r\n        fn = errorImpl.length == 2 ? function (msg) {\r\n          errorImpl(key, msg);\r\n        } : errorImpl;\r\n      }\r\n\r\n      errorHandler[key] = fn && function (msg) {\r\n        fn('[xmldom ' + key + ']\\t' + msg + _locator(locator));\r\n      } || function () {};\r\n    }\r\n\r\n    build('warning');\r\n    build('error');\r\n    build('fatalError');\r\n    return errorHandler;\r\n  } //console.log('#\\n\\n\\n\\n\\n\\n\\n####')\r\n\r\n  /**\r\n   * +ContentHandler+ErrorHandler\r\n   * +LexicalHandler+EntityResolver2\r\n   * -DeclHandler-DTDHandler\r\n   *\r\n   * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\r\n   * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\r\n   */\r\n\r\n\r\n  function DOMHandler() {\r\n    this.cdata = false;\r\n  }\r\n\r\n  function position(locator, node) {\r\n    node.lineNumber = locator.lineNumber;\r\n    node.columnNumber = locator.columnNumber;\r\n  }\r\n  /**\r\n   * @see org.xml.sax.ContentHandler#startDocument\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\r\n   */\r\n\r\n\r\n  DOMHandler.prototype = {\r\n    startDocument: function startDocument() {\r\n      this.doc = new DOMImplementation().createDocument(null, null, null);\r\n\r\n      if (this.locator) {\r\n        this.doc.documentURI = this.locator.systemId;\r\n      }\r\n    },\r\n    startElement: function startElement(namespaceURI, localName, qName, attrs) {\r\n      var doc = this.doc;\r\n      var el = doc.createElementNS(namespaceURI, qName || localName);\r\n      var len = attrs.length;\r\n      appendElement(this, el);\r\n      this.currentElement = el;\r\n      this.locator && position(this.locator, el);\r\n\r\n      for (var i = 0; i < len; i++) {\r\n        var namespaceURI = attrs.getURI(i);\r\n        var value = attrs.getValue(i);\r\n        var qName = attrs.getQName(i);\r\n        var attr = doc.createAttributeNS(namespaceURI, qName);\r\n        this.locator && position(attrs.getLocator(i), attr);\r\n        attr.value = attr.nodeValue = value;\r\n        el.setAttributeNode(attr);\r\n      }\r\n    },\r\n    endElement: function endElement(namespaceURI, localName, qName) {\r\n      var current = this.currentElement;\r\n      current.tagName;\r\n      this.currentElement = current.parentNode;\r\n    },\r\n    startPrefixMapping: function startPrefixMapping(prefix, uri) {},\r\n    endPrefixMapping: function endPrefixMapping(prefix) {},\r\n    processingInstruction: function processingInstruction(target, data) {\r\n      var ins = this.doc.createProcessingInstruction(target, data);\r\n      this.locator && position(this.locator, ins);\r\n      appendElement(this, ins);\r\n    },\r\n    ignorableWhitespace: function ignorableWhitespace(ch, start, length) {},\r\n    characters: function characters(chars, start, length) {\r\n      chars = _toString.apply(this, arguments); //console.log(chars)\r\n\r\n      if (chars) {\r\n        if (this.cdata) {\r\n          var charNode = this.doc.createCDATASection(chars);\r\n        } else {\r\n          var charNode = this.doc.createTextNode(chars);\r\n        }\r\n\r\n        if (this.currentElement) {\r\n          this.currentElement.appendChild(charNode);\r\n        } else if (/^\\s*$/.test(chars)) {\r\n          this.doc.appendChild(charNode); //process xml\r\n        }\r\n\r\n        this.locator && position(this.locator, charNode);\r\n      }\r\n    },\r\n    skippedEntity: function skippedEntity(name) {},\r\n    endDocument: function endDocument() {\r\n      this.doc.normalize();\r\n    },\r\n    setDocumentLocator: function setDocumentLocator(locator) {\r\n      if (this.locator = locator) {\r\n        // && !('lineNumber' in locator)){\r\n        locator.lineNumber = 0;\r\n      }\r\n    },\r\n    //LexicalHandler\r\n    comment: function comment(chars, start, length) {\r\n      chars = _toString.apply(this, arguments);\r\n      var comm = this.doc.createComment(chars);\r\n      this.locator && position(this.locator, comm);\r\n      appendElement(this, comm);\r\n    },\r\n    startCDATA: function startCDATA() {\r\n      //used in characters() methods\r\n      this.cdata = true;\r\n    },\r\n    endCDATA: function endCDATA() {\r\n      this.cdata = false;\r\n    },\r\n    startDTD: function startDTD(name, publicId, systemId) {\r\n      var impl = this.doc.implementation;\r\n\r\n      if (impl && impl.createDocumentType) {\r\n        var dt = impl.createDocumentType(name, publicId, systemId);\r\n        this.locator && position(this.locator, dt);\r\n        appendElement(this, dt);\r\n        this.doc.doctype = dt;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @see org.xml.sax.ErrorHandler\r\n     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\r\n     */\r\n    warning: function warning(error) {\r\n      console.warn('[xmldom warning]\\t' + error, _locator(this.locator));\r\n    },\r\n    error: function error(_error) {\r\n      console.error('[xmldom error]\\t' + _error, _locator(this.locator));\r\n    },\r\n    fatalError: function fatalError(error) {\r\n      throw new ParseError(error, this.locator);\r\n    }\r\n  };\r\n\r\n  function _locator(l) {\r\n    if (l) {\r\n      return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\r\n    }\r\n  }\r\n\r\n  function _toString(chars, start, length) {\r\n    if (typeof chars == 'string') {\r\n      return chars.substr(start, length);\r\n    } else {\r\n      //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\r\n      if (chars.length >= start + length || start) {\r\n        return new java.lang.String(chars, start, length) + '';\r\n      }\r\n\r\n      return chars;\r\n    }\r\n  }\r\n  /*\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\r\n   * used method of org.xml.sax.ext.LexicalHandler:\r\n   *  #comment(chars, start, length)\r\n   *  #startCDATA()\r\n   *  #endCDATA()\r\n   *  #startDTD(name, publicId, systemId)\r\n   *\r\n   *\r\n   * IGNORED method of org.xml.sax.ext.LexicalHandler:\r\n   *  #endDTD()\r\n   *  #startEntity(name)\r\n   *  #endEntity(name)\r\n   *\r\n   *\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\r\n   * IGNORED method of org.xml.sax.ext.DeclHandler\r\n   * \t#attributeDecl(eName, aName, type, mode, value)\r\n   *  #elementDecl(name, model)\r\n   *  #externalEntityDecl(name, publicId, systemId)\r\n   *  #internalEntityDecl(name, value)\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\r\n   * IGNORED method of org.xml.sax.EntityResolver2\r\n   *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\r\n   *  #resolveEntity(publicId, systemId)\r\n   *  #getExternalSubset(name, baseURI)\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\r\n   * IGNORED method of org.xml.sax.DTDHandler\r\n   *  #notationDecl(name, publicId, systemId) {};\r\n   *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\r\n   */\r\n\r\n\r\n  \"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\r\n    DOMHandler.prototype[key] = function () {\r\n      return null;\r\n    };\r\n  });\r\n  /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\r\n\r\n  function appendElement(hander, node) {\r\n    if (!hander.currentElement) {\r\n      hander.doc.appendChild(node);\r\n    } else {\r\n      hander.currentElement.appendChild(node);\r\n    }\r\n  } //appendChild and setAttributeNS are preformance key\r\n\r\n\r\n  var __DOMHandler = DOMHandler;\r\n  var DOMParser_1 = DOMParser$1;\r\n  /**\r\n   * @deprecated Import/require from main entry point instead\r\n   */\r\n\r\n  var DOMImplementation_1 = dom.DOMImplementation;\r\n  /**\r\n   * @deprecated Import/require from main entry point instead\r\n   */\r\n\r\n  var XMLSerializer = dom.XMLSerializer;\r\n  var domParser = {\r\n    __DOMHandler: __DOMHandler,\r\n    DOMParser: DOMParser_1,\r\n    DOMImplementation: DOMImplementation_1,\r\n    XMLSerializer: XMLSerializer\r\n  };\r\n\r\n  var DOMParser = domParser.DOMParser;\r\n\r\n  /*! @name mpd-parser @version 0.21.1 @license Apache-2.0 */\r\n\r\n  var isObject = function isObject(obj) {\r\n    return !!obj && typeof obj === 'object';\r\n  };\r\n\r\n  var merge = function merge() {\r\n    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      objects[_key] = arguments[_key];\r\n    }\r\n\r\n    return objects.reduce(function (result, source) {\r\n      if (typeof source !== 'object') {\r\n        return result;\r\n      }\r\n\r\n      Object.keys(source).forEach(function (key) {\r\n        if (Array.isArray(result[key]) && Array.isArray(source[key])) {\r\n          result[key] = result[key].concat(source[key]);\r\n        } else if (isObject(result[key]) && isObject(source[key])) {\r\n          result[key] = merge(result[key], source[key]);\r\n        } else {\r\n          result[key] = source[key];\r\n        }\r\n      });\r\n      return result;\r\n    }, {});\r\n  };\r\n\r\n  var values = function values(o) {\r\n    return Object.keys(o).map(function (k) {\r\n      return o[k];\r\n    });\r\n  };\r\n\r\n  var range = function range(start, end) {\r\n    var result = [];\r\n\r\n    for (var i = start; i < end; i++) {\r\n      result.push(i);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var flatten = function flatten(lists) {\r\n    return lists.reduce(function (x, y) {\r\n      return x.concat(y);\r\n    }, []);\r\n  };\r\n\r\n  var from = function from(list) {\r\n    if (!list.length) {\r\n      return [];\r\n    }\r\n\r\n    var result = [];\r\n\r\n    for (var i = 0; i < list.length; i++) {\r\n      result.push(list[i]);\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var findIndexes = function findIndexes(l, key) {\r\n    return l.reduce(function (a, e, i) {\r\n      if (e[key]) {\r\n        a.push(i);\r\n      }\r\n\r\n      return a;\r\n    }, []);\r\n  };\r\n  /**\r\n   * Returns the first index that satisfies the matching function, or -1 if not found.\r\n   *\r\n   * Only necessary because of IE11 support.\r\n   *\r\n   * @param {Array} list - the list to search through\r\n   * @param {Function} matchingFunction - the matching function\r\n   *\r\n   * @return {number} the matching index or -1 if not found\r\n   */\r\n\r\n\r\n  var findIndex = function findIndex(list, matchingFunction) {\r\n    for (var i = 0; i < list.length; i++) {\r\n      if (matchingFunction(list[i])) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  };\r\n  /**\r\n   * Returns a union of the included lists provided each element can be identified by a key.\r\n   *\r\n   * @param {Array} list - list of lists to get the union of\r\n   * @param {Function} keyFunction - the function to use as a key for each element\r\n   *\r\n   * @return {Array} the union of the arrays\r\n   */\r\n\r\n\r\n  var union = function union(lists, keyFunction) {\r\n    return values(lists.reduce(function (acc, list) {\r\n      list.forEach(function (el) {\r\n        acc[keyFunction(el)] = el;\r\n      });\r\n      return acc;\r\n    }, {}));\r\n  };\r\n\r\n  var errors = {\r\n    INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\r\n    DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\r\n    DASH_INVALID_XML: 'DASH_INVALID_XML',\r\n    NO_BASE_URL: 'NO_BASE_URL',\r\n    MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\r\n    SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\r\n    UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\r\n  };\r\n  /**\r\n   * @typedef {Object} SingleUri\r\n   * @property {string} uri - relative location of segment\r\n   * @property {string} resolvedUri - resolved location of segment\r\n   * @property {Object} byterange - Object containing information on how to make byte range\r\n   *   requests following byte-range-spec per RFC2616.\r\n   * @property {String} byterange.length - length of range request\r\n   * @property {String} byterange.offset - byte offset of range request\r\n   *\r\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\r\n   */\r\n\r\n  /**\r\n   * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\r\n   * that conforms to how m3u8-parser is structured\r\n   *\r\n   * @see https://github.com/videojs/m3u8-parser\r\n   *\r\n   * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\r\n   * @param {string} source - source url for segment\r\n   * @param {string} range - optional range used for range calls,\r\n   *   follows  RFC 2616, Clause 14.35.1\r\n   * @return {SingleUri} full segment information transformed into a format similar\r\n   *   to m3u8-parser\r\n   */\r\n\r\n  var urlTypeToSegment = function urlTypeToSegment(_ref) {\r\n    var _ref$baseUrl = _ref.baseUrl,\r\n        baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\r\n        _ref$source = _ref.source,\r\n        source = _ref$source === void 0 ? '' : _ref$source,\r\n        _ref$range = _ref.range,\r\n        range = _ref$range === void 0 ? '' : _ref$range,\r\n        _ref$indexRange = _ref.indexRange,\r\n        indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;\r\n    var segment = {\r\n      uri: source,\r\n      resolvedUri: resolveUrl$1(baseUrl || '', source)\r\n    };\r\n\r\n    if (range || indexRange) {\r\n      var rangeStr = range ? range : indexRange;\r\n      var ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\r\n\r\n      var startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\r\n      var endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\r\n\r\n      if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\r\n        startRange = Number(startRange);\r\n      }\r\n\r\n      if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\r\n        endRange = Number(endRange);\r\n      }\r\n\r\n      var length;\r\n\r\n      if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\r\n        length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\r\n      } else {\r\n        length = endRange - startRange + 1;\r\n      }\r\n\r\n      if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\r\n        length = Number(length);\r\n      } // byterange should be inclusive according to\r\n      // RFC 2616, Clause 14.35.1\r\n\r\n\r\n      segment.byterange = {\r\n        length: length,\r\n        offset: startRange\r\n      };\r\n    }\r\n\r\n    return segment;\r\n  };\r\n\r\n  var byteRangeToString = function byteRangeToString(byterange) {\r\n    // `endRange` is one less than `offset + length` because the HTTP range\r\n    // header uses inclusive ranges\r\n    var endRange;\r\n\r\n    if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\r\n      endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\r\n    } else {\r\n      endRange = byterange.offset + byterange.length - 1;\r\n    }\r\n\r\n    return byterange.offset + \"-\" + endRange;\r\n  };\r\n  /**\r\n   * parse the end number attribue that can be a string\r\n   * number, or undefined.\r\n   *\r\n   * @param {string|number|undefined} endNumber\r\n   *        The end number attribute.\r\n   *\r\n   * @return {number|null}\r\n   *          The result of parsing the end number.\r\n   */\r\n\r\n\r\n  var parseEndNumber = function parseEndNumber(endNumber) {\r\n    if (endNumber && typeof endNumber !== 'number') {\r\n      endNumber = parseInt(endNumber, 10);\r\n    }\r\n\r\n    if (isNaN(endNumber)) {\r\n      return null;\r\n    }\r\n\r\n    return endNumber;\r\n  };\r\n  /**\r\n   * Functions for calculating the range of available segments in static and dynamic\r\n   * manifests.\r\n   */\r\n\r\n\r\n  var segmentRange = {\r\n    /**\r\n     * Returns the entire range of available segments for a static MPD\r\n     *\r\n     * @param {Object} attributes\r\n     *        Inheritied MPD attributes\r\n     * @return {{ start: number, end: number }}\r\n     *         The start and end numbers for available segments\r\n     */\r\n    \"static\": function _static(attributes) {\r\n      var duration = attributes.duration,\r\n          _attributes$timescale = attributes.timescale,\r\n          timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\r\n          sourceDuration = attributes.sourceDuration,\r\n          periodDuration = attributes.periodDuration;\r\n      var endNumber = parseEndNumber(attributes.endNumber);\r\n      var segmentDuration = duration / timescale;\r\n\r\n      if (typeof endNumber === 'number') {\r\n        return {\r\n          start: 0,\r\n          end: endNumber\r\n        };\r\n      }\r\n\r\n      if (typeof periodDuration === 'number') {\r\n        return {\r\n          start: 0,\r\n          end: periodDuration / segmentDuration\r\n        };\r\n      }\r\n\r\n      return {\r\n        start: 0,\r\n        end: sourceDuration / segmentDuration\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns the current live window range of available segments for a dynamic MPD\r\n     *\r\n     * @param {Object} attributes\r\n     *        Inheritied MPD attributes\r\n     * @return {{ start: number, end: number }}\r\n     *         The start and end numbers for available segments\r\n     */\r\n    dynamic: function dynamic(attributes) {\r\n      var NOW = attributes.NOW,\r\n          clientOffset = attributes.clientOffset,\r\n          availabilityStartTime = attributes.availabilityStartTime,\r\n          _attributes$timescale2 = attributes.timescale,\r\n          timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\r\n          duration = attributes.duration,\r\n          _attributes$periodSta = attributes.periodStart,\r\n          periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\r\n          _attributes$minimumUp = attributes.minimumUpdatePeriod,\r\n          minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\r\n          _attributes$timeShift = attributes.timeShiftBufferDepth,\r\n          timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\r\n      var endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\r\n      // after retrieving UTC server time.\r\n\r\n      var now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\r\n      // Convert the period start time to EPOCH.\r\n\r\n      var periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\r\n\r\n      var periodEndWC = now + minimumUpdatePeriod;\r\n      var periodDuration = periodEndWC - periodStartWC;\r\n      var segmentCount = Math.ceil(periodDuration * timescale / duration);\r\n      var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\r\n      var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\r\n      return {\r\n        start: Math.max(0, availableStart),\r\n        end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\r\n      };\r\n    }\r\n  };\r\n  /**\r\n   * Maps a range of numbers to objects with information needed to build the corresponding\r\n   * segment list\r\n   *\r\n   * @name toSegmentsCallback\r\n   * @function\r\n   * @param {number} number\r\n   *        Number of the segment\r\n   * @param {number} index\r\n   *        Index of the number in the range list\r\n   * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\r\n   *         Object with segment timing and duration info\r\n   */\r\n\r\n  /**\r\n   * Returns a callback for Array.prototype.map for mapping a range of numbers to\r\n   * information needed to build the segment list.\r\n   *\r\n   * @param {Object} attributes\r\n   *        Inherited MPD attributes\r\n   * @return {toSegmentsCallback}\r\n   *         Callback map function\r\n   */\r\n\r\n  var toSegments = function toSegments(attributes) {\r\n    return function (number) {\r\n      var duration = attributes.duration,\r\n          _attributes$timescale3 = attributes.timescale,\r\n          timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\r\n          periodStart = attributes.periodStart,\r\n          _attributes$startNumb = attributes.startNumber,\r\n          startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\r\n      return {\r\n        number: startNumber + number,\r\n        duration: duration / timescale,\r\n        timeline: periodStart,\r\n        time: number * duration\r\n      };\r\n    };\r\n  };\r\n  /**\r\n   * Returns a list of objects containing segment timing and duration info used for\r\n   * building the list of segments. This uses the @duration attribute specified\r\n   * in the MPD manifest to derive the range of segments.\r\n   *\r\n   * @param {Object} attributes\r\n   *        Inherited MPD attributes\r\n   * @return {{number: number, duration: number, time: number, timeline: number}[]}\r\n   *         List of Objects with segment timing and duration info\r\n   */\r\n\r\n\r\n  var parseByDuration = function parseByDuration(attributes) {\r\n    var type = attributes.type,\r\n        duration = attributes.duration,\r\n        _attributes$timescale4 = attributes.timescale,\r\n        timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\r\n        periodDuration = attributes.periodDuration,\r\n        sourceDuration = attributes.sourceDuration;\r\n\r\n    var _segmentRange$type = segmentRange[type](attributes),\r\n        start = _segmentRange$type.start,\r\n        end = _segmentRange$type.end;\r\n\r\n    var segments = range(start, end).map(toSegments(attributes));\r\n\r\n    if (type === 'static') {\r\n      var index = segments.length - 1; // section is either a period or the full source\r\n\r\n      var sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\r\n\r\n      segments[index].duration = sectionDuration - duration / timescale * index;\r\n    }\r\n\r\n    return segments;\r\n  };\r\n  /**\r\n   * Translates SegmentBase into a set of segments.\r\n   * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\r\n   * node should be translated into segment.\r\n   *\r\n   * @param {Object} attributes\r\n   *   Object containing all inherited attributes from parent elements with attribute\r\n   *   names as keys\r\n   * @return {Object.<Array>} list of segments\r\n   */\r\n\r\n\r\n  var segmentsFromBase = function segmentsFromBase(attributes) {\r\n    var baseUrl = attributes.baseUrl,\r\n        _attributes$initializ = attributes.initialization,\r\n        initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\r\n        sourceDuration = attributes.sourceDuration,\r\n        _attributes$indexRang = attributes.indexRange,\r\n        indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\r\n        periodStart = attributes.periodStart,\r\n        presentationTime = attributes.presentationTime,\r\n        _attributes$number = attributes.number,\r\n        number = _attributes$number === void 0 ? 0 : _attributes$number,\r\n        duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\r\n\r\n    if (!baseUrl) {\r\n      throw new Error(errors.NO_BASE_URL);\r\n    }\r\n\r\n    var initSegment = urlTypeToSegment({\r\n      baseUrl: baseUrl,\r\n      source: initialization.sourceURL,\r\n      range: initialization.range\r\n    });\r\n    var segment = urlTypeToSegment({\r\n      baseUrl: baseUrl,\r\n      source: baseUrl,\r\n      indexRange: indexRange\r\n    });\r\n    segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\r\n    // (since SegmentBase is only for one total segment)\r\n\r\n    if (duration) {\r\n      var segmentTimeInfo = parseByDuration(attributes);\r\n\r\n      if (segmentTimeInfo.length) {\r\n        segment.duration = segmentTimeInfo[0].duration;\r\n        segment.timeline = segmentTimeInfo[0].timeline;\r\n      }\r\n    } else if (sourceDuration) {\r\n      segment.duration = sourceDuration;\r\n      segment.timeline = periodStart;\r\n    } // If presentation time is provided, these segments are being generated by SIDX\r\n    // references, and should use the time provided. For the general case of SegmentBase,\r\n    // there should only be one segment in the period, so its presentation time is the same\r\n    // as its period start.\r\n\r\n\r\n    segment.presentationTime = presentationTime || periodStart;\r\n    segment.number = number;\r\n    return [segment];\r\n  };\r\n  /**\r\n   * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\r\n   * according to the sidx information given.\r\n   *\r\n   * playlist.sidx has metadadata about the sidx where-as the sidx param\r\n   * is the parsed sidx box itself.\r\n   *\r\n   * @param {Object} playlist the playlist to update the sidx information for\r\n   * @param {Object} sidx the parsed sidx box\r\n   * @return {Object} the playlist object with the updated sidx information\r\n   */\r\n\r\n\r\n  var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {\r\n    // Retain init segment information\r\n    var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\r\n\r\n    var sourceDuration = playlist.sidx.duration; // Retain source timeline\r\n\r\n    var timeline = playlist.timeline || 0;\r\n    var sidxByteRange = playlist.sidx.byterange;\r\n    var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\r\n\r\n    var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\r\n\r\n    var mediaReferences = sidx.references.filter(function (r) {\r\n      return r.referenceType !== 1;\r\n    });\r\n    var segments = [];\r\n    var type = playlist.endList ? 'static' : 'dynamic';\r\n    var periodStart = playlist.sidx.timeline;\r\n    var presentationTime = periodStart;\r\n    var number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\r\n\r\n    var startIndex; // eslint-disable-next-line\r\n\r\n    if (typeof sidx.firstOffset === 'bigint') {\r\n      startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\r\n    } else {\r\n      startIndex = sidxEnd + sidx.firstOffset;\r\n    }\r\n\r\n    for (var i = 0; i < mediaReferences.length; i++) {\r\n      var reference = sidx.references[i]; // size of the referenced (sub)segment\r\n\r\n      var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\r\n      // this will be converted to seconds when generating segments\r\n\r\n      var duration = reference.subsegmentDuration; // should be an inclusive range\r\n\r\n      var endIndex = void 0; // eslint-disable-next-line\r\n\r\n      if (typeof startIndex === 'bigint') {\r\n        endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\r\n      } else {\r\n        endIndex = startIndex + size - 1;\r\n      }\r\n\r\n      var indexRange = startIndex + \"-\" + endIndex;\r\n      var attributes = {\r\n        baseUrl: baseUrl,\r\n        timescale: timescale,\r\n        timeline: timeline,\r\n        periodStart: periodStart,\r\n        presentationTime: presentationTime,\r\n        number: number,\r\n        duration: duration,\r\n        sourceDuration: sourceDuration,\r\n        indexRange: indexRange,\r\n        type: type\r\n      };\r\n      var segment = segmentsFromBase(attributes)[0];\r\n\r\n      if (initSegment) {\r\n        segment.map = initSegment;\r\n      }\r\n\r\n      segments.push(segment);\r\n\r\n      if (typeof startIndex === 'bigint') {\r\n        startIndex += window.BigInt(size);\r\n      } else {\r\n        startIndex += size;\r\n      }\r\n\r\n      presentationTime += duration / timescale;\r\n      number++;\r\n    }\r\n\r\n    playlist.segments = segments;\r\n    return playlist;\r\n  };\r\n\r\n  var SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\r\n\r\n  var TIME_FUDGE = 1 / 60;\r\n  /**\r\n   * Given a list of timelineStarts, combines, dedupes, and sorts them.\r\n   *\r\n   * @param {TimelineStart[]} timelineStarts - list of timeline starts\r\n   *\r\n   * @return {TimelineStart[]} the combined and deduped timeline starts\r\n   */\r\n\r\n  var getUniqueTimelineStarts = function getUniqueTimelineStarts(timelineStarts) {\r\n    return union(timelineStarts, function (_ref) {\r\n      var timeline = _ref.timeline;\r\n      return timeline;\r\n    }).sort(function (a, b) {\r\n      return a.timeline > b.timeline ? 1 : -1;\r\n    });\r\n  };\r\n  /**\r\n   * Finds the playlist with the matching NAME attribute.\r\n   *\r\n   * @param {Array} playlists - playlists to search through\r\n   * @param {string} name - the NAME attribute to search for\r\n   *\r\n   * @return {Object|null} the matching playlist object, or null\r\n   */\r\n\r\n\r\n  var findPlaylistWithName = function findPlaylistWithName(playlists, name) {\r\n    for (var i = 0; i < playlists.length; i++) {\r\n      if (playlists[i].attributes.NAME === name) {\r\n        return playlists[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n  /**\r\n   * Gets a flattened array of media group playlists.\r\n   *\r\n   * @param {Object} manifest - the main manifest object\r\n   *\r\n   * @return {Array} the media group playlists\r\n   */\r\n\r\n\r\n  var getMediaGroupPlaylists = function getMediaGroupPlaylists(manifest) {\r\n    var mediaGroupPlaylists = [];\r\n    forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, function (properties, type, group, label) {\r\n      mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\r\n    });\r\n    return mediaGroupPlaylists;\r\n  };\r\n  /**\r\n   * Updates the playlist's media sequence numbers.\r\n   *\r\n   * @param {Object} config - options object\r\n   * @param {Object} config.playlist - the playlist to update\r\n   * @param {number} config.mediaSequence - the mediaSequence number to start with\r\n   */\r\n\r\n\r\n  var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist(_ref2) {\r\n    var playlist = _ref2.playlist,\r\n        mediaSequence = _ref2.mediaSequence;\r\n    playlist.mediaSequence = mediaSequence;\r\n    playlist.segments.forEach(function (segment, index) {\r\n      segment.number = playlist.mediaSequence + index;\r\n    });\r\n  };\r\n  /**\r\n   * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\r\n   * and a complete list of timeline starts.\r\n   *\r\n   * If no matching playlist is found, only the discontinuity sequence number of the playlist\r\n   * will be updated.\r\n   *\r\n   * Since early available timelines are not supported, at least one segment must be present.\r\n   *\r\n   * @param {Object} config - options object\r\n   * @param {Object[]} oldPlaylists - the old playlists to use as a reference\r\n   * @param {Object[]} newPlaylists - the new playlists to update\r\n   * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\r\n   */\r\n\r\n\r\n  var updateSequenceNumbers = function updateSequenceNumbers(_ref3) {\r\n    var oldPlaylists = _ref3.oldPlaylists,\r\n        newPlaylists = _ref3.newPlaylists,\r\n        timelineStarts = _ref3.timelineStarts;\r\n    newPlaylists.forEach(function (playlist) {\r\n      playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref4) {\r\n        var timeline = _ref4.timeline;\r\n        return timeline === playlist.timeline;\r\n      }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\r\n      // (see ISO_23009-1-2012 5.3.5.2).\r\n      //\r\n      // If the same Representation existed in a prior Period, it will retain the same NAME.\r\n\r\n      var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\r\n\r\n      if (!oldPlaylist) {\r\n        // Since this is a new playlist, the media sequence values can start from 0 without\r\n        // consequence.\r\n        return;\r\n      } // TODO better support for live SIDX\r\n      //\r\n      // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\r\n      // This is evident by a playlist only having a single SIDX reference. In a multiperiod\r\n      // playlist there would need to be multiple SIDX references. In addition, live SIDX is\r\n      // not supported when the SIDX properties change on refreshes.\r\n      //\r\n      // In the future, if support needs to be added, the merging logic here can be called\r\n      // after SIDX references are resolved. For now, exit early to prevent exceptions being\r\n      // thrown due to undefined references.\r\n\r\n\r\n      if (playlist.sidx) {\r\n        return;\r\n      } // Since we don't yet support early available timelines, we don't need to support\r\n      // playlists with no segments.\r\n\r\n\r\n      var firstNewSegment = playlist.segments[0];\r\n      var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function (oldSegment) {\r\n        return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\r\n      }); // No matching segment from the old playlist means the entire playlist was refreshed.\r\n      // In this case the media sequence should account for this update, and the new segments\r\n      // should be marked as discontinuous from the prior content, since the last prior\r\n      // timeline was removed.\r\n\r\n      if (oldMatchingSegmentIndex === -1) {\r\n        updateMediaSequenceForPlaylist({\r\n          playlist: playlist,\r\n          mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\r\n        });\r\n        playlist.segments[0].discontinuity = true;\r\n        playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\r\n        //\r\n        // If the new playlist's timeline is the same as the last seen segment's timeline,\r\n        // then a discontinuity can be added to identify that there's potentially missing\r\n        // content. If there's no missing content, the discontinuity should still be rather\r\n        // harmless. It's possible that if segment durations are accurate enough, that the\r\n        // existence of a gap can be determined using the presentation times and durations,\r\n        // but if the segment timing info is off, it may introduce more problems than simply\r\n        // adding the discontinuity.\r\n        //\r\n        // If the new playlist's timeline is different from the last seen segment's timeline,\r\n        // then a discontinuity can be added to identify that this is the first seen segment\r\n        // of a new timeline. However, the logic at the start of this function that\r\n        // determined the disconinuity sequence by timeline index is now off by one (the\r\n        // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\r\n        // we added it), so the disconinuity sequence must be decremented.\r\n        //\r\n        // A period may also have a duration of zero, so the case of no segments is handled\r\n        // here even though we don't yet support early available periods.\r\n\r\n        if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\r\n          playlist.discontinuitySequence--;\r\n        }\r\n\r\n        return;\r\n      } // If the first segment matched with a prior segment on a discontinuity (it's matching\r\n      // on the first segment of a period), then the discontinuitySequence shouldn't be the\r\n      // timeline's matching one, but instead should be the one prior, and the first segment\r\n      // of the new manifest should be marked with a discontinuity.\r\n      //\r\n      // The reason for this special case is that discontinuity sequence shows how many\r\n      // discontinuities have fallen off of the playlist, and discontinuities are marked on\r\n      // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\r\n      // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\r\n      // sequence, and that first segment is an indicator, but can be removed before that\r\n      // timeline is gone.\r\n\r\n\r\n      var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\r\n\r\n      if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\r\n        firstNewSegment.discontinuity = true;\r\n        playlist.discontinuityStarts.unshift(0);\r\n        playlist.discontinuitySequence--;\r\n      }\r\n\r\n      updateMediaSequenceForPlaylist({\r\n        playlist: playlist,\r\n        mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * Given an old parsed manifest object and a new parsed manifest object, updates the\r\n   * sequence and timing values within the new manifest to ensure that it lines up with the\r\n   * old.\r\n   *\r\n   * @param {Array} oldManifest - the old main manifest object\r\n   * @param {Array} newManifest - the new main manifest object\r\n   *\r\n   * @return {Object} the updated new manifest object\r\n   */\r\n\r\n\r\n  var positionManifestOnTimeline = function positionManifestOnTimeline(_ref5) {\r\n    var oldManifest = _ref5.oldManifest,\r\n        newManifest = _ref5.newManifest; // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\r\n    //\r\n    // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\r\n    //\r\n    // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\r\n    //\r\n    // Because of this change, and the difficulty of supporting periods with changing start\r\n    // times, periods with changing start times are not supported. This makes the logic much\r\n    // simpler, since periods with the same start time can be considerred the same period\r\n    // across refreshes.\r\n    //\r\n    // To give an example as to the difficulty of handling periods where the start time may\r\n    // change, if a single period manifest is refreshed with another manifest with a single\r\n    // period, and both the start and end times are increased, then the only way to determine\r\n    // if it's a new period or an old one that has changed is to look through the segments of\r\n    // each playlist and determine the presentation time bounds to find a match. In addition,\r\n    // if the period start changed to exceed the old period end, then there would be no\r\n    // match, and it would not be possible to determine whether the refreshed period is a new\r\n    // one or the old one.\r\n\r\n    var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\r\n    var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\r\n    // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\r\n    // of properties are saved for each seen Period. Even long running live streams won't\r\n    // generate too many Periods, unless the stream is watched for decades. In the future,\r\n    // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\r\n    // but it may not become an issue, and the additional info can be useful for debugging.\r\n\r\n    newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\r\n    updateSequenceNumbers({\r\n      oldPlaylists: oldPlaylists,\r\n      newPlaylists: newPlaylists,\r\n      timelineStarts: newManifest.timelineStarts\r\n    });\r\n    return newManifest;\r\n  };\r\n\r\n  var generateSidxKey = function generateSidxKey(sidx) {\r\n    return sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\r\n  };\r\n\r\n  var mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\r\n    var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\r\n      // assuming playlist IDs are the same across periods\r\n      // TODO: handle multiperiod where representation sets are not the same\r\n      // across periods\r\n      var name = playlist.attributes.id + (playlist.attributes.lang || '');\r\n\r\n      if (!acc[name]) {\r\n        // First Period\r\n        acc[name] = playlist;\r\n        acc[name].attributes.timelineStarts = [];\r\n      } else {\r\n        // Subsequent Periods\r\n        if (playlist.segments) {\r\n          var _acc$name$segments; // first segment of subsequent periods signal a discontinuity\r\n\r\n\r\n          if (playlist.segments[0]) {\r\n            playlist.segments[0].discontinuity = true;\r\n          }\r\n\r\n          (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);\r\n        } // bubble up contentProtection, this assumes all DRM content\r\n        // has the same contentProtection\r\n\r\n\r\n        if (playlist.attributes.contentProtection) {\r\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\r\n        }\r\n      }\r\n\r\n      acc[name].attributes.timelineStarts.push({\r\n        // Although they represent the same number, it's important to have both to make it\r\n        // compatible with HLS potentially having a similar attribute.\r\n        start: playlist.attributes.periodStart,\r\n        timeline: playlist.attributes.periodStart\r\n      });\r\n      return acc;\r\n    }, {}));\r\n    return mergedPlaylists.map(function (playlist) {\r\n      playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\r\n      return playlist;\r\n    });\r\n  };\r\n\r\n  var addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist(playlist, sidxMapping) {\r\n    var sidxKey = generateSidxKey(playlist.sidx);\r\n    var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\r\n\r\n    if (sidxMatch) {\r\n      addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\r\n    }\r\n\r\n    return playlist;\r\n  };\r\n\r\n  var addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists(playlists, sidxMapping) {\r\n    if (sidxMapping === void 0) {\r\n      sidxMapping = {};\r\n    }\r\n\r\n    if (!Object.keys(sidxMapping).length) {\r\n      return playlists;\r\n    }\r\n\r\n    for (var i in playlists) {\r\n      playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\r\n    }\r\n\r\n    return playlists;\r\n  };\r\n\r\n  var formatAudioPlaylist = function formatAudioPlaylist(_ref, isAudioOnly) {\r\n    var _attributes;\r\n\r\n    var attributes = _ref.attributes,\r\n        segments = _ref.segments,\r\n        sidx = _ref.sidx,\r\n        mediaSequence = _ref.mediaSequence,\r\n        discontinuitySequence = _ref.discontinuitySequence,\r\n        discontinuityStarts = _ref.discontinuityStarts;\r\n    var playlist = {\r\n      attributes: (_attributes = {\r\n        NAME: attributes.id,\r\n        BANDWIDTH: attributes.bandwidth,\r\n        CODECS: attributes.codecs\r\n      }, _attributes['PROGRAM-ID'] = 1, _attributes),\r\n      uri: '',\r\n      endList: attributes.type === 'static',\r\n      timeline: attributes.periodStart,\r\n      resolvedUri: '',\r\n      targetDuration: attributes.duration,\r\n      discontinuitySequence: discontinuitySequence,\r\n      discontinuityStarts: discontinuityStarts,\r\n      timelineStarts: attributes.timelineStarts,\r\n      mediaSequence: mediaSequence,\r\n      segments: segments\r\n    };\r\n\r\n    if (attributes.contentProtection) {\r\n      playlist.contentProtection = attributes.contentProtection;\r\n    }\r\n\r\n    if (sidx) {\r\n      playlist.sidx = sidx;\r\n    }\r\n\r\n    if (isAudioOnly) {\r\n      playlist.attributes.AUDIO = 'audio';\r\n      playlist.attributes.SUBTITLES = 'subs';\r\n    }\r\n\r\n    return playlist;\r\n  };\r\n\r\n  var formatVttPlaylist = function formatVttPlaylist(_ref2) {\r\n    var _m3u8Attributes;\r\n\r\n    var attributes = _ref2.attributes,\r\n        segments = _ref2.segments,\r\n        mediaSequence = _ref2.mediaSequence,\r\n        discontinuityStarts = _ref2.discontinuityStarts,\r\n        discontinuitySequence = _ref2.discontinuitySequence;\r\n\r\n    if (typeof segments === 'undefined') {\r\n      // vtt tracks may use single file in BaseURL\r\n      segments = [{\r\n        uri: attributes.baseUrl,\r\n        timeline: attributes.periodStart,\r\n        resolvedUri: attributes.baseUrl || '',\r\n        duration: attributes.sourceDuration,\r\n        number: 0\r\n      }]; // targetDuration should be the same duration as the only segment\r\n\r\n      attributes.duration = attributes.sourceDuration;\r\n    }\r\n\r\n    var m3u8Attributes = (_m3u8Attributes = {\r\n      NAME: attributes.id,\r\n      BANDWIDTH: attributes.bandwidth\r\n    }, _m3u8Attributes['PROGRAM-ID'] = 1, _m3u8Attributes);\r\n\r\n    if (attributes.codecs) {\r\n      m3u8Attributes.CODECS = attributes.codecs;\r\n    }\r\n\r\n    return {\r\n      attributes: m3u8Attributes,\r\n      uri: '',\r\n      endList: attributes.type === 'static',\r\n      timeline: attributes.periodStart,\r\n      resolvedUri: attributes.baseUrl || '',\r\n      targetDuration: attributes.duration,\r\n      timelineStarts: attributes.timelineStarts,\r\n      discontinuityStarts: discontinuityStarts,\r\n      discontinuitySequence: discontinuitySequence,\r\n      mediaSequence: mediaSequence,\r\n      segments: segments\r\n    };\r\n  };\r\n\r\n  var organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping, isAudioOnly) {\r\n    if (sidxMapping === void 0) {\r\n      sidxMapping = {};\r\n    }\r\n\r\n    if (isAudioOnly === void 0) {\r\n      isAudioOnly = false;\r\n    }\r\n\r\n    var mainPlaylist;\r\n    var formattedPlaylists = playlists.reduce(function (a, playlist) {\r\n      var role = playlist.attributes.role && playlist.attributes.role.value || '';\r\n      var language = playlist.attributes.lang || '';\r\n      var label = playlist.attributes.label || 'main';\r\n\r\n      if (language && !playlist.attributes.label) {\r\n        var roleLabel = role ? \" (\" + role + \")\" : '';\r\n        label = \"\" + playlist.attributes.lang + roleLabel;\r\n      }\r\n\r\n      if (!a[label]) {\r\n        a[label] = {\r\n          language: language,\r\n          autoselect: true,\r\n          \"default\": role === 'main',\r\n          playlists: [],\r\n          uri: ''\r\n        };\r\n      }\r\n\r\n      var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\r\n      a[label].playlists.push(formatted);\r\n\r\n      if (typeof mainPlaylist === 'undefined' && role === 'main') {\r\n        mainPlaylist = playlist;\r\n        mainPlaylist[\"default\"] = true;\r\n      }\r\n\r\n      return a;\r\n    }, {}); // if no playlists have role \"main\", mark the first as main\r\n\r\n    if (!mainPlaylist) {\r\n      var firstLabel = Object.keys(formattedPlaylists)[0];\r\n      formattedPlaylists[firstLabel][\"default\"] = true;\r\n    }\r\n\r\n    return formattedPlaylists;\r\n  };\r\n\r\n  var organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\r\n    if (sidxMapping === void 0) {\r\n      sidxMapping = {};\r\n    }\r\n\r\n    return playlists.reduce(function (a, playlist) {\r\n      var label = playlist.attributes.lang || 'text';\r\n\r\n      if (!a[label]) {\r\n        a[label] = {\r\n          language: label,\r\n          \"default\": false,\r\n          autoselect: false,\r\n          playlists: [],\r\n          uri: ''\r\n        };\r\n      }\r\n\r\n      a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\r\n      return a;\r\n    }, {});\r\n  };\r\n\r\n  var organizeCaptionServices = function organizeCaptionServices(captionServices) {\r\n    return captionServices.reduce(function (svcObj, svc) {\r\n      if (!svc) {\r\n        return svcObj;\r\n      }\r\n\r\n      svc.forEach(function (service) {\r\n        var channel = service.channel,\r\n            language = service.language;\r\n        svcObj[language] = {\r\n          autoselect: false,\r\n          \"default\": false,\r\n          instreamId: channel,\r\n          language: language\r\n        };\r\n\r\n        if (service.hasOwnProperty('aspectRatio')) {\r\n          svcObj[language].aspectRatio = service.aspectRatio;\r\n        }\r\n\r\n        if (service.hasOwnProperty('easyReader')) {\r\n          svcObj[language].easyReader = service.easyReader;\r\n        }\r\n\r\n        if (service.hasOwnProperty('3D')) {\r\n          svcObj[language]['3D'] = service['3D'];\r\n        }\r\n      });\r\n      return svcObj;\r\n    }, {});\r\n  };\r\n\r\n  var formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\r\n    var _attributes2;\r\n\r\n    var attributes = _ref3.attributes,\r\n        segments = _ref3.segments,\r\n        sidx = _ref3.sidx,\r\n        discontinuityStarts = _ref3.discontinuityStarts;\r\n    var playlist = {\r\n      attributes: (_attributes2 = {\r\n        NAME: attributes.id,\r\n        AUDIO: 'audio',\r\n        SUBTITLES: 'subs',\r\n        RESOLUTION: {\r\n          width: attributes.width,\r\n          height: attributes.height\r\n        },\r\n        CODECS: attributes.codecs,\r\n        BANDWIDTH: attributes.bandwidth\r\n      }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\r\n      uri: '',\r\n      endList: attributes.type === 'static',\r\n      timeline: attributes.periodStart,\r\n      resolvedUri: '',\r\n      targetDuration: attributes.duration,\r\n      discontinuityStarts: discontinuityStarts,\r\n      timelineStarts: attributes.timelineStarts,\r\n      segments: segments\r\n    };\r\n\r\n    if (attributes.contentProtection) {\r\n      playlist.contentProtection = attributes.contentProtection;\r\n    }\r\n\r\n    if (sidx) {\r\n      playlist.sidx = sidx;\r\n    }\r\n\r\n    return playlist;\r\n  };\r\n\r\n  var videoOnly = function videoOnly(_ref4) {\r\n    var attributes = _ref4.attributes;\r\n    return attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\r\n  };\r\n\r\n  var audioOnly = function audioOnly(_ref5) {\r\n    var attributes = _ref5.attributes;\r\n    return attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\r\n  };\r\n\r\n  var vttOnly = function vttOnly(_ref6) {\r\n    var attributes = _ref6.attributes;\r\n    return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\r\n  };\r\n  /**\r\n   * Contains start and timeline properties denoting a timeline start. For DASH, these will\r\n   * be the same number.\r\n   *\r\n   * @typedef {Object} TimelineStart\r\n   * @property {number} start - the start time of the timeline\r\n   * @property {number} timeline - the timeline number\r\n   */\r\n\r\n  /**\r\n   * Adds appropriate media and discontinuity sequence values to the segments and playlists.\r\n   *\r\n   * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\r\n   * DASH specific attribute used in constructing segment URI's from templates. However, from\r\n   * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\r\n   * value, which should start at the original media sequence value (or 0) and increment by 1\r\n   * for each segment thereafter. Since DASH's `startNumber` values are independent per\r\n   * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\r\n   * from a 0 mediaSequence value and increment from there.\r\n   *\r\n   * Note that VHS currently doesn't use the `number` property, but it can be helpful for\r\n   * debugging and making sense of the manifest.\r\n   *\r\n   * For live playlists, to account for values increasing in manifests when periods are\r\n   * removed on refreshes, merging logic should be used to update the numbers to their\r\n   * appropriate values (to ensure they're sequential and increasing).\r\n   *\r\n   * @param {Object[]} playlists - the playlists to update\r\n   * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\r\n   */\r\n\r\n\r\n  var addMediaSequenceValues = function addMediaSequenceValues(playlists, timelineStarts) {\r\n    // increment all segments sequentially\r\n    playlists.forEach(function (playlist) {\r\n      playlist.mediaSequence = 0;\r\n      playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref7) {\r\n        var timeline = _ref7.timeline;\r\n        return timeline === playlist.timeline;\r\n      });\r\n\r\n      if (!playlist.segments) {\r\n        return;\r\n      }\r\n\r\n      playlist.segments.forEach(function (segment, index) {\r\n        segment.number = index;\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * Given a media group object, flattens all playlists within the media group into a single\r\n   * array.\r\n   *\r\n   * @param {Object} mediaGroupObject - the media group object\r\n   *\r\n   * @return {Object[]}\r\n   *         The media group playlists\r\n   */\r\n\r\n\r\n  var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists(mediaGroupObject) {\r\n    if (!mediaGroupObject) {\r\n      return [];\r\n    }\r\n\r\n    return Object.keys(mediaGroupObject).reduce(function (acc, label) {\r\n      var labelContents = mediaGroupObject[label];\r\n      return acc.concat(labelContents.playlists);\r\n    }, []);\r\n  };\r\n\r\n  var toM3u8 = function toM3u8(_ref8) {\r\n    var _mediaGroups;\r\n\r\n    var dashPlaylists = _ref8.dashPlaylists,\r\n        locations = _ref8.locations,\r\n        _ref8$sidxMapping = _ref8.sidxMapping,\r\n        sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping,\r\n        previousManifest = _ref8.previousManifest;\r\n\r\n    if (!dashPlaylists.length) {\r\n      return {};\r\n    } // grab all main manifest attributes\r\n\r\n\r\n    var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\r\n        duration = _dashPlaylists$0$attr.sourceDuration,\r\n        type = _dashPlaylists$0$attr.type,\r\n        suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay,\r\n        minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;\r\n    var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\r\n    var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\r\n    var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\r\n    var captions = dashPlaylists.map(function (playlist) {\r\n      return playlist.attributes.captionServices;\r\n    }).filter(Boolean);\r\n    var manifest = {\r\n      allowCache: true,\r\n      discontinuityStarts: [],\r\n      segments: [],\r\n      endList: true,\r\n      mediaGroups: (_mediaGroups = {\r\n        AUDIO: {},\r\n        VIDEO: {}\r\n      }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\r\n      uri: '',\r\n      duration: duration,\r\n      playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\r\n    };\r\n\r\n    if (minimumUpdatePeriod >= 0) {\r\n      manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\r\n    }\r\n\r\n    if (locations) {\r\n      manifest.locations = locations;\r\n    }\r\n\r\n    if (type === 'dynamic') {\r\n      manifest.suggestedPresentationDelay = suggestedPresentationDelay;\r\n    }\r\n\r\n    var isAudioOnly = manifest.playlists.length === 0;\r\n    var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\r\n    var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\r\n    var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\r\n    var playlistTimelineStarts = formattedPlaylists.map(function (_ref9) {\r\n      var timelineStarts = _ref9.timelineStarts;\r\n      return timelineStarts;\r\n    });\r\n    manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\r\n    addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\r\n\r\n    if (organizedAudioGroup) {\r\n      manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\r\n    }\r\n\r\n    if (organizedVttGroup) {\r\n      manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\r\n    }\r\n\r\n    if (captions.length) {\r\n      manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\r\n    }\r\n\r\n    if (previousManifest) {\r\n      return positionManifestOnTimeline({\r\n        oldManifest: previousManifest,\r\n        newManifest: manifest\r\n      });\r\n    }\r\n\r\n    return manifest;\r\n  };\r\n  /**\r\n   * Calculates the R (repetition) value for a live stream (for the final segment\r\n   * in a manifest where the r value is negative 1)\r\n   *\r\n   * @param {Object} attributes\r\n   *        Object containing all inherited attributes from parent elements with attribute\r\n   *        names as keys\r\n   * @param {number} time\r\n   *        current time (typically the total time up until the final segment)\r\n   * @param {number} duration\r\n   *        duration property for the given <S />\r\n   *\r\n   * @return {number}\r\n   *        R value to reach the end of the given period\r\n   */\r\n\r\n\r\n  var getLiveRValue = function getLiveRValue(attributes, time, duration) {\r\n    var NOW = attributes.NOW,\r\n        clientOffset = attributes.clientOffset,\r\n        availabilityStartTime = attributes.availabilityStartTime,\r\n        _attributes$timescale = attributes.timescale,\r\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\r\n        _attributes$periodSta = attributes.periodStart,\r\n        periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\r\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\r\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\r\n    var now = (NOW + clientOffset) / 1000;\r\n    var periodStartWC = availabilityStartTime + periodStart;\r\n    var periodEndWC = now + minimumUpdatePeriod;\r\n    var periodDuration = periodEndWC - periodStartWC;\r\n    return Math.ceil((periodDuration * timescale - time) / duration);\r\n  };\r\n  /**\r\n   * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\r\n   * timing and duration\r\n   *\r\n   * @param {Object} attributes\r\n   *        Object containing all inherited attributes from parent elements with attribute\r\n   *        names as keys\r\n   * @param {Object[]} segmentTimeline\r\n   *        List of objects representing the attributes of each S element contained within\r\n   *\r\n   * @return {{number: number, duration: number, time: number, timeline: number}[]}\r\n   *         List of Objects with segment timing and duration info\r\n   */\r\n\r\n\r\n  var parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\r\n    var type = attributes.type,\r\n        _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\r\n        minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\r\n        _attributes$media = attributes.media,\r\n        media = _attributes$media === void 0 ? '' : _attributes$media,\r\n        sourceDuration = attributes.sourceDuration,\r\n        _attributes$timescale2 = attributes.timescale,\r\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\r\n        _attributes$startNumb = attributes.startNumber,\r\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\r\n        timeline = attributes.periodStart;\r\n    var segments = [];\r\n    var time = -1;\r\n\r\n    for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\r\n      var S = segmentTimeline[sIndex];\r\n      var duration = S.d;\r\n      var repeat = S.r || 0;\r\n      var segmentTime = S.t || 0;\r\n\r\n      if (time < 0) {\r\n        // first segment\r\n        time = segmentTime;\r\n      }\r\n\r\n      if (segmentTime && segmentTime > time) {\r\n        // discontinuity\r\n        // TODO: How to handle this type of discontinuity\r\n        // timeline++ here would treat it like HLS discontuity and content would\r\n        // get appended without gap\r\n        // E.G.\r\n        //  <S t=\"0\" d=\"1\" />\r\n        //  <S d=\"1\" />\r\n        //  <S d=\"1\" />\r\n        //  <S t=\"5\" d=\"1\" />\r\n        // would have $Time$ values of [0, 1, 2, 5]\r\n        // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\r\n        // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\r\n        // does the value of sourceDuration consider this when calculating arbitrary\r\n        // negative @r repeat value?\r\n        // E.G. Same elements as above with this added at the end\r\n        //  <S d=\"1\" r=\"-1\" />\r\n        //  with a sourceDuration of 10\r\n        // Would the 2 gaps be included in the time duration calculations resulting in\r\n        // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\r\n        // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\r\n        time = segmentTime;\r\n      }\r\n\r\n      var count = void 0;\r\n\r\n      if (repeat < 0) {\r\n        var nextS = sIndex + 1;\r\n\r\n        if (nextS === segmentTimeline.length) {\r\n          // last segment\r\n          if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\r\n            count = getLiveRValue(attributes, time, duration);\r\n          } else {\r\n            // TODO: This may be incorrect depending on conclusion of TODO above\r\n            count = (sourceDuration * timescale - time) / duration;\r\n          }\r\n        } else {\r\n          count = (segmentTimeline[nextS].t - time) / duration;\r\n        }\r\n      } else {\r\n        count = repeat + 1;\r\n      }\r\n\r\n      var end = startNumber + segments.length + count;\r\n      var number = startNumber + segments.length;\r\n\r\n      while (number < end) {\r\n        segments.push({\r\n          number: number,\r\n          duration: duration / timescale,\r\n          time: time,\r\n          timeline: timeline\r\n        });\r\n        time += duration;\r\n        number++;\r\n      }\r\n    }\r\n\r\n    return segments;\r\n  };\r\n\r\n  var identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\r\n  /**\r\n   * Replaces template identifiers with corresponding values. To be used as the callback\r\n   * for String.prototype.replace\r\n   *\r\n   * @name replaceCallback\r\n   * @function\r\n   * @param {string} match\r\n   *        Entire match of identifier\r\n   * @param {string} identifier\r\n   *        Name of matched identifier\r\n   * @param {string} format\r\n   *        Format tag string. Its presence indicates that padding is expected\r\n   * @param {string} width\r\n   *        Desired length of the replaced value. Values less than this width shall be left\r\n   *        zero padded\r\n   * @return {string}\r\n   *         Replacement for the matched identifier\r\n   */\r\n\r\n  /**\r\n   * Returns a function to be used as a callback for String.prototype.replace to replace\r\n   * template identifiers\r\n   *\r\n   * @param {Obect} values\r\n   *        Object containing values that shall be used to replace known identifiers\r\n   * @param {number} values.RepresentationID\r\n   *        Value of the Representation@id attribute\r\n   * @param {number} values.Number\r\n   *        Number of the corresponding segment\r\n   * @param {number} values.Bandwidth\r\n   *        Value of the Representation@bandwidth attribute.\r\n   * @param {number} values.Time\r\n   *        Timestamp value of the corresponding segment\r\n   * @return {replaceCallback}\r\n   *         Callback to be used with String.prototype.replace to replace identifiers\r\n   */\r\n\r\n  var identifierReplacement = function identifierReplacement(values) {\r\n    return function (match, identifier, format, width) {\r\n      if (match === '$$') {\r\n        // escape sequence\r\n        return '$';\r\n      }\r\n\r\n      if (typeof values[identifier] === 'undefined') {\r\n        return match;\r\n      }\r\n\r\n      var value = '' + values[identifier];\r\n\r\n      if (identifier === 'RepresentationID') {\r\n        // Format tag shall not be present with RepresentationID\r\n        return value;\r\n      }\r\n\r\n      if (!format) {\r\n        width = 1;\r\n      } else {\r\n        width = parseInt(width, 10);\r\n      }\r\n\r\n      if (value.length >= width) {\r\n        return value;\r\n      }\r\n\r\n      return \"\" + new Array(width - value.length + 1).join('0') + value;\r\n    };\r\n  };\r\n  /**\r\n   * Constructs a segment url from a template string\r\n   *\r\n   * @param {string} url\r\n   *        Template string to construct url from\r\n   * @param {Obect} values\r\n   *        Object containing values that shall be used to replace known identifiers\r\n   * @param {number} values.RepresentationID\r\n   *        Value of the Representation@id attribute\r\n   * @param {number} values.Number\r\n   *        Number of the corresponding segment\r\n   * @param {number} values.Bandwidth\r\n   *        Value of the Representation@bandwidth attribute.\r\n   * @param {number} values.Time\r\n   *        Timestamp value of the corresponding segment\r\n   * @return {string}\r\n   *         Segment url with identifiers replaced\r\n   */\r\n\r\n\r\n  var constructTemplateUrl = function constructTemplateUrl(url, values) {\r\n    return url.replace(identifierPattern, identifierReplacement(values));\r\n  };\r\n  /**\r\n   * Generates a list of objects containing timing and duration information about each\r\n   * segment needed to generate segment uris and the complete segment object\r\n   *\r\n   * @param {Object} attributes\r\n   *        Object containing all inherited attributes from parent elements with attribute\r\n   *        names as keys\r\n   * @param {Object[]|undefined} segmentTimeline\r\n   *        List of objects representing the attributes of each S element contained within\r\n   *        the SegmentTimeline element\r\n   * @return {{number: number, duration: number, time: number, timeline: number}[]}\r\n   *         List of Objects with segment timing and duration info\r\n   */\r\n\r\n\r\n  var parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\r\n    if (!attributes.duration && !segmentTimeline) {\r\n      // if neither @duration or SegmentTimeline are present, then there shall be exactly\r\n      // one media segment\r\n      return [{\r\n        number: attributes.startNumber || 1,\r\n        duration: attributes.sourceDuration,\r\n        time: 0,\r\n        timeline: attributes.periodStart\r\n      }];\r\n    }\r\n\r\n    if (attributes.duration) {\r\n      return parseByDuration(attributes);\r\n    }\r\n\r\n    return parseByTimeline(attributes, segmentTimeline);\r\n  };\r\n  /**\r\n   * Generates a list of segments using information provided by the SegmentTemplate element\r\n   *\r\n   * @param {Object} attributes\r\n   *        Object containing all inherited attributes from parent elements with attribute\r\n   *        names as keys\r\n   * @param {Object[]|undefined} segmentTimeline\r\n   *        List of objects representing the attributes of each S element contained within\r\n   *        the SegmentTimeline element\r\n   * @return {Object[]}\r\n   *         List of segment objects\r\n   */\r\n\r\n\r\n  var segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\r\n    var templateValues = {\r\n      RepresentationID: attributes.id,\r\n      Bandwidth: attributes.bandwidth || 0\r\n    };\r\n    var _attributes$initializ = attributes.initialization,\r\n        initialization = _attributes$initializ === void 0 ? {\r\n      sourceURL: '',\r\n      range: ''\r\n    } : _attributes$initializ;\r\n    var mapSegment = urlTypeToSegment({\r\n      baseUrl: attributes.baseUrl,\r\n      source: constructTemplateUrl(initialization.sourceURL, templateValues),\r\n      range: initialization.range\r\n    });\r\n    var segments = parseTemplateInfo(attributes, segmentTimeline);\r\n    return segments.map(function (segment) {\r\n      templateValues.Number = segment.number;\r\n      templateValues.Time = segment.time;\r\n      var uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\r\n      // - if timescale isn't present on any level, default to 1.\r\n\r\n      var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\r\n\r\n      var presentationTimeOffset = attributes.presentationTimeOffset || 0;\r\n      var presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\r\n      // calculated in mpd-parser prior to this, so it's assumed to be available.\r\n      attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\r\n      var map = {\r\n        uri: uri,\r\n        timeline: segment.timeline,\r\n        duration: segment.duration,\r\n        resolvedUri: resolveUrl$1(attributes.baseUrl || '', uri),\r\n        map: mapSegment,\r\n        number: segment.number,\r\n        presentationTime: presentationTime\r\n      };\r\n      return map;\r\n    });\r\n  };\r\n  /**\r\n   * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\r\n   * to an object that matches the output of a segment in videojs/mpd-parser\r\n   *\r\n   * @param {Object} attributes\r\n   *   Object containing all inherited attributes from parent elements with attribute\r\n   *   names as keys\r\n   * @param {Object} segmentUrl\r\n   *   <SegmentURL> node to translate into a segment object\r\n   * @return {Object} translated segment object\r\n   */\r\n\r\n\r\n  var SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\r\n    var baseUrl = attributes.baseUrl,\r\n        _attributes$initializ = attributes.initialization,\r\n        initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\r\n    var initSegment = urlTypeToSegment({\r\n      baseUrl: baseUrl,\r\n      source: initialization.sourceURL,\r\n      range: initialization.range\r\n    });\r\n    var segment = urlTypeToSegment({\r\n      baseUrl: baseUrl,\r\n      source: segmentUrl.media,\r\n      range: segmentUrl.mediaRange\r\n    });\r\n    segment.map = initSegment;\r\n    return segment;\r\n  };\r\n  /**\r\n   * Generates a list of segments using information provided by the SegmentList element\r\n   * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\r\n   * node should be translated into segment.\r\n   *\r\n   * @param {Object} attributes\r\n   *   Object containing all inherited attributes from parent elements with attribute\r\n   *   names as keys\r\n   * @param {Object[]|undefined} segmentTimeline\r\n   *        List of objects representing the attributes of each S element contained within\r\n   *        the SegmentTimeline element\r\n   * @return {Object.<Array>} list of segments\r\n   */\r\n\r\n\r\n  var segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\r\n    var duration = attributes.duration,\r\n        _attributes$segmentUr = attributes.segmentUrls,\r\n        segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr,\r\n        periodStart = attributes.periodStart; // Per spec (5.3.9.2.1) no way to determine segment duration OR\r\n    // if both SegmentTimeline and @duration are defined, it is outside of spec.\r\n\r\n    if (!duration && !segmentTimeline || duration && segmentTimeline) {\r\n      throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\r\n    }\r\n\r\n    var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\r\n      return SegmentURLToSegmentObject(attributes, segmentUrlObject);\r\n    });\r\n    var segmentTimeInfo;\r\n\r\n    if (duration) {\r\n      segmentTimeInfo = parseByDuration(attributes);\r\n    }\r\n\r\n    if (segmentTimeline) {\r\n      segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\r\n    }\r\n\r\n    var segments = segmentTimeInfo.map(function (segmentTime, index) {\r\n      if (segmentUrlMap[index]) {\r\n        var segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\r\n        // - if timescale isn't present on any level, default to 1.\r\n\r\n        var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\r\n\r\n        var presentationTimeOffset = attributes.presentationTimeOffset || 0;\r\n        segment.timeline = segmentTime.timeline;\r\n        segment.duration = segmentTime.duration;\r\n        segment.number = segmentTime.number;\r\n        segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\r\n        return segment;\r\n      } // Since we're mapping we should get rid of any blank segments (in case\r\n      // the given SegmentTimeline is handling for more elements than we have\r\n      // SegmentURLs for).\r\n\r\n    }).filter(function (segment) {\r\n      return segment;\r\n    });\r\n    return segments;\r\n  };\r\n\r\n  var generateSegments = function generateSegments(_ref) {\r\n    var attributes = _ref.attributes,\r\n        segmentInfo = _ref.segmentInfo;\r\n    var segmentAttributes;\r\n    var segmentsFn;\r\n\r\n    if (segmentInfo.template) {\r\n      segmentsFn = segmentsFromTemplate;\r\n      segmentAttributes = merge(attributes, segmentInfo.template);\r\n    } else if (segmentInfo.base) {\r\n      segmentsFn = segmentsFromBase;\r\n      segmentAttributes = merge(attributes, segmentInfo.base);\r\n    } else if (segmentInfo.list) {\r\n      segmentsFn = segmentsFromList;\r\n      segmentAttributes = merge(attributes, segmentInfo.list);\r\n    }\r\n\r\n    var segmentsInfo = {\r\n      attributes: attributes\r\n    };\r\n\r\n    if (!segmentsFn) {\r\n      return segmentsInfo;\r\n    }\r\n\r\n    var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\r\n    // must be in seconds. Since we've generated the segment list, we no longer need\r\n    // @duration to be in @timescale units, so we can convert it here.\r\n\r\n    if (segmentAttributes.duration) {\r\n      var _segmentAttributes = segmentAttributes,\r\n          duration = _segmentAttributes.duration,\r\n          _segmentAttributes$ti = _segmentAttributes.timescale,\r\n          timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\r\n      segmentAttributes.duration = duration / timescale;\r\n    } else if (segments.length) {\r\n      // if there is no @duration attribute, use the largest segment duration as\r\n      // as target duration\r\n      segmentAttributes.duration = segments.reduce(function (max, segment) {\r\n        return Math.max(max, Math.ceil(segment.duration));\r\n      }, 0);\r\n    } else {\r\n      segmentAttributes.duration = 0;\r\n    }\r\n\r\n    segmentsInfo.attributes = segmentAttributes;\r\n    segmentsInfo.segments = segments; // This is a sidx box without actual segment information\r\n\r\n    if (segmentInfo.base && segmentAttributes.indexRange) {\r\n      segmentsInfo.sidx = segments[0];\r\n      segmentsInfo.segments = [];\r\n    }\r\n\r\n    return segmentsInfo;\r\n  };\r\n\r\n  var toPlaylists = function toPlaylists(representations) {\r\n    return representations.map(generateSegments);\r\n  };\r\n\r\n  var findChildren = function findChildren(element, name) {\r\n    return from(element.childNodes).filter(function (_ref) {\r\n      var tagName = _ref.tagName;\r\n      return tagName === name;\r\n    });\r\n  };\r\n\r\n  var getContent = function getContent(element) {\r\n    return element.textContent.trim();\r\n  };\r\n\r\n  var parseDuration = function parseDuration(str) {\r\n    var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\r\n    var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\r\n    var SECONDS_IN_DAY = 24 * 60 * 60;\r\n    var SECONDS_IN_HOUR = 60 * 60;\r\n    var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\r\n\r\n    var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\r\n    var match = durationRegex.exec(str);\r\n\r\n    if (!match) {\r\n      return 0;\r\n    }\r\n\r\n    var _match$slice = match.slice(1),\r\n        year = _match$slice[0],\r\n        month = _match$slice[1],\r\n        day = _match$slice[2],\r\n        hour = _match$slice[3],\r\n        minute = _match$slice[4],\r\n        second = _match$slice[5];\r\n\r\n    return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\r\n  };\r\n\r\n  var parseDate = function parseDate(str) {\r\n    // Date format without timezone according to ISO 8601\r\n    // YYY-MM-DDThh:mm:ss.ssssss\r\n    var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\r\n    // expressed by ending with 'Z'\r\n\r\n    if (dateRegex.test(str)) {\r\n      str += 'Z';\r\n    }\r\n\r\n    return Date.parse(str);\r\n  };\r\n\r\n  var parsers = {\r\n    /**\r\n     * Specifies the duration of the entire Media Presentation. Format is a duration string\r\n     * as specified in ISO 8601\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The duration in seconds\r\n     */\r\n    mediaPresentationDuration: function mediaPresentationDuration(value) {\r\n      return parseDuration(value);\r\n    },\r\n\r\n    /**\r\n     * Specifies the Segment availability start time for all Segments referred to in this\r\n     * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\r\n     * time. Format is a date string as specified in ISO 8601\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The date as seconds from unix epoch\r\n     */\r\n    availabilityStartTime: function availabilityStartTime(value) {\r\n      return parseDate(value) / 1000;\r\n    },\r\n\r\n    /**\r\n     * Specifies the smallest period between potential changes to the MPD. Format is a\r\n     * duration string as specified in ISO 8601\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The duration in seconds\r\n     */\r\n    minimumUpdatePeriod: function minimumUpdatePeriod(value) {\r\n      return parseDuration(value);\r\n    },\r\n\r\n    /**\r\n     * Specifies the suggested presentation delay. Format is a\r\n     * duration string as specified in ISO 8601\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The duration in seconds\r\n     */\r\n    suggestedPresentationDelay: function suggestedPresentationDelay(value) {\r\n      return parseDuration(value);\r\n    },\r\n\r\n    /**\r\n     * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     *\r\n     * @return {string}\r\n     *         The type as a string\r\n     */\r\n    type: function type(value) {\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Specifies the duration of the smallest time shifting buffer for any Representation\r\n     * in the MPD. Format is a duration string as specified in ISO 8601\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The duration in seconds\r\n     */\r\n    timeShiftBufferDepth: function timeShiftBufferDepth(value) {\r\n      return parseDuration(value);\r\n    },\r\n\r\n    /**\r\n     * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\r\n     * Format is a duration string as specified in ISO 8601\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The duration in seconds\r\n     */\r\n    start: function start(value) {\r\n      return parseDuration(value);\r\n    },\r\n\r\n    /**\r\n     * Specifies the width of the visual presentation\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed width\r\n     */\r\n    width: function width(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the height of the visual presentation\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed height\r\n     */\r\n    height: function height(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the bitrate of the representation\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed bandwidth\r\n     */\r\n    bandwidth: function bandwidth(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the number of the first Media Segment in this Representation in the Period\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed number\r\n     */\r\n    startNumber: function startNumber(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the timescale in units per seconds\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed timescale\r\n     */\r\n    timescale: function timescale(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the presentationTimeOffset.\r\n     *\r\n     * @param {string} value\r\n     *        value of the attribute as a string\r\n     *\r\n     * @return {number}\r\n     *         The parsed presentationTimeOffset\r\n     */\r\n    presentationTimeOffset: function presentationTimeOffset(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the constant approximate Segment duration\r\n     * NOTE: The <Period> element also contains an @duration attribute. This duration\r\n     *       specifies the duration of the Period. This attribute is currently not\r\n     *       supported by the rest of the parser, however we still check for it to prevent\r\n     *       errors.\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed duration\r\n     */\r\n    duration: function duration(value) {\r\n      var parsedValue = parseInt(value, 10);\r\n\r\n      if (isNaN(parsedValue)) {\r\n        return parseDuration(value);\r\n      }\r\n\r\n      return parsedValue;\r\n    },\r\n\r\n    /**\r\n     * Specifies the Segment duration, in units of the value of the @timescale.\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed duration\r\n     */\r\n    d: function d(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the MPD start time, in @timescale units, the first Segment in the series\r\n     * starts relative to the beginning of the Period\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed time\r\n     */\r\n    t: function t(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Specifies the repeat count of the number of following contiguous Segments with the\r\n     * same duration expressed by the value of @d\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {number}\r\n     *         The parsed number\r\n     */\r\n    r: function r(value) {\r\n      return parseInt(value, 10);\r\n    },\r\n\r\n    /**\r\n     * Default parser for all other attributes. Acts as a no-op and just returns the value\r\n     * as a string\r\n     *\r\n     * @param {string} value\r\n     *        value of attribute as a string\r\n     * @return {string}\r\n     *         Unparsed value\r\n     */\r\n    DEFAULT: function DEFAULT(value) {\r\n      return value;\r\n    }\r\n  };\r\n  /**\r\n   * Gets all the attributes and values of the provided node, parses attributes with known\r\n   * types, and returns an object with attribute names mapped to values.\r\n   *\r\n   * @param {Node} el\r\n   *        The node to parse attributes from\r\n   * @return {Object}\r\n   *         Object with all attributes of el parsed\r\n   */\r\n\r\n  var parseAttributes = function parseAttributes(el) {\r\n    if (!(el && el.attributes)) {\r\n      return {};\r\n    }\r\n\r\n    return from(el.attributes).reduce(function (a, e) {\r\n      var parseFn = parsers[e.name] || parsers.DEFAULT;\r\n      a[e.name] = parseFn(e.value);\r\n      return a;\r\n    }, {});\r\n  };\r\n\r\n  var keySystemsMap = {\r\n    'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\r\n    'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\r\n    'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\r\n    'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\r\n  };\r\n  /**\r\n   * Builds a list of urls that is the product of the reference urls and BaseURL values\r\n   *\r\n   * @param {string[]} referenceUrls\r\n   *        List of reference urls to resolve to\r\n   * @param {Node[]} baseUrlElements\r\n   *        List of BaseURL nodes from the mpd\r\n   * @return {string[]}\r\n   *         List of resolved urls\r\n   */\r\n\r\n  var buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\r\n    if (!baseUrlElements.length) {\r\n      return referenceUrls;\r\n    }\r\n\r\n    return flatten(referenceUrls.map(function (reference) {\r\n      return baseUrlElements.map(function (baseUrlElement) {\r\n        return resolveUrl$1(reference, getContent(baseUrlElement));\r\n      });\r\n    }));\r\n  };\r\n  /**\r\n   * Contains all Segment information for its containing AdaptationSet\r\n   *\r\n   * @typedef {Object} SegmentInformation\r\n   * @property {Object|undefined} template\r\n   *           Contains the attributes for the SegmentTemplate node\r\n   * @property {Object[]|undefined} segmentTimeline\r\n   *           Contains a list of atrributes for each S node within the SegmentTimeline node\r\n   * @property {Object|undefined} list\r\n   *           Contains the attributes for the SegmentList node\r\n   * @property {Object|undefined} base\r\n   *           Contains the attributes for the SegmentBase node\r\n   */\r\n\r\n  /**\r\n   * Returns all available Segment information contained within the AdaptationSet node\r\n   *\r\n   * @param {Node} adaptationSet\r\n   *        The AdaptationSet node to get Segment information from\r\n   * @return {SegmentInformation}\r\n   *         The Segment information contained within the provided AdaptationSet\r\n   */\r\n\r\n\r\n  var getSegmentInformation = function getSegmentInformation(adaptationSet) {\r\n    var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\r\n    var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\r\n    var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\r\n      return merge({\r\n        tag: 'SegmentURL'\r\n      }, parseAttributes(s));\r\n    });\r\n    var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\r\n    var segmentTimelineParentNode = segmentList || segmentTemplate;\r\n    var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\r\n    var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\r\n    var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\r\n    // @initialization and an <Initialization> node.  @initialization can be templated,\r\n    // while the node can have a url and range specified.  If the <SegmentTemplate> has\r\n    // both @initialization and an <Initialization> subelement we opt to override with\r\n    // the node, as this interaction is not defined in the spec.\r\n\r\n    var template = segmentTemplate && parseAttributes(segmentTemplate);\r\n\r\n    if (template && segmentInitialization) {\r\n      template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\r\n    } else if (template && template.initialization) {\r\n      // If it is @initialization we convert it to an object since this is the format that\r\n      // later functions will rely on for the initialization segment.  This is only valid\r\n      // for <SegmentTemplate>\r\n      template.initialization = {\r\n        sourceURL: template.initialization\r\n      };\r\n    }\r\n\r\n    var segmentInfo = {\r\n      template: template,\r\n      segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\r\n        return parseAttributes(s);\r\n      }),\r\n      list: segmentList && merge(parseAttributes(segmentList), {\r\n        segmentUrls: segmentUrls,\r\n        initialization: parseAttributes(segmentInitialization)\r\n      }),\r\n      base: segmentBase && merge(parseAttributes(segmentBase), {\r\n        initialization: parseAttributes(segmentInitialization)\r\n      })\r\n    };\r\n    Object.keys(segmentInfo).forEach(function (key) {\r\n      if (!segmentInfo[key]) {\r\n        delete segmentInfo[key];\r\n      }\r\n    });\r\n    return segmentInfo;\r\n  };\r\n  /**\r\n   * Contains Segment information and attributes needed to construct a Playlist object\r\n   * from a Representation\r\n   *\r\n   * @typedef {Object} RepresentationInformation\r\n   * @property {SegmentInformation} segmentInfo\r\n   *           Segment information for this Representation\r\n   * @property {Object} attributes\r\n   *           Inherited attributes for this Representation\r\n   */\r\n\r\n  /**\r\n   * Maps a Representation node to an object containing Segment information and attributes\r\n   *\r\n   * @name inheritBaseUrlsCallback\r\n   * @function\r\n   * @param {Node} representation\r\n   *        Representation node from the mpd\r\n   * @return {RepresentationInformation}\r\n   *         Representation information needed to construct a Playlist object\r\n   */\r\n\r\n  /**\r\n   * Returns a callback for Array.prototype.map for mapping Representation nodes to\r\n   * Segment information and attributes using inherited BaseURL nodes.\r\n   *\r\n   * @param {Object} adaptationSetAttributes\r\n   *        Contains attributes inherited by the AdaptationSet\r\n   * @param {string[]} adaptationSetBaseUrls\r\n   *        Contains list of resolved base urls inherited by the AdaptationSet\r\n   * @param {SegmentInformation} adaptationSetSegmentInfo\r\n   *        Contains Segment information for the AdaptationSet\r\n   * @return {inheritBaseUrlsCallback}\r\n   *         Callback map function\r\n   */\r\n\r\n\r\n  var inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\r\n    return function (representation) {\r\n      var repBaseUrlElements = findChildren(representation, 'BaseURL');\r\n      var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\r\n      var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\r\n      var representationSegmentInfo = getSegmentInformation(representation);\r\n      return repBaseUrls.map(function (baseUrl) {\r\n        return {\r\n          segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\r\n          attributes: merge(attributes, {\r\n            baseUrl: baseUrl\r\n          })\r\n        };\r\n      });\r\n    };\r\n  };\r\n  /**\r\n   * Tranforms a series of content protection nodes to\r\n   * an object containing pssh data by key system\r\n   *\r\n   * @param {Node[]} contentProtectionNodes\r\n   *        Content protection nodes\r\n   * @return {Object}\r\n   *        Object containing pssh data by key system\r\n   */\r\n\r\n\r\n  var generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\r\n    return contentProtectionNodes.reduce(function (acc, node) {\r\n      var attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\r\n      // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\r\n      // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\r\n      // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\r\n\r\n      if (attributes.schemeIdUri) {\r\n        attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\r\n      }\r\n\r\n      var keySystem = keySystemsMap[attributes.schemeIdUri];\r\n\r\n      if (keySystem) {\r\n        acc[keySystem] = {\r\n          attributes: attributes\r\n        };\r\n        var psshNode = findChildren(node, 'cenc:pssh')[0];\r\n\r\n        if (psshNode) {\r\n          var pssh = getContent(psshNode);\r\n          acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\r\n        }\r\n      }\r\n\r\n      return acc;\r\n    }, {});\r\n  }; // defined in ANSI_SCTE 214-1 2016\r\n\r\n\r\n  var parseCaptionServiceMetadata = function parseCaptionServiceMetadata(service) {\r\n    // 608 captions\r\n    if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\r\n      var values = typeof service.value !== 'string' ? [] : service.value.split(';');\r\n      return values.map(function (value) {\r\n        var channel;\r\n        var language; // default language to value\r\n\r\n        language = value;\r\n\r\n        if (/^CC\\d=/.test(value)) {\r\n          var _value$split = value.split('=');\r\n\r\n          channel = _value$split[0];\r\n          language = _value$split[1];\r\n        } else if (/^CC\\d$/.test(value)) {\r\n          channel = value;\r\n        }\r\n\r\n        return {\r\n          channel: channel,\r\n          language: language\r\n        };\r\n      });\r\n    } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\r\n      var _values = typeof service.value !== 'string' ? [] : service.value.split(';');\r\n\r\n      return _values.map(function (value) {\r\n        var flags = {\r\n          // service or channel number 1-63\r\n          'channel': undefined,\r\n          // language is a 3ALPHA per ISO 639.2/B\r\n          // field is required\r\n          'language': undefined,\r\n          // BIT 1/0 or ?\r\n          // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\r\n          'aspectRatio': 1,\r\n          // BIT 1/0\r\n          // easy reader flag indicated the text is tailed to the needs of beginning readers\r\n          // default 0, or off\r\n          'easyReader': 0,\r\n          // BIT 1/0\r\n          // If 3d metadata is present (CEA-708.1) then 1\r\n          // default 0\r\n          '3D': 0\r\n        };\r\n\r\n        if (/=/.test(value)) {\r\n          var _value$split2 = value.split('='),\r\n              channel = _value$split2[0],\r\n              _value$split2$ = _value$split2[1],\r\n              opts = _value$split2$ === void 0 ? '' : _value$split2$;\r\n\r\n          flags.channel = channel;\r\n          flags.language = value;\r\n          opts.split(',').forEach(function (opt) {\r\n            var _opt$split = opt.split(':'),\r\n                name = _opt$split[0],\r\n                val = _opt$split[1];\r\n\r\n            if (name === 'lang') {\r\n              flags.language = val; // er for easyReadery\r\n            } else if (name === 'er') {\r\n              flags.easyReader = Number(val); // war for wide aspect ratio\r\n            } else if (name === 'war') {\r\n              flags.aspectRatio = Number(val);\r\n            } else if (name === '3D') {\r\n              flags['3D'] = Number(val);\r\n            }\r\n          });\r\n        } else {\r\n          flags.language = value;\r\n        }\r\n\r\n        if (flags.channel) {\r\n          flags.channel = 'SERVICE' + flags.channel;\r\n        }\r\n\r\n        return flags;\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * Maps an AdaptationSet node to a list of Representation information objects\r\n   *\r\n   * @name toRepresentationsCallback\r\n   * @function\r\n   * @param {Node} adaptationSet\r\n   *        AdaptationSet node from the mpd\r\n   * @return {RepresentationInformation[]}\r\n   *         List of objects containing Representaion information\r\n   */\r\n\r\n  /**\r\n   * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\r\n   * Representation information objects\r\n   *\r\n   * @param {Object} periodAttributes\r\n   *        Contains attributes inherited by the Period\r\n   * @param {string[]} periodBaseUrls\r\n   *        Contains list of resolved base urls inherited by the Period\r\n   * @param {string[]} periodSegmentInfo\r\n   *        Contains Segment Information at the period level\r\n   * @return {toRepresentationsCallback}\r\n   *         Callback map function\r\n   */\r\n\r\n\r\n  var toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\r\n    return function (adaptationSet) {\r\n      var adaptationSetAttributes = parseAttributes(adaptationSet);\r\n      var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\r\n      var role = findChildren(adaptationSet, 'Role')[0];\r\n      var roleAttributes = {\r\n        role: parseAttributes(role)\r\n      };\r\n      var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\r\n      var accessibility = findChildren(adaptationSet, 'Accessibility')[0];\r\n      var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\r\n\r\n      if (captionServices) {\r\n        attrs = merge(attrs, {\r\n          captionServices: captionServices\r\n        });\r\n      }\r\n\r\n      var label = findChildren(adaptationSet, 'Label')[0];\r\n\r\n      if (label && label.childNodes.length) {\r\n        var labelVal = label.childNodes[0].nodeValue.trim();\r\n        attrs = merge(attrs, {\r\n          label: labelVal\r\n        });\r\n      }\r\n\r\n      var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\r\n\r\n      if (Object.keys(contentProtection).length) {\r\n        attrs = merge(attrs, {\r\n          contentProtection: contentProtection\r\n        });\r\n      }\r\n\r\n      var segmentInfo = getSegmentInformation(adaptationSet);\r\n      var representations = findChildren(adaptationSet, 'Representation');\r\n      var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\r\n      return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\r\n    };\r\n  };\r\n  /**\r\n   * Contains all period information for mapping nodes onto adaptation sets.\r\n   *\r\n   * @typedef {Object} PeriodInformation\r\n   * @property {Node} period.node\r\n   *           Period node from the mpd\r\n   * @property {Object} period.attributes\r\n   *           Parsed period attributes from node plus any added\r\n   */\r\n\r\n  /**\r\n   * Maps a PeriodInformation object to a list of Representation information objects for all\r\n   * AdaptationSet nodes contained within the Period.\r\n   *\r\n   * @name toAdaptationSetsCallback\r\n   * @function\r\n   * @param {PeriodInformation} period\r\n   *        Period object containing necessary period information\r\n   * @param {number} periodStart\r\n   *        Start time of the Period within the mpd\r\n   * @return {RepresentationInformation[]}\r\n   *         List of objects containing Representaion information\r\n   */\r\n\r\n  /**\r\n   * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\r\n   * Representation information objects\r\n   *\r\n   * @param {Object} mpdAttributes\r\n   *        Contains attributes inherited by the mpd\r\n   * @param {string[]} mpdBaseUrls\r\n   *        Contains list of resolved base urls inherited by the mpd\r\n   * @return {toAdaptationSetsCallback}\r\n   *         Callback map function\r\n   */\r\n\r\n\r\n  var toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\r\n    return function (period, index) {\r\n      var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\r\n      var periodAttributes = merge(mpdAttributes, {\r\n        periodStart: period.attributes.start\r\n      });\r\n\r\n      if (typeof period.attributes.duration === 'number') {\r\n        periodAttributes.periodDuration = period.attributes.duration;\r\n      }\r\n\r\n      var adaptationSets = findChildren(period.node, 'AdaptationSet');\r\n      var periodSegmentInfo = getSegmentInformation(period.node);\r\n      return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\r\n    };\r\n  };\r\n  /**\r\n   * Gets Period@start property for a given period.\r\n   *\r\n   * @param {Object} options\r\n   *        Options object\r\n   * @param {Object} options.attributes\r\n   *        Period attributes\r\n   * @param {Object} [options.priorPeriodAttributes]\r\n   *        Prior period attributes (if prior period is available)\r\n   * @param {string} options.mpdType\r\n   *        The MPD@type these periods came from\r\n   * @return {number|null}\r\n   *         The period start, or null if it's an early available period or error\r\n   */\r\n\r\n\r\n  var getPeriodStart = function getPeriodStart(_ref) {\r\n    var attributes = _ref.attributes,\r\n        priorPeriodAttributes = _ref.priorPeriodAttributes,\r\n        mpdType = _ref.mpdType; // Summary of period start time calculation from DASH spec section 5.3.2.1\r\n    //\r\n    // A period's start is the first period's start + time elapsed after playing all\r\n    // prior periods to this one. Periods continue one after the other in time (without\r\n    // gaps) until the end of the presentation.\r\n    //\r\n    // The value of Period@start should be:\r\n    // 1. if Period@start is present: value of Period@start\r\n    // 2. if previous period exists and it has @duration: previous Period@start +\r\n    //    previous Period@duration\r\n    // 3. if this is first period and MPD@type is 'static': 0\r\n    // 4. in all other cases, consider the period an \"early available period\" (note: not\r\n    //    currently supported)\r\n    // (1)\r\n\r\n    if (typeof attributes.start === 'number') {\r\n      return attributes.start;\r\n    } // (2)\r\n\r\n\r\n    if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\r\n      return priorPeriodAttributes.start + priorPeriodAttributes.duration;\r\n    } // (3)\r\n\r\n\r\n    if (!priorPeriodAttributes && mpdType === 'static') {\r\n      return 0;\r\n    } // (4)\r\n    // There is currently no logic for calculating the Period@start value if there is\r\n    // no Period@start or prior Period@start and Period@duration available. This is not made\r\n    // explicit by the DASH interop guidelines or the DASH spec, however, since there's\r\n    // nothing about any other resolution strategies, it's implied. Thus, this case should\r\n    // be considered an early available period, or error, and null should suffice for both\r\n    // of those cases.\r\n\r\n\r\n    return null;\r\n  };\r\n  /**\r\n   * Traverses the mpd xml tree to generate a list of Representation information objects\r\n   * that have inherited attributes from parent nodes\r\n   *\r\n   * @param {Node} mpd\r\n   *        The root node of the mpd\r\n   * @param {Object} options\r\n   *        Available options for inheritAttributes\r\n   * @param {string} options.manifestUri\r\n   *        The uri source of the mpd\r\n   * @param {number} options.NOW\r\n   *        Current time per DASH IOP.  Default is current time in ms since epoch\r\n   * @param {number} options.clientOffset\r\n   *        Client time difference from NOW (in milliseconds)\r\n   * @return {RepresentationInformation[]}\r\n   *         List of objects containing Representation information\r\n   */\r\n\r\n\r\n  var inheritAttributes = function inheritAttributes(mpd, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var _options = options,\r\n        _options$manifestUri = _options.manifestUri,\r\n        manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\r\n        _options$NOW = _options.NOW,\r\n        NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\r\n        _options$clientOffset = _options.clientOffset,\r\n        clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\r\n    var periodNodes = findChildren(mpd, 'Period');\r\n\r\n    if (!periodNodes.length) {\r\n      throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\r\n    }\r\n\r\n    var locations = findChildren(mpd, 'Location');\r\n    var mpdAttributes = parseAttributes(mpd);\r\n    var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\r\n\r\n    mpdAttributes.type = mpdAttributes.type || 'static';\r\n    mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\r\n    mpdAttributes.NOW = NOW;\r\n    mpdAttributes.clientOffset = clientOffset;\r\n\r\n    if (locations.length) {\r\n      mpdAttributes.locations = locations.map(getContent);\r\n    }\r\n\r\n    var periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\r\n    // adding properties that require looking at prior periods is to parse attributes and add\r\n    // missing ones before toAdaptationSets is called. If more such properties are added, it\r\n    // may be better to refactor toAdaptationSets.\r\n\r\n    periodNodes.forEach(function (node, index) {\r\n      var attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\r\n      // for this period.\r\n\r\n      var priorPeriod = periods[index - 1];\r\n      attributes.start = getPeriodStart({\r\n        attributes: attributes,\r\n        priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\r\n        mpdType: mpdAttributes.type\r\n      });\r\n      periods.push({\r\n        node: node,\r\n        attributes: attributes\r\n      });\r\n    });\r\n    return {\r\n      locations: mpdAttributes.locations,\r\n      representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\r\n    };\r\n  };\r\n\r\n  var stringToMpdXml = function stringToMpdXml(manifestString) {\r\n    if (manifestString === '') {\r\n      throw new Error(errors.DASH_EMPTY_MANIFEST);\r\n    }\r\n\r\n    var parser = new DOMParser();\r\n    var xml;\r\n    var mpd;\r\n\r\n    try {\r\n      xml = parser.parseFromString(manifestString, 'application/xml');\r\n      mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\r\n    } catch (e) {// ie 11 throwsw on invalid xml\r\n    }\r\n\r\n    if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\r\n      throw new Error(errors.DASH_INVALID_XML);\r\n    }\r\n\r\n    return mpd;\r\n  };\r\n  /**\r\n   * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\r\n   *\r\n   * @param {string} mpd\r\n   *        XML string of the MPD manifest\r\n   * @return {Object|null}\r\n   *         Attributes of UTCTiming node specified in the manifest. Null if none found\r\n   */\r\n\r\n\r\n  var parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\r\n    var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\r\n\r\n    if (!UTCTimingNode) {\r\n      return null;\r\n    }\r\n\r\n    var attributes = parseAttributes(UTCTimingNode);\r\n\r\n    switch (attributes.schemeIdUri) {\r\n      case 'urn:mpeg:dash:utc:http-head:2014':\r\n      case 'urn:mpeg:dash:utc:http-head:2012':\r\n        attributes.method = 'HEAD';\r\n        break;\r\n\r\n      case 'urn:mpeg:dash:utc:http-xsdate:2014':\r\n      case 'urn:mpeg:dash:utc:http-iso:2014':\r\n      case 'urn:mpeg:dash:utc:http-xsdate:2012':\r\n      case 'urn:mpeg:dash:utc:http-iso:2012':\r\n        attributes.method = 'GET';\r\n        break;\r\n\r\n      case 'urn:mpeg:dash:utc:direct:2014':\r\n      case 'urn:mpeg:dash:utc:direct:2012':\r\n        attributes.method = 'DIRECT';\r\n        attributes.value = Date.parse(attributes.value);\r\n        break;\r\n\r\n      case 'urn:mpeg:dash:utc:http-ntp:2014':\r\n      case 'urn:mpeg:dash:utc:ntp:2014':\r\n      case 'urn:mpeg:dash:utc:sntp:2014':\r\n      default:\r\n        throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\r\n    }\r\n\r\n    return attributes;\r\n  };\r\n  /*\r\n   * Given a DASH manifest string and options, parses the DASH manifest into an object in the\r\n   * form outputed by m3u8-parser and accepted by videojs/http-streaming.\r\n   *\r\n   * For live DASH manifests, if `previousManifest` is provided in options, then the newly\r\n   * parsed DASH manifest will have its media sequence and discontinuity sequence values\r\n   * updated to reflect its position relative to the prior manifest.\r\n   *\r\n   * @param {string} manifestString - the DASH manifest as a string\r\n   * @param {options} [options] - any options\r\n   *\r\n   * @return {Object} the manifest object\r\n   */\r\n\r\n  var parse = function parse(manifestString, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\r\n    var playlists = toPlaylists(parsedManifestInfo.representationInfo);\r\n    return toM3u8({\r\n      dashPlaylists: playlists,\r\n      locations: parsedManifestInfo.locations,\r\n      sidxMapping: options.sidxMapping,\r\n      previousManifest: options.previousManifest\r\n    });\r\n  };\r\n  /**\r\n   * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\r\n   *\r\n   * @param {string} manifestString\r\n   *        XML string of the MPD manifest\r\n   * @return {Object|null}\r\n   *         Attributes of UTCTiming node specified in the manifest. Null if none found\r\n   */\r\n\r\n\r\n  var parseUTCTiming = function parseUTCTiming(manifestString) {\r\n    return parseUTCTimingScheme(stringToMpdXml(manifestString));\r\n  };\r\n\r\n  var MAX_UINT32 = Math.pow(2, 32);\r\n\r\n  var getUint64$1 = function getUint64(uint8) {\r\n    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\r\n    var value;\r\n\r\n    if (dv.getBigUint64) {\r\n      value = dv.getBigUint64(0);\r\n\r\n      if (value < Number.MAX_SAFE_INTEGER) {\r\n        return Number(value);\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);\r\n  };\r\n\r\n  var numbers = {\r\n    getUint64: getUint64$1,\r\n    MAX_UINT32: MAX_UINT32\r\n  };\r\n\r\n  var getUint64 = numbers.getUint64;\r\n\r\n  var parseSidx = function parseSidx(data) {\r\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\r\n        result = {\r\n      version: data[0],\r\n      flags: new Uint8Array(data.subarray(1, 4)),\r\n      references: [],\r\n      referenceId: view.getUint32(4),\r\n      timescale: view.getUint32(8)\r\n    },\r\n        i = 12;\r\n\r\n    if (result.version === 0) {\r\n      result.earliestPresentationTime = view.getUint32(i);\r\n      result.firstOffset = view.getUint32(i + 4);\r\n      i += 8;\r\n    } else {\r\n      // read 64 bits\r\n      result.earliestPresentationTime = getUint64(data.subarray(i));\r\n      result.firstOffset = getUint64(data.subarray(i + 8));\r\n      i += 16;\r\n    }\r\n\r\n    i += 2; // reserved\r\n\r\n    var referenceCount = view.getUint16(i);\r\n    i += 2; // start of references\r\n\r\n    for (; referenceCount > 0; i += 12, referenceCount--) {\r\n      result.references.push({\r\n        referenceType: (data[i] & 0x80) >>> 7,\r\n        referencedSize: view.getUint32(i) & 0x7FFFFFFF,\r\n        subsegmentDuration: view.getUint32(i + 4),\r\n        startsWithSap: !!(data[i + 8] & 0x80),\r\n        sapType: (data[i + 8] & 0x70) >>> 4,\r\n        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\r\n      });\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var parseSidx_1 = parseSidx;\r\n\r\n  var ID3 = toUint8([0x49, 0x44, 0x33]);\r\n  var getId3Size = function getId3Size(bytes, offset) {\r\n    if (offset === void 0) {\r\n      offset = 0;\r\n    }\r\n\r\n    bytes = toUint8(bytes);\r\n    var flags = bytes[offset + 5];\r\n    var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];\r\n    var footerPresent = (flags & 16) >> 4;\r\n\r\n    if (footerPresent) {\r\n      return returnSize + 20;\r\n    }\r\n\r\n    return returnSize + 10;\r\n  };\r\n  var getId3Offset = function getId3Offset(bytes, offset) {\r\n    if (offset === void 0) {\r\n      offset = 0;\r\n    }\r\n\r\n    bytes = toUint8(bytes);\r\n\r\n    if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {\r\n      offset: offset\r\n    })) {\r\n      return offset;\r\n    }\r\n\r\n    offset += getId3Size(bytes, offset); // recursive check for id3 tags as some files\r\n    // have multiple ID3 tag sections even though\r\n    // they should not.\r\n\r\n    return getId3Offset(bytes, offset);\r\n  };\r\n\r\n  var normalizePath$1 = function normalizePath(path) {\r\n    if (typeof path === 'string') {\r\n      return stringToBytes(path);\r\n    }\r\n\r\n    if (typeof path === 'number') {\r\n      return path;\r\n    }\r\n\r\n    return path;\r\n  };\r\n\r\n  var normalizePaths$1 = function normalizePaths(paths) {\r\n    if (!Array.isArray(paths)) {\r\n      return [normalizePath$1(paths)];\r\n    }\r\n\r\n    return paths.map(function (p) {\r\n      return normalizePath$1(p);\r\n    });\r\n  };\r\n  /**\r\n   * find any number of boxes by name given a path to it in an iso bmff\r\n   * such as mp4.\r\n   *\r\n   * @param {TypedArray} bytes\r\n   *        bytes for the iso bmff to search for boxes in\r\n   *\r\n   * @param {Uint8Array[]|string[]|string|Uint8Array} name\r\n   *        An array of paths or a single path representing the name\r\n   *        of boxes to search through in bytes. Paths may be\r\n   *        uint8 (character codes) or strings.\r\n   *\r\n   * @param {boolean} [complete=false]\r\n   *        Should we search only for complete boxes on the final path.\r\n   *        This is very useful when you do not want to get back partial boxes\r\n   *        in the case of streaming files.\r\n   *\r\n   * @return {Uint8Array[]}\r\n   *         An array of the end paths that we found.\r\n   */\r\n\r\n  var findBox = function findBox(bytes, paths, complete) {\r\n    if (complete === void 0) {\r\n      complete = false;\r\n    }\r\n\r\n    paths = normalizePaths$1(paths);\r\n    bytes = toUint8(bytes);\r\n    var results = [];\r\n\r\n    if (!paths.length) {\r\n      // short-circuit the search for empty paths\r\n      return results;\r\n    }\r\n\r\n    var i = 0;\r\n\r\n    while (i < bytes.length) {\r\n      var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\r\n      var type = bytes.subarray(i + 4, i + 8); // invalid box format.\r\n\r\n      if (size === 0) {\r\n        break;\r\n      }\r\n\r\n      var end = i + size;\r\n\r\n      if (end > bytes.length) {\r\n        // this box is bigger than the number of bytes we have\r\n        // and complete is set, we cannot find any more boxes.\r\n        if (complete) {\r\n          break;\r\n        }\r\n\r\n        end = bytes.length;\r\n      }\r\n\r\n      var data = bytes.subarray(i + 8, end);\r\n\r\n      if (bytesMatch(type, paths[0])) {\r\n        if (paths.length === 1) {\r\n          // this is the end of the path and we've found the box we were\r\n          // looking for\r\n          results.push(data);\r\n        } else {\r\n          // recursively search for the next box along the path\r\n          results.push.apply(results, findBox(data, paths.slice(1), complete));\r\n        }\r\n      }\r\n\r\n      i = end;\r\n    } // we've finished searching all of bytes\r\n\r\n\r\n    return results;\r\n  };\r\n\r\n  // https://matroska-org.github.io/libebml/specs.html\r\n  // https://www.matroska.org/technical/elements.html\r\n  // https://www.webmproject.org/docs/container/\r\n\r\n  var EBML_TAGS = {\r\n    EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\r\n    DocType: toUint8([0x42, 0x82]),\r\n    Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\r\n    SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\r\n    Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\r\n    Track: toUint8([0xAE]),\r\n    TrackNumber: toUint8([0xd7]),\r\n    DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\r\n    TrackEntry: toUint8([0xAE]),\r\n    TrackType: toUint8([0x83]),\r\n    FlagDefault: toUint8([0x88]),\r\n    CodecID: toUint8([0x86]),\r\n    CodecPrivate: toUint8([0x63, 0xA2]),\r\n    VideoTrack: toUint8([0xe0]),\r\n    AudioTrack: toUint8([0xe1]),\r\n    // Not used yet, but will be used for live webm/mkv\r\n    // see https://www.matroska.org/technical/basics.html#block-structure\r\n    // see https://www.matroska.org/technical/basics.html#simpleblock-structure\r\n    Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\r\n    Timestamp: toUint8([0xE7]),\r\n    TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\r\n    BlockGroup: toUint8([0xA0]),\r\n    BlockDuration: toUint8([0x9B]),\r\n    Block: toUint8([0xA1]),\r\n    SimpleBlock: toUint8([0xA3])\r\n  };\r\n  /**\r\n   * This is a simple table to determine the length\r\n   * of things in ebml. The length is one based (starts at 1,\r\n   * rather than zero) and for every zero bit before a one bit\r\n   * we add one to length. We also need this table because in some\r\n   * case we have to xor all the length bits from another value.\r\n   */\r\n\r\n  var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\r\n\r\n  var getLength = function getLength(_byte) {\r\n    var len = 1;\r\n\r\n    for (var i = 0; i < LENGTH_TABLE.length; i++) {\r\n      if (_byte & LENGTH_TABLE[i]) {\r\n        break;\r\n      }\r\n\r\n      len++;\r\n    }\r\n\r\n    return len;\r\n  }; // length in ebml is stored in the first 4 to 8 bits\r\n  // of the first byte. 4 for the id length and 8 for the\r\n  // data size length. Length is measured by converting the number to binary\r\n  // then 1 + the number of zeros before a 1 is encountered starting\r\n  // from the left.\r\n\r\n\r\n  var getvint = function getvint(bytes, offset, removeLength, signed) {\r\n    if (removeLength === void 0) {\r\n      removeLength = true;\r\n    }\r\n\r\n    if (signed === void 0) {\r\n      signed = false;\r\n    }\r\n\r\n    var length = getLength(bytes[offset]);\r\n    var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\r\n    // as they will be modified below to remove the dataSizeLen bits and we do not\r\n    // want to modify the original data. normally we could just call slice on\r\n    // uint8array but ie 11 does not support that...\r\n\r\n    if (removeLength) {\r\n      valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\r\n      valueBytes[0] ^= LENGTH_TABLE[length - 1];\r\n    }\r\n\r\n    return {\r\n      length: length,\r\n      value: bytesToNumber(valueBytes, {\r\n        signed: signed\r\n      }),\r\n      bytes: valueBytes\r\n    };\r\n  };\r\n\r\n  var normalizePath = function normalizePath(path) {\r\n    if (typeof path === 'string') {\r\n      return path.match(/.{1,2}/g).map(function (p) {\r\n        return normalizePath(p);\r\n      });\r\n    }\r\n\r\n    if (typeof path === 'number') {\r\n      return numberToBytes(path);\r\n    }\r\n\r\n    return path;\r\n  };\r\n\r\n  var normalizePaths = function normalizePaths(paths) {\r\n    if (!Array.isArray(paths)) {\r\n      return [normalizePath(paths)];\r\n    }\r\n\r\n    return paths.map(function (p) {\r\n      return normalizePath(p);\r\n    });\r\n  };\r\n\r\n  var getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\r\n    if (offset >= bytes.length) {\r\n      return bytes.length;\r\n    }\r\n\r\n    var innerid = getvint(bytes, offset, false);\r\n\r\n    if (bytesMatch(id.bytes, innerid.bytes)) {\r\n      return offset;\r\n    }\r\n\r\n    var dataHeader = getvint(bytes, offset + innerid.length);\r\n    return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\r\n  };\r\n  /**\r\n   * Notes on the EBLM format.\r\n   *\r\n   * EBLM uses \"vints\" tags. Every vint tag contains\r\n   * two parts\r\n   *\r\n   * 1. The length from the first byte. You get this by\r\n   *    converting the byte to binary and counting the zeros\r\n   *    before a 1. Then you add 1 to that. Examples\r\n   *    00011111 = length 4 because there are 3 zeros before a 1.\r\n   *    00100000 = length 3 because there are 2 zeros before a 1.\r\n   *    00000011 = length 7 because there are 6 zeros before a 1.\r\n   *\r\n   * 2. The bits used for length are removed from the first byte\r\n   *    Then all the bytes are merged into a value. NOTE: this\r\n   *    is not the case for id ebml tags as there id includes\r\n   *    length bits.\r\n   *\r\n   */\r\n\r\n\r\n  var findEbml = function findEbml(bytes, paths) {\r\n    paths = normalizePaths(paths);\r\n    bytes = toUint8(bytes);\r\n    var results = [];\r\n\r\n    if (!paths.length) {\r\n      return results;\r\n    }\r\n\r\n    var i = 0;\r\n\r\n    while (i < bytes.length) {\r\n      var id = getvint(bytes, i, false);\r\n      var dataHeader = getvint(bytes, i + id.length);\r\n      var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\r\n\r\n      if (dataHeader.value === 0x7f) {\r\n        dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\r\n\r\n        if (dataHeader.value !== bytes.length) {\r\n          dataHeader.value -= dataStart;\r\n        }\r\n      }\r\n\r\n      var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\r\n      var data = bytes.subarray(dataStart, dataEnd);\r\n\r\n      if (bytesMatch(paths[0], id.bytes)) {\r\n        if (paths.length === 1) {\r\n          // this is the end of the paths and we've found the tag we were\r\n          // looking for\r\n          results.push(data);\r\n        } else {\r\n          // recursively search for the next tag inside of the data\r\n          // of this one\r\n          results = results.concat(findEbml(data, paths.slice(1)));\r\n        }\r\n      }\r\n\r\n      var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\r\n\r\n      i += totalLength;\r\n    }\r\n\r\n    return results;\r\n  }; // see https://www.matroska.org/technical/basics.html#block-structure\r\n\r\n  var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\r\n  var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\r\n  var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\r\n  /**\r\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\r\n   * Sequence Payload\"\r\n   *\r\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\r\n   * unit\r\n   * @return {Uint8Array} the RBSP without any Emulation\r\n   * Prevention Bytes\r\n   */\r\n\r\n  var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\r\n    var positions = [];\r\n    var i = 1; // Find all `Emulation Prevention Bytes`\r\n\r\n    while (i < bytes.length - 2) {\r\n      if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\r\n        positions.push(i + 2);\r\n        i++;\r\n      }\r\n\r\n      i++;\r\n    } // If no Emulation Prevention Bytes were found just return the original\r\n    // array\r\n\r\n\r\n    if (positions.length === 0) {\r\n      return bytes;\r\n    } // Create a new array to hold the NAL unit data\r\n\r\n\r\n    var newLength = bytes.length - positions.length;\r\n    var newData = new Uint8Array(newLength);\r\n    var sourceIndex = 0;\r\n\r\n    for (i = 0; i < newLength; sourceIndex++, i++) {\r\n      if (sourceIndex === positions[0]) {\r\n        // Skip this byte\r\n        sourceIndex++; // Remove this position index\r\n\r\n        positions.shift();\r\n      }\r\n\r\n      newData[i] = bytes[sourceIndex];\r\n    }\r\n\r\n    return newData;\r\n  };\r\n  var findNal = function findNal(bytes, dataType, types, nalLimit) {\r\n    if (nalLimit === void 0) {\r\n      nalLimit = Infinity;\r\n    }\r\n\r\n    bytes = toUint8(bytes);\r\n    types = [].concat(types);\r\n    var i = 0;\r\n    var nalStart;\r\n    var nalsFound = 0; // keep searching until:\r\n    // we reach the end of bytes\r\n    // we reach the maximum number of nals they want to seach\r\n    // NOTE: that we disregard nalLimit when we have found the start\r\n    // of the nal we want so that we can find the end of the nal we want.\r\n\r\n    while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\r\n      var nalOffset = void 0;\r\n\r\n      if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\r\n        nalOffset = 4;\r\n      } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\r\n        nalOffset = 3;\r\n      } // we are unsynced,\r\n      // find the next nal unit\r\n\r\n\r\n      if (!nalOffset) {\r\n        i++;\r\n        continue;\r\n      }\r\n\r\n      nalsFound++;\r\n\r\n      if (nalStart) {\r\n        return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\r\n      }\r\n\r\n      var nalType = void 0;\r\n\r\n      if (dataType === 'h264') {\r\n        nalType = bytes[i + nalOffset] & 0x1f;\r\n      } else if (dataType === 'h265') {\r\n        nalType = bytes[i + nalOffset] >> 1 & 0x3f;\r\n      }\r\n\r\n      if (types.indexOf(nalType) !== -1) {\r\n        nalStart = i + nalOffset;\r\n      } // nal header is 1 length for h264, and 2 for h265\r\n\r\n\r\n      i += nalOffset + (dataType === 'h264' ? 1 : 2);\r\n    }\r\n\r\n    return bytes.subarray(0, 0);\r\n  };\r\n  var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\r\n    return findNal(bytes, 'h264', type, nalLimit);\r\n  };\r\n  var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\r\n    return findNal(bytes, 'h265', type, nalLimit);\r\n  };\r\n\r\n  var CONSTANTS = {\r\n    // \"webm\" string literal in hex\r\n    'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\r\n    // \"matroska\" string literal in hex\r\n    'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\r\n    // \"fLaC\" string literal in hex\r\n    'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\r\n    // \"OggS\" string literal in hex\r\n    'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\r\n    // ac-3 sync byte, also works for ec-3 as that is simply a codec\r\n    // of ac-3\r\n    'ac3': toUint8([0x0b, 0x77]),\r\n    // \"RIFF\" string literal in hex used for wav and avi\r\n    'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\r\n    // \"AVI\" string literal in hex\r\n    'avi': toUint8([0x41, 0x56, 0x49]),\r\n    // \"WAVE\" string literal in hex\r\n    'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\r\n    // \"ftyp3g\" string literal in hex\r\n    '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\r\n    // \"ftyp\" string literal in hex\r\n    'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\r\n    // \"styp\" string literal in hex\r\n    'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\r\n    // \"ftypqt\" string literal in hex\r\n    'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\r\n    // moov string literal in hex\r\n    'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\r\n    // moof string literal in hex\r\n    'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\r\n  };\r\n  var _isLikely = {\r\n    aac: function aac(bytes) {\r\n      var offset = getId3Offset(bytes);\r\n      return bytesMatch(bytes, [0xFF, 0x10], {\r\n        offset: offset,\r\n        mask: [0xFF, 0x16]\r\n      });\r\n    },\r\n    mp3: function mp3(bytes) {\r\n      var offset = getId3Offset(bytes);\r\n      return bytesMatch(bytes, [0xFF, 0x02], {\r\n        offset: offset,\r\n        mask: [0xFF, 0x06]\r\n      });\r\n    },\r\n    webm: function webm(bytes) {\r\n      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\r\n\r\n      return bytesMatch(docType, CONSTANTS.webm);\r\n    },\r\n    mkv: function mkv(bytes) {\r\n      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\r\n\r\n      return bytesMatch(docType, CONSTANTS.matroska);\r\n    },\r\n    mp4: function mp4(bytes) {\r\n      // if this file is another base media file format, it is not mp4\r\n      if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\r\n        return false;\r\n      } // if this file starts with a ftyp or styp box its mp4\r\n\r\n\r\n      if (bytesMatch(bytes, CONSTANTS.mp4, {\r\n        offset: 4\r\n      }) || bytesMatch(bytes, CONSTANTS.fmp4, {\r\n        offset: 4\r\n      })) {\r\n        return true;\r\n      } // if this file starts with a moof/moov box its mp4\r\n\r\n\r\n      if (bytesMatch(bytes, CONSTANTS.moof, {\r\n        offset: 4\r\n      }) || bytesMatch(bytes, CONSTANTS.moov, {\r\n        offset: 4\r\n      })) {\r\n        return true;\r\n      }\r\n    },\r\n    mov: function mov(bytes) {\r\n      return bytesMatch(bytes, CONSTANTS.mov, {\r\n        offset: 4\r\n      });\r\n    },\r\n    '3gp': function gp(bytes) {\r\n      return bytesMatch(bytes, CONSTANTS['3gp'], {\r\n        offset: 4\r\n      });\r\n    },\r\n    ac3: function ac3(bytes) {\r\n      var offset = getId3Offset(bytes);\r\n      return bytesMatch(bytes, CONSTANTS.ac3, {\r\n        offset: offset\r\n      });\r\n    },\r\n    ts: function ts(bytes) {\r\n      if (bytes.length < 189 && bytes.length >= 1) {\r\n        return bytes[0] === 0x47;\r\n      }\r\n\r\n      var i = 0; // check the first 376 bytes for two matching sync bytes\r\n\r\n      while (i + 188 < bytes.length && i < 188) {\r\n        if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\r\n          return true;\r\n        }\r\n\r\n        i += 1;\r\n      }\r\n\r\n      return false;\r\n    },\r\n    flac: function flac(bytes) {\r\n      var offset = getId3Offset(bytes);\r\n      return bytesMatch(bytes, CONSTANTS.flac, {\r\n        offset: offset\r\n      });\r\n    },\r\n    ogg: function ogg(bytes) {\r\n      return bytesMatch(bytes, CONSTANTS.ogg);\r\n    },\r\n    avi: function avi(bytes) {\r\n      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\r\n        offset: 8\r\n      });\r\n    },\r\n    wav: function wav(bytes) {\r\n      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\r\n        offset: 8\r\n      });\r\n    },\r\n    'h264': function h264(bytes) {\r\n      // find seq_parameter_set_rbsp\r\n      return findH264Nal(bytes, 7, 3).length;\r\n    },\r\n    'h265': function h265(bytes) {\r\n      // find video_parameter_set_rbsp or seq_parameter_set_rbsp\r\n      return findH265Nal(bytes, [32, 33], 3).length;\r\n    }\r\n  }; // get all the isLikely functions\r\n  // but make sure 'ts' is above h264 and h265\r\n  // but below everything else as it is the least specific\r\n\r\n  var isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\r\n  .filter(function (t) {\r\n    return t !== 'ts' && t !== 'h264' && t !== 'h265';\r\n  }) // add it back to the bottom\r\n  .concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\r\n\r\n  isLikelyTypes.forEach(function (type) {\r\n    var isLikelyFn = _isLikely[type];\r\n\r\n    _isLikely[type] = function (bytes) {\r\n      return isLikelyFn(toUint8(bytes));\r\n    };\r\n  }); // export after wrapping\r\n\r\n  var isLikely = _isLikely; // A useful list of file signatures can be found here\r\n  // https://en.wikipedia.org/wiki/List_of_file_signatures\r\n\r\n  var detectContainerForBytes = function detectContainerForBytes(bytes) {\r\n    bytes = toUint8(bytes);\r\n\r\n    for (var i = 0; i < isLikelyTypes.length; i++) {\r\n      var type = isLikelyTypes[i];\r\n\r\n      if (isLikely[type](bytes)) {\r\n        return type;\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }; // fmp4 is not a container\r\n\r\n  var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\r\n    return findBox(bytes, ['moof']).length > 0;\r\n  };\r\n\r\n  /**\r\n   * mux.js\r\n   *\r\n   * Copyright (c) Brightcove\r\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n   */\r\n  var ONE_SECOND_IN_TS = 90000,\r\n      // 90kHz clock\r\n  secondsToVideoTs,\r\n      secondsToAudioTs,\r\n      videoTsToSeconds,\r\n      audioTsToSeconds,\r\n      audioTsToVideoTs,\r\n      videoTsToAudioTs,\r\n      metadataTsToSeconds;\r\n\r\n  secondsToVideoTs = function secondsToVideoTs(seconds) {\r\n    return seconds * ONE_SECOND_IN_TS;\r\n  };\r\n\r\n  secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\r\n    return seconds * sampleRate;\r\n  };\r\n\r\n  videoTsToSeconds = function videoTsToSeconds(timestamp) {\r\n    return timestamp / ONE_SECOND_IN_TS;\r\n  };\r\n\r\n  audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\r\n    return timestamp / sampleRate;\r\n  };\r\n\r\n  audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\r\n    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\r\n  };\r\n\r\n  videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\r\n    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\r\n  };\r\n  /**\r\n   * Adjust ID3 tag or caption timing information by the timeline pts values\r\n   * (if keepOriginalTimestamps is false) and convert to seconds\r\n   */\r\n\r\n\r\n  metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\r\n    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\r\n  };\r\n\r\n  var clock = {\r\n    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,\r\n    secondsToVideoTs: secondsToVideoTs,\r\n    secondsToAudioTs: secondsToAudioTs,\r\n    videoTsToSeconds: videoTsToSeconds,\r\n    audioTsToSeconds: audioTsToSeconds,\r\n    audioTsToVideoTs: audioTsToVideoTs,\r\n    videoTsToAudioTs: videoTsToAudioTs,\r\n    metadataTsToSeconds: metadataTsToSeconds\r\n  };\r\n  var clock_1 = clock.ONE_SECOND_IN_TS;\r\n\r\n  /*! @name @videojs/http-streaming @version 2.14.3 @license Apache-2.0 */\r\n  /**\r\n   * @file resolve-url.js - Handling how URLs are resolved and manipulated\r\n   */\r\n\r\n  var resolveUrl = resolveUrl$2;\r\n  /**\r\n   * Checks whether xhr request was redirected and returns correct url depending\r\n   * on `handleManifestRedirects` option\r\n   *\r\n   * @api private\r\n   *\r\n   * @param  {string} url - an url being requested\r\n   * @param  {XMLHttpRequest} req - xhr request result\r\n   *\r\n   * @return {string}\r\n   */\r\n\r\n  var resolveManifestRedirect = function resolveManifestRedirect(handleManifestRedirect, url, req) {\r\n    // To understand how the responseURL below is set and generated:\r\n    // - https://fetch.spec.whatwg.org/#concept-response-url\r\n    // - https://fetch.spec.whatwg.org/#atomic-http-redirect-handling\r\n    if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {\r\n      return req.responseURL;\r\n    }\r\n\r\n    return url;\r\n  };\r\n\r\n  var logger = function logger(source) {\r\n    if (videojs.log.debug) {\r\n      return videojs.log.debug.bind(videojs, 'VHS:', source + \" >\");\r\n    }\r\n\r\n    return function () {};\r\n  };\r\n  /**\r\n   * ranges\r\n   *\r\n   * Utilities for working with TimeRanges.\r\n   *\r\n   */\r\n\r\n\r\n  var TIME_FUDGE_FACTOR = 1 / 30; // Comparisons between time values such as current time and the end of the buffered range\r\n  // can be misleading because of precision differences or when the current media has poorly\r\n  // aligned audio and video, which can cause values to be slightly off from what you would\r\n  // expect. This value is what we consider to be safe to use in such comparisons to account\r\n  // for these scenarios.\r\n\r\n  var SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\r\n\r\n  var filterRanges = function filterRanges(timeRanges, predicate) {\r\n    var results = [];\r\n    var i;\r\n\r\n    if (timeRanges && timeRanges.length) {\r\n      // Search for ranges that match the predicate\r\n      for (i = 0; i < timeRanges.length; i++) {\r\n        if (predicate(timeRanges.start(i), timeRanges.end(i))) {\r\n          results.push([timeRanges.start(i), timeRanges.end(i)]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return videojs.createTimeRanges(results);\r\n  };\r\n  /**\r\n   * Attempts to find the buffered TimeRange that contains the specified\r\n   * time.\r\n   *\r\n   * @param {TimeRanges} buffered - the TimeRanges object to query\r\n   * @param {number} time  - the time to filter on.\r\n   * @return {TimeRanges} a new TimeRanges object\r\n   */\r\n\r\n\r\n  var findRange = function findRange(buffered, time) {\r\n    return filterRanges(buffered, function (start, end) {\r\n      return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;\r\n    });\r\n  };\r\n  /**\r\n   * Returns the TimeRanges that begin later than the specified time.\r\n   *\r\n   * @param {TimeRanges} timeRanges - the TimeRanges object to query\r\n   * @param {number} time - the time to filter on.\r\n   * @return {TimeRanges} a new TimeRanges object.\r\n   */\r\n\r\n\r\n  var findNextRange = function findNextRange(timeRanges, time) {\r\n    return filterRanges(timeRanges, function (start) {\r\n      return start - TIME_FUDGE_FACTOR >= time;\r\n    });\r\n  };\r\n  /**\r\n   * Returns gaps within a list of TimeRanges\r\n   *\r\n   * @param {TimeRanges} buffered - the TimeRanges object\r\n   * @return {TimeRanges} a TimeRanges object of gaps\r\n   */\r\n\r\n\r\n  var findGaps = function findGaps(buffered) {\r\n    if (buffered.length < 2) {\r\n      return videojs.createTimeRanges();\r\n    }\r\n\r\n    var ranges = [];\r\n\r\n    for (var i = 1; i < buffered.length; i++) {\r\n      var start = buffered.end(i - 1);\r\n      var end = buffered.start(i);\r\n      ranges.push([start, end]);\r\n    }\r\n\r\n    return videojs.createTimeRanges(ranges);\r\n  };\r\n  /**\r\n   * Calculate the intersection of two TimeRanges\r\n   *\r\n   * @param {TimeRanges} bufferA\r\n   * @param {TimeRanges} bufferB\r\n   * @return {TimeRanges} The interesection of `bufferA` with `bufferB`\r\n   */\r\n\r\n\r\n  var bufferIntersection = function bufferIntersection(bufferA, bufferB) {\r\n    var start = null;\r\n    var end = null;\r\n    var arity = 0;\r\n    var extents = [];\r\n    var ranges = [];\r\n\r\n    if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\r\n      return videojs.createTimeRange();\r\n    } // Handle the case where we have both buffers and create an\r\n    // intersection of the two\r\n\r\n\r\n    var count = bufferA.length; // A) Gather up all start and end times\r\n\r\n    while (count--) {\r\n      extents.push({\r\n        time: bufferA.start(count),\r\n        type: 'start'\r\n      });\r\n      extents.push({\r\n        time: bufferA.end(count),\r\n        type: 'end'\r\n      });\r\n    }\r\n\r\n    count = bufferB.length;\r\n\r\n    while (count--) {\r\n      extents.push({\r\n        time: bufferB.start(count),\r\n        type: 'start'\r\n      });\r\n      extents.push({\r\n        time: bufferB.end(count),\r\n        type: 'end'\r\n      });\r\n    } // B) Sort them by time\r\n\r\n\r\n    extents.sort(function (a, b) {\r\n      return a.time - b.time;\r\n    }); // C) Go along one by one incrementing arity for start and decrementing\r\n    //    arity for ends\r\n\r\n    for (count = 0; count < extents.length; count++) {\r\n      if (extents[count].type === 'start') {\r\n        arity++; // D) If arity is ever incremented to 2 we are entering an\r\n        //    overlapping range\r\n\r\n        if (arity === 2) {\r\n          start = extents[count].time;\r\n        }\r\n      } else if (extents[count].type === 'end') {\r\n        arity--; // E) If arity is ever decremented to 1 we leaving an\r\n        //    overlapping range\r\n\r\n        if (arity === 1) {\r\n          end = extents[count].time;\r\n        }\r\n      } // F) Record overlapping ranges\r\n\r\n\r\n      if (start !== null && end !== null) {\r\n        ranges.push([start, end]);\r\n        start = null;\r\n        end = null;\r\n      }\r\n    }\r\n\r\n    return videojs.createTimeRanges(ranges);\r\n  };\r\n  /**\r\n   * Gets a human readable string for a TimeRange\r\n   *\r\n   * @param {TimeRange} range\r\n   * @return {string} a human readable string\r\n   */\r\n\r\n\r\n  var printableRange = function printableRange(range) {\r\n    var strArr = [];\r\n\r\n    if (!range || !range.length) {\r\n      return '';\r\n    }\r\n\r\n    for (var i = 0; i < range.length; i++) {\r\n      strArr.push(range.start(i) + ' => ' + range.end(i));\r\n    }\r\n\r\n    return strArr.join(', ');\r\n  };\r\n  /**\r\n   * Calculates the amount of time left in seconds until the player hits the end of the\r\n   * buffer and causes a rebuffer\r\n   *\r\n   * @param {TimeRange} buffered\r\n   *        The state of the buffer\r\n   * @param {Numnber} currentTime\r\n   *        The current time of the player\r\n   * @param {number} playbackRate\r\n   *        The current playback rate of the player. Defaults to 1.\r\n   * @return {number}\r\n   *         Time until the player has to start rebuffering in seconds.\r\n   * @function timeUntilRebuffer\r\n   */\r\n\r\n\r\n  var timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime, playbackRate) {\r\n    if (playbackRate === void 0) {\r\n      playbackRate = 1;\r\n    }\r\n\r\n    var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\r\n    return (bufferedEnd - currentTime) / playbackRate;\r\n  };\r\n  /**\r\n   * Converts a TimeRanges object into an array representation\r\n   *\r\n   * @param {TimeRanges} timeRanges\r\n   * @return {Array}\r\n   */\r\n\r\n\r\n  var timeRangesToArray = function timeRangesToArray(timeRanges) {\r\n    var timeRangesList = [];\r\n\r\n    for (var i = 0; i < timeRanges.length; i++) {\r\n      timeRangesList.push({\r\n        start: timeRanges.start(i),\r\n        end: timeRanges.end(i)\r\n      });\r\n    }\r\n\r\n    return timeRangesList;\r\n  };\r\n  /**\r\n   * Determines if two time range objects are different.\r\n   *\r\n   * @param {TimeRange} a\r\n   *        the first time range object to check\r\n   *\r\n   * @param {TimeRange} b\r\n   *        the second time range object to check\r\n   *\r\n   * @return {Boolean}\r\n   *         Whether the time range objects differ\r\n   */\r\n\r\n\r\n  var isRangeDifferent = function isRangeDifferent(a, b) {\r\n    // same object\r\n    if (a === b) {\r\n      return false;\r\n    } // one or the other is undefined\r\n\r\n\r\n    if (!a && b || !b && a) {\r\n      return true;\r\n    } // length is different\r\n\r\n\r\n    if (a.length !== b.length) {\r\n      return true;\r\n    } // see if any start/end pair is different\r\n\r\n\r\n    for (var i = 0; i < a.length; i++) {\r\n      if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {\r\n        return true;\r\n      }\r\n    } // if the length and every pair is the same\r\n    // this is the same time range\r\n\r\n\r\n    return false;\r\n  };\r\n\r\n  var lastBufferedEnd = function lastBufferedEnd(a) {\r\n    if (!a || !a.length || !a.end) {\r\n      return;\r\n    }\r\n\r\n    return a.end(a.length - 1);\r\n  };\r\n  /**\r\n   * A utility function to add up the amount of time in a timeRange\r\n   * after a specified startTime.\r\n   * ie:[[0, 10], [20, 40], [50, 60]] with a startTime 0\r\n   *     would return 40 as there are 40s seconds after 0 in the timeRange\r\n   *\r\n   * @param {TimeRange} range\r\n   *        The range to check against\r\n   * @param {number} startTime\r\n   *        The time in the time range that you should start counting from\r\n   *\r\n   * @return {number}\r\n   *          The number of seconds in the buffer passed the specified time.\r\n   */\r\n\r\n\r\n  var timeAheadOf = function timeAheadOf(range, startTime) {\r\n    var time = 0;\r\n\r\n    if (!range || !range.length) {\r\n      return time;\r\n    }\r\n\r\n    for (var i = 0; i < range.length; i++) {\r\n      var start = range.start(i);\r\n      var end = range.end(i); // startTime is after this range entirely\r\n\r\n      if (startTime > end) {\r\n        continue;\r\n      } // startTime is within this range\r\n\r\n\r\n      if (startTime > start && startTime <= end) {\r\n        time += end - startTime;\r\n        continue;\r\n      } // startTime is before this range.\r\n\r\n\r\n      time += end - start;\r\n    }\r\n\r\n    return time;\r\n  };\r\n  /**\r\n   * @file playlist.js\r\n   *\r\n   * Playlist related utilities.\r\n   */\r\n\r\n\r\n  var createTimeRange = videojs.createTimeRange;\r\n  /**\r\n   * Get the duration of a segment, with special cases for\r\n   * llhls segments that do not have a duration yet.\r\n   *\r\n   * @param {Object} playlist\r\n   *        the playlist that the segment belongs to.\r\n   * @param {Object} segment\r\n   *        the segment to get a duration for.\r\n   *\r\n   * @return {number}\r\n   *          the segment duration\r\n   */\r\n\r\n  var segmentDurationWithParts = function segmentDurationWithParts(playlist, segment) {\r\n    // if this isn't a preload segment\r\n    // then we will have a segment duration that is accurate.\r\n    if (!segment.preload) {\r\n      return segment.duration;\r\n    } // otherwise we have to add up parts and preload hints\r\n    // to get an up to date duration.\r\n\r\n\r\n    var result = 0;\r\n    (segment.parts || []).forEach(function (p) {\r\n      result += p.duration;\r\n    }); // for preload hints we have to use partTargetDuration\r\n    // as they won't even have a duration yet.\r\n\r\n    (segment.preloadHints || []).forEach(function (p) {\r\n      if (p.type === 'PART') {\r\n        result += playlist.partTargetDuration;\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n  /**\r\n   * A function to get a combined list of parts and segments with durations\r\n   * and indexes.\r\n   *\r\n   * @param {Playlist} playlist the playlist to get the list for.\r\n   *\r\n   * @return {Array} The part/segment list.\r\n   */\r\n\r\n\r\n  var getPartsAndSegments = function getPartsAndSegments(playlist) {\r\n    return (playlist.segments || []).reduce(function (acc, segment, si) {\r\n      if (segment.parts) {\r\n        segment.parts.forEach(function (part, pi) {\r\n          acc.push({\r\n            duration: part.duration,\r\n            segmentIndex: si,\r\n            partIndex: pi,\r\n            part: part,\r\n            segment: segment\r\n          });\r\n        });\r\n      } else {\r\n        acc.push({\r\n          duration: segment.duration,\r\n          segmentIndex: si,\r\n          partIndex: null,\r\n          segment: segment,\r\n          part: null\r\n        });\r\n      }\r\n\r\n      return acc;\r\n    }, []);\r\n  };\r\n\r\n  var getLastParts = function getLastParts(media) {\r\n    var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];\r\n    return lastSegment && lastSegment.parts || [];\r\n  };\r\n\r\n  var getKnownPartCount = function getKnownPartCount(_ref) {\r\n    var preloadSegment = _ref.preloadSegment;\r\n\r\n    if (!preloadSegment) {\r\n      return;\r\n    }\r\n\r\n    var parts = preloadSegment.parts,\r\n        preloadHints = preloadSegment.preloadHints;\r\n    var partCount = (preloadHints || []).reduce(function (count, hint) {\r\n      return count + (hint.type === 'PART' ? 1 : 0);\r\n    }, 0);\r\n    partCount += parts && parts.length ? parts.length : 0;\r\n    return partCount;\r\n  };\r\n  /**\r\n   * Get the number of seconds to delay from the end of a\r\n   * live playlist.\r\n   *\r\n   * @param {Playlist} master the master playlist\r\n   * @param {Playlist} media the media playlist\r\n   * @return {number} the hold back in seconds.\r\n   */\r\n\r\n\r\n  var liveEdgeDelay = function liveEdgeDelay(master, media) {\r\n    if (media.endList) {\r\n      return 0;\r\n    } // dash suggestedPresentationDelay trumps everything\r\n\r\n\r\n    if (master && master.suggestedPresentationDelay) {\r\n      return master.suggestedPresentationDelay;\r\n    }\r\n\r\n    var hasParts = getLastParts(media).length > 0; // look for \"part\" delays from ll-hls first\r\n\r\n    if (hasParts && media.serverControl && media.serverControl.partHoldBack) {\r\n      return media.serverControl.partHoldBack;\r\n    } else if (hasParts && media.partTargetDuration) {\r\n      return media.partTargetDuration * 3; // finally look for full segment delays\r\n    } else if (media.serverControl && media.serverControl.holdBack) {\r\n      return media.serverControl.holdBack;\r\n    } else if (media.targetDuration) {\r\n      return media.targetDuration * 3;\r\n    }\r\n\r\n    return 0;\r\n  };\r\n  /**\r\n   * walk backward until we find a duration we can use\r\n   * or return a failure\r\n   *\r\n   * @param {Playlist} playlist the playlist to walk through\r\n   * @param {Number} endSequence the mediaSequence to stop walking on\r\n   */\r\n\r\n\r\n  var backwardDuration = function backwardDuration(playlist, endSequence) {\r\n    var result = 0;\r\n    var i = endSequence - playlist.mediaSequence; // if a start time is available for segment immediately following\r\n    // the interval, use it\r\n\r\n    var segment = playlist.segments[i]; // Walk backward until we find the latest segment with timeline\r\n    // information that is earlier than endSequence\r\n\r\n    if (segment) {\r\n      if (typeof segment.start !== 'undefined') {\r\n        return {\r\n          result: segment.start,\r\n          precise: true\r\n        };\r\n      }\r\n\r\n      if (typeof segment.end !== 'undefined') {\r\n        return {\r\n          result: segment.end - segment.duration,\r\n          precise: true\r\n        };\r\n      }\r\n    }\r\n\r\n    while (i--) {\r\n      segment = playlist.segments[i];\r\n\r\n      if (typeof segment.end !== 'undefined') {\r\n        return {\r\n          result: result + segment.end,\r\n          precise: true\r\n        };\r\n      }\r\n\r\n      result += segmentDurationWithParts(playlist, segment);\r\n\r\n      if (typeof segment.start !== 'undefined') {\r\n        return {\r\n          result: result + segment.start,\r\n          precise: true\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      result: result,\r\n      precise: false\r\n    };\r\n  };\r\n  /**\r\n   * walk forward until we find a duration we can use\r\n   * or return a failure\r\n   *\r\n   * @param {Playlist} playlist the playlist to walk through\r\n   * @param {number} endSequence the mediaSequence to stop walking on\r\n   */\r\n\r\n\r\n  var forwardDuration = function forwardDuration(playlist, endSequence) {\r\n    var result = 0;\r\n    var segment;\r\n    var i = endSequence - playlist.mediaSequence; // Walk forward until we find the earliest segment with timeline\r\n    // information\r\n\r\n    for (; i < playlist.segments.length; i++) {\r\n      segment = playlist.segments[i];\r\n\r\n      if (typeof segment.start !== 'undefined') {\r\n        return {\r\n          result: segment.start - result,\r\n          precise: true\r\n        };\r\n      }\r\n\r\n      result += segmentDurationWithParts(playlist, segment);\r\n\r\n      if (typeof segment.end !== 'undefined') {\r\n        return {\r\n          result: segment.end - result,\r\n          precise: true\r\n        };\r\n      }\r\n    } // indicate we didn't find a useful duration estimate\r\n\r\n\r\n    return {\r\n      result: -1,\r\n      precise: false\r\n    };\r\n  };\r\n  /**\r\n    * Calculate the media duration from the segments associated with a\r\n    * playlist. The duration of a subinterval of the available segments\r\n    * may be calculated by specifying an end index.\r\n    *\r\n    * @param {Object} playlist a media playlist object\r\n    * @param {number=} endSequence an exclusive upper boundary\r\n    * for the playlist.  Defaults to playlist length.\r\n    * @param {number} expired the amount of time that has dropped\r\n    * off the front of the playlist in a live scenario\r\n    * @return {number} the duration between the first available segment\r\n    * and end index.\r\n    */\r\n\r\n\r\n  var intervalDuration = function intervalDuration(playlist, endSequence, expired) {\r\n    if (typeof endSequence === 'undefined') {\r\n      endSequence = playlist.mediaSequence + playlist.segments.length;\r\n    }\r\n\r\n    if (endSequence < playlist.mediaSequence) {\r\n      return 0;\r\n    } // do a backward walk to estimate the duration\r\n\r\n\r\n    var backward = backwardDuration(playlist, endSequence);\r\n\r\n    if (backward.precise) {\r\n      // if we were able to base our duration estimate on timing\r\n      // information provided directly from the Media Source, return\r\n      // it\r\n      return backward.result;\r\n    } // walk forward to see if a precise duration estimate can be made\r\n    // that way\r\n\r\n\r\n    var forward = forwardDuration(playlist, endSequence);\r\n\r\n    if (forward.precise) {\r\n      // we found a segment that has been buffered and so it's\r\n      // position is known precisely\r\n      return forward.result;\r\n    } // return the less-precise, playlist-based duration estimate\r\n\r\n\r\n    return backward.result + expired;\r\n  };\r\n  /**\r\n    * Calculates the duration of a playlist. If a start and end index\r\n    * are specified, the duration will be for the subset of the media\r\n    * timeline between those two indices. The total duration for live\r\n    * playlists is always Infinity.\r\n    *\r\n    * @param {Object} playlist a media playlist object\r\n    * @param {number=} endSequence an exclusive upper\r\n    * boundary for the playlist. Defaults to the playlist media\r\n    * sequence number plus its length.\r\n    * @param {number=} expired the amount of time that has\r\n    * dropped off the front of the playlist in a live scenario\r\n    * @return {number} the duration between the start index and end\r\n    * index.\r\n    */\r\n\r\n\r\n  var duration = function duration(playlist, endSequence, expired) {\r\n    if (!playlist) {\r\n      return 0;\r\n    }\r\n\r\n    if (typeof expired !== 'number') {\r\n      expired = 0;\r\n    } // if a slice of the total duration is not requested, use\r\n    // playlist-level duration indicators when they're present\r\n\r\n\r\n    if (typeof endSequence === 'undefined') {\r\n      // if present, use the duration specified in the playlist\r\n      if (playlist.totalDuration) {\r\n        return playlist.totalDuration;\r\n      } // duration should be Infinity for live playlists\r\n\r\n\r\n      if (!playlist.endList) {\r\n        return window.Infinity;\r\n      }\r\n    } // calculate the total duration based on the segment durations\r\n\r\n\r\n    return intervalDuration(playlist, endSequence, expired);\r\n  };\r\n  /**\r\n    * Calculate the time between two indexes in the current playlist\r\n    * neight the start- nor the end-index need to be within the current\r\n    * playlist in which case, the targetDuration of the playlist is used\r\n    * to approximate the durations of the segments\r\n    *\r\n    * @param {Array} options.durationList list to iterate over for durations.\r\n    * @param {number} options.defaultDuration duration to use for elements before or after the durationList\r\n    * @param {number} options.startIndex partsAndSegments index to start\r\n    * @param {number} options.endIndex partsAndSegments index to end.\r\n    * @return {number} the number of seconds between startIndex and endIndex\r\n    */\r\n\r\n\r\n  var sumDurations = function sumDurations(_ref2) {\r\n    var defaultDuration = _ref2.defaultDuration,\r\n        durationList = _ref2.durationList,\r\n        startIndex = _ref2.startIndex,\r\n        endIndex = _ref2.endIndex;\r\n    var durations = 0;\r\n\r\n    if (startIndex > endIndex) {\r\n      var _ref3 = [endIndex, startIndex];\r\n      startIndex = _ref3[0];\r\n      endIndex = _ref3[1];\r\n    }\r\n\r\n    if (startIndex < 0) {\r\n      for (var i = startIndex; i < Math.min(0, endIndex); i++) {\r\n        durations += defaultDuration;\r\n      }\r\n\r\n      startIndex = 0;\r\n    }\r\n\r\n    for (var _i = startIndex; _i < endIndex; _i++) {\r\n      durations += durationList[_i].duration;\r\n    }\r\n\r\n    return durations;\r\n  };\r\n  /**\r\n   * Calculates the playlist end time\r\n   *\r\n   * @param {Object} playlist a media playlist object\r\n   * @param {number=} expired the amount of time that has\r\n   *                  dropped off the front of the playlist in a live scenario\r\n   * @param {boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\r\n   *                        playlist end calculation should consider the safe live end\r\n   *                        (truncate the playlist end by three segments). This is normally\r\n   *                        used for calculating the end of the playlist's seekable range.\r\n   *                        This takes into account the value of liveEdgePadding.\r\n   *                        Setting liveEdgePadding to 0 is equivalent to setting this to false.\r\n   * @param {number} liveEdgePadding a number indicating how far from the end of the playlist we should be in seconds.\r\n   *                 If this is provided, it is used in the safe live end calculation.\r\n   *                 Setting useSafeLiveEnd=false or liveEdgePadding=0 are equivalent.\r\n   *                 Corresponds to suggestedPresentationDelay in DASH manifests.\r\n   * @return {number} the end time of playlist\r\n   * @function playlistEnd\r\n   */\r\n\r\n\r\n  var playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding) {\r\n    if (!playlist || !playlist.segments) {\r\n      return null;\r\n    }\r\n\r\n    if (playlist.endList) {\r\n      return duration(playlist);\r\n    }\r\n\r\n    if (expired === null) {\r\n      return null;\r\n    }\r\n\r\n    expired = expired || 0;\r\n    var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);\r\n\r\n    if (useSafeLiveEnd) {\r\n      liveEdgePadding = typeof liveEdgePadding === 'number' ? liveEdgePadding : liveEdgeDelay(null, playlist);\r\n      lastSegmentEndTime -= liveEdgePadding;\r\n    } // don't return a time less than zero\r\n\r\n\r\n    return Math.max(0, lastSegmentEndTime);\r\n  };\r\n  /**\r\n    * Calculates the interval of time that is currently seekable in a\r\n    * playlist. The returned time ranges are relative to the earliest\r\n    * moment in the specified playlist that is still available. A full\r\n    * seekable implementation for live streams would need to offset\r\n    * these values by the duration of content that has expired from the\r\n    * stream.\r\n    *\r\n    * @param {Object} playlist a media playlist object\r\n    * dropped off the front of the playlist in a live scenario\r\n    * @param {number=} expired the amount of time that has\r\n    * dropped off the front of the playlist in a live scenario\r\n    * @param {number} liveEdgePadding how far from the end of the playlist we should be in seconds.\r\n    *        Corresponds to suggestedPresentationDelay in DASH manifests.\r\n    * @return {TimeRanges} the periods of time that are valid targets\r\n    * for seeking\r\n    */\r\n\r\n\r\n  var seekable = function seekable(playlist, expired, liveEdgePadding) {\r\n    var useSafeLiveEnd = true;\r\n    var seekableStart = expired || 0;\r\n    var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);\r\n\r\n    if (seekableEnd === null) {\r\n      return createTimeRange();\r\n    }\r\n\r\n    return createTimeRange(seekableStart, seekableEnd);\r\n  };\r\n  /**\r\n   * Determine the index and estimated starting time of the segment that\r\n   * contains a specified playback position in a media playlist.\r\n   *\r\n   * @param {Object} options.playlist the media playlist to query\r\n   * @param {number} options.currentTime The number of seconds since the earliest\r\n   * possible position to determine the containing segment for\r\n   * @param {number} options.startTime the time when the segment/part starts\r\n   * @param {number} options.startingSegmentIndex the segment index to start looking at.\r\n   * @param {number?} [options.startingPartIndex] the part index to look at within the segment.\r\n   *\r\n   * @return {Object} an object with partIndex, segmentIndex, and startTime.\r\n   */\r\n\r\n\r\n  var getMediaInfoForTime = function getMediaInfoForTime(_ref4) {\r\n    var playlist = _ref4.playlist,\r\n        currentTime = _ref4.currentTime,\r\n        startingSegmentIndex = _ref4.startingSegmentIndex,\r\n        startingPartIndex = _ref4.startingPartIndex,\r\n        startTime = _ref4.startTime,\r\n        experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings;\r\n    var time = currentTime - startTime;\r\n    var partsAndSegments = getPartsAndSegments(playlist);\r\n    var startIndex = 0;\r\n\r\n    for (var i = 0; i < partsAndSegments.length; i++) {\r\n      var partAndSegment = partsAndSegments[i];\r\n\r\n      if (startingSegmentIndex !== partAndSegment.segmentIndex) {\r\n        continue;\r\n      } // skip this if part index does not match.\r\n\r\n\r\n      if (typeof startingPartIndex === 'number' && typeof partAndSegment.partIndex === 'number' && startingPartIndex !== partAndSegment.partIndex) {\r\n        continue;\r\n      }\r\n\r\n      startIndex = i;\r\n      break;\r\n    }\r\n\r\n    if (time < 0) {\r\n      // Walk backward from startIndex in the playlist, adding durations\r\n      // until we find a segment that contains `time` and return it\r\n      if (startIndex > 0) {\r\n        for (var _i2 = startIndex - 1; _i2 >= 0; _i2--) {\r\n          var _partAndSegment = partsAndSegments[_i2];\r\n          time += _partAndSegment.duration;\r\n\r\n          if (experimentalExactManifestTimings) {\r\n            if (time < 0) {\r\n              continue;\r\n            }\r\n          } else if (time + TIME_FUDGE_FACTOR <= 0) {\r\n            continue;\r\n          }\r\n\r\n          return {\r\n            partIndex: _partAndSegment.partIndex,\r\n            segmentIndex: _partAndSegment.segmentIndex,\r\n            startTime: startTime - sumDurations({\r\n              defaultDuration: playlist.targetDuration,\r\n              durationList: partsAndSegments,\r\n              startIndex: startIndex,\r\n              endIndex: _i2\r\n            })\r\n          };\r\n        }\r\n      } // We were unable to find a good segment within the playlist\r\n      // so select the first segment\r\n\r\n\r\n      return {\r\n        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\r\n        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\r\n        startTime: currentTime\r\n      };\r\n    } // When startIndex is negative, we first walk forward to first segment\r\n    // adding target durations. If we \"run out of time\" before getting to\r\n    // the first segment, return the first segment\r\n\r\n\r\n    if (startIndex < 0) {\r\n      for (var _i3 = startIndex; _i3 < 0; _i3++) {\r\n        time -= playlist.targetDuration;\r\n\r\n        if (time < 0) {\r\n          return {\r\n            partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\r\n            segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\r\n            startTime: currentTime\r\n          };\r\n        }\r\n      }\r\n\r\n      startIndex = 0;\r\n    } // Walk forward from startIndex in the playlist, subtracting durations\r\n    // until we find a segment that contains `time` and return it\r\n\r\n\r\n    for (var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++) {\r\n      var _partAndSegment2 = partsAndSegments[_i4];\r\n      time -= _partAndSegment2.duration;\r\n\r\n      if (experimentalExactManifestTimings) {\r\n        if (time > 0) {\r\n          continue;\r\n        }\r\n      } else if (time - TIME_FUDGE_FACTOR >= 0) {\r\n        continue;\r\n      }\r\n\r\n      return {\r\n        partIndex: _partAndSegment2.partIndex,\r\n        segmentIndex: _partAndSegment2.segmentIndex,\r\n        startTime: startTime + sumDurations({\r\n          defaultDuration: playlist.targetDuration,\r\n          durationList: partsAndSegments,\r\n          startIndex: startIndex,\r\n          endIndex: _i4\r\n        })\r\n      };\r\n    } // We are out of possible candidates so load the last one...\r\n\r\n\r\n    return {\r\n      segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,\r\n      partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,\r\n      startTime: currentTime\r\n    };\r\n  };\r\n  /**\r\n   * Check whether the playlist is blacklisted or not.\r\n   *\r\n   * @param {Object} playlist the media playlist object\r\n   * @return {boolean} whether the playlist is blacklisted or not\r\n   * @function isBlacklisted\r\n   */\r\n\r\n\r\n  var isBlacklisted = function isBlacklisted(playlist) {\r\n    return playlist.excludeUntil && playlist.excludeUntil > Date.now();\r\n  };\r\n  /**\r\n   * Check whether the playlist is compatible with current playback configuration or has\r\n   * been blacklisted permanently for being incompatible.\r\n   *\r\n   * @param {Object} playlist the media playlist object\r\n   * @return {boolean} whether the playlist is incompatible or not\r\n   * @function isIncompatible\r\n   */\r\n\r\n\r\n  var isIncompatible = function isIncompatible(playlist) {\r\n    return playlist.excludeUntil && playlist.excludeUntil === Infinity;\r\n  };\r\n  /**\r\n   * Check whether the playlist is enabled or not.\r\n   *\r\n   * @param {Object} playlist the media playlist object\r\n   * @return {boolean} whether the playlist is enabled or not\r\n   * @function isEnabled\r\n   */\r\n\r\n\r\n  var isEnabled = function isEnabled(playlist) {\r\n    var blacklisted = isBlacklisted(playlist);\r\n    return !playlist.disabled && !blacklisted;\r\n  };\r\n  /**\r\n   * Check whether the playlist has been manually disabled through the representations api.\r\n   *\r\n   * @param {Object} playlist the media playlist object\r\n   * @return {boolean} whether the playlist is disabled manually or not\r\n   * @function isDisabled\r\n   */\r\n\r\n\r\n  var isDisabled = function isDisabled(playlist) {\r\n    return playlist.disabled;\r\n  };\r\n  /**\r\n   * Returns whether the current playlist is an AES encrypted HLS stream\r\n   *\r\n   * @return {boolean} true if it's an AES encrypted HLS stream\r\n   */\r\n\r\n\r\n  var isAes = function isAes(media) {\r\n    for (var i = 0; i < media.segments.length; i++) {\r\n      if (media.segments[i].key) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n  /**\r\n   * Checks if the playlist has a value for the specified attribute\r\n   *\r\n   * @param {string} attr\r\n   *        Attribute to check for\r\n   * @param {Object} playlist\r\n   *        The media playlist object\r\n   * @return {boolean}\r\n   *         Whether the playlist contains a value for the attribute or not\r\n   * @function hasAttribute\r\n   */\r\n\r\n\r\n  var hasAttribute = function hasAttribute(attr, playlist) {\r\n    return playlist.attributes && playlist.attributes[attr];\r\n  };\r\n  /**\r\n   * Estimates the time required to complete a segment download from the specified playlist\r\n   *\r\n   * @param {number} segmentDuration\r\n   *        Duration of requested segment\r\n   * @param {number} bandwidth\r\n   *        Current measured bandwidth of the player\r\n   * @param {Object} playlist\r\n   *        The media playlist object\r\n   * @param {number=} bytesReceived\r\n   *        Number of bytes already received for the request. Defaults to 0\r\n   * @return {number|NaN}\r\n   *         The estimated time to request the segment. NaN if bandwidth information for\r\n   *         the given playlist is unavailable\r\n   * @function estimateSegmentRequestTime\r\n   */\r\n\r\n\r\n  var estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist, bytesReceived) {\r\n    if (bytesReceived === void 0) {\r\n      bytesReceived = 0;\r\n    }\r\n\r\n    if (!hasAttribute('BANDWIDTH', playlist)) {\r\n      return NaN;\r\n    }\r\n\r\n    var size = segmentDuration * playlist.attributes.BANDWIDTH;\r\n    return (size - bytesReceived * 8) / bandwidth;\r\n  };\r\n  /*\r\n   * Returns whether the current playlist is the lowest rendition\r\n   *\r\n   * @return {Boolean} true if on lowest rendition\r\n   */\r\n\r\n\r\n  var isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {\r\n    if (master.playlists.length === 1) {\r\n      return true;\r\n    }\r\n\r\n    var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\r\n    return master.playlists.filter(function (playlist) {\r\n      if (!isEnabled(playlist)) {\r\n        return false;\r\n      }\r\n\r\n      return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\r\n    }).length === 0;\r\n  };\r\n\r\n  var playlistMatch = function playlistMatch(a, b) {\r\n    // both playlits are null\r\n    // or only one playlist is non-null\r\n    // no match\r\n    if (!a && !b || !a && b || a && !b) {\r\n      return false;\r\n    } // playlist objects are the same, match\r\n\r\n\r\n    if (a === b) {\r\n      return true;\r\n    } // first try to use id as it should be the most\r\n    // accurate\r\n\r\n\r\n    if (a.id && b.id && a.id === b.id) {\r\n      return true;\r\n    } // next try to use reslovedUri as it should be the\r\n    // second most accurate.\r\n\r\n\r\n    if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {\r\n      return true;\r\n    } // finally try to use uri as it should be accurate\r\n    // but might miss a few cases for relative uris\r\n\r\n\r\n    if (a.uri && b.uri && a.uri === b.uri) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  var someAudioVariant = function someAudioVariant(master, callback) {\r\n    var AUDIO = master && master.mediaGroups && master.mediaGroups.AUDIO || {};\r\n    var found = false;\r\n\r\n    for (var groupName in AUDIO) {\r\n      for (var label in AUDIO[groupName]) {\r\n        found = callback(AUDIO[groupName][label]);\r\n\r\n        if (found) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (found) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return !!found;\r\n  };\r\n\r\n  var isAudioOnly = function isAudioOnly(master) {\r\n    // we are audio only if we have no main playlists but do\r\n    // have media group playlists.\r\n    if (!master || !master.playlists || !master.playlists.length) {\r\n      // without audio variants or playlists this\r\n      // is not an audio only master.\r\n      var found = someAudioVariant(master, function (variant) {\r\n        return variant.playlists && variant.playlists.length || variant.uri;\r\n      });\r\n      return found;\r\n    } // if every playlist has only an audio codec it is audio only\r\n\r\n\r\n    var _loop = function _loop(i) {\r\n      var playlist = master.playlists[i];\r\n      var CODECS = playlist.attributes && playlist.attributes.CODECS; // all codecs are audio, this is an audio playlist.\r\n\r\n      if (CODECS && CODECS.split(',').every(function (c) {\r\n        return isAudioCodec(c);\r\n      })) {\r\n        return \"continue\";\r\n      } // playlist is in an audio group it is audio only\r\n\r\n\r\n      var found = someAudioVariant(master, function (variant) {\r\n        return playlistMatch(playlist, variant);\r\n      });\r\n\r\n      if (found) {\r\n        return \"continue\";\r\n      } // if we make it here this playlist isn't audio and we\r\n      // are not audio only\r\n\r\n\r\n      return {\r\n        v: false\r\n      };\r\n    };\r\n\r\n    for (var i = 0; i < master.playlists.length; i++) {\r\n      var _ret = _loop(i);\r\n\r\n      if (_ret === \"continue\") continue;\r\n      if (typeof _ret === \"object\") return _ret.v;\r\n    } // if we make it past every playlist without returning, then\r\n    // this is an audio only playlist.\r\n\r\n\r\n    return true;\r\n  }; // exports\r\n\r\n\r\n  var Playlist = {\r\n    liveEdgeDelay: liveEdgeDelay,\r\n    duration: duration,\r\n    seekable: seekable,\r\n    getMediaInfoForTime: getMediaInfoForTime,\r\n    isEnabled: isEnabled,\r\n    isDisabled: isDisabled,\r\n    isBlacklisted: isBlacklisted,\r\n    isIncompatible: isIncompatible,\r\n    playlistEnd: playlistEnd,\r\n    isAes: isAes,\r\n    hasAttribute: hasAttribute,\r\n    estimateSegmentRequestTime: estimateSegmentRequestTime,\r\n    isLowestEnabledRendition: isLowestEnabledRendition,\r\n    isAudioOnly: isAudioOnly,\r\n    playlistMatch: playlistMatch,\r\n    segmentDurationWithParts: segmentDurationWithParts\r\n  };\r\n  var log = videojs.log;\r\n\r\n  var createPlaylistID = function createPlaylistID(index, uri) {\r\n    return index + \"-\" + uri;\r\n  };\r\n  /**\r\n   * Parses a given m3u8 playlist\r\n   *\r\n   * @param {Function} [onwarn]\r\n   *        a function to call when the parser triggers a warning event.\r\n   * @param {Function} [oninfo]\r\n   *        a function to call when the parser triggers an info event.\r\n   * @param {string} manifestString\r\n   *        The downloaded manifest string\r\n   * @param {Object[]} [customTagParsers]\r\n   *        An array of custom tag parsers for the m3u8-parser instance\r\n   * @param {Object[]} [customTagMappers]\r\n   *        An array of custom tag mappers for the m3u8-parser instance\r\n   * @param {boolean} [experimentalLLHLS=false]\r\n   *        Whether to keep ll-hls features in the manifest after parsing.\r\n   * @return {Object}\r\n   *         The manifest object\r\n   */\r\n\r\n\r\n  var parseManifest = function parseManifest(_ref) {\r\n    var onwarn = _ref.onwarn,\r\n        oninfo = _ref.oninfo,\r\n        manifestString = _ref.manifestString,\r\n        _ref$customTagParsers = _ref.customTagParsers,\r\n        customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers,\r\n        _ref$customTagMappers = _ref.customTagMappers,\r\n        customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers,\r\n        experimentalLLHLS = _ref.experimentalLLHLS;\r\n    var parser = new Parser();\r\n\r\n    if (onwarn) {\r\n      parser.on('warn', onwarn);\r\n    }\r\n\r\n    if (oninfo) {\r\n      parser.on('info', oninfo);\r\n    }\r\n\r\n    customTagParsers.forEach(function (customParser) {\r\n      return parser.addParser(customParser);\r\n    });\r\n    customTagMappers.forEach(function (mapper) {\r\n      return parser.addTagMapper(mapper);\r\n    });\r\n    parser.push(manifestString);\r\n    parser.end();\r\n    var manifest = parser.manifest; // remove llhls features from the parsed manifest\r\n    // if we don't want llhls support.\r\n\r\n    if (!experimentalLLHLS) {\r\n      ['preloadSegment', 'skip', 'serverControl', 'renditionReports', 'partInf', 'partTargetDuration'].forEach(function (k) {\r\n        if (manifest.hasOwnProperty(k)) {\r\n          delete manifest[k];\r\n        }\r\n      });\r\n\r\n      if (manifest.segments) {\r\n        manifest.segments.forEach(function (segment) {\r\n          ['parts', 'preloadHints'].forEach(function (k) {\r\n            if (segment.hasOwnProperty(k)) {\r\n              delete segment[k];\r\n            }\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\n    if (!manifest.targetDuration) {\r\n      var targetDuration = 10;\r\n\r\n      if (manifest.segments && manifest.segments.length) {\r\n        targetDuration = manifest.segments.reduce(function (acc, s) {\r\n          return Math.max(acc, s.duration);\r\n        }, 0);\r\n      }\r\n\r\n      if (onwarn) {\r\n        onwarn(\"manifest has no targetDuration defaulting to \" + targetDuration);\r\n      }\r\n\r\n      manifest.targetDuration = targetDuration;\r\n    }\r\n\r\n    var parts = getLastParts(manifest);\r\n\r\n    if (parts.length && !manifest.partTargetDuration) {\r\n      var partTargetDuration = parts.reduce(function (acc, p) {\r\n        return Math.max(acc, p.duration);\r\n      }, 0);\r\n\r\n      if (onwarn) {\r\n        onwarn(\"manifest has no partTargetDuration defaulting to \" + partTargetDuration);\r\n        log.error('LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.');\r\n      }\r\n\r\n      manifest.partTargetDuration = partTargetDuration;\r\n    }\r\n\r\n    return manifest;\r\n  };\r\n  /**\r\n   * Loops through all supported media groups in master and calls the provided\r\n   * callback for each group\r\n   *\r\n   * @param {Object} master\r\n   *        The parsed master manifest object\r\n   * @param {Function} callback\r\n   *        Callback to call for each media group\r\n   */\r\n\r\n\r\n  var forEachMediaGroup = function forEachMediaGroup(master, callback) {\r\n    if (!master.mediaGroups) {\r\n      return;\r\n    }\r\n\r\n    ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {\r\n      if (!master.mediaGroups[mediaType]) {\r\n        return;\r\n      }\r\n\r\n      for (var groupKey in master.mediaGroups[mediaType]) {\r\n        for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\r\n          var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\r\n          callback(mediaProperties, mediaType, groupKey, labelKey);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * Adds properties and attributes to the playlist to keep consistent functionality for\r\n   * playlists throughout VHS.\r\n   *\r\n   * @param {Object} config\r\n   *        Arguments object\r\n   * @param {Object} config.playlist\r\n   *        The media playlist\r\n   * @param {string} [config.uri]\r\n   *        The uri to the media playlist (if media playlist is not from within a master\r\n   *        playlist)\r\n   * @param {string} id\r\n   *        ID to use for the playlist\r\n   */\r\n\r\n\r\n  var setupMediaPlaylist = function setupMediaPlaylist(_ref2) {\r\n    var playlist = _ref2.playlist,\r\n        uri = _ref2.uri,\r\n        id = _ref2.id;\r\n    playlist.id = id;\r\n    playlist.playlistErrors_ = 0;\r\n\r\n    if (uri) {\r\n      // For media playlists, m3u8-parser does not have access to a URI, as HLS media\r\n      // playlists do not contain their own source URI, but one is needed for consistency in\r\n      // VHS.\r\n      playlist.uri = uri;\r\n    } // For HLS master playlists, even though certain attributes MUST be defined, the\r\n    // stream may still be played without them.\r\n    // For HLS media playlists, m3u8-parser does not attach an attributes object to the\r\n    // manifest.\r\n    //\r\n    // To avoid undefined reference errors through the project, and make the code easier\r\n    // to write/read, add an empty attributes object for these cases.\r\n\r\n\r\n    playlist.attributes = playlist.attributes || {};\r\n  };\r\n  /**\r\n   * Adds ID, resolvedUri, and attributes properties to each playlist of the master, where\r\n   * necessary. In addition, creates playlist IDs for each playlist and adds playlist ID to\r\n   * playlist references to the playlists array.\r\n   *\r\n   * @param {Object} master\r\n   *        The master playlist\r\n   */\r\n\r\n\r\n  var setupMediaPlaylists = function setupMediaPlaylists(master) {\r\n    var i = master.playlists.length;\r\n\r\n    while (i--) {\r\n      var playlist = master.playlists[i];\r\n      setupMediaPlaylist({\r\n        playlist: playlist,\r\n        id: createPlaylistID(i, playlist.uri)\r\n      });\r\n      playlist.resolvedUri = resolveUrl(master.uri, playlist.uri);\r\n      master.playlists[playlist.id] = playlist; // URI reference added for backwards compatibility\r\n\r\n      master.playlists[playlist.uri] = playlist; // Although the spec states an #EXT-X-STREAM-INF tag MUST have a BANDWIDTH attribute,\r\n      // the stream can be played without it. Although an attributes property may have been\r\n      // added to the playlist to prevent undefined references, issue a warning to fix the\r\n      // manifest.\r\n\r\n      if (!playlist.attributes.BANDWIDTH) {\r\n        log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Adds resolvedUri properties to each media group.\r\n   *\r\n   * @param {Object} master\r\n   *        The master playlist\r\n   */\r\n\r\n\r\n  var resolveMediaGroupUris = function resolveMediaGroupUris(master) {\r\n    forEachMediaGroup(master, function (properties) {\r\n      if (properties.uri) {\r\n        properties.resolvedUri = resolveUrl(master.uri, properties.uri);\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * Creates a master playlist wrapper to insert a sole media playlist into.\r\n   *\r\n   * @param {Object} media\r\n   *        Media playlist\r\n   * @param {string} uri\r\n   *        The media URI\r\n   *\r\n   * @return {Object}\r\n   *         Master playlist\r\n   */\r\n\r\n\r\n  var masterForMedia = function masterForMedia(media, uri) {\r\n    var id = createPlaylistID(0, uri);\r\n    var master = {\r\n      mediaGroups: {\r\n        'AUDIO': {},\r\n        'VIDEO': {},\r\n        'CLOSED-CAPTIONS': {},\r\n        'SUBTITLES': {}\r\n      },\r\n      uri: window.location.href,\r\n      resolvedUri: window.location.href,\r\n      playlists: [{\r\n        uri: uri,\r\n        id: id,\r\n        resolvedUri: uri,\r\n        // m3u8-parser does not attach an attributes property to media playlists so make\r\n        // sure that the property is attached to avoid undefined reference errors\r\n        attributes: {}\r\n      }]\r\n    }; // set up ID reference\r\n\r\n    master.playlists[id] = master.playlists[0]; // URI reference added for backwards compatibility\r\n\r\n    master.playlists[uri] = master.playlists[0];\r\n    return master;\r\n  };\r\n  /**\r\n   * Does an in-place update of the master manifest to add updated playlist URI references\r\n   * as well as other properties needed by VHS that aren't included by the parser.\r\n   *\r\n   * @param {Object} master\r\n   *        Master manifest object\r\n   * @param {string} uri\r\n   *        The source URI\r\n   */\r\n\r\n\r\n  var addPropertiesToMaster = function addPropertiesToMaster(master, uri) {\r\n    master.uri = uri;\r\n\r\n    for (var i = 0; i < master.playlists.length; i++) {\r\n      if (!master.playlists[i].uri) {\r\n        // Set up phony URIs for the playlists since playlists are referenced by their URIs\r\n        // throughout VHS, but some formats (e.g., DASH) don't have external URIs\r\n        // TODO: consider adding dummy URIs in mpd-parser\r\n        var phonyUri = \"placeholder-uri-\" + i;\r\n        master.playlists[i].uri = phonyUri;\r\n      }\r\n    }\r\n\r\n    var audioOnlyMaster = isAudioOnly(master);\r\n    forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {\r\n      var groupId = \"placeholder-uri-\" + mediaType + \"-\" + groupKey + \"-\" + labelKey; // add a playlist array under properties\r\n\r\n      if (!properties.playlists || !properties.playlists.length) {\r\n        // If the manifest is audio only and this media group does not have a uri, check\r\n        // if the media group is located in the main list of playlists. If it is, don't add\r\n        // placeholder properties as it shouldn't be considered an alternate audio track.\r\n        if (audioOnlyMaster && mediaType === 'AUDIO' && !properties.uri) {\r\n          for (var _i = 0; _i < master.playlists.length; _i++) {\r\n            var p = master.playlists[_i];\r\n\r\n            if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {\r\n              return;\r\n            }\r\n          }\r\n        }\r\n\r\n        properties.playlists = [_extends_1({}, properties)];\r\n      }\r\n\r\n      properties.playlists.forEach(function (p, i) {\r\n        var id = createPlaylistID(i, groupId);\r\n\r\n        if (p.uri) {\r\n          p.resolvedUri = p.resolvedUri || resolveUrl(master.uri, p.uri);\r\n        } else {\r\n          // DEPRECATED, this has been added to prevent a breaking change.\r\n          // previously we only ever had a single media group playlist, so\r\n          // we mark the first playlist uri without prepending the index as we used to\r\n          // ideally we would do all of the playlists the same way.\r\n          p.uri = i === 0 ? groupId : id; // don't resolve a placeholder uri to an absolute url, just use\r\n          // the placeholder again\r\n\r\n          p.resolvedUri = p.uri;\r\n        }\r\n\r\n        p.id = p.id || id; // add an empty attributes object, all playlists are\r\n        // expected to have this.\r\n\r\n        p.attributes = p.attributes || {}; // setup ID and URI references (URI for backwards compatibility)\r\n\r\n        master.playlists[p.id] = p;\r\n        master.playlists[p.uri] = p;\r\n      });\r\n    });\r\n    setupMediaPlaylists(master);\r\n    resolveMediaGroupUris(master);\r\n  };\r\n\r\n  var mergeOptions$2 = videojs.mergeOptions,\r\n      EventTarget$1 = videojs.EventTarget;\r\n\r\n  var addLLHLSQueryDirectives = function addLLHLSQueryDirectives(uri, media) {\r\n    if (media.endList || !media.serverControl) {\r\n      return uri;\r\n    }\r\n\r\n    var parameters = {};\r\n\r\n    if (media.serverControl.canBlockReload) {\r\n      var preloadSegment = media.preloadSegment; // next msn is a zero based value, length is not.\r\n\r\n      var nextMSN = media.mediaSequence + media.segments.length; // If preload segment has parts then it is likely\r\n      // that we are going to request a part of that preload segment.\r\n      // the logic below is used to determine that.\r\n\r\n      if (preloadSegment) {\r\n        var parts = preloadSegment.parts || []; // _HLS_part is a zero based index\r\n\r\n        var nextPart = getKnownPartCount(media) - 1; // if nextPart is > -1 and not equal to just the\r\n        // length of parts, then we know we had part preload hints\r\n        // and we need to add the _HLS_part= query\r\n\r\n        if (nextPart > -1 && nextPart !== parts.length - 1) {\r\n          // add existing parts to our preload hints\r\n          // eslint-disable-next-line\r\n          parameters._HLS_part = nextPart;\r\n        } // this if statement makes sure that we request the msn\r\n        // of the preload segment if:\r\n        // 1. the preload segment had parts (and was not yet a full segment)\r\n        //    but was added to our segments array\r\n        // 2. the preload segment had preload hints for parts that are not in\r\n        //    the manifest yet.\r\n        // in all other cases we want the segment after the preload segment\r\n        // which will be given by using media.segments.length because it is 1 based\r\n        // rather than 0 based.\r\n\r\n\r\n        if (nextPart > -1 || parts.length) {\r\n          nextMSN--;\r\n        }\r\n      } // add _HLS_msn= in front of any _HLS_part query\r\n      // eslint-disable-next-line\r\n\r\n\r\n      parameters._HLS_msn = nextMSN;\r\n    }\r\n\r\n    if (media.serverControl && media.serverControl.canSkipUntil) {\r\n      // add _HLS_skip= infront of all other queries.\r\n      // eslint-disable-next-line\r\n      parameters._HLS_skip = media.serverControl.canSkipDateranges ? 'v2' : 'YES';\r\n    }\r\n\r\n    if (Object.keys(parameters).length) {\r\n      var parsedUri = new window.URL(uri);\r\n      ['_HLS_skip', '_HLS_msn', '_HLS_part'].forEach(function (name) {\r\n        if (!parameters.hasOwnProperty(name)) {\r\n          return;\r\n        }\r\n\r\n        parsedUri.searchParams.set(name, parameters[name]);\r\n      });\r\n      uri = parsedUri.toString();\r\n    }\r\n\r\n    return uri;\r\n  };\r\n  /**\r\n   * Returns a new segment object with properties and\r\n   * the parts array merged.\r\n   *\r\n   * @param {Object} a the old segment\r\n   * @param {Object} b the new segment\r\n   *\r\n   * @return {Object} the merged segment\r\n   */\r\n\r\n\r\n  var updateSegment = function updateSegment(a, b) {\r\n    if (!a) {\r\n      return b;\r\n    }\r\n\r\n    var result = mergeOptions$2(a, b); // if only the old segment has preload hints\r\n    // and the new one does not, remove preload hints.\r\n\r\n    if (a.preloadHints && !b.preloadHints) {\r\n      delete result.preloadHints;\r\n    } // if only the old segment has parts\r\n    // then the parts are no longer valid\r\n\r\n\r\n    if (a.parts && !b.parts) {\r\n      delete result.parts; // if both segments have parts\r\n      // copy part propeties from the old segment\r\n      // to the new one.\r\n    } else if (a.parts && b.parts) {\r\n      for (var i = 0; i < b.parts.length; i++) {\r\n        if (a.parts && a.parts[i]) {\r\n          result.parts[i] = mergeOptions$2(a.parts[i], b.parts[i]);\r\n        }\r\n      }\r\n    } // set skipped to false for segments that have\r\n    // have had information merged from the old segment.\r\n\r\n\r\n    if (!a.skipped && b.skipped) {\r\n      result.skipped = false;\r\n    } // set preload to false for segments that have\r\n    // had information added in the new segment.\r\n\r\n\r\n    if (a.preload && !b.preload) {\r\n      result.preload = false;\r\n    }\r\n\r\n    return result;\r\n  };\r\n  /**\r\n   * Returns a new array of segments that is the result of merging\r\n   * properties from an older list of segments onto an updated\r\n   * list. No properties on the updated playlist will be ovewritten.\r\n   *\r\n   * @param {Array} original the outdated list of segments\r\n   * @param {Array} update the updated list of segments\r\n   * @param {number=} offset the index of the first update\r\n   * segment in the original segment list. For non-live playlists,\r\n   * this should always be zero and does not need to be\r\n   * specified. For live playlists, it should be the difference\r\n   * between the media sequence numbers in the original and updated\r\n   * playlists.\r\n   * @return {Array} a list of merged segment objects\r\n   */\r\n\r\n\r\n  var updateSegments = function updateSegments(original, update, offset) {\r\n    var oldSegments = original.slice();\r\n    var newSegments = update.slice();\r\n    offset = offset || 0;\r\n    var result = [];\r\n    var currentMap;\r\n\r\n    for (var newIndex = 0; newIndex < newSegments.length; newIndex++) {\r\n      var oldSegment = oldSegments[newIndex + offset];\r\n      var newSegment = newSegments[newIndex];\r\n\r\n      if (oldSegment) {\r\n        currentMap = oldSegment.map || currentMap;\r\n        result.push(updateSegment(oldSegment, newSegment));\r\n      } else {\r\n        // carry over map to new segment if it is missing\r\n        if (currentMap && !newSegment.map) {\r\n          newSegment.map = currentMap;\r\n        }\r\n\r\n        result.push(newSegment);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {\r\n    // preloadSegment will not have a uri at all\r\n    // as the segment isn't actually in the manifest yet, only parts\r\n    if (!segment.resolvedUri && segment.uri) {\r\n      segment.resolvedUri = resolveUrl(baseUri, segment.uri);\r\n    }\r\n\r\n    if (segment.key && !segment.key.resolvedUri) {\r\n      segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);\r\n    }\r\n\r\n    if (segment.map && !segment.map.resolvedUri) {\r\n      segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);\r\n    }\r\n\r\n    if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {\r\n      segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);\r\n    }\r\n\r\n    if (segment.parts && segment.parts.length) {\r\n      segment.parts.forEach(function (p) {\r\n        if (p.resolvedUri) {\r\n          return;\r\n        }\r\n\r\n        p.resolvedUri = resolveUrl(baseUri, p.uri);\r\n      });\r\n    }\r\n\r\n    if (segment.preloadHints && segment.preloadHints.length) {\r\n      segment.preloadHints.forEach(function (p) {\r\n        if (p.resolvedUri) {\r\n          return;\r\n        }\r\n\r\n        p.resolvedUri = resolveUrl(baseUri, p.uri);\r\n      });\r\n    }\r\n  };\r\n\r\n  var getAllSegments = function getAllSegments(media) {\r\n    var segments = media.segments || [];\r\n    var preloadSegment = media.preloadSegment; // a preloadSegment with only preloadHints is not currently\r\n    // a usable segment, only include a preloadSegment that has\r\n    // parts.\r\n\r\n    if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {\r\n      // if preloadHints has a MAP that means that the\r\n      // init segment is going to change. We cannot use any of the parts\r\n      // from this preload segment.\r\n      if (preloadSegment.preloadHints) {\r\n        for (var i = 0; i < preloadSegment.preloadHints.length; i++) {\r\n          if (preloadSegment.preloadHints[i].type === 'MAP') {\r\n            return segments;\r\n          }\r\n        }\r\n      } // set the duration for our preload segment to target duration.\r\n\r\n\r\n      preloadSegment.duration = media.targetDuration;\r\n      preloadSegment.preload = true;\r\n      segments.push(preloadSegment);\r\n    }\r\n\r\n    return segments;\r\n  }; // consider the playlist unchanged if the playlist object is the same or\r\n  // the number of segments is equal, the media sequence number is unchanged,\r\n  // and this playlist hasn't become the end of the playlist\r\n\r\n\r\n  var isPlaylistUnchanged = function isPlaylistUnchanged(a, b) {\r\n    return a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;\r\n  };\r\n  /**\r\n    * Returns a new master playlist that is the result of merging an\r\n    * updated media playlist into the original version. If the\r\n    * updated media playlist does not match any of the playlist\r\n    * entries in the original master playlist, null is returned.\r\n    *\r\n    * @param {Object} master a parsed master M3U8 object\r\n    * @param {Object} media a parsed media M3U8 object\r\n    * @return {Object} a new object that represents the original\r\n    * master playlist with the updated media playlist merged in, or\r\n    * null if the merge produced no change.\r\n    */\r\n\r\n\r\n  var updateMaster$1 = function updateMaster(master, newMedia, unchangedCheck) {\r\n    if (unchangedCheck === void 0) {\r\n      unchangedCheck = isPlaylistUnchanged;\r\n    }\r\n\r\n    var result = mergeOptions$2(master, {});\r\n    var oldMedia = result.playlists[newMedia.id];\r\n\r\n    if (!oldMedia) {\r\n      return null;\r\n    }\r\n\r\n    if (unchangedCheck(oldMedia, newMedia)) {\r\n      return null;\r\n    }\r\n\r\n    newMedia.segments = getAllSegments(newMedia);\r\n    var mergedPlaylist = mergeOptions$2(oldMedia, newMedia); // always use the new media's preload segment\r\n\r\n    if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {\r\n      delete mergedPlaylist.preloadSegment;\r\n    } // if the update could overlap existing segment information, merge the two segment lists\r\n\r\n\r\n    if (oldMedia.segments) {\r\n      if (newMedia.skip) {\r\n        newMedia.segments = newMedia.segments || []; // add back in objects for skipped segments, so that we merge\r\n        // old properties into the new segments\r\n\r\n        for (var i = 0; i < newMedia.skip.skippedSegments; i++) {\r\n          newMedia.segments.unshift({\r\n            skipped: true\r\n          });\r\n        }\r\n      }\r\n\r\n      mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);\r\n    } // resolve any segment URIs to prevent us from having to do it later\r\n\r\n\r\n    mergedPlaylist.segments.forEach(function (segment) {\r\n      resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\r\n    }); // TODO Right now in the playlists array there are two references to each playlist, one\r\n    // that is referenced by index, and one by URI. The index reference may no longer be\r\n    // necessary.\r\n\r\n    for (var _i = 0; _i < result.playlists.length; _i++) {\r\n      if (result.playlists[_i].id === newMedia.id) {\r\n        result.playlists[_i] = mergedPlaylist;\r\n      }\r\n    }\r\n\r\n    result.playlists[newMedia.id] = mergedPlaylist; // URI reference added for backwards compatibility\r\n\r\n    result.playlists[newMedia.uri] = mergedPlaylist; // update media group playlist references.\r\n\r\n    forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {\r\n      if (!properties.playlists) {\r\n        return;\r\n      }\r\n\r\n      for (var _i2 = 0; _i2 < properties.playlists.length; _i2++) {\r\n        if (newMedia.id === properties.playlists[_i2].id) {\r\n          properties.playlists[_i2] = mergedPlaylist;\r\n        }\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n  /**\r\n   * Calculates the time to wait before refreshing a live playlist\r\n   *\r\n   * @param {Object} media\r\n   *        The current media\r\n   * @param {boolean} update\r\n   *        True if there were any updates from the last refresh, false otherwise\r\n   * @return {number}\r\n   *         The time in ms to wait before refreshing the live playlist\r\n   */\r\n\r\n\r\n  var refreshDelay = function refreshDelay(media, update) {\r\n    var segments = media.segments || [];\r\n    var lastSegment = segments[segments.length - 1];\r\n    var lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];\r\n    var lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;\r\n\r\n    if (update && lastDuration) {\r\n      return lastDuration * 1000;\r\n    } // if the playlist is unchanged since the last reload or last segment duration\r\n    // cannot be determined, try again after half the target duration\r\n\r\n\r\n    return (media.partTargetDuration || media.targetDuration || 10) * 500;\r\n  };\r\n  /**\r\n   * Load a playlist from a remote location\r\n   *\r\n   * @class PlaylistLoader\r\n   * @extends Stream\r\n   * @param {string|Object} src url or object of manifest\r\n   * @param {boolean} withCredentials the withCredentials xhr option\r\n   * @class\r\n   */\r\n\r\n\r\n  var PlaylistLoader = /*#__PURE__*/function (_EventTarget) {\r\n    inheritsLoose(PlaylistLoader, _EventTarget);\r\n\r\n    function PlaylistLoader(src, vhs, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _EventTarget.call(this) || this;\r\n\r\n      if (!src) {\r\n        throw new Error('A non-empty playlist URL or object is required');\r\n      }\r\n\r\n      _this.logger_ = logger('PlaylistLoader');\r\n      var _options = options,\r\n          _options$withCredenti = _options.withCredentials,\r\n          withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti,\r\n          _options$handleManife = _options.handleManifestRedirects,\r\n          handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;\r\n      _this.src = src;\r\n      _this.vhs_ = vhs;\r\n      _this.withCredentials = withCredentials;\r\n      _this.handleManifestRedirects = handleManifestRedirects;\r\n      var vhsOptions = vhs.options_;\r\n      _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];\r\n      _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];\r\n      _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || false; // force experimentalLLHLS for IE 11\r\n\r\n      if (videojs.browser.IE_VERSION) {\r\n        _this.experimentalLLHLS = false;\r\n      } // initialize the loader state\r\n\r\n\r\n      _this.state = 'HAVE_NOTHING'; // live playlist staleness timeout\r\n\r\n      _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind(assertThisInitialized(_this));\r\n\r\n      _this.on('mediaupdatetimeout', _this.handleMediaupdatetimeout_);\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = PlaylistLoader.prototype;\r\n\r\n    _proto.handleMediaupdatetimeout_ = function handleMediaupdatetimeout_() {\r\n      var _this2 = this;\r\n\r\n      if (this.state !== 'HAVE_METADATA') {\r\n        // only refresh the media playlist if no other activity is going on\r\n        return;\r\n      }\r\n\r\n      var media = this.media();\r\n      var uri = resolveUrl(this.master.uri, media.uri);\r\n\r\n      if (this.experimentalLLHLS) {\r\n        uri = addLLHLSQueryDirectives(uri, media);\r\n      }\r\n\r\n      this.state = 'HAVE_CURRENT_METADATA';\r\n      this.request = this.vhs_.xhr({\r\n        uri: uri,\r\n        withCredentials: this.withCredentials\r\n      }, function (error, req) {\r\n        // disposed\r\n        if (!_this2.request) {\r\n          return;\r\n        }\r\n\r\n        if (error) {\r\n          return _this2.playlistRequestError(_this2.request, _this2.media(), 'HAVE_METADATA');\r\n        }\r\n\r\n        _this2.haveMetadata({\r\n          playlistString: _this2.request.responseText,\r\n          url: _this2.media().uri,\r\n          id: _this2.media().id\r\n        });\r\n      });\r\n    };\r\n\r\n    _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {\r\n      var uri = playlist.uri,\r\n          id = playlist.id; // any in-flight request is now finished\r\n\r\n      this.request = null;\r\n\r\n      if (startingState) {\r\n        this.state = startingState;\r\n      }\r\n\r\n      this.error = {\r\n        playlist: this.master.playlists[id],\r\n        status: xhr.status,\r\n        message: \"HLS playlist request error at URL: \" + uri + \".\",\r\n        responseText: xhr.responseText,\r\n        code: xhr.status >= 500 ? 4 : 2\r\n      };\r\n      this.trigger('error');\r\n    };\r\n\r\n    _proto.parseManifest_ = function parseManifest_(_ref) {\r\n      var _this3 = this;\r\n\r\n      var url = _ref.url,\r\n          manifestString = _ref.manifestString;\r\n      return parseManifest({\r\n        onwarn: function onwarn(_ref2) {\r\n          var message = _ref2.message;\r\n          return _this3.logger_(\"m3u8-parser warn for \" + url + \": \" + message);\r\n        },\r\n        oninfo: function oninfo(_ref3) {\r\n          var message = _ref3.message;\r\n          return _this3.logger_(\"m3u8-parser info for \" + url + \": \" + message);\r\n        },\r\n        manifestString: manifestString,\r\n        customTagParsers: this.customTagParsers,\r\n        customTagMappers: this.customTagMappers,\r\n        experimentalLLHLS: this.experimentalLLHLS\r\n      });\r\n    }\r\n    /**\r\n     * Update the playlist loader's state in response to a new or updated playlist.\r\n     *\r\n     * @param {string} [playlistString]\r\n     *        Playlist string (if playlistObject is not provided)\r\n     * @param {Object} [playlistObject]\r\n     *        Playlist object (if playlistString is not provided)\r\n     * @param {string} url\r\n     *        URL of playlist\r\n     * @param {string} id\r\n     *        ID to use for playlist\r\n     */\r\n    ;\r\n\r\n    _proto.haveMetadata = function haveMetadata(_ref4) {\r\n      var playlistString = _ref4.playlistString,\r\n          playlistObject = _ref4.playlistObject,\r\n          url = _ref4.url,\r\n          id = _ref4.id; // any in-flight request is now finished\r\n\r\n      this.request = null;\r\n      this.state = 'HAVE_METADATA';\r\n      var playlist = playlistObject || this.parseManifest_({\r\n        url: url,\r\n        manifestString: playlistString\r\n      });\r\n      playlist.lastRequest = Date.now();\r\n      setupMediaPlaylist({\r\n        playlist: playlist,\r\n        uri: url,\r\n        id: id\r\n      }); // merge this playlist into the master\r\n\r\n      var update = updateMaster$1(this.master, playlist);\r\n      this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;\r\n      this.pendingMedia_ = null;\r\n\r\n      if (update) {\r\n        this.master = update;\r\n        this.media_ = this.master.playlists[id];\r\n      } else {\r\n        this.trigger('playlistunchanged');\r\n      }\r\n\r\n      this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));\r\n      this.trigger('loadedplaylist');\r\n    }\r\n    /**\r\n      * Abort any outstanding work and clean up.\r\n      */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.trigger('dispose');\r\n      this.stopRequest();\r\n      window.clearTimeout(this.mediaUpdateTimeout);\r\n      window.clearTimeout(this.finalRenditionTimeout);\r\n      this.off();\r\n    };\r\n\r\n    _proto.stopRequest = function stopRequest() {\r\n      if (this.request) {\r\n        var oldRequest = this.request;\r\n        this.request = null;\r\n        oldRequest.onreadystatechange = null;\r\n        oldRequest.abort();\r\n      }\r\n    }\r\n    /**\r\n      * When called without any arguments, returns the currently\r\n      * active media playlist. When called with a single argument,\r\n      * triggers the playlist loader to asynchronously switch to the\r\n      * specified media playlist. Calling this method while the\r\n      * loader is in the HAVE_NOTHING causes an error to be emitted\r\n      * but otherwise has no effect.\r\n      *\r\n      * @param {Object=} playlist the parsed media playlist\r\n      * object to switch to\r\n      * @param {boolean=} shouldDelay whether we should delay the request by half target duration\r\n      *\r\n      * @return {Playlist} the current loaded media\r\n      */\r\n    ;\r\n\r\n    _proto.media = function media(playlist, shouldDelay) {\r\n      var _this4 = this; // getter\r\n\r\n\r\n      if (!playlist) {\r\n        return this.media_;\r\n      } // setter\r\n\r\n\r\n      if (this.state === 'HAVE_NOTHING') {\r\n        throw new Error('Cannot switch media playlist from ' + this.state);\r\n      } // find the playlist object if the target playlist has been\r\n      // specified by URI\r\n\r\n\r\n      if (typeof playlist === 'string') {\r\n        if (!this.master.playlists[playlist]) {\r\n          throw new Error('Unknown playlist URI: ' + playlist);\r\n        }\r\n\r\n        playlist = this.master.playlists[playlist];\r\n      }\r\n\r\n      window.clearTimeout(this.finalRenditionTimeout);\r\n\r\n      if (shouldDelay) {\r\n        var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1000 || 5 * 1000;\r\n        this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, playlist, false), delay);\r\n        return;\r\n      }\r\n\r\n      var startingState = this.state;\r\n      var mediaChange = !this.media_ || playlist.id !== this.media_.id;\r\n      var masterPlaylistRef = this.master.playlists[playlist.id]; // switch to fully loaded playlists immediately\r\n\r\n      if (masterPlaylistRef && masterPlaylistRef.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved\r\n      // media playlist or, for the case of demuxed audio, a resolved audio media group)\r\n      playlist.endList && playlist.segments.length) {\r\n        // abort outstanding playlist requests\r\n        if (this.request) {\r\n          this.request.onreadystatechange = null;\r\n          this.request.abort();\r\n          this.request = null;\r\n        }\r\n\r\n        this.state = 'HAVE_METADATA';\r\n        this.media_ = playlist; // trigger media change if the active media has been updated\r\n\r\n        if (mediaChange) {\r\n          this.trigger('mediachanging');\r\n\r\n          if (startingState === 'HAVE_MASTER') {\r\n            // The initial playlist was a master manifest, and the first media selected was\r\n            // also provided (in the form of a resolved playlist object) as part of the\r\n            // source object (rather than just a URL). Therefore, since the media playlist\r\n            // doesn't need to be requested, loadedmetadata won't trigger as part of the\r\n            // normal flow, and needs an explicit trigger here.\r\n            this.trigger('loadedmetadata');\r\n          } else {\r\n            this.trigger('mediachange');\r\n          }\r\n        }\r\n\r\n        return;\r\n      } // We update/set the timeout here so that live playlists\r\n      // that are not a media change will \"start\" the loader as expected.\r\n      // We expect that this function will start the media update timeout\r\n      // cycle again. This also prevents a playlist switch failure from\r\n      // causing us to stall during live.\r\n\r\n\r\n      this.updateMediaUpdateTimeout_(refreshDelay(playlist, true)); // switching to the active playlist is a no-op\r\n\r\n      if (!mediaChange) {\r\n        return;\r\n      }\r\n\r\n      this.state = 'SWITCHING_MEDIA'; // there is already an outstanding playlist request\r\n\r\n      if (this.request) {\r\n        if (playlist.resolvedUri === this.request.url) {\r\n          // requesting to switch to the same playlist multiple times\r\n          // has no effect after the first\r\n          return;\r\n        }\r\n\r\n        this.request.onreadystatechange = null;\r\n        this.request.abort();\r\n        this.request = null;\r\n      } // request the new playlist\r\n\r\n\r\n      if (this.media_) {\r\n        this.trigger('mediachanging');\r\n      }\r\n\r\n      this.pendingMedia_ = playlist;\r\n      this.request = this.vhs_.xhr({\r\n        uri: playlist.resolvedUri,\r\n        withCredentials: this.withCredentials\r\n      }, function (error, req) {\r\n        // disposed\r\n        if (!_this4.request) {\r\n          return;\r\n        }\r\n\r\n        playlist.lastRequest = Date.now();\r\n        playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req);\r\n\r\n        if (error) {\r\n          return _this4.playlistRequestError(_this4.request, playlist, startingState);\r\n        }\r\n\r\n        _this4.haveMetadata({\r\n          playlistString: req.responseText,\r\n          url: playlist.uri,\r\n          id: playlist.id\r\n        }); // fire loadedmetadata the first time a media playlist is loaded\r\n\r\n\r\n        if (startingState === 'HAVE_MASTER') {\r\n          _this4.trigger('loadedmetadata');\r\n        } else {\r\n          _this4.trigger('mediachange');\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * pause loading of the playlist\r\n     */\r\n    ;\r\n\r\n    _proto.pause = function pause() {\r\n      if (this.mediaUpdateTimeout) {\r\n        window.clearTimeout(this.mediaUpdateTimeout);\r\n        this.mediaUpdateTimeout = null;\r\n      }\r\n\r\n      this.stopRequest();\r\n\r\n      if (this.state === 'HAVE_NOTHING') {\r\n        // If we pause the loader before any data has been retrieved, its as if we never\r\n        // started, so reset to an unstarted state.\r\n        this.started = false;\r\n      } // Need to restore state now that no activity is happening\r\n\r\n\r\n      if (this.state === 'SWITCHING_MEDIA') {\r\n        // if the loader was in the process of switching media, it should either return to\r\n        // HAVE_MASTER or HAVE_METADATA depending on if the loader has loaded a media\r\n        // playlist yet. This is determined by the existence of loader.media_\r\n        if (this.media_) {\r\n          this.state = 'HAVE_METADATA';\r\n        } else {\r\n          this.state = 'HAVE_MASTER';\r\n        }\r\n      } else if (this.state === 'HAVE_CURRENT_METADATA') {\r\n        this.state = 'HAVE_METADATA';\r\n      }\r\n    }\r\n    /**\r\n     * start loading of the playlist\r\n     */\r\n    ;\r\n\r\n    _proto.load = function load(shouldDelay) {\r\n      var _this5 = this;\r\n\r\n      if (this.mediaUpdateTimeout) {\r\n        window.clearTimeout(this.mediaUpdateTimeout);\r\n        this.mediaUpdateTimeout = null;\r\n      }\r\n\r\n      var media = this.media();\r\n\r\n      if (shouldDelay) {\r\n        var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1000 : 5 * 1000;\r\n        this.mediaUpdateTimeout = window.setTimeout(function () {\r\n          _this5.mediaUpdateTimeout = null;\r\n\r\n          _this5.load();\r\n        }, delay);\r\n        return;\r\n      }\r\n\r\n      if (!this.started) {\r\n        this.start();\r\n        return;\r\n      }\r\n\r\n      if (media && !media.endList) {\r\n        this.trigger('mediaupdatetimeout');\r\n      } else {\r\n        this.trigger('loadedplaylist');\r\n      }\r\n    };\r\n\r\n    _proto.updateMediaUpdateTimeout_ = function updateMediaUpdateTimeout_(delay) {\r\n      var _this6 = this;\r\n\r\n      if (this.mediaUpdateTimeout) {\r\n        window.clearTimeout(this.mediaUpdateTimeout);\r\n        this.mediaUpdateTimeout = null;\r\n      } // we only have use mediaupdatetimeout for live playlists.\r\n\r\n\r\n      if (!this.media() || this.media().endList) {\r\n        return;\r\n      }\r\n\r\n      this.mediaUpdateTimeout = window.setTimeout(function () {\r\n        _this6.mediaUpdateTimeout = null;\r\n\r\n        _this6.trigger('mediaupdatetimeout');\r\n\r\n        _this6.updateMediaUpdateTimeout_(delay);\r\n      }, delay);\r\n    }\r\n    /**\r\n     * start loading of the playlist\r\n     */\r\n    ;\r\n\r\n    _proto.start = function start() {\r\n      var _this7 = this;\r\n\r\n      this.started = true;\r\n\r\n      if (typeof this.src === 'object') {\r\n        // in the case of an entirely constructed manifest object (meaning there's no actual\r\n        // manifest on a server), default the uri to the page's href\r\n        if (!this.src.uri) {\r\n          this.src.uri = window.location.href;\r\n        } // resolvedUri is added on internally after the initial request. Since there's no\r\n        // request for pre-resolved manifests, add on resolvedUri here.\r\n\r\n\r\n        this.src.resolvedUri = this.src.uri; // Since a manifest object was passed in as the source (instead of a URL), the first\r\n        // request can be skipped (since the top level of the manifest, at a minimum, is\r\n        // already available as a parsed manifest object). However, if the manifest object\r\n        // represents a master playlist, some media playlists may need to be resolved before\r\n        // the starting segment list is available. Therefore, go directly to setup of the\r\n        // initial playlist, and let the normal flow continue from there.\r\n        //\r\n        // Note that the call to setup is asynchronous, as other sections of VHS may assume\r\n        // that the first request is asynchronous.\r\n\r\n        setTimeout(function () {\r\n          _this7.setupInitialPlaylist(_this7.src);\r\n        }, 0);\r\n        return;\r\n      } // request the specified URL\r\n\r\n\r\n      this.request = this.vhs_.xhr({\r\n        uri: this.src,\r\n        withCredentials: this.withCredentials\r\n      }, function (error, req) {\r\n        // disposed\r\n        if (!_this7.request) {\r\n          return;\r\n        } // clear the loader's request reference\r\n\r\n\r\n        _this7.request = null;\r\n\r\n        if (error) {\r\n          _this7.error = {\r\n            status: req.status,\r\n            message: \"HLS playlist request error at URL: \" + _this7.src + \".\",\r\n            responseText: req.responseText,\r\n            // MEDIA_ERR_NETWORK\r\n            code: 2\r\n          };\r\n\r\n          if (_this7.state === 'HAVE_NOTHING') {\r\n            _this7.started = false;\r\n          }\r\n\r\n          return _this7.trigger('error');\r\n        }\r\n\r\n        _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);\r\n\r\n        var manifest = _this7.parseManifest_({\r\n          manifestString: req.responseText,\r\n          url: _this7.src\r\n        });\r\n\r\n        _this7.setupInitialPlaylist(manifest);\r\n      });\r\n    };\r\n\r\n    _proto.srcUri = function srcUri() {\r\n      return typeof this.src === 'string' ? this.src : this.src.uri;\r\n    }\r\n    /**\r\n     * Given a manifest object that's either a master or media playlist, trigger the proper\r\n     * events and set the state of the playlist loader.\r\n     *\r\n     * If the manifest object represents a master playlist, `loadedplaylist` will be\r\n     * triggered to allow listeners to select a playlist. If none is selected, the loader\r\n     * will default to the first one in the playlists array.\r\n     *\r\n     * If the manifest object represents a media playlist, `loadedplaylist` will be\r\n     * triggered followed by `loadedmetadata`, as the only available playlist is loaded.\r\n     *\r\n     * In the case of a media playlist, a master playlist object wrapper with one playlist\r\n     * will be created so that all logic can handle playlists in the same fashion (as an\r\n     * assumed manifest object schema).\r\n     *\r\n     * @param {Object} manifest\r\n     *        The parsed manifest object\r\n     */\r\n    ;\r\n\r\n    _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {\r\n      this.state = 'HAVE_MASTER';\r\n\r\n      if (manifest.playlists) {\r\n        this.master = manifest;\r\n        addPropertiesToMaster(this.master, this.srcUri()); // If the initial master playlist has playlists wtih segments already resolved,\r\n        // then resolve URIs in advance, as they are usually done after a playlist request,\r\n        // which may not happen if the playlist is resolved.\r\n\r\n        manifest.playlists.forEach(function (playlist) {\r\n          playlist.segments = getAllSegments(playlist);\r\n          playlist.segments.forEach(function (segment) {\r\n            resolveSegmentUris(segment, playlist.resolvedUri);\r\n          });\r\n        });\r\n        this.trigger('loadedplaylist');\r\n\r\n        if (!this.request) {\r\n          // no media playlist was specifically selected so start\r\n          // from the first listed one\r\n          this.media(this.master.playlists[0]);\r\n        }\r\n\r\n        return;\r\n      } // In order to support media playlists passed in as vhs-json, the case where the uri\r\n      // is not provided as part of the manifest should be considered, and an appropriate\r\n      // default used.\r\n\r\n\r\n      var uri = this.srcUri() || window.location.href;\r\n      this.master = masterForMedia(manifest, uri);\r\n      this.haveMetadata({\r\n        playlistObject: manifest,\r\n        url: uri,\r\n        id: this.master.playlists[0].id\r\n      });\r\n      this.trigger('loadedmetadata');\r\n    };\r\n\r\n    return PlaylistLoader;\r\n  }(EventTarget$1);\r\n  /**\r\n   * @file xhr.js\r\n   */\r\n\r\n\r\n  var videojsXHR = videojs.xhr,\r\n      mergeOptions$1 = videojs.mergeOptions;\r\n\r\n  var callbackWrapper = function callbackWrapper(request, error, response, callback) {\r\n    var reqResponse = request.responseType === 'arraybuffer' ? request.response : request.responseText;\r\n\r\n    if (!error && reqResponse) {\r\n      request.responseTime = Date.now();\r\n      request.roundTripTime = request.responseTime - request.requestTime;\r\n      request.bytesReceived = reqResponse.byteLength || reqResponse.length;\r\n\r\n      if (!request.bandwidth) {\r\n        request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\r\n      }\r\n    }\r\n\r\n    if (response.headers) {\r\n      request.responseHeaders = response.headers;\r\n    } // videojs.xhr now uses a specific code on the error\r\n    // object to signal that a request has timed out instead\r\n    // of setting a boolean on the request object\r\n\r\n\r\n    if (error && error.code === 'ETIMEDOUT') {\r\n      request.timedout = true;\r\n    } // videojs.xhr no longer considers status codes outside of 200 and 0\r\n    // (for file uris) to be errors, but the old XHR did, so emulate that\r\n    // behavior. Status 206 may be used in response to byterange requests.\r\n\r\n\r\n    if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\r\n      error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\r\n    }\r\n\r\n    callback(error, request);\r\n  };\r\n\r\n  var xhrFactory = function xhrFactory() {\r\n    var xhr = function XhrFunction(options, callback) {\r\n      // Add a default timeout\r\n      options = mergeOptions$1({\r\n        timeout: 45e3\r\n      }, options); // Allow an optional user-specified function to modify the option\r\n      // object before we construct the xhr request\r\n\r\n      var beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;\r\n\r\n      if (beforeRequest && typeof beforeRequest === 'function') {\r\n        var newOptions = beforeRequest(options);\r\n\r\n        if (newOptions) {\r\n          options = newOptions;\r\n        }\r\n      } // Use the standard videojs.xhr() method unless `videojs.Vhs.xhr` has been overriden\r\n      // TODO: switch back to videojs.Vhs.xhr.name === 'XhrFunction' when we drop IE11\r\n\r\n\r\n      var xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;\r\n      var request = xhrMethod(options, function (error, response) {\r\n        return callbackWrapper(request, error, response, callback);\r\n      });\r\n      var originalAbort = request.abort;\r\n\r\n      request.abort = function () {\r\n        request.aborted = true;\r\n        return originalAbort.apply(request, arguments);\r\n      };\r\n\r\n      request.uri = options.uri;\r\n      request.requestTime = Date.now();\r\n      return request;\r\n    };\r\n\r\n    xhr.original = true;\r\n    return xhr;\r\n  };\r\n  /**\r\n   * Turns segment byterange into a string suitable for use in\r\n   * HTTP Range requests\r\n   *\r\n   * @param {Object} byterange - an object with two values defining the start and end\r\n   *                             of a byte-range\r\n   */\r\n\r\n\r\n  var byterangeStr = function byterangeStr(byterange) {\r\n    // `byterangeEnd` is one less than `offset + length` because the HTTP range\r\n    // header uses inclusive ranges\r\n    var byterangeEnd;\r\n    var byterangeStart = byterange.offset;\r\n\r\n    if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\r\n      byterangeEnd = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\r\n    } else {\r\n      byterangeEnd = byterange.offset + byterange.length - 1;\r\n    }\r\n\r\n    return 'bytes=' + byterangeStart + '-' + byterangeEnd;\r\n  };\r\n  /**\r\n   * Defines headers for use in the xhr request for a particular segment.\r\n   *\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   */\r\n\r\n\r\n  var segmentXhrHeaders = function segmentXhrHeaders(segment) {\r\n    var headers = {};\r\n\r\n    if (segment.byterange) {\r\n      headers.Range = byterangeStr(segment.byterange);\r\n    }\r\n\r\n    return headers;\r\n  };\r\n  /**\r\n   * @file bin-utils.js\r\n   */\r\n\r\n  /**\r\n   * convert a TimeRange to text\r\n   *\r\n   * @param {TimeRange} range the timerange to use for conversion\r\n   * @param {number} i the iterator on the range to convert\r\n   * @return {string} the range in string format\r\n   */\r\n\r\n\r\n  var textRange = function textRange(range, i) {\r\n    return range.start(i) + '-' + range.end(i);\r\n  };\r\n  /**\r\n   * format a number as hex string\r\n   *\r\n   * @param {number} e The number\r\n   * @param {number} i the iterator\r\n   * @return {string} the hex formatted number as a string\r\n   */\r\n\r\n\r\n  var formatHexString = function formatHexString(e, i) {\r\n    var value = e.toString(16);\r\n    return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\r\n  };\r\n\r\n  var formatAsciiString = function formatAsciiString(e) {\r\n    if (e >= 0x20 && e < 0x7e) {\r\n      return String.fromCharCode(e);\r\n    }\r\n\r\n    return '.';\r\n  };\r\n  /**\r\n   * Creates an object for sending to a web worker modifying properties that are TypedArrays\r\n   * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\r\n   *\r\n   * @param {Object} message\r\n   *        Object of properties and values to send to the web worker\r\n   * @return {Object}\r\n   *         Modified message with TypedArray values expanded\r\n   * @function createTransferableMessage\r\n   */\r\n\r\n\r\n  var createTransferableMessage = function createTransferableMessage(message) {\r\n    var transferable = {};\r\n    Object.keys(message).forEach(function (key) {\r\n      var value = message[key];\r\n\r\n      if (isArrayBufferView(value)) {\r\n        transferable[key] = {\r\n          bytes: value.buffer,\r\n          byteOffset: value.byteOffset,\r\n          byteLength: value.byteLength\r\n        };\r\n      } else {\r\n        transferable[key] = value;\r\n      }\r\n    });\r\n    return transferable;\r\n  };\r\n  /**\r\n   * Returns a unique string identifier for a media initialization\r\n   * segment.\r\n   *\r\n   * @param {Object} initSegment\r\n   *        the init segment object.\r\n   *\r\n   * @return {string} the generated init segment id\r\n   */\r\n\r\n\r\n  var initSegmentId = function initSegmentId(initSegment) {\r\n    var byterange = initSegment.byterange || {\r\n      length: Infinity,\r\n      offset: 0\r\n    };\r\n    return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\r\n  };\r\n  /**\r\n   * Returns a unique string identifier for a media segment key.\r\n   *\r\n   * @param {Object} key the encryption key\r\n   * @return {string} the unique id for the media segment key.\r\n   */\r\n\r\n\r\n  var segmentKeyId = function segmentKeyId(key) {\r\n    return key.resolvedUri;\r\n  };\r\n  /**\r\n   * utils to help dump binary data to the console\r\n   *\r\n   * @param {Array|TypedArray} data\r\n   *        data to dump to a string\r\n   *\r\n   * @return {string} the data as a hex string.\r\n   */\r\n\r\n\r\n  var hexDump = function hexDump(data) {\r\n    var bytes = Array.prototype.slice.call(data);\r\n    var step = 16;\r\n    var result = '';\r\n    var hex;\r\n    var ascii;\r\n\r\n    for (var j = 0; j < bytes.length / step; j++) {\r\n      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\r\n      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\r\n      result += hex + ' ' + ascii + '\\n';\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var tagDump = function tagDump(_ref) {\r\n    var bytes = _ref.bytes;\r\n    return hexDump(bytes);\r\n  };\r\n\r\n  var textRanges = function textRanges(ranges) {\r\n    var result = '';\r\n    var i;\r\n\r\n    for (i = 0; i < ranges.length; i++) {\r\n      result += textRange(ranges, i) + ' ';\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var utils = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    createTransferableMessage: createTransferableMessage,\r\n    initSegmentId: initSegmentId,\r\n    segmentKeyId: segmentKeyId,\r\n    hexDump: hexDump,\r\n    tagDump: tagDump,\r\n    textRanges: textRanges\r\n  }); // TODO handle fmp4 case where the timing info is accurate and doesn't involve transmux\r\n  // 25% was arbitrarily chosen, and may need to be refined over time.\r\n\r\n  var SEGMENT_END_FUDGE_PERCENT = 0.25;\r\n  /**\r\n   * Converts a player time (any time that can be gotten/set from player.currentTime(),\r\n   * e.g., any time within player.seekable().start(0) to player.seekable().end(0)) to a\r\n   * program time (any time referencing the real world (e.g., EXT-X-PROGRAM-DATE-TIME)).\r\n   *\r\n   * The containing segment is required as the EXT-X-PROGRAM-DATE-TIME serves as an \"anchor\r\n   * point\" (a point where we have a mapping from program time to player time, with player\r\n   * time being the post transmux start of the segment).\r\n   *\r\n   * For more details, see [this doc](../../docs/program-time-from-player-time.md).\r\n   *\r\n   * @param {number} playerTime the player time\r\n   * @param {Object} segment the segment which contains the player time\r\n   * @return {Date} program time\r\n   */\r\n\r\n  var playerTimeToProgramTime = function playerTimeToProgramTime(playerTime, segment) {\r\n    if (!segment.dateTimeObject) {\r\n      // Can't convert without an \"anchor point\" for the program time (i.e., a time that can\r\n      // be used to map the start of a segment with a real world time).\r\n      return null;\r\n    }\r\n\r\n    var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;\r\n    var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart; // get the start of the content from before old content is prepended\r\n\r\n    var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;\r\n    var offsetFromSegmentStart = playerTime - startOfSegment;\r\n    return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1000);\r\n  };\r\n\r\n  var originalSegmentVideoDuration = function originalSegmentVideoDuration(videoTimingInfo) {\r\n    return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;\r\n  };\r\n  /**\r\n   * Finds a segment that contains the time requested given as an ISO-8601 string. The\r\n   * returned segment might be an estimate or an accurate match.\r\n   *\r\n   * @param {string} programTime The ISO-8601 programTime to find a match for\r\n   * @param {Object} playlist A playlist object to search within\r\n   */\r\n\r\n\r\n  var findSegmentForProgramTime = function findSegmentForProgramTime(programTime, playlist) {\r\n    // Assumptions:\r\n    //  - verifyProgramDateTimeTags has already been run\r\n    //  - live streams have been started\r\n    var dateTimeObject;\r\n\r\n    try {\r\n      dateTimeObject = new Date(programTime);\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n\r\n    if (!playlist || !playlist.segments || playlist.segments.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    var segment = playlist.segments[0];\r\n\r\n    if (dateTimeObject < segment.dateTimeObject) {\r\n      // Requested time is before stream start.\r\n      return null;\r\n    }\r\n\r\n    for (var i = 0; i < playlist.segments.length - 1; i++) {\r\n      segment = playlist.segments[i];\r\n      var nextSegmentStart = playlist.segments[i + 1].dateTimeObject;\r\n\r\n      if (dateTimeObject < nextSegmentStart) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    var lastSegment = playlist.segments[playlist.segments.length - 1];\r\n    var lastSegmentStart = lastSegment.dateTimeObject;\r\n    var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;\r\n    var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1000);\r\n\r\n    if (dateTimeObject > lastSegmentEnd) {\r\n      // Beyond the end of the stream, or our best guess of the end of the stream.\r\n      return null;\r\n    }\r\n\r\n    if (dateTimeObject > lastSegmentStart) {\r\n      segment = lastSegment;\r\n    }\r\n\r\n    return {\r\n      segment: segment,\r\n      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),\r\n      // Although, given that all segments have accurate date time objects, the segment\r\n      // selected should be accurate, unless the video has been transmuxed at some point\r\n      // (determined by the presence of the videoTimingInfo object), the segment's \"player\r\n      // time\" (the start time in the player) can't be considered accurate.\r\n      type: segment.videoTimingInfo ? 'accurate' : 'estimate'\r\n    };\r\n  };\r\n  /**\r\n   * Finds a segment that contains the given player time(in seconds).\r\n   *\r\n   * @param {number} time The player time to find a match for\r\n   * @param {Object} playlist A playlist object to search within\r\n   */\r\n\r\n\r\n  var findSegmentForPlayerTime = function findSegmentForPlayerTime(time, playlist) {\r\n    // Assumptions:\r\n    // - there will always be a segment.duration\r\n    // - we can start from zero\r\n    // - segments are in time order\r\n    if (!playlist || !playlist.segments || playlist.segments.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    var segmentEnd = 0;\r\n    var segment;\r\n\r\n    for (var i = 0; i < playlist.segments.length; i++) {\r\n      segment = playlist.segments[i]; // videoTimingInfo is set after the segment is downloaded and transmuxed, and\r\n      // should contain the most accurate values we have for the segment's player times.\r\n      //\r\n      // Use the accurate transmuxedPresentationEnd value if it is available, otherwise fall\r\n      // back to an estimate based on the manifest derived (inaccurate) segment.duration, to\r\n      // calculate an end value.\r\n\r\n      segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;\r\n\r\n      if (time <= segmentEnd) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    var lastSegment = playlist.segments[playlist.segments.length - 1];\r\n\r\n    if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {\r\n      // The time requested is beyond the stream end.\r\n      return null;\r\n    }\r\n\r\n    if (time > segmentEnd) {\r\n      // The time is within or beyond the last segment.\r\n      //\r\n      // Check to see if the time is beyond a reasonable guess of the end of the stream.\r\n      if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {\r\n        // Technically, because the duration value is only an estimate, the time may still\r\n        // exist in the last segment, however, there isn't enough information to make even\r\n        // a reasonable estimate.\r\n        return null;\r\n      }\r\n\r\n      segment = lastSegment;\r\n    }\r\n\r\n    return {\r\n      segment: segment,\r\n      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,\r\n      // Because videoTimingInfo is only set after transmux, it is the only way to get\r\n      // accurate timing values.\r\n      type: segment.videoTimingInfo ? 'accurate' : 'estimate'\r\n    };\r\n  };\r\n  /**\r\n   * Gives the offset of the comparisonTimestamp from the programTime timestamp in seconds.\r\n   * If the offset returned is positive, the programTime occurs after the\r\n   * comparisonTimestamp.\r\n   * If the offset is negative, the programTime occurs before the comparisonTimestamp.\r\n   *\r\n   * @param {string} comparisonTimeStamp An ISO-8601 timestamp to compare against\r\n   * @param {string} programTime The programTime as an ISO-8601 string\r\n   * @return {number} offset\r\n   */\r\n\r\n\r\n  var getOffsetFromTimestamp = function getOffsetFromTimestamp(comparisonTimeStamp, programTime) {\r\n    var segmentDateTime;\r\n    var programDateTime;\r\n\r\n    try {\r\n      segmentDateTime = new Date(comparisonTimeStamp);\r\n      programDateTime = new Date(programTime);\r\n    } catch (e) {// TODO handle error\r\n    }\r\n\r\n    var segmentTimeEpoch = segmentDateTime.getTime();\r\n    var programTimeEpoch = programDateTime.getTime();\r\n    return (programTimeEpoch - segmentTimeEpoch) / 1000;\r\n  };\r\n  /**\r\n   * Checks that all segments in this playlist have programDateTime tags.\r\n   *\r\n   * @param {Object} playlist A playlist object\r\n   */\r\n\r\n\r\n  var verifyProgramDateTimeTags = function verifyProgramDateTimeTags(playlist) {\r\n    if (!playlist.segments || playlist.segments.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (var i = 0; i < playlist.segments.length; i++) {\r\n      var segment = playlist.segments[i];\r\n\r\n      if (!segment.dateTimeObject) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * Returns the programTime of the media given a playlist and a playerTime.\r\n   * The playlist must have programDateTime tags for a programDateTime tag to be returned.\r\n   * If the segments containing the time requested have not been buffered yet, an estimate\r\n   * may be returned to the callback.\r\n   *\r\n   * @param {Object} args\r\n   * @param {Object} args.playlist A playlist object to search within\r\n   * @param {number} time A playerTime in seconds\r\n   * @param {Function} callback(err, programTime)\r\n   * @return {string} err.message A detailed error message\r\n   * @return {Object} programTime\r\n   * @return {number} programTime.mediaSeconds The streamTime in seconds\r\n   * @return {string} programTime.programDateTime The programTime as an ISO-8601 String\r\n   */\r\n\r\n\r\n  var getProgramTime = function getProgramTime(_ref) {\r\n    var playlist = _ref.playlist,\r\n        _ref$time = _ref.time,\r\n        time = _ref$time === void 0 ? undefined : _ref$time,\r\n        callback = _ref.callback;\r\n\r\n    if (!callback) {\r\n      throw new Error('getProgramTime: callback must be provided');\r\n    }\r\n\r\n    if (!playlist || time === undefined) {\r\n      return callback({\r\n        message: 'getProgramTime: playlist and time must be provided'\r\n      });\r\n    }\r\n\r\n    var matchedSegment = findSegmentForPlayerTime(time, playlist);\r\n\r\n    if (!matchedSegment) {\r\n      return callback({\r\n        message: 'valid programTime was not found'\r\n      });\r\n    }\r\n\r\n    if (matchedSegment.type === 'estimate') {\r\n      return callback({\r\n        message: 'Accurate programTime could not be determined.' + ' Please seek to e.seekTime and try again',\r\n        seekTime: matchedSegment.estimatedStart\r\n      });\r\n    }\r\n\r\n    var programTimeObject = {\r\n      mediaSeconds: time\r\n    };\r\n    var programTime = playerTimeToProgramTime(time, matchedSegment.segment);\r\n\r\n    if (programTime) {\r\n      programTimeObject.programDateTime = programTime.toISOString();\r\n    }\r\n\r\n    return callback(null, programTimeObject);\r\n  };\r\n  /**\r\n   * Seeks in the player to a time that matches the given programTime ISO-8601 string.\r\n   *\r\n   * @param {Object} args\r\n   * @param {string} args.programTime A programTime to seek to as an ISO-8601 String\r\n   * @param {Object} args.playlist A playlist to look within\r\n   * @param {number} args.retryCount The number of times to try for an accurate seek. Default is 2.\r\n   * @param {Function} args.seekTo A method to perform a seek\r\n   * @param {boolean} args.pauseAfterSeek Whether to end in a paused state after seeking. Default is true.\r\n   * @param {Object} args.tech The tech to seek on\r\n   * @param {Function} args.callback(err, newTime) A callback to return the new time to\r\n   * @return {string} err.message A detailed error message\r\n   * @return {number} newTime The exact time that was seeked to in seconds\r\n   */\r\n\r\n\r\n  var seekToProgramTime = function seekToProgramTime(_ref2) {\r\n    var programTime = _ref2.programTime,\r\n        playlist = _ref2.playlist,\r\n        _ref2$retryCount = _ref2.retryCount,\r\n        retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount,\r\n        seekTo = _ref2.seekTo,\r\n        _ref2$pauseAfterSeek = _ref2.pauseAfterSeek,\r\n        pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek,\r\n        tech = _ref2.tech,\r\n        callback = _ref2.callback;\r\n\r\n    if (!callback) {\r\n      throw new Error('seekToProgramTime: callback must be provided');\r\n    }\r\n\r\n    if (typeof programTime === 'undefined' || !playlist || !seekTo) {\r\n      return callback({\r\n        message: 'seekToProgramTime: programTime, seekTo and playlist must be provided'\r\n      });\r\n    }\r\n\r\n    if (!playlist.endList && !tech.hasStarted_) {\r\n      return callback({\r\n        message: 'player must be playing a live stream to start buffering'\r\n      });\r\n    }\r\n\r\n    if (!verifyProgramDateTimeTags(playlist)) {\r\n      return callback({\r\n        message: 'programDateTime tags must be provided in the manifest ' + playlist.resolvedUri\r\n      });\r\n    }\r\n\r\n    var matchedSegment = findSegmentForProgramTime(programTime, playlist); // no match\r\n\r\n    if (!matchedSegment) {\r\n      return callback({\r\n        message: programTime + \" was not found in the stream\"\r\n      });\r\n    }\r\n\r\n    var segment = matchedSegment.segment;\r\n    var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);\r\n\r\n    if (matchedSegment.type === 'estimate') {\r\n      // we've run out of retries\r\n      if (retryCount === 0) {\r\n        return callback({\r\n          message: programTime + \" is not buffered yet. Try again\"\r\n        });\r\n      }\r\n\r\n      seekTo(matchedSegment.estimatedStart + mediaOffset);\r\n      tech.one('seeked', function () {\r\n        seekToProgramTime({\r\n          programTime: programTime,\r\n          playlist: playlist,\r\n          retryCount: retryCount - 1,\r\n          seekTo: seekTo,\r\n          pauseAfterSeek: pauseAfterSeek,\r\n          tech: tech,\r\n          callback: callback\r\n        });\r\n      });\r\n      return;\r\n    } // Since the segment.start value is determined from the buffered end or ending time\r\n    // of the prior segment, the seekToTime doesn't need to account for any transmuxer\r\n    // modifications.\r\n\r\n\r\n    var seekToTime = segment.start + mediaOffset;\r\n\r\n    var seekedCallback = function seekedCallback() {\r\n      return callback(null, tech.currentTime());\r\n    }; // listen for seeked event\r\n\r\n\r\n    tech.one('seeked', seekedCallback); // pause before seeking as video.js will restore this state\r\n\r\n    if (pauseAfterSeek) {\r\n      tech.pause();\r\n    }\r\n\r\n    seekTo(seekToTime);\r\n  }; // which will only happen if the request is complete.\r\n\r\n\r\n  var callbackOnCompleted = function callbackOnCompleted(request, cb) {\r\n    if (request.readyState === 4) {\r\n      return cb();\r\n    }\r\n\r\n    return;\r\n  };\r\n\r\n  var containerRequest = function containerRequest(uri, xhr, cb) {\r\n    var bytes = [];\r\n    var id3Offset;\r\n    var finished = false;\r\n\r\n    var endRequestAndCallback = function endRequestAndCallback(err, req, type, _bytes) {\r\n      req.abort();\r\n      finished = true;\r\n      return cb(err, req, type, _bytes);\r\n    };\r\n\r\n    var progressListener = function progressListener(error, request) {\r\n      if (finished) {\r\n        return;\r\n      }\r\n\r\n      if (error) {\r\n        return endRequestAndCallback(error, request, '', bytes);\r\n      } // grap the new part of content that was just downloaded\r\n\r\n\r\n      var newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length); // add that onto bytes\r\n\r\n      bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));\r\n      id3Offset = id3Offset || getId3Offset(bytes); // we need at least 10 bytes to determine a type\r\n      // or we need at least two bytes after an id3Offset\r\n\r\n      if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {\r\n        return callbackOnCompleted(request, function () {\r\n          return endRequestAndCallback(error, request, '', bytes);\r\n        });\r\n      }\r\n\r\n      var type = detectContainerForBytes(bytes); // if this looks like a ts segment but we don't have enough data\r\n      // to see the second sync byte, wait until we have enough data\r\n      // before declaring it ts\r\n\r\n      if (type === 'ts' && bytes.length < 188) {\r\n        return callbackOnCompleted(request, function () {\r\n          return endRequestAndCallback(error, request, '', bytes);\r\n        });\r\n      } // this may be an unsynced ts segment\r\n      // wait for 376 bytes before detecting no container\r\n\r\n\r\n      if (!type && bytes.length < 376) {\r\n        return callbackOnCompleted(request, function () {\r\n          return endRequestAndCallback(error, request, '', bytes);\r\n        });\r\n      }\r\n\r\n      return endRequestAndCallback(null, request, type, bytes);\r\n    };\r\n\r\n    var options = {\r\n      uri: uri,\r\n      beforeSend: function beforeSend(request) {\r\n        // this forces the browser to pass the bytes to us unprocessed\r\n        request.overrideMimeType('text/plain; charset=x-user-defined');\r\n        request.addEventListener('progress', function (_ref) {\r\n          _ref.total;\r\n          _ref.loaded;\r\n          return callbackWrapper(request, null, {\r\n            statusCode: request.status\r\n          }, progressListener);\r\n        });\r\n      }\r\n    };\r\n    var request = xhr(options, function (error, response) {\r\n      return callbackWrapper(request, error, response, progressListener);\r\n    });\r\n    return request;\r\n  };\r\n\r\n  var EventTarget = videojs.EventTarget,\r\n      mergeOptions = videojs.mergeOptions;\r\n\r\n  var dashPlaylistUnchanged = function dashPlaylistUnchanged(a, b) {\r\n    if (!isPlaylistUnchanged(a, b)) {\r\n      return false;\r\n    } // for dash the above check will often return true in scenarios where\r\n    // the playlist actually has changed because mediaSequence isn't a\r\n    // dash thing, and we often set it to 1. So if the playlists have the same amount\r\n    // of segments we return true.\r\n    // So for dash we need to make sure that the underlying segments are different.\r\n    // if sidx changed then the playlists are different.\r\n\r\n\r\n    if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {\r\n      return false;\r\n    } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {\r\n      return false;\r\n    } // one or the other does not have segments\r\n    // there was a change.\r\n\r\n\r\n    if (a.segments && !b.segments || !a.segments && b.segments) {\r\n      return false;\r\n    } // neither has segments nothing changed\r\n\r\n\r\n    if (!a.segments && !b.segments) {\r\n      return true;\r\n    } // check segments themselves\r\n\r\n\r\n    for (var i = 0; i < a.segments.length; i++) {\r\n      var aSegment = a.segments[i];\r\n      var bSegment = b.segments[i]; // if uris are different between segments there was a change\r\n\r\n      if (aSegment.uri !== bSegment.uri) {\r\n        return false;\r\n      } // neither segment has a byterange, there will be no byterange change.\r\n\r\n\r\n      if (!aSegment.byterange && !bSegment.byterange) {\r\n        continue;\r\n      }\r\n\r\n      var aByterange = aSegment.byterange;\r\n      var bByterange = bSegment.byterange; // if byterange only exists on one of the segments, there was a change.\r\n\r\n      if (aByterange && !bByterange || !aByterange && bByterange) {\r\n        return false;\r\n      } // if both segments have byterange with different offsets, there was a change.\r\n\r\n\r\n      if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {\r\n        return false;\r\n      }\r\n    } // if everything was the same with segments, this is the same playlist.\r\n\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * Parses the master XML string and updates playlist URI references.\r\n   *\r\n   * @param {Object} config\r\n   *        Object of arguments\r\n   * @param {string} config.masterXml\r\n   *        The mpd XML\r\n   * @param {string} config.srcUrl\r\n   *        The mpd URL\r\n   * @param {Date} config.clientOffset\r\n   *         A time difference between server and client\r\n   * @param {Object} config.sidxMapping\r\n   *        SIDX mappings for moof/mdat URIs and byte ranges\r\n   * @return {Object}\r\n   *         The parsed mpd manifest object\r\n   */\r\n\r\n\r\n  var parseMasterXml = function parseMasterXml(_ref) {\r\n    var masterXml = _ref.masterXml,\r\n        srcUrl = _ref.srcUrl,\r\n        clientOffset = _ref.clientOffset,\r\n        sidxMapping = _ref.sidxMapping,\r\n        previousManifest = _ref.previousManifest;\r\n    var manifest = parse(masterXml, {\r\n      manifestUri: srcUrl,\r\n      clientOffset: clientOffset,\r\n      sidxMapping: sidxMapping,\r\n      previousManifest: previousManifest\r\n    });\r\n    addPropertiesToMaster(manifest, srcUrl);\r\n    return manifest;\r\n  };\r\n  /**\r\n   * Returns a new master manifest that is the result of merging an updated master manifest\r\n   * into the original version.\r\n   *\r\n   * @param {Object} oldMaster\r\n   *        The old parsed mpd object\r\n   * @param {Object} newMaster\r\n   *        The updated parsed mpd object\r\n   * @return {Object}\r\n   *         A new object representing the original master manifest with the updated media\r\n   *         playlists merged in\r\n   */\r\n\r\n\r\n  var updateMaster = function updateMaster(oldMaster, newMaster, sidxMapping) {\r\n    var noChanges = true;\r\n    var update = mergeOptions(oldMaster, {\r\n      // These are top level properties that can be updated\r\n      duration: newMaster.duration,\r\n      minimumUpdatePeriod: newMaster.minimumUpdatePeriod,\r\n      timelineStarts: newMaster.timelineStarts\r\n    }); // First update the playlists in playlist list\r\n\r\n    for (var i = 0; i < newMaster.playlists.length; i++) {\r\n      var playlist = newMaster.playlists[i];\r\n\r\n      if (playlist.sidx) {\r\n        var sidxKey = generateSidxKey(playlist.sidx); // add sidx segments to the playlist if we have all the sidx info already\r\n\r\n        if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {\r\n          addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);\r\n        }\r\n      }\r\n\r\n      var playlistUpdate = updateMaster$1(update, playlist, dashPlaylistUnchanged);\r\n\r\n      if (playlistUpdate) {\r\n        update = playlistUpdate;\r\n        noChanges = false;\r\n      }\r\n    } // Then update media group playlists\r\n\r\n\r\n    forEachMediaGroup(newMaster, function (properties, type, group, label) {\r\n      if (properties.playlists && properties.playlists.length) {\r\n        var id = properties.playlists[0].id;\r\n\r\n        var _playlistUpdate = updateMaster$1(update, properties.playlists[0], dashPlaylistUnchanged);\r\n\r\n        if (_playlistUpdate) {\r\n          update = _playlistUpdate; // update the playlist reference within media groups\r\n\r\n          update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];\r\n          noChanges = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {\r\n      noChanges = false;\r\n    }\r\n\r\n    if (noChanges) {\r\n      return null;\r\n    }\r\n\r\n    return update;\r\n  }; // SIDX should be equivalent if the URI and byteranges of the SIDX match.\r\n  // If the SIDXs have maps, the two maps should match,\r\n  // both `a` and `b` missing SIDXs is considered matching.\r\n  // If `a` or `b` but not both have a map, they aren't matching.\r\n\r\n\r\n  var equivalentSidx = function equivalentSidx(a, b) {\r\n    var neitherMap = Boolean(!a.map && !b.map);\r\n    var equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);\r\n    return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;\r\n  }; // exported for testing\r\n\r\n\r\n  var compareSidxEntry = function compareSidxEntry(playlists, oldSidxMapping) {\r\n    var newSidxMapping = {};\r\n\r\n    for (var id in playlists) {\r\n      var playlist = playlists[id];\r\n      var currentSidxInfo = playlist.sidx;\r\n\r\n      if (currentSidxInfo) {\r\n        var key = generateSidxKey(currentSidxInfo);\r\n\r\n        if (!oldSidxMapping[key]) {\r\n          break;\r\n        }\r\n\r\n        var savedSidxInfo = oldSidxMapping[key].sidxInfo;\r\n\r\n        if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {\r\n          newSidxMapping[key] = oldSidxMapping[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return newSidxMapping;\r\n  };\r\n  /**\r\n   *  A function that filters out changed items as they need to be requested separately.\r\n   *\r\n   *  The method is exported for testing\r\n   *\r\n   *  @param {Object} master the parsed mpd XML returned via mpd-parser\r\n   *  @param {Object} oldSidxMapping the SIDX to compare against\r\n   */\r\n\r\n\r\n  var filterChangedSidxMappings = function filterChangedSidxMappings(master, oldSidxMapping) {\r\n    var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);\r\n    var mediaGroupSidx = videoSidx;\r\n    forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {\r\n      if (properties.playlists && properties.playlists.length) {\r\n        var playlists = properties.playlists;\r\n        mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));\r\n      }\r\n    });\r\n    return mediaGroupSidx;\r\n  };\r\n\r\n  var DashPlaylistLoader = /*#__PURE__*/function (_EventTarget) {\r\n    inheritsLoose(DashPlaylistLoader, _EventTarget); // DashPlaylistLoader must accept either a src url or a playlist because subsequent\r\n    // playlist loader setups from media groups will expect to be able to pass a playlist\r\n    // (since there aren't external URLs to media playlists with DASH)\r\n\r\n\r\n    function DashPlaylistLoader(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _EventTarget.call(this) || this;\r\n      _this.masterPlaylistLoader_ = masterPlaylistLoader || assertThisInitialized(_this);\r\n\r\n      if (!masterPlaylistLoader) {\r\n        _this.isMaster_ = true;\r\n      }\r\n\r\n      var _options = options,\r\n          _options$withCredenti = _options.withCredentials,\r\n          withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti,\r\n          _options$handleManife = _options.handleManifestRedirects,\r\n          handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;\r\n      _this.vhs_ = vhs;\r\n      _this.withCredentials = withCredentials;\r\n      _this.handleManifestRedirects = handleManifestRedirects;\r\n\r\n      if (!srcUrlOrPlaylist) {\r\n        throw new Error('A non-empty playlist URL or object is required');\r\n      } // event naming?\r\n\r\n\r\n      _this.on('minimumUpdatePeriod', function () {\r\n        _this.refreshXml_();\r\n      }); // live playlist staleness timeout\r\n\r\n\r\n      _this.on('mediaupdatetimeout', function () {\r\n        _this.refreshMedia_(_this.media().id);\r\n      });\r\n\r\n      _this.state = 'HAVE_NOTHING';\r\n      _this.loadedPlaylists_ = {};\r\n      _this.logger_ = logger('DashPlaylistLoader'); // initialize the loader state\r\n      // The masterPlaylistLoader will be created with a string\r\n\r\n      if (_this.isMaster_) {\r\n        _this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist; // TODO: reset sidxMapping between period changes\r\n        // once multi-period is refactored\r\n\r\n        _this.masterPlaylistLoader_.sidxMapping_ = {};\r\n      } else {\r\n        _this.childPlaylist_ = srcUrlOrPlaylist;\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = DashPlaylistLoader.prototype;\r\n\r\n    _proto.requestErrored_ = function requestErrored_(err, request, startingState) {\r\n      // disposed\r\n      if (!this.request) {\r\n        return true;\r\n      } // pending request is cleared\r\n\r\n\r\n      this.request = null;\r\n\r\n      if (err) {\r\n        // use the provided error object or create one\r\n        // based on the request/response\r\n        this.error = typeof err === 'object' && !(err instanceof Error) ? err : {\r\n          status: request.status,\r\n          message: 'DASH request error at URL: ' + request.uri,\r\n          response: request.response,\r\n          // MEDIA_ERR_NETWORK\r\n          code: 2\r\n        };\r\n\r\n        if (startingState) {\r\n          this.state = startingState;\r\n        }\r\n\r\n        this.trigger('error');\r\n        return true;\r\n      }\r\n    }\r\n    /**\r\n     * Verify that the container of the sidx segment can be parsed\r\n     * and if it can, get and parse that segment.\r\n     */\r\n    ;\r\n\r\n    _proto.addSidxSegments_ = function addSidxSegments_(playlist, startingState, cb) {\r\n      var _this2 = this;\r\n\r\n      var sidxKey = playlist.sidx && generateSidxKey(playlist.sidx); // playlist lacks sidx or sidx segments were added to this playlist already.\r\n\r\n      if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {\r\n        // keep this function async\r\n        this.mediaRequest_ = window.setTimeout(function () {\r\n          return cb(false);\r\n        }, 0);\r\n        return;\r\n      } // resolve the segment URL relative to the playlist\r\n\r\n\r\n      var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri);\r\n\r\n      var fin = function fin(err, request) {\r\n        if (_this2.requestErrored_(err, request, startingState)) {\r\n          return;\r\n        }\r\n\r\n        var sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;\r\n        var sidx;\r\n\r\n        try {\r\n          sidx = parseSidx_1(toUint8(request.response).subarray(8));\r\n        } catch (e) {\r\n          // sidx parsing failed.\r\n          _this2.requestErrored_(e, request, startingState);\r\n\r\n          return;\r\n        }\r\n\r\n        sidxMapping[sidxKey] = {\r\n          sidxInfo: playlist.sidx,\r\n          sidx: sidx\r\n        };\r\n        addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);\r\n        return cb(true);\r\n      };\r\n\r\n      this.request = containerRequest(uri, this.vhs_.xhr, function (err, request, container, bytes) {\r\n        if (err) {\r\n          return fin(err, request);\r\n        }\r\n\r\n        if (!container || container !== 'mp4') {\r\n          return fin({\r\n            status: request.status,\r\n            message: \"Unsupported \" + (container || 'unknown') + \" container type for sidx segment at URL: \" + uri,\r\n            // response is just bytes in this case\r\n            // but we really don't want to return that.\r\n            response: '',\r\n            playlist: playlist,\r\n            internal: true,\r\n            blacklistDuration: Infinity,\r\n            // MEDIA_ERR_NETWORK\r\n            code: 2\r\n          }, request);\r\n        } // if we already downloaded the sidx bytes in the container request, use them\r\n\r\n\r\n        var _playlist$sidx$bytera = playlist.sidx.byterange,\r\n            offset = _playlist$sidx$bytera.offset,\r\n            length = _playlist$sidx$bytera.length;\r\n\r\n        if (bytes.length >= length + offset) {\r\n          return fin(err, {\r\n            response: bytes.subarray(offset, offset + length),\r\n            status: request.status,\r\n            uri: request.uri\r\n          });\r\n        } // otherwise request sidx bytes\r\n\r\n\r\n        _this2.request = _this2.vhs_.xhr({\r\n          uri: uri,\r\n          responseType: 'arraybuffer',\r\n          headers: segmentXhrHeaders({\r\n            byterange: playlist.sidx.byterange\r\n          })\r\n        }, fin);\r\n      });\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.trigger('dispose');\r\n      this.stopRequest();\r\n      this.loadedPlaylists_ = {};\r\n      window.clearTimeout(this.minimumUpdatePeriodTimeout_);\r\n      window.clearTimeout(this.mediaRequest_);\r\n      window.clearTimeout(this.mediaUpdateTimeout);\r\n      this.mediaUpdateTimeout = null;\r\n      this.mediaRequest_ = null;\r\n      this.minimumUpdatePeriodTimeout_ = null;\r\n\r\n      if (this.masterPlaylistLoader_.createMupOnMedia_) {\r\n        this.off('loadedmetadata', this.masterPlaylistLoader_.createMupOnMedia_);\r\n        this.masterPlaylistLoader_.createMupOnMedia_ = null;\r\n      }\r\n\r\n      this.off();\r\n    };\r\n\r\n    _proto.hasPendingRequest = function hasPendingRequest() {\r\n      return this.request || this.mediaRequest_;\r\n    };\r\n\r\n    _proto.stopRequest = function stopRequest() {\r\n      if (this.request) {\r\n        var oldRequest = this.request;\r\n        this.request = null;\r\n        oldRequest.onreadystatechange = null;\r\n        oldRequest.abort();\r\n      }\r\n    };\r\n\r\n    _proto.media = function media(playlist) {\r\n      var _this3 = this; // getter\r\n\r\n\r\n      if (!playlist) {\r\n        return this.media_;\r\n      } // setter\r\n\r\n\r\n      if (this.state === 'HAVE_NOTHING') {\r\n        throw new Error('Cannot switch media playlist from ' + this.state);\r\n      }\r\n\r\n      var startingState = this.state; // find the playlist object if the target playlist has been specified by URI\r\n\r\n      if (typeof playlist === 'string') {\r\n        if (!this.masterPlaylistLoader_.master.playlists[playlist]) {\r\n          throw new Error('Unknown playlist URI: ' + playlist);\r\n        }\r\n\r\n        playlist = this.masterPlaylistLoader_.master.playlists[playlist];\r\n      }\r\n\r\n      var mediaChange = !this.media_ || playlist.id !== this.media_.id; // switch to previously loaded playlists immediately\r\n\r\n      if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {\r\n        this.state = 'HAVE_METADATA';\r\n        this.media_ = playlist; // trigger media change if the active media has been updated\r\n\r\n        if (mediaChange) {\r\n          this.trigger('mediachanging');\r\n          this.trigger('mediachange');\r\n        }\r\n\r\n        return;\r\n      } // switching to the active playlist is a no-op\r\n\r\n\r\n      if (!mediaChange) {\r\n        return;\r\n      } // switching from an already loaded playlist\r\n\r\n\r\n      if (this.media_) {\r\n        this.trigger('mediachanging');\r\n      }\r\n\r\n      this.addSidxSegments_(playlist, startingState, function (sidxChanged) {\r\n        // everything is ready just continue to haveMetadata\r\n        _this3.haveMetadata({\r\n          startingState: startingState,\r\n          playlist: playlist\r\n        });\r\n      });\r\n    };\r\n\r\n    _proto.haveMetadata = function haveMetadata(_ref2) {\r\n      var startingState = _ref2.startingState,\r\n          playlist = _ref2.playlist;\r\n      this.state = 'HAVE_METADATA';\r\n      this.loadedPlaylists_[playlist.id] = playlist;\r\n      this.mediaRequest_ = null; // This will trigger loadedplaylist\r\n\r\n      this.refreshMedia_(playlist.id); // fire loadedmetadata the first time a media playlist is loaded\r\n      // to resolve setup of media groups\r\n\r\n      if (startingState === 'HAVE_MASTER') {\r\n        this.trigger('loadedmetadata');\r\n      } else {\r\n        // trigger media change if the active media has been updated\r\n        this.trigger('mediachange');\r\n      }\r\n    };\r\n\r\n    _proto.pause = function pause() {\r\n      if (this.masterPlaylistLoader_.createMupOnMedia_) {\r\n        this.off('loadedmetadata', this.masterPlaylistLoader_.createMupOnMedia_);\r\n        this.masterPlaylistLoader_.createMupOnMedia_ = null;\r\n      }\r\n\r\n      this.stopRequest();\r\n      window.clearTimeout(this.mediaUpdateTimeout);\r\n      this.mediaUpdateTimeout = null;\r\n\r\n      if (this.isMaster_) {\r\n        window.clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_);\r\n        this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;\r\n      }\r\n\r\n      if (this.state === 'HAVE_NOTHING') {\r\n        // If we pause the loader before any data has been retrieved, its as if we never\r\n        // started, so reset to an unstarted state.\r\n        this.started = false;\r\n      }\r\n    };\r\n\r\n    _proto.load = function load(isFinalRendition) {\r\n      var _this4 = this;\r\n\r\n      window.clearTimeout(this.mediaUpdateTimeout);\r\n      this.mediaUpdateTimeout = null;\r\n      var media = this.media();\r\n\r\n      if (isFinalRendition) {\r\n        var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\r\n        this.mediaUpdateTimeout = window.setTimeout(function () {\r\n          return _this4.load();\r\n        }, delay);\r\n        return;\r\n      } // because the playlists are internal to the manifest, load should either load the\r\n      // main manifest, or do nothing but trigger an event\r\n\r\n\r\n      if (!this.started) {\r\n        this.start();\r\n        return;\r\n      }\r\n\r\n      if (media && !media.endList) {\r\n        // Check to see if this is the master loader and the MUP was cleared (this happens\r\n        // when the loader was paused). `media` should be set at this point since one is always\r\n        // set during `start()`.\r\n        if (this.isMaster_ && !this.minimumUpdatePeriodTimeout_) {\r\n          // Trigger minimumUpdatePeriod to refresh the master manifest\r\n          this.trigger('minimumUpdatePeriod'); // Since there was no prior minimumUpdatePeriodTimeout it should be recreated\r\n\r\n          this.updateMinimumUpdatePeriodTimeout_();\r\n        }\r\n\r\n        this.trigger('mediaupdatetimeout');\r\n      } else {\r\n        this.trigger('loadedplaylist');\r\n      }\r\n    };\r\n\r\n    _proto.start = function start() {\r\n      var _this5 = this;\r\n\r\n      this.started = true; // We don't need to request the master manifest again\r\n      // Call this asynchronously to match the xhr request behavior below\r\n\r\n      if (!this.isMaster_) {\r\n        this.mediaRequest_ = window.setTimeout(function () {\r\n          return _this5.haveMaster_();\r\n        }, 0);\r\n        return;\r\n      }\r\n\r\n      this.requestMaster_(function (req, masterChanged) {\r\n        _this5.haveMaster_();\r\n\r\n        if (!_this5.hasPendingRequest() && !_this5.media_) {\r\n          _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);\r\n        }\r\n      });\r\n    };\r\n\r\n    _proto.requestMaster_ = function requestMaster_(cb) {\r\n      var _this6 = this;\r\n\r\n      this.request = this.vhs_.xhr({\r\n        uri: this.masterPlaylistLoader_.srcUrl,\r\n        withCredentials: this.withCredentials\r\n      }, function (error, req) {\r\n        if (_this6.requestErrored_(error, req)) {\r\n          if (_this6.state === 'HAVE_NOTHING') {\r\n            _this6.started = false;\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;\r\n        _this6.masterPlaylistLoader_.masterXml_ = req.responseText;\r\n\r\n        if (req.responseHeaders && req.responseHeaders.date) {\r\n          _this6.masterLoaded_ = Date.parse(req.responseHeaders.date);\r\n        } else {\r\n          _this6.masterLoaded_ = Date.now();\r\n        }\r\n\r\n        _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req);\r\n\r\n        if (masterChanged) {\r\n          _this6.handleMaster_();\r\n\r\n          _this6.syncClientServerClock_(function () {\r\n            return cb(req, masterChanged);\r\n          });\r\n\r\n          return;\r\n        }\r\n\r\n        return cb(req, masterChanged);\r\n      });\r\n    }\r\n    /**\r\n     * Parses the master xml for UTCTiming node to sync the client clock to the server\r\n     * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.\r\n     *\r\n     * @param {Function} done\r\n     *        Function to call when clock sync has completed\r\n     */\r\n    ;\r\n\r\n    _proto.syncClientServerClock_ = function syncClientServerClock_(done) {\r\n      var _this7 = this;\r\n\r\n      var utcTiming = parseUTCTiming(this.masterPlaylistLoader_.masterXml_); // No UTCTiming element found in the mpd. Use Date header from mpd request as the\r\n      // server clock\r\n\r\n      if (utcTiming === null) {\r\n        this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now();\r\n        return done();\r\n      }\r\n\r\n      if (utcTiming.method === 'DIRECT') {\r\n        this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();\r\n        return done();\r\n      }\r\n\r\n      this.request = this.vhs_.xhr({\r\n        uri: resolveUrl(this.masterPlaylistLoader_.srcUrl, utcTiming.value),\r\n        method: utcTiming.method,\r\n        withCredentials: this.withCredentials\r\n      }, function (error, req) {\r\n        // disposed\r\n        if (!_this7.request) {\r\n          return;\r\n        }\r\n\r\n        if (error) {\r\n          // sync request failed, fall back to using date header from mpd\r\n          // TODO: log warning\r\n          _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now();\r\n          return done();\r\n        }\r\n\r\n        var serverTime;\r\n\r\n        if (utcTiming.method === 'HEAD') {\r\n          if (!req.responseHeaders || !req.responseHeaders.date) {\r\n            // expected date header not preset, fall back to using date header from mpd\r\n            // TODO: log warning\r\n            serverTime = _this7.masterLoaded_;\r\n          } else {\r\n            serverTime = Date.parse(req.responseHeaders.date);\r\n          }\r\n        } else {\r\n          serverTime = Date.parse(req.responseText);\r\n        }\r\n\r\n        _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now();\r\n        done();\r\n      });\r\n    };\r\n\r\n    _proto.haveMaster_ = function haveMaster_() {\r\n      this.state = 'HAVE_MASTER';\r\n\r\n      if (this.isMaster_) {\r\n        // We have the master playlist at this point, so\r\n        // trigger this to allow MasterPlaylistController\r\n        // to make an initial playlist selection\r\n        this.trigger('loadedplaylist');\r\n      } else if (!this.media_) {\r\n        // no media playlist was specifically selected so select\r\n        // the one the child playlist loader was created with\r\n        this.media(this.childPlaylist_);\r\n      }\r\n    };\r\n\r\n    _proto.handleMaster_ = function handleMaster_() {\r\n      // clear media request\r\n      this.mediaRequest_ = null;\r\n      var oldMaster = this.masterPlaylistLoader_.master;\r\n      var newMaster = parseMasterXml({\r\n        masterXml: this.masterPlaylistLoader_.masterXml_,\r\n        srcUrl: this.masterPlaylistLoader_.srcUrl,\r\n        clientOffset: this.masterPlaylistLoader_.clientOffset_,\r\n        sidxMapping: this.masterPlaylistLoader_.sidxMapping_,\r\n        previousManifest: oldMaster\r\n      }); // if we have an old master to compare the new master against\r\n\r\n      if (oldMaster) {\r\n        newMaster = updateMaster(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_);\r\n      } // only update master if we have a new master\r\n\r\n\r\n      this.masterPlaylistLoader_.master = newMaster ? newMaster : oldMaster;\r\n      var location = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];\r\n\r\n      if (location && location !== this.masterPlaylistLoader_.srcUrl) {\r\n        this.masterPlaylistLoader_.srcUrl = location;\r\n      }\r\n\r\n      if (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {\r\n        this.updateMinimumUpdatePeriodTimeout_();\r\n      }\r\n\r\n      return Boolean(newMaster);\r\n    };\r\n\r\n    _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {\r\n      var mpl = this.masterPlaylistLoader_; // cancel any pending creation of mup on media\r\n      // a new one will be added if needed.\r\n\r\n      if (mpl.createMupOnMedia_) {\r\n        mpl.off('loadedmetadata', mpl.createMupOnMedia_);\r\n        mpl.createMupOnMedia_ = null;\r\n      } // clear any pending timeouts\r\n\r\n\r\n      if (mpl.minimumUpdatePeriodTimeout_) {\r\n        window.clearTimeout(mpl.minimumUpdatePeriodTimeout_);\r\n        mpl.minimumUpdatePeriodTimeout_ = null;\r\n      }\r\n\r\n      var mup = mpl.master && mpl.master.minimumUpdatePeriod; // If the minimumUpdatePeriod has a value of 0, that indicates that the current\r\n      // MPD has no future validity, so a new one will need to be acquired when new\r\n      // media segments are to be made available. Thus, we use the target duration\r\n      // in this case\r\n\r\n      if (mup === 0) {\r\n        if (mpl.media()) {\r\n          mup = mpl.media().targetDuration * 1000;\r\n        } else {\r\n          mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;\r\n          mpl.one('loadedmetadata', mpl.createMupOnMedia_);\r\n        }\r\n      } // if minimumUpdatePeriod is invalid or <= zero, which\r\n      // can happen when a live video becomes VOD. skip timeout\r\n      // creation.\r\n\r\n\r\n      if (typeof mup !== 'number' || mup <= 0) {\r\n        if (mup < 0) {\r\n          this.logger_(\"found invalid minimumUpdatePeriod of \" + mup + \", not setting a timeout\");\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      this.createMUPTimeout_(mup);\r\n    };\r\n\r\n    _proto.createMUPTimeout_ = function createMUPTimeout_(mup) {\r\n      var mpl = this.masterPlaylistLoader_;\r\n      mpl.minimumUpdatePeriodTimeout_ = window.setTimeout(function () {\r\n        mpl.minimumUpdatePeriodTimeout_ = null;\r\n        mpl.trigger('minimumUpdatePeriod');\r\n        mpl.createMUPTimeout_(mup);\r\n      }, mup);\r\n    }\r\n    /**\r\n     * Sends request to refresh the master xml and updates the parsed master manifest\r\n     */\r\n    ;\r\n\r\n    _proto.refreshXml_ = function refreshXml_() {\r\n      var _this8 = this;\r\n\r\n      this.requestMaster_(function (req, masterChanged) {\r\n        if (!masterChanged) {\r\n          return;\r\n        }\r\n\r\n        if (_this8.media_) {\r\n          _this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id];\r\n        } // This will filter out updated sidx info from the mapping\r\n\r\n\r\n        _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_);\r\n\r\n        _this8.addSidxSegments_(_this8.media(), _this8.state, function (sidxChanged) {\r\n          // TODO: do we need to reload the current playlist?\r\n          _this8.refreshMedia_(_this8.media().id);\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Refreshes the media playlist by re-parsing the master xml and updating playlist\r\n     * references. If this is an alternate loader, the updated parsed manifest is retrieved\r\n     * from the master loader.\r\n     */\r\n    ;\r\n\r\n    _proto.refreshMedia_ = function refreshMedia_(mediaID) {\r\n      var _this9 = this;\r\n\r\n      if (!mediaID) {\r\n        throw new Error('refreshMedia_ must take a media id');\r\n      } // for master we have to reparse the master xml\r\n      // to re-create segments based on current timing values\r\n      // which may change media. We only skip updating master\r\n      // if this is the first time this.media_ is being set.\r\n      // as master was just parsed in that case.\r\n\r\n\r\n      if (this.media_ && this.isMaster_) {\r\n        this.handleMaster_();\r\n      }\r\n\r\n      var playlists = this.masterPlaylistLoader_.master.playlists;\r\n      var mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];\r\n\r\n      if (mediaChanged) {\r\n        this.media_ = playlists[mediaID];\r\n      } else {\r\n        this.trigger('playlistunchanged');\r\n      }\r\n\r\n      if (!this.mediaUpdateTimeout) {\r\n        var createMediaUpdateTimeout = function createMediaUpdateTimeout() {\r\n          if (_this9.media().endList) {\r\n            return;\r\n          }\r\n\r\n          _this9.mediaUpdateTimeout = window.setTimeout(function () {\r\n            _this9.trigger('mediaupdatetimeout');\r\n\r\n            createMediaUpdateTimeout();\r\n          }, refreshDelay(_this9.media(), Boolean(mediaChanged)));\r\n        };\r\n\r\n        createMediaUpdateTimeout();\r\n      }\r\n\r\n      this.trigger('loadedplaylist');\r\n    };\r\n\r\n    return DashPlaylistLoader;\r\n  }(EventTarget);\r\n\r\n  var Config = {\r\n    GOAL_BUFFER_LENGTH: 30,\r\n    MAX_GOAL_BUFFER_LENGTH: 60,\r\n    BACK_BUFFER_LENGTH: 30,\r\n    GOAL_BUFFER_LENGTH_RATE: 1,\r\n    // 0.5 MB/s\r\n    INITIAL_BANDWIDTH: 4194304,\r\n    // A fudge factor to apply to advertised playlist bitrates to account for\r\n    // temporary flucations in client bandwidth\r\n    BANDWIDTH_VARIANCE: 1.2,\r\n    // How much of the buffer must be filled before we consider upswitching\r\n    BUFFER_LOW_WATER_LINE: 0,\r\n    MAX_BUFFER_LOW_WATER_LINE: 30,\r\n    // TODO: Remove this when experimentalBufferBasedABR is removed\r\n    EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,\r\n    BUFFER_LOW_WATER_LINE_RATE: 1,\r\n    // If the buffer is greater than the high water line, we won't switch down\r\n    BUFFER_HIGH_WATER_LINE: 30\r\n  };\r\n\r\n  var stringToArrayBuffer = function stringToArrayBuffer(string) {\r\n    var view = new Uint8Array(new ArrayBuffer(string.length));\r\n\r\n    for (var i = 0; i < string.length; i++) {\r\n      view[i] = string.charCodeAt(i);\r\n    }\r\n\r\n    return view.buffer;\r\n  };\r\n  /* global Blob, BlobBuilder, Worker */\r\n  // unify worker interface\r\n\r\n\r\n  var browserWorkerPolyFill = function browserWorkerPolyFill(workerObj) {\r\n    // node only supports on/off\r\n    workerObj.on = workerObj.addEventListener;\r\n    workerObj.off = workerObj.removeEventListener;\r\n    return workerObj;\r\n  };\r\n\r\n  var createObjectURL = function createObjectURL(str) {\r\n    try {\r\n      return URL.createObjectURL(new Blob([str], {\r\n        type: 'application/javascript'\r\n      }));\r\n    } catch (e) {\r\n      var blob = new BlobBuilder();\r\n      blob.append(str);\r\n      return URL.createObjectURL(blob.getBlob());\r\n    }\r\n  };\r\n\r\n  var factory = function factory(code) {\r\n    return function () {\r\n      var objectUrl = createObjectURL(code);\r\n      var worker = browserWorkerPolyFill(new Worker(objectUrl));\r\n      worker.objURL = objectUrl;\r\n      var terminate = worker.terminate;\r\n      worker.on = worker.addEventListener;\r\n      worker.off = worker.removeEventListener;\r\n\r\n      worker.terminate = function () {\r\n        URL.revokeObjectURL(objectUrl);\r\n        return terminate.call(this);\r\n      };\r\n\r\n      return worker;\r\n    };\r\n  };\r\n\r\n  var transform = function transform(code) {\r\n    return \"var browserWorkerPolyFill = \" + browserWorkerPolyFill.toString() + \";\\n\" + 'browserWorkerPolyFill(self);\\n' + code;\r\n  };\r\n\r\n  var getWorkerString = function getWorkerString(fn) {\r\n    return fn.toString().replace(/^function.+?{/, '').slice(0, -1);\r\n  };\r\n  /* rollup-plugin-worker-factory start for worker!/Users/abarstow/videojs/http-streaming/src/transmuxer-worker.js */\r\n\r\n\r\n  var workerCode$1 = transform(getWorkerString(function () {\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     *\r\n     * A lightweight readable stream implemention that handles event dispatching.\r\n     * Objects that inherit from streams should call init in their constructors.\r\n     */\r\n    var Stream = function Stream() {\r\n      this.init = function () {\r\n        var listeners = {};\r\n        /**\r\n         * Add a listener for a specified event type.\r\n         * @param type {string} the event name\r\n         * @param listener {function} the callback to be invoked when an event of\r\n         * the specified type occurs\r\n         */\r\n\r\n        this.on = function (type, listener) {\r\n          if (!listeners[type]) {\r\n            listeners[type] = [];\r\n          }\r\n\r\n          listeners[type] = listeners[type].concat(listener);\r\n        };\r\n        /**\r\n         * Remove a listener for a specified event type.\r\n         * @param type {string} the event name\r\n         * @param listener {function} a function previously registered for this\r\n         * type of event through `on`\r\n         */\r\n\r\n\r\n        this.off = function (type, listener) {\r\n          var index;\r\n\r\n          if (!listeners[type]) {\r\n            return false;\r\n          }\r\n\r\n          index = listeners[type].indexOf(listener);\r\n          listeners[type] = listeners[type].slice();\r\n          listeners[type].splice(index, 1);\r\n          return index > -1;\r\n        };\r\n        /**\r\n         * Trigger an event of the specified type on this stream. Any additional\r\n         * arguments to this function are passed as parameters to event listeners.\r\n         * @param type {string} the event name\r\n         */\r\n\r\n\r\n        this.trigger = function (type) {\r\n          var callbacks, i, length, args;\r\n          callbacks = listeners[type];\r\n\r\n          if (!callbacks) {\r\n            return;\r\n          } // Slicing the arguments on every invocation of this method\r\n          // can add a significant amount of overhead. Avoid the\r\n          // intermediate object creation for the common case of a\r\n          // single callback argument\r\n\r\n\r\n          if (arguments.length === 2) {\r\n            length = callbacks.length;\r\n\r\n            for (i = 0; i < length; ++i) {\r\n              callbacks[i].call(this, arguments[1]);\r\n            }\r\n          } else {\r\n            args = [];\r\n            i = arguments.length;\r\n\r\n            for (i = 1; i < arguments.length; ++i) {\r\n              args.push(arguments[i]);\r\n            }\r\n\r\n            length = callbacks.length;\r\n\r\n            for (i = 0; i < length; ++i) {\r\n              callbacks[i].apply(this, args);\r\n            }\r\n          }\r\n        };\r\n        /**\r\n         * Destroys the stream and cleans up.\r\n         */\r\n\r\n\r\n        this.dispose = function () {\r\n          listeners = {};\r\n        };\r\n      };\r\n    };\r\n    /**\r\n     * Forwards all `data` events on this stream to the destination stream. The\r\n     * destination stream should provide a method `push` to receive the data\r\n     * events as they arrive.\r\n     * @param destination {stream} the stream that will receive all `data` events\r\n     * @param autoFlush {boolean} if false, we will not call `flush` on the destination\r\n     *                            when the current stream emits a 'done' event\r\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n     */\r\n\r\n\r\n    Stream.prototype.pipe = function (destination) {\r\n      this.on('data', function (data) {\r\n        destination.push(data);\r\n      });\r\n      this.on('done', function (flushSource) {\r\n        destination.flush(flushSource);\r\n      });\r\n      this.on('partialdone', function (flushSource) {\r\n        destination.partialFlush(flushSource);\r\n      });\r\n      this.on('endedtimeline', function (flushSource) {\r\n        destination.endTimeline(flushSource);\r\n      });\r\n      this.on('reset', function (flushSource) {\r\n        destination.reset(flushSource);\r\n      });\r\n      return destination;\r\n    }; // Default stream functions that are expected to be overridden to perform\r\n    // actual work. These are provided by the prototype as a sort of no-op\r\n    // implementation so that we don't have to check for their existence in the\r\n    // `pipe` function above.\r\n\r\n\r\n    Stream.prototype.push = function (data) {\r\n      this.trigger('data', data);\r\n    };\r\n\r\n    Stream.prototype.flush = function (flushSource) {\r\n      this.trigger('done', flushSource);\r\n    };\r\n\r\n    Stream.prototype.partialFlush = function (flushSource) {\r\n      this.trigger('partialdone', flushSource);\r\n    };\r\n\r\n    Stream.prototype.endTimeline = function (flushSource) {\r\n      this.trigger('endedtimeline', flushSource);\r\n    };\r\n\r\n    Stream.prototype.reset = function (flushSource) {\r\n      this.trigger('reset', flushSource);\r\n    };\r\n\r\n    var stream = Stream;\r\n    var MAX_UINT32$1 = Math.pow(2, 32);\r\n\r\n    var getUint64$2 = function getUint64(uint8) {\r\n      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\r\n      var value;\r\n\r\n      if (dv.getBigUint64) {\r\n        value = dv.getBigUint64(0);\r\n\r\n        if (value < Number.MAX_SAFE_INTEGER) {\r\n          return Number(value);\r\n        }\r\n\r\n        return value;\r\n      }\r\n\r\n      return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\r\n    };\r\n\r\n    var numbers = {\r\n      getUint64: getUint64$2,\r\n      MAX_UINT32: MAX_UINT32$1\r\n    };\r\n    var MAX_UINT32 = numbers.MAX_UINT32;\r\n    var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\r\n\r\n    (function () {\r\n      var i;\r\n      types = {\r\n        avc1: [],\r\n        // codingname\r\n        avcC: [],\r\n        btrt: [],\r\n        dinf: [],\r\n        dref: [],\r\n        esds: [],\r\n        ftyp: [],\r\n        hdlr: [],\r\n        mdat: [],\r\n        mdhd: [],\r\n        mdia: [],\r\n        mfhd: [],\r\n        minf: [],\r\n        moof: [],\r\n        moov: [],\r\n        mp4a: [],\r\n        // codingname\r\n        mvex: [],\r\n        mvhd: [],\r\n        pasp: [],\r\n        sdtp: [],\r\n        smhd: [],\r\n        stbl: [],\r\n        stco: [],\r\n        stsc: [],\r\n        stsd: [],\r\n        stsz: [],\r\n        stts: [],\r\n        styp: [],\r\n        tfdt: [],\r\n        tfhd: [],\r\n        traf: [],\r\n        trak: [],\r\n        trun: [],\r\n        trex: [],\r\n        tkhd: [],\r\n        vmhd: []\r\n      }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\r\n      // don't throw an error\r\n\r\n      if (typeof Uint8Array === 'undefined') {\r\n        return;\r\n      }\r\n\r\n      for (i in types) {\r\n        if (types.hasOwnProperty(i)) {\r\n          types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\r\n        }\r\n      }\r\n\r\n      MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\r\n      AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\r\n      MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\r\n      VIDEO_HDLR = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x00, // pre_defined\r\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\r\n      ]);\r\n      AUDIO_HDLR = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x00, // pre_defined\r\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\r\n      ]);\r\n      HDLR_TYPES = {\r\n        video: VIDEO_HDLR,\r\n        audio: AUDIO_HDLR\r\n      };\r\n      DREF = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x01, // entry_count\r\n      0x00, 0x00, 0x00, 0x0c, // entry_size\r\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\r\n      0x00, // version 0\r\n      0x00, 0x00, 0x01 // entry_flags\r\n      ]);\r\n      SMHD = new Uint8Array([0x00, // version\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, // balance, 0 means centered\r\n      0x00, 0x00 // reserved\r\n      ]);\r\n      STCO = new Uint8Array([0x00, // version\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x00 // entry_count\r\n      ]);\r\n      STSC = STCO;\r\n      STSZ = new Uint8Array([0x00, // version\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x00, // sample_size\r\n      0x00, 0x00, 0x00, 0x00 // sample_count\r\n      ]);\r\n      STTS = STCO;\r\n      VMHD = new Uint8Array([0x00, // version\r\n      0x00, 0x00, 0x01, // flags\r\n      0x00, 0x00, // graphicsmode\r\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\r\n      ]);\r\n    })();\r\n\r\n    box = function box(type) {\r\n      var payload = [],\r\n          size = 0,\r\n          i,\r\n          result,\r\n          view;\r\n\r\n      for (i = 1; i < arguments.length; i++) {\r\n        payload.push(arguments[i]);\r\n      }\r\n\r\n      i = payload.length; // calculate the total size we need to allocate\r\n\r\n      while (i--) {\r\n        size += payload[i].byteLength;\r\n      }\r\n\r\n      result = new Uint8Array(size + 8);\r\n      view = new DataView(result.buffer, result.byteOffset, result.byteLength);\r\n      view.setUint32(0, result.byteLength);\r\n      result.set(type, 4); // copy the payload into the result\r\n\r\n      for (i = 0, size = 8; i < payload.length; i++) {\r\n        result.set(payload[i], size);\r\n        size += payload[i].byteLength;\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    dinf = function dinf() {\r\n      return box(types.dinf, box(types.dref, DREF));\r\n    };\r\n\r\n    esds = function esds(track) {\r\n      return box(types.esds, new Uint8Array([0x00, // version\r\n      0x00, 0x00, 0x00, // flags\r\n      // ES_Descriptor\r\n      0x03, // tag, ES_DescrTag\r\n      0x19, // length\r\n      0x00, 0x00, // ES_ID\r\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\r\n      // DecoderConfigDescriptor\r\n      0x04, // tag, DecoderConfigDescrTag\r\n      0x11, // length\r\n      0x40, // object type\r\n      0x15, // streamType\r\n      0x00, 0x06, 0x00, // bufferSizeDB\r\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\r\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\r\n      // DecoderSpecificInfo\r\n      0x05, // tag, DecoderSpecificInfoTag\r\n      0x02, // length\r\n      // ISO/IEC 14496-3, AudioSpecificConfig\r\n      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\r\n      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\r\n      ]));\r\n    };\r\n\r\n    ftyp = function ftyp() {\r\n      return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\r\n    };\r\n\r\n    hdlr = function hdlr(type) {\r\n      return box(types.hdlr, HDLR_TYPES[type]);\r\n    };\r\n\r\n    mdat = function mdat(data) {\r\n      return box(types.mdat, data);\r\n    };\r\n\r\n    mdhd = function mdhd(track) {\r\n      var result = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x02, // creation_time\r\n      0x00, 0x00, 0x00, 0x03, // modification_time\r\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\r\n      track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\r\n      0x55, 0xc4, // 'und' language (undetermined)\r\n      0x00, 0x00]); // Use the sample rate from the track metadata, when it is\r\n      // defined. The sample rate can be parsed out of an ADTS header, for\r\n      // instance.\r\n\r\n      if (track.samplerate) {\r\n        result[12] = track.samplerate >>> 24 & 0xFF;\r\n        result[13] = track.samplerate >>> 16 & 0xFF;\r\n        result[14] = track.samplerate >>> 8 & 0xFF;\r\n        result[15] = track.samplerate & 0xFF;\r\n      }\r\n\r\n      return box(types.mdhd, result);\r\n    };\r\n\r\n    mdia = function mdia(track) {\r\n      return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\r\n    };\r\n\r\n    mfhd = function mfhd(sequenceNumber) {\r\n      return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\r\n      (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\r\n      ]));\r\n    };\r\n\r\n    minf = function minf(track) {\r\n      return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\r\n    };\r\n\r\n    moof = function moof(sequenceNumber, tracks) {\r\n      var trackFragments = [],\r\n          i = tracks.length; // build traf boxes for each track fragment\r\n\r\n      while (i--) {\r\n        trackFragments[i] = traf(tracks[i]);\r\n      }\r\n\r\n      return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\r\n    };\r\n    /**\r\n     * Returns a movie box.\r\n     * @param tracks {array} the tracks associated with this movie\r\n     * @see ISO/IEC 14496-12:2012(E), section 8.2.1\r\n     */\r\n\r\n\r\n    moov = function moov(tracks) {\r\n      var i = tracks.length,\r\n          boxes = [];\r\n\r\n      while (i--) {\r\n        boxes[i] = trak(tracks[i]);\r\n      }\r\n\r\n      return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\r\n    };\r\n\r\n    mvex = function mvex(tracks) {\r\n      var i = tracks.length,\r\n          boxes = [];\r\n\r\n      while (i--) {\r\n        boxes[i] = trex(tracks[i]);\r\n      }\r\n\r\n      return box.apply(null, [types.mvex].concat(boxes));\r\n    };\r\n\r\n    mvhd = function mvhd(duration) {\r\n      var bytes = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x00, // flags\r\n      0x00, 0x00, 0x00, 0x01, // creation_time\r\n      0x00, 0x00, 0x00, 0x02, // modification_time\r\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\r\n      (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\r\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\r\n      0x01, 0x00, // 1.0 volume\r\n      0x00, 0x00, // reserved\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\r\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\r\n      0xff, 0xff, 0xff, 0xff // next_track_ID\r\n      ]);\r\n      return box(types.mvhd, bytes);\r\n    };\r\n\r\n    sdtp = function sdtp(track) {\r\n      var samples = track.samples || [],\r\n          bytes = new Uint8Array(4 + samples.length),\r\n          flags,\r\n          i; // leave the full box header (4 bytes) all zero\r\n      // write the sample table\r\n\r\n      for (i = 0; i < samples.length; i++) {\r\n        flags = samples[i].flags;\r\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\r\n      }\r\n\r\n      return box(types.sdtp, bytes);\r\n    };\r\n\r\n    stbl = function stbl(track) {\r\n      return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\r\n    };\r\n\r\n    (function () {\r\n      var videoSample, audioSample;\r\n\r\n      stsd = function stsd(track) {\r\n        return box(types.stsd, new Uint8Array([0x00, // version 0\r\n        0x00, 0x00, 0x00, // flags\r\n        0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\r\n      };\r\n\r\n      videoSample = function videoSample(track) {\r\n        var sps = track.sps || [],\r\n            pps = track.pps || [],\r\n            sequenceParameterSets = [],\r\n            pictureParameterSets = [],\r\n            i,\r\n            avc1Box; // assemble the SPSs\r\n\r\n        for (i = 0; i < sps.length; i++) {\r\n          sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\r\n          sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\r\n\r\n          sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\r\n        } // assemble the PPSs\r\n\r\n\r\n        for (i = 0; i < pps.length; i++) {\r\n          pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\r\n          pictureParameterSets.push(pps[i].byteLength & 0xFF);\r\n          pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\r\n        }\r\n\r\n        avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\r\n        0x00, 0x01, // data_reference_index\r\n        0x00, 0x00, // pre_defined\r\n        0x00, 0x00, // reserved\r\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\r\n        (track.width & 0xff00) >> 8, track.width & 0xff, // width\r\n        (track.height & 0xff00) >> 8, track.height & 0xff, // height\r\n        0x00, 0x48, 0x00, 0x00, // horizresolution\r\n        0x00, 0x48, 0x00, 0x00, // vertresolution\r\n        0x00, 0x00, 0x00, 0x00, // reserved\r\n        0x00, 0x01, // frame_count\r\n        0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\r\n        0x00, 0x18, // depth = 24\r\n        0x11, 0x11 // pre_defined = -1\r\n        ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\r\n        track.profileIdc, // AVCProfileIndication\r\n        track.profileCompatibility, // profile_compatibility\r\n        track.levelIdc, // AVCLevelIndication\r\n        0xff // lengthSizeMinusOne, hard-coded to 4 bytes\r\n        ].concat([sps.length], // numOfSequenceParameterSets\r\n        sequenceParameterSets, // \"SPS\"\r\n        [pps.length], // numOfPictureParameterSets\r\n        pictureParameterSets // \"PPS\"\r\n        ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\r\n        0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\r\n        0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\r\n        ]))];\r\n\r\n        if (track.sarRatio) {\r\n          var hSpacing = track.sarRatio[0],\r\n              vSpacing = track.sarRatio[1];\r\n          avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\r\n        }\r\n\r\n        return box.apply(null, avc1Box);\r\n      };\r\n\r\n      audioSample = function audioSample(track) {\r\n        return box(types.mp4a, new Uint8Array([// SampleEntry, ISO/IEC 14496-12\r\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\r\n        0x00, 0x01, // data_reference_index\r\n        // AudioSampleEntry, ISO/IEC 14496-12\r\n        0x00, 0x00, 0x00, 0x00, // reserved\r\n        0x00, 0x00, 0x00, 0x00, // reserved\r\n        (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\r\n        (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\r\n        0x00, 0x00, // pre_defined\r\n        0x00, 0x00, // reserved\r\n        (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\r\n        // MP4AudioSampleEntry, ISO/IEC 14496-14\r\n        ]), esds(track));\r\n      };\r\n    })();\r\n\r\n    tkhd = function tkhd(track) {\r\n      var result = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x07, // flags\r\n      0x00, 0x00, 0x00, 0x00, // creation_time\r\n      0x00, 0x00, 0x00, 0x00, // modification_time\r\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\r\n      0x00, 0x00, 0x00, 0x00, // reserved\r\n      (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\r\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\r\n      0x00, 0x00, // layer\r\n      0x00, 0x00, // alternate_group\r\n      0x01, 0x00, // non-audio track volume\r\n      0x00, 0x00, // reserved\r\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\r\n      (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\r\n      (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\r\n      ]);\r\n      return box(types.tkhd, result);\r\n    };\r\n    /**\r\n     * Generate a track fragment (traf) box. A traf box collects metadata\r\n     * about tracks in a movie fragment (moof) box.\r\n     */\r\n\r\n\r\n    traf = function traf(track) {\r\n      var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\r\n      trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x3a, // flags\r\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\r\n      0x00, 0x00, 0x00, 0x01, // sample_description_index\r\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\r\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\r\n      0x00, 0x00, 0x00, 0x00 // default_sample_flags\r\n      ]));\r\n      upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\r\n      lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\r\n      trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\r\n      0x00, 0x00, 0x00, // flags\r\n      // baseMediaDecodeTime\r\n      upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\r\n      // the containing moof to the first payload byte of the associated\r\n      // mdat\r\n\r\n      dataOffset = 32 + // tfhd\r\n      20 + // tfdt\r\n      8 + // traf header\r\n      16 + // mfhd\r\n      8 + // moof header\r\n      8; // mdat header\r\n      // audio tracks require less metadata\r\n\r\n      if (track.type === 'audio') {\r\n        trackFragmentRun = trun$1(track, dataOffset);\r\n        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\r\n      } // video tracks should contain an independent and disposable samples\r\n      // box (sdtp)\r\n      // generate one and adjust offsets to match\r\n\r\n\r\n      sampleDependencyTable = sdtp(track);\r\n      trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\r\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\r\n    };\r\n    /**\r\n     * Generate a track box.\r\n     * @param track {object} a track definition\r\n     * @return {Uint8Array} the track box\r\n     */\r\n\r\n\r\n    trak = function trak(track) {\r\n      track.duration = track.duration || 0xffffffff;\r\n      return box(types.trak, tkhd(track), mdia(track));\r\n    };\r\n\r\n    trex = function trex(track) {\r\n      var result = new Uint8Array([0x00, // version 0\r\n      0x00, 0x00, 0x00, // flags\r\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\r\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\r\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\r\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\r\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\r\n      ]); // the last two bytes of default_sample_flags is the sample\r\n      // degradation priority, a hint about the importance of this sample\r\n      // relative to others. Lower the degradation priority for all sample\r\n      // types other than video.\r\n\r\n      if (track.type !== 'video') {\r\n        result[result.length - 1] = 0x00;\r\n      }\r\n\r\n      return box(types.trex, result);\r\n    };\r\n\r\n    (function () {\r\n      var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\r\n      // duration is present for the first sample, it will be present for\r\n      // all subsequent samples.\r\n      // see ISO/IEC 14496-12:2012, Section 8.8.8.1\r\n\r\n      trunHeader = function trunHeader(samples, offset) {\r\n        var durationPresent = 0,\r\n            sizePresent = 0,\r\n            flagsPresent = 0,\r\n            compositionTimeOffset = 0; // trun flag constants\r\n\r\n        if (samples.length) {\r\n          if (samples[0].duration !== undefined) {\r\n            durationPresent = 0x1;\r\n          }\r\n\r\n          if (samples[0].size !== undefined) {\r\n            sizePresent = 0x2;\r\n          }\r\n\r\n          if (samples[0].flags !== undefined) {\r\n            flagsPresent = 0x4;\r\n          }\r\n\r\n          if (samples[0].compositionTimeOffset !== undefined) {\r\n            compositionTimeOffset = 0x8;\r\n          }\r\n        }\r\n\r\n        return [0x00, // version 0\r\n        0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\r\n        (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\r\n        (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\r\n        ];\r\n      };\r\n\r\n      videoTrun = function videoTrun(track, offset) {\r\n        var bytesOffest, bytes, header, samples, sample, i;\r\n        samples = track.samples || [];\r\n        offset += 8 + 12 + 16 * samples.length;\r\n        header = trunHeader(samples, offset);\r\n        bytes = new Uint8Array(header.length + samples.length * 16);\r\n        bytes.set(header);\r\n        bytesOffest = header.length;\r\n\r\n        for (i = 0; i < samples.length; i++) {\r\n          sample = samples[i];\r\n          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\r\n          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\r\n          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\r\n          bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\r\n\r\n          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\r\n          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\r\n          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\r\n          bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\r\n\r\n          bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\r\n          bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\r\n          bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\r\n          bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\r\n\r\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\r\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\r\n          bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\r\n          bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\r\n        }\r\n\r\n        return box(types.trun, bytes);\r\n      };\r\n\r\n      audioTrun = function audioTrun(track, offset) {\r\n        var bytes, bytesOffest, header, samples, sample, i;\r\n        samples = track.samples || [];\r\n        offset += 8 + 12 + 8 * samples.length;\r\n        header = trunHeader(samples, offset);\r\n        bytes = new Uint8Array(header.length + samples.length * 8);\r\n        bytes.set(header);\r\n        bytesOffest = header.length;\r\n\r\n        for (i = 0; i < samples.length; i++) {\r\n          sample = samples[i];\r\n          bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\r\n          bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\r\n          bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\r\n          bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\r\n\r\n          bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\r\n          bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\r\n          bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\r\n          bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\r\n        }\r\n\r\n        return box(types.trun, bytes);\r\n      };\r\n\r\n      trun$1 = function trun(track, offset) {\r\n        if (track.type === 'audio') {\r\n          return audioTrun(track, offset);\r\n        }\r\n\r\n        return videoTrun(track, offset);\r\n      };\r\n    })();\r\n\r\n    var mp4Generator = {\r\n      ftyp: ftyp,\r\n      mdat: mdat,\r\n      moof: moof,\r\n      moov: moov,\r\n      initSegment: function initSegment(tracks) {\r\n        var fileType = ftyp(),\r\n            movie = moov(tracks),\r\n            result;\r\n        result = new Uint8Array(fileType.byteLength + movie.byteLength);\r\n        result.set(fileType);\r\n        result.set(movie, fileType.byteLength);\r\n        return result;\r\n      }\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n    // Convert an array of nal units into an array of frames with each frame being\r\n    // composed of the nal units that make up that frame\r\n    // Also keep track of cummulative data about the frame from the nal units such\r\n    // as the frame duration, starting pts, etc.\r\n\r\n    var groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {\r\n      var i,\r\n          currentNal,\r\n          currentFrame = [],\r\n          frames = []; // TODO added for LHLS, make sure this is OK\r\n\r\n      frames.byteLength = 0;\r\n      frames.nalCount = 0;\r\n      frames.duration = 0;\r\n      currentFrame.byteLength = 0;\r\n\r\n      for (i = 0; i < nalUnits.length; i++) {\r\n        currentNal = nalUnits[i]; // Split on 'aud'-type nal units\r\n\r\n        if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\r\n          // Since the very first nal unit is expected to be an AUD\r\n          // only push to the frames array when currentFrame is not empty\r\n          if (currentFrame.length) {\r\n            currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\r\n\r\n            frames.byteLength += currentFrame.byteLength;\r\n            frames.nalCount += currentFrame.length;\r\n            frames.duration += currentFrame.duration;\r\n            frames.push(currentFrame);\r\n          }\r\n\r\n          currentFrame = [currentNal];\r\n          currentFrame.byteLength = currentNal.data.byteLength;\r\n          currentFrame.pts = currentNal.pts;\r\n          currentFrame.dts = currentNal.dts;\r\n        } else {\r\n          // Specifically flag key frames for ease of use later\r\n          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\r\n            currentFrame.keyFrame = true;\r\n          }\r\n\r\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\r\n          currentFrame.byteLength += currentNal.data.byteLength;\r\n          currentFrame.push(currentNal);\r\n        }\r\n      } // For the last frame, use the duration of the previous frame if we\r\n      // have nothing better to go on\r\n\r\n\r\n      if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\r\n        currentFrame.duration = frames[frames.length - 1].duration;\r\n      } // Push the final frame\r\n      // TODO added for LHLS, make sure this is OK\r\n\r\n\r\n      frames.byteLength += currentFrame.byteLength;\r\n      frames.nalCount += currentFrame.length;\r\n      frames.duration += currentFrame.duration;\r\n      frames.push(currentFrame);\r\n      return frames;\r\n    }; // Convert an array of frames into an array of Gop with each Gop being composed\r\n    // of the frames that make up that Gop\r\n    // Also keep track of cummulative data about the Gop from the frames such as the\r\n    // Gop duration, starting pts, etc.\r\n\r\n\r\n    var groupFramesIntoGops = function groupFramesIntoGops(frames) {\r\n      var i,\r\n          currentFrame,\r\n          currentGop = [],\r\n          gops = []; // We must pre-set some of the values on the Gop since we\r\n      // keep running totals of these values\r\n\r\n      currentGop.byteLength = 0;\r\n      currentGop.nalCount = 0;\r\n      currentGop.duration = 0;\r\n      currentGop.pts = frames[0].pts;\r\n      currentGop.dts = frames[0].dts; // store some metadata about all the Gops\r\n\r\n      gops.byteLength = 0;\r\n      gops.nalCount = 0;\r\n      gops.duration = 0;\r\n      gops.pts = frames[0].pts;\r\n      gops.dts = frames[0].dts;\r\n\r\n      for (i = 0; i < frames.length; i++) {\r\n        currentFrame = frames[i];\r\n\r\n        if (currentFrame.keyFrame) {\r\n          // Since the very first frame is expected to be an keyframe\r\n          // only push to the gops array when currentGop is not empty\r\n          if (currentGop.length) {\r\n            gops.push(currentGop);\r\n            gops.byteLength += currentGop.byteLength;\r\n            gops.nalCount += currentGop.nalCount;\r\n            gops.duration += currentGop.duration;\r\n          }\r\n\r\n          currentGop = [currentFrame];\r\n          currentGop.nalCount = currentFrame.length;\r\n          currentGop.byteLength = currentFrame.byteLength;\r\n          currentGop.pts = currentFrame.pts;\r\n          currentGop.dts = currentFrame.dts;\r\n          currentGop.duration = currentFrame.duration;\r\n        } else {\r\n          currentGop.duration += currentFrame.duration;\r\n          currentGop.nalCount += currentFrame.length;\r\n          currentGop.byteLength += currentFrame.byteLength;\r\n          currentGop.push(currentFrame);\r\n        }\r\n      }\r\n\r\n      if (gops.length && currentGop.duration <= 0) {\r\n        currentGop.duration = gops[gops.length - 1].duration;\r\n      }\r\n\r\n      gops.byteLength += currentGop.byteLength;\r\n      gops.nalCount += currentGop.nalCount;\r\n      gops.duration += currentGop.duration; // push the final Gop\r\n\r\n      gops.push(currentGop);\r\n      return gops;\r\n    };\r\n    /*\r\n     * Search for the first keyframe in the GOPs and throw away all frames\r\n     * until that keyframe. Then extend the duration of the pulled keyframe\r\n     * and pull the PTS and DTS of the keyframe so that it covers the time\r\n     * range of the frames that were disposed.\r\n     *\r\n     * @param {Array} gops video GOPs\r\n     * @returns {Array} modified video GOPs\r\n     */\r\n\r\n\r\n    var extendFirstKeyFrame = function extendFirstKeyFrame(gops) {\r\n      var currentGop;\r\n\r\n      if (!gops[0][0].keyFrame && gops.length > 1) {\r\n        // Remove the first GOP\r\n        currentGop = gops.shift();\r\n        gops.byteLength -= currentGop.byteLength;\r\n        gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\r\n        // first gop to cover the time period of the\r\n        // frames we just removed\r\n\r\n        gops[0][0].dts = currentGop.dts;\r\n        gops[0][0].pts = currentGop.pts;\r\n        gops[0][0].duration += currentGop.duration;\r\n      }\r\n\r\n      return gops;\r\n    };\r\n    /**\r\n     * Default sample object\r\n     * see ISO/IEC 14496-12:2012, section 8.6.4.3\r\n     */\r\n\r\n\r\n    var createDefaultSample = function createDefaultSample() {\r\n      return {\r\n        size: 0,\r\n        flags: {\r\n          isLeading: 0,\r\n          dependsOn: 1,\r\n          isDependedOn: 0,\r\n          hasRedundancy: 0,\r\n          degradationPriority: 0,\r\n          isNonSyncSample: 1\r\n        }\r\n      };\r\n    };\r\n    /*\r\n     * Collates information from a video frame into an object for eventual\r\n     * entry into an MP4 sample table.\r\n     *\r\n     * @param {Object} frame the video frame\r\n     * @param {Number} dataOffset the byte offset to position the sample\r\n     * @return {Object} object containing sample table info for a frame\r\n     */\r\n\r\n\r\n    var sampleForFrame = function sampleForFrame(frame, dataOffset) {\r\n      var sample = createDefaultSample();\r\n      sample.dataOffset = dataOffset;\r\n      sample.compositionTimeOffset = frame.pts - frame.dts;\r\n      sample.duration = frame.duration;\r\n      sample.size = 4 * frame.length; // Space for nal unit size\r\n\r\n      sample.size += frame.byteLength;\r\n\r\n      if (frame.keyFrame) {\r\n        sample.flags.dependsOn = 2;\r\n        sample.flags.isNonSyncSample = 0;\r\n      }\r\n\r\n      return sample;\r\n    }; // generate the track's sample table from an array of gops\r\n\r\n\r\n    var generateSampleTable$1 = function generateSampleTable(gops, baseDataOffset) {\r\n      var h,\r\n          i,\r\n          sample,\r\n          currentGop,\r\n          currentFrame,\r\n          dataOffset = baseDataOffset || 0,\r\n          samples = [];\r\n\r\n      for (h = 0; h < gops.length; h++) {\r\n        currentGop = gops[h];\r\n\r\n        for (i = 0; i < currentGop.length; i++) {\r\n          currentFrame = currentGop[i];\r\n          sample = sampleForFrame(currentFrame, dataOffset);\r\n          dataOffset += sample.size;\r\n          samples.push(sample);\r\n        }\r\n      }\r\n\r\n      return samples;\r\n    }; // generate the track's raw mdat data from an array of gops\r\n\r\n\r\n    var concatenateNalData = function concatenateNalData(gops) {\r\n      var h,\r\n          i,\r\n          j,\r\n          currentGop,\r\n          currentFrame,\r\n          currentNal,\r\n          dataOffset = 0,\r\n          nalsByteLength = gops.byteLength,\r\n          numberOfNals = gops.nalCount,\r\n          totalByteLength = nalsByteLength + 4 * numberOfNals,\r\n          data = new Uint8Array(totalByteLength),\r\n          view = new DataView(data.buffer); // For each Gop..\r\n\r\n      for (h = 0; h < gops.length; h++) {\r\n        currentGop = gops[h]; // For each Frame..\r\n\r\n        for (i = 0; i < currentGop.length; i++) {\r\n          currentFrame = currentGop[i]; // For each NAL..\r\n\r\n          for (j = 0; j < currentFrame.length; j++) {\r\n            currentNal = currentFrame[j];\r\n            view.setUint32(dataOffset, currentNal.data.byteLength);\r\n            dataOffset += 4;\r\n            data.set(currentNal.data, dataOffset);\r\n            dataOffset += currentNal.data.byteLength;\r\n          }\r\n        }\r\n      }\r\n\r\n      return data;\r\n    }; // generate the track's sample table from a frame\r\n\r\n\r\n    var generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {\r\n      var sample,\r\n          dataOffset = baseDataOffset || 0,\r\n          samples = [];\r\n      sample = sampleForFrame(frame, dataOffset);\r\n      samples.push(sample);\r\n      return samples;\r\n    }; // generate the track's raw mdat data from a frame\r\n\r\n\r\n    var concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {\r\n      var i,\r\n          currentNal,\r\n          dataOffset = 0,\r\n          nalsByteLength = frame.byteLength,\r\n          numberOfNals = frame.length,\r\n          totalByteLength = nalsByteLength + 4 * numberOfNals,\r\n          data = new Uint8Array(totalByteLength),\r\n          view = new DataView(data.buffer); // For each NAL..\r\n\r\n      for (i = 0; i < frame.length; i++) {\r\n        currentNal = frame[i];\r\n        view.setUint32(dataOffset, currentNal.data.byteLength);\r\n        dataOffset += 4;\r\n        data.set(currentNal.data, dataOffset);\r\n        dataOffset += currentNal.data.byteLength;\r\n      }\r\n\r\n      return data;\r\n    };\r\n\r\n    var frameUtils = {\r\n      groupNalsIntoFrames: groupNalsIntoFrames,\r\n      groupFramesIntoGops: groupFramesIntoGops,\r\n      extendFirstKeyFrame: extendFirstKeyFrame,\r\n      generateSampleTable: generateSampleTable$1,\r\n      concatenateNalData: concatenateNalData,\r\n      generateSampleTableForFrame: generateSampleTableForFrame,\r\n      concatenateNalDataForFrame: concatenateNalDataForFrame\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n    var highPrefix = [33, 16, 5, 32, 164, 27];\r\n    var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\r\n\r\n    var zeroFill = function zeroFill(count) {\r\n      var a = [];\r\n\r\n      while (count--) {\r\n        a.push(0);\r\n      }\r\n\r\n      return a;\r\n    };\r\n\r\n    var makeTable = function makeTable(metaTable) {\r\n      return Object.keys(metaTable).reduce(function (obj, key) {\r\n        obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\r\n          return arr.concat(part);\r\n        }, []));\r\n        return obj;\r\n      }, {});\r\n    };\r\n\r\n    var silence;\r\n\r\n    var silence_1 = function silence_1() {\r\n      if (!silence) {\r\n        // Frames-of-silence to use for filling in missing AAC frames\r\n        var coneOfSilence = {\r\n          96000: [highPrefix, [227, 64], zeroFill(154), [56]],\r\n          88200: [highPrefix, [231], zeroFill(170), [56]],\r\n          64000: [highPrefix, [248, 192], zeroFill(240), [56]],\r\n          48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\r\n          44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\r\n          32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\r\n          24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\r\n          16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\r\n          12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\r\n          11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\r\n          8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\r\n        };\r\n        silence = makeTable(coneOfSilence);\r\n      }\r\n\r\n      return silence;\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n\r\n    var ONE_SECOND_IN_TS$4 = 90000,\r\n        // 90kHz clock\r\n    secondsToVideoTs,\r\n        secondsToAudioTs,\r\n        videoTsToSeconds,\r\n        audioTsToSeconds,\r\n        audioTsToVideoTs,\r\n        videoTsToAudioTs,\r\n        metadataTsToSeconds;\r\n\r\n    secondsToVideoTs = function secondsToVideoTs(seconds) {\r\n      return seconds * ONE_SECOND_IN_TS$4;\r\n    };\r\n\r\n    secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\r\n      return seconds * sampleRate;\r\n    };\r\n\r\n    videoTsToSeconds = function videoTsToSeconds(timestamp) {\r\n      return timestamp / ONE_SECOND_IN_TS$4;\r\n    };\r\n\r\n    audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\r\n      return timestamp / sampleRate;\r\n    };\r\n\r\n    audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\r\n      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\r\n    };\r\n\r\n    videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\r\n      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\r\n    };\r\n    /**\r\n     * Adjust ID3 tag or caption timing information by the timeline pts values\r\n     * (if keepOriginalTimestamps is false) and convert to seconds\r\n     */\r\n\r\n\r\n    metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\r\n      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\r\n    };\r\n\r\n    var clock = {\r\n      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,\r\n      secondsToVideoTs: secondsToVideoTs,\r\n      secondsToAudioTs: secondsToAudioTs,\r\n      videoTsToSeconds: videoTsToSeconds,\r\n      audioTsToSeconds: audioTsToSeconds,\r\n      audioTsToVideoTs: audioTsToVideoTs,\r\n      videoTsToAudioTs: videoTsToAudioTs,\r\n      metadataTsToSeconds: metadataTsToSeconds\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n    /**\r\n     * Sum the `byteLength` properties of the data in each AAC frame\r\n     */\r\n\r\n    var sumFrameByteLengths = function sumFrameByteLengths(array) {\r\n      var i,\r\n          currentObj,\r\n          sum = 0; // sum the byteLength's all each nal unit in the frame\r\n\r\n      for (i = 0; i < array.length; i++) {\r\n        currentObj = array[i];\r\n        sum += currentObj.data.byteLength;\r\n      }\r\n\r\n      return sum;\r\n    }; // Possibly pad (prefix) the audio track with silence if appending this track\r\n    // would lead to the introduction of a gap in the audio buffer\r\n\r\n\r\n    var prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\r\n      var baseMediaDecodeTimeTs,\r\n          frameDuration = 0,\r\n          audioGapDuration = 0,\r\n          audioFillFrameCount = 0,\r\n          audioFillDuration = 0,\r\n          silentFrame,\r\n          i,\r\n          firstFrame;\r\n\r\n      if (!frames.length) {\r\n        return;\r\n      }\r\n\r\n      baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\r\n\r\n      frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));\r\n\r\n      if (audioAppendStartTs && videoBaseMediaDecodeTime) {\r\n        // insert the shortest possible amount (audio gap or audio to video gap)\r\n        audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\r\n\r\n        audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\r\n        audioFillDuration = audioFillFrameCount * frameDuration;\r\n      } // don't attempt to fill gaps smaller than a single frame or larger\r\n      // than a half second\r\n\r\n\r\n      if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {\r\n        return;\r\n      }\r\n\r\n      silentFrame = silence_1()[track.samplerate];\r\n\r\n      if (!silentFrame) {\r\n        // we don't have a silent frame pregenerated for the sample rate, so use a frame\r\n        // from the content instead\r\n        silentFrame = frames[0].data;\r\n      }\r\n\r\n      for (i = 0; i < audioFillFrameCount; i++) {\r\n        firstFrame = frames[0];\r\n        frames.splice(0, 0, {\r\n          data: silentFrame,\r\n          dts: firstFrame.dts - frameDuration,\r\n          pts: firstFrame.pts - frameDuration\r\n        });\r\n      }\r\n\r\n      track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\r\n      return audioFillDuration;\r\n    }; // If the audio segment extends before the earliest allowed dts\r\n    // value, remove AAC frames until starts at or after the earliest\r\n    // allowed DTS so that we don't end up with a negative baseMedia-\r\n    // DecodeTime for the audio track\r\n\r\n\r\n    var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {\r\n      if (track.minSegmentDts >= earliestAllowedDts) {\r\n        return adtsFrames;\r\n      } // We will need to recalculate the earliest segment Dts\r\n\r\n\r\n      track.minSegmentDts = Infinity;\r\n      return adtsFrames.filter(function (currentFrame) {\r\n        // If this is an allowed frame, keep it and record it's Dts\r\n        if (currentFrame.dts >= earliestAllowedDts) {\r\n          track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\r\n          track.minSegmentPts = track.minSegmentDts;\r\n          return true;\r\n        } // Otherwise, discard it\r\n\r\n\r\n        return false;\r\n      });\r\n    }; // generate the track's raw mdat data from an array of frames\r\n\r\n\r\n    var generateSampleTable = function generateSampleTable(frames) {\r\n      var i,\r\n          currentFrame,\r\n          samples = [];\r\n\r\n      for (i = 0; i < frames.length; i++) {\r\n        currentFrame = frames[i];\r\n        samples.push({\r\n          size: currentFrame.data.byteLength,\r\n          duration: 1024 // For AAC audio, all samples contain 1024 samples\r\n\r\n        });\r\n      }\r\n\r\n      return samples;\r\n    }; // generate the track's sample table from an array of frames\r\n\r\n\r\n    var concatenateFrameData = function concatenateFrameData(frames) {\r\n      var i,\r\n          currentFrame,\r\n          dataOffset = 0,\r\n          data = new Uint8Array(sumFrameByteLengths(frames));\r\n\r\n      for (i = 0; i < frames.length; i++) {\r\n        currentFrame = frames[i];\r\n        data.set(currentFrame.data, dataOffset);\r\n        dataOffset += currentFrame.data.byteLength;\r\n      }\r\n\r\n      return data;\r\n    };\r\n\r\n    var audioFrameUtils = {\r\n      prefixWithSilence: prefixWithSilence,\r\n      trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\r\n      generateSampleTable: generateSampleTable,\r\n      concatenateFrameData: concatenateFrameData\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n    var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;\r\n    /**\r\n     * Store information about the start and end of the track and the\r\n     * duration for each frame/sample we process in order to calculate\r\n     * the baseMediaDecodeTime\r\n     */\r\n\r\n    var collectDtsInfo = function collectDtsInfo(track, data) {\r\n      if (typeof data.pts === 'number') {\r\n        if (track.timelineStartInfo.pts === undefined) {\r\n          track.timelineStartInfo.pts = data.pts;\r\n        }\r\n\r\n        if (track.minSegmentPts === undefined) {\r\n          track.minSegmentPts = data.pts;\r\n        } else {\r\n          track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\r\n        }\r\n\r\n        if (track.maxSegmentPts === undefined) {\r\n          track.maxSegmentPts = data.pts;\r\n        } else {\r\n          track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\r\n        }\r\n      }\r\n\r\n      if (typeof data.dts === 'number') {\r\n        if (track.timelineStartInfo.dts === undefined) {\r\n          track.timelineStartInfo.dts = data.dts;\r\n        }\r\n\r\n        if (track.minSegmentDts === undefined) {\r\n          track.minSegmentDts = data.dts;\r\n        } else {\r\n          track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\r\n        }\r\n\r\n        if (track.maxSegmentDts === undefined) {\r\n          track.maxSegmentDts = data.dts;\r\n        } else {\r\n          track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * Clear values used to calculate the baseMediaDecodeTime between\r\n     * tracks\r\n     */\r\n\r\n\r\n    var clearDtsInfo = function clearDtsInfo(track) {\r\n      delete track.minSegmentDts;\r\n      delete track.maxSegmentDts;\r\n      delete track.minSegmentPts;\r\n      delete track.maxSegmentPts;\r\n    };\r\n    /**\r\n     * Calculate the track's baseMediaDecodeTime based on the earliest\r\n     * DTS the transmuxer has ever seen and the minimum DTS for the\r\n     * current track\r\n     * @param track {object} track metadata configuration\r\n     * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\r\n     *        in the source; false to adjust the first segment to start at 0.\r\n     */\r\n\r\n\r\n    var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\r\n      var baseMediaDecodeTime,\r\n          scale,\r\n          minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\r\n\r\n      if (!keepOriginalTimestamps) {\r\n        minSegmentDts -= track.timelineStartInfo.dts;\r\n      } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\r\n      // we want the start of the first segment to be placed\r\n\r\n\r\n      baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\r\n\r\n      baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\r\n\r\n      baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\r\n\r\n      if (track.type === 'audio') {\r\n        // Audio has a different clock equal to the sampling_rate so we need to\r\n        // scale the PTS values into the clock rate of the track\r\n        scale = track.samplerate / ONE_SECOND_IN_TS$3;\r\n        baseMediaDecodeTime *= scale;\r\n        baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\r\n      }\r\n\r\n      return baseMediaDecodeTime;\r\n    };\r\n\r\n    var trackDecodeInfo = {\r\n      clearDtsInfo: clearDtsInfo,\r\n      calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\r\n      collectDtsInfo: collectDtsInfo\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     *\r\n     * Reads in-band caption information from a video elementary\r\n     * stream. Captions must follow the CEA-708 standard for injection\r\n     * into an MPEG-2 transport streams.\r\n     * @see https://en.wikipedia.org/wiki/CEA-708\r\n     * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\r\n     */\r\n    // payload type field to indicate how they are to be\r\n    // interpreted. CEAS-708 caption content is always transmitted with\r\n    // payload type 0x04.\r\n\r\n    var USER_DATA_REGISTERED_ITU_T_T35 = 4,\r\n        RBSP_TRAILING_BITS = 128;\r\n    /**\r\n      * Parse a supplemental enhancement information (SEI) NAL unit.\r\n      * Stops parsing once a message of type ITU T T35 has been found.\r\n      *\r\n      * @param bytes {Uint8Array} the bytes of a SEI NAL unit\r\n      * @return {object} the parsed SEI payload\r\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\r\n      */\r\n\r\n    var parseSei = function parseSei(bytes) {\r\n      var i = 0,\r\n          result = {\r\n        payloadType: -1,\r\n        payloadSize: 0\r\n      },\r\n          payloadType = 0,\r\n          payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\r\n\r\n      while (i < bytes.byteLength) {\r\n        // stop once we have hit the end of the sei_rbsp\r\n        if (bytes[i] === RBSP_TRAILING_BITS) {\r\n          break;\r\n        } // Parse payload type\r\n\r\n\r\n        while (bytes[i] === 0xFF) {\r\n          payloadType += 255;\r\n          i++;\r\n        }\r\n\r\n        payloadType += bytes[i++]; // Parse payload size\r\n\r\n        while (bytes[i] === 0xFF) {\r\n          payloadSize += 255;\r\n          i++;\r\n        }\r\n\r\n        payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\r\n        // there can only ever be one caption message in a frame's sei\r\n\r\n        if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\r\n          var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\r\n\r\n          if (userIdentifier === 'GA94') {\r\n            result.payloadType = payloadType;\r\n            result.payloadSize = payloadSize;\r\n            result.payload = bytes.subarray(i, i + payloadSize);\r\n            break;\r\n          } else {\r\n            result.payload = void 0;\r\n          }\r\n        } // skip the payload and parse the next message\r\n\r\n\r\n        i += payloadSize;\r\n        payloadType = 0;\r\n        payloadSize = 0;\r\n      }\r\n\r\n      return result;\r\n    }; // see ANSI/SCTE 128-1 (2013), section 8.1\r\n\r\n\r\n    var parseUserData = function parseUserData(sei) {\r\n      // itu_t_t35_contry_code must be 181 (United States) for\r\n      // captions\r\n      if (sei.payload[0] !== 181) {\r\n        return null;\r\n      } // itu_t_t35_provider_code should be 49 (ATSC) for captions\r\n\r\n\r\n      if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\r\n        return null;\r\n      } // the user_identifier should be \"GA94\" to indicate ATSC1 data\r\n\r\n\r\n      if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\r\n        return null;\r\n      } // finally, user_data_type_code should be 0x03 for caption data\r\n\r\n\r\n      if (sei.payload[7] !== 0x03) {\r\n        return null;\r\n      } // return the user_data_type_structure and strip the trailing\r\n      // marker bits\r\n\r\n\r\n      return sei.payload.subarray(8, sei.payload.length - 1);\r\n    }; // see CEA-708-D, section 4.4\r\n\r\n\r\n    var parseCaptionPackets = function parseCaptionPackets(pts, userData) {\r\n      var results = [],\r\n          i,\r\n          count,\r\n          offset,\r\n          data; // if this is just filler, return immediately\r\n\r\n      if (!(userData[0] & 0x40)) {\r\n        return results;\r\n      } // parse out the cc_data_1 and cc_data_2 fields\r\n\r\n\r\n      count = userData[0] & 0x1f;\r\n\r\n      for (i = 0; i < count; i++) {\r\n        offset = i * 3;\r\n        data = {\r\n          type: userData[offset + 2] & 0x03,\r\n          pts: pts\r\n        }; // capture cc data when cc_valid is 1\r\n\r\n        if (userData[offset + 2] & 0x04) {\r\n          data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\r\n          results.push(data);\r\n        }\r\n      }\r\n\r\n      return results;\r\n    };\r\n\r\n    var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes(data) {\r\n      var length = data.byteLength,\r\n          emulationPreventionBytesPositions = [],\r\n          i = 1,\r\n          newLength,\r\n          newData; // Find all `Emulation Prevention Bytes`\r\n\r\n      while (i < length - 2) {\r\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\r\n          emulationPreventionBytesPositions.push(i + 2);\r\n          i += 2;\r\n        } else {\r\n          i++;\r\n        }\r\n      } // If no Emulation Prevention Bytes were found just return the original\r\n      // array\r\n\r\n\r\n      if (emulationPreventionBytesPositions.length === 0) {\r\n        return data;\r\n      } // Create a new array to hold the NAL unit data\r\n\r\n\r\n      newLength = length - emulationPreventionBytesPositions.length;\r\n      newData = new Uint8Array(newLength);\r\n      var sourceIndex = 0;\r\n\r\n      for (i = 0; i < newLength; sourceIndex++, i++) {\r\n        if (sourceIndex === emulationPreventionBytesPositions[0]) {\r\n          // Skip this byte\r\n          sourceIndex++; // Remove this position index\r\n\r\n          emulationPreventionBytesPositions.shift();\r\n        }\r\n\r\n        newData[i] = data[sourceIndex];\r\n      }\r\n\r\n      return newData;\r\n    }; // exports\r\n\r\n\r\n    var captionPacketParser = {\r\n      parseSei: parseSei,\r\n      parseUserData: parseUserData,\r\n      parseCaptionPackets: parseCaptionPackets,\r\n      discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\r\n      USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\r\n    }; // Link To Transport\r\n    // -----------------\r\n\r\n    var CaptionStream$1 = function CaptionStream(options) {\r\n      options = options || {};\r\n      CaptionStream.prototype.init.call(this); // parse708captions flag, default to true\r\n\r\n      this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\r\n      this.captionPackets_ = [];\r\n      this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\r\n      new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\r\n      new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\r\n      new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\r\n      ];\r\n\r\n      if (this.parse708captions_) {\r\n        this.cc708Stream_ = new Cea708Stream({\r\n          captionServices: options.captionServices\r\n        }); // eslint-disable-line no-use-before-define\r\n      }\r\n\r\n      this.reset(); // forward data and done events from CCs to this CaptionStream\r\n\r\n      this.ccStreams_.forEach(function (cc) {\r\n        cc.on('data', this.trigger.bind(this, 'data'));\r\n        cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\r\n        cc.on('done', this.trigger.bind(this, 'done'));\r\n      }, this);\r\n\r\n      if (this.parse708captions_) {\r\n        this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\r\n        this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\r\n        this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\r\n      }\r\n    };\r\n\r\n    CaptionStream$1.prototype = new stream();\r\n\r\n    CaptionStream$1.prototype.push = function (event) {\r\n      var sei, userData, newCaptionPackets; // only examine SEI NALs\r\n\r\n      if (event.nalUnitType !== 'sei_rbsp') {\r\n        return;\r\n      } // parse the sei\r\n\r\n\r\n      sei = captionPacketParser.parseSei(event.escapedRBSP); // no payload data, skip\r\n\r\n      if (!sei.payload) {\r\n        return;\r\n      } // ignore everything but user_data_registered_itu_t_t35\r\n\r\n\r\n      if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {\r\n        return;\r\n      } // parse out the user data payload\r\n\r\n\r\n      userData = captionPacketParser.parseUserData(sei); // ignore unrecognized userData\r\n\r\n      if (!userData) {\r\n        return;\r\n      } // Sometimes, the same segment # will be downloaded twice. To stop the\r\n      // caption data from being processed twice, we track the latest dts we've\r\n      // received and ignore everything with a dts before that. However, since\r\n      // data for a specific dts can be split across packets on either side of\r\n      // a segment boundary, we need to make sure we *don't* ignore the packets\r\n      // from the *next* segment that have dts === this.latestDts_. By constantly\r\n      // tracking the number of packets received with dts === this.latestDts_, we\r\n      // know how many should be ignored once we start receiving duplicates.\r\n\r\n\r\n      if (event.dts < this.latestDts_) {\r\n        // We've started getting older data, so set the flag.\r\n        this.ignoreNextEqualDts_ = true;\r\n        return;\r\n      } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\r\n        this.numSameDts_--;\r\n\r\n        if (!this.numSameDts_) {\r\n          // We've received the last duplicate packet, time to start processing again\r\n          this.ignoreNextEqualDts_ = false;\r\n        }\r\n\r\n        return;\r\n      } // parse out CC data packets and save them for later\r\n\r\n\r\n      newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);\r\n      this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\r\n\r\n      if (this.latestDts_ !== event.dts) {\r\n        this.numSameDts_ = 0;\r\n      }\r\n\r\n      this.numSameDts_++;\r\n      this.latestDts_ = event.dts;\r\n    };\r\n\r\n    CaptionStream$1.prototype.flushCCStreams = function (flushType) {\r\n      this.ccStreams_.forEach(function (cc) {\r\n        return flushType === 'flush' ? cc.flush() : cc.partialFlush();\r\n      }, this);\r\n    };\r\n\r\n    CaptionStream$1.prototype.flushStream = function (flushType) {\r\n      // make sure we actually parsed captions before proceeding\r\n      if (!this.captionPackets_.length) {\r\n        this.flushCCStreams(flushType);\r\n        return;\r\n      } // In Chrome, the Array#sort function is not stable so add a\r\n      // presortIndex that we can use to ensure we get a stable-sort\r\n\r\n\r\n      this.captionPackets_.forEach(function (elem, idx) {\r\n        elem.presortIndex = idx;\r\n      }); // sort caption byte-pairs based on their PTS values\r\n\r\n      this.captionPackets_.sort(function (a, b) {\r\n        if (a.pts === b.pts) {\r\n          return a.presortIndex - b.presortIndex;\r\n        }\r\n\r\n        return a.pts - b.pts;\r\n      });\r\n      this.captionPackets_.forEach(function (packet) {\r\n        if (packet.type < 2) {\r\n          // Dispatch packet to the right Cea608Stream\r\n          this.dispatchCea608Packet(packet);\r\n        } else {\r\n          // Dispatch packet to the Cea708Stream\r\n          this.dispatchCea708Packet(packet);\r\n        }\r\n      }, this);\r\n      this.captionPackets_.length = 0;\r\n      this.flushCCStreams(flushType);\r\n    };\r\n\r\n    CaptionStream$1.prototype.flush = function () {\r\n      return this.flushStream('flush');\r\n    }; // Only called if handling partial data\r\n\r\n\r\n    CaptionStream$1.prototype.partialFlush = function () {\r\n      return this.flushStream('partialFlush');\r\n    };\r\n\r\n    CaptionStream$1.prototype.reset = function () {\r\n      this.latestDts_ = null;\r\n      this.ignoreNextEqualDts_ = false;\r\n      this.numSameDts_ = 0;\r\n      this.activeCea608Channel_ = [null, null];\r\n      this.ccStreams_.forEach(function (ccStream) {\r\n        ccStream.reset();\r\n      });\r\n    }; // From the CEA-608 spec:\r\n\r\n    /*\r\n     * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\r\n     * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\r\n     * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\r\n     * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\r\n     * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\r\n     * to switch to captioning or Text.\r\n    */\r\n    // With that in mind, we ignore any data between an XDS control code and a\r\n    // subsequent closed-captioning control code.\r\n\r\n\r\n    CaptionStream$1.prototype.dispatchCea608Packet = function (packet) {\r\n      // NOTE: packet.type is the CEA608 field\r\n      if (this.setsTextOrXDSActive(packet)) {\r\n        this.activeCea608Channel_[packet.type] = null;\r\n      } else if (this.setsChannel1Active(packet)) {\r\n        this.activeCea608Channel_[packet.type] = 0;\r\n      } else if (this.setsChannel2Active(packet)) {\r\n        this.activeCea608Channel_[packet.type] = 1;\r\n      }\r\n\r\n      if (this.activeCea608Channel_[packet.type] === null) {\r\n        // If we haven't received anything to set the active channel, or the\r\n        // packets are Text/XDS data, discard the data; we don't want jumbled\r\n        // captions\r\n        return;\r\n      }\r\n\r\n      this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\r\n    };\r\n\r\n    CaptionStream$1.prototype.setsChannel1Active = function (packet) {\r\n      return (packet.ccData & 0x7800) === 0x1000;\r\n    };\r\n\r\n    CaptionStream$1.prototype.setsChannel2Active = function (packet) {\r\n      return (packet.ccData & 0x7800) === 0x1800;\r\n    };\r\n\r\n    CaptionStream$1.prototype.setsTextOrXDSActive = function (packet) {\r\n      return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\r\n    };\r\n\r\n    CaptionStream$1.prototype.dispatchCea708Packet = function (packet) {\r\n      if (this.parse708captions_) {\r\n        this.cc708Stream_.push(packet);\r\n      }\r\n    }; // ----------------------\r\n    // Session to Application\r\n    // ----------------------\r\n    // This hash maps special and extended character codes to their\r\n    // proper Unicode equivalent. The first one-byte key is just a\r\n    // non-standard character code. The two-byte keys that follow are\r\n    // the extended CEA708 character codes, along with the preceding\r\n    // 0x10 extended character byte to distinguish these codes from\r\n    // non-extended character codes. Every CEA708 character code that\r\n    // is not in this object maps directly to a standard unicode\r\n    // character code.\r\n    // The transparent space and non-breaking transparent space are\r\n    // technically not fully supported since there is no code to\r\n    // make them transparent, so they have normal non-transparent\r\n    // stand-ins.\r\n    // The special closed caption (CC) character isn't a standard\r\n    // unicode character, so a fairly similar unicode character was\r\n    // chosen in it's place.\r\n\r\n\r\n    var CHARACTER_TRANSLATION_708 = {\r\n      0x7f: 0x266a,\r\n      // \r\n      0x1020: 0x20,\r\n      // Transparent Space\r\n      0x1021: 0xa0,\r\n      // Nob-breaking Transparent Space\r\n      0x1025: 0x2026,\r\n      // \r\n      0x102a: 0x0160,\r\n      // \r\n      0x102c: 0x0152,\r\n      // \r\n      0x1030: 0x2588,\r\n      // \r\n      0x1031: 0x2018,\r\n      // \r\n      0x1032: 0x2019,\r\n      // \r\n      0x1033: 0x201c,\r\n      // \r\n      0x1034: 0x201d,\r\n      // \r\n      0x1035: 0x2022,\r\n      // \r\n      0x1039: 0x2122,\r\n      // \r\n      0x103a: 0x0161,\r\n      // \r\n      0x103c: 0x0153,\r\n      // \r\n      0x103d: 0x2120,\r\n      // \r\n      0x103f: 0x0178,\r\n      // \r\n      0x1076: 0x215b,\r\n      // \r\n      0x1077: 0x215c,\r\n      // \r\n      0x1078: 0x215d,\r\n      // \r\n      0x1079: 0x215e,\r\n      // \r\n      0x107a: 0x23d0,\r\n      // \r\n      0x107b: 0x23a4,\r\n      // \r\n      0x107c: 0x23a3,\r\n      // \r\n      0x107d: 0x23af,\r\n      // \r\n      0x107e: 0x23a6,\r\n      // \r\n      0x107f: 0x23a1,\r\n      // \r\n      0x10a0: 0x3138 //  (CC char)\r\n\r\n    };\r\n\r\n    var get708CharFromCode = function get708CharFromCode(code) {\r\n      var newCode = CHARACTER_TRANSLATION_708[code] || code;\r\n\r\n      if (code & 0x1000 && code === newCode) {\r\n        // Invalid extended code\r\n        return '';\r\n      }\r\n\r\n      return String.fromCharCode(newCode);\r\n    };\r\n\r\n    var within708TextBlock = function within708TextBlock(b) {\r\n      return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\r\n    };\r\n\r\n    var Cea708Window = function Cea708Window(windowNum) {\r\n      this.windowNum = windowNum;\r\n      this.reset();\r\n    };\r\n\r\n    Cea708Window.prototype.reset = function () {\r\n      this.clearText();\r\n      this.pendingNewLine = false;\r\n      this.winAttr = {};\r\n      this.penAttr = {};\r\n      this.penLoc = {};\r\n      this.penColor = {}; // These default values are arbitrary,\r\n      // defineWindow will usually override them\r\n\r\n      this.visible = 0;\r\n      this.rowLock = 0;\r\n      this.columnLock = 0;\r\n      this.priority = 0;\r\n      this.relativePositioning = 0;\r\n      this.anchorVertical = 0;\r\n      this.anchorHorizontal = 0;\r\n      this.anchorPoint = 0;\r\n      this.rowCount = 1;\r\n      this.virtualRowCount = this.rowCount + 1;\r\n      this.columnCount = 41;\r\n      this.windowStyle = 0;\r\n      this.penStyle = 0;\r\n    };\r\n\r\n    Cea708Window.prototype.getText = function () {\r\n      return this.rows.join('\\n');\r\n    };\r\n\r\n    Cea708Window.prototype.clearText = function () {\r\n      this.rows = [''];\r\n      this.rowIdx = 0;\r\n    };\r\n\r\n    Cea708Window.prototype.newLine = function (pts) {\r\n      if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\r\n        this.beforeRowOverflow(pts);\r\n      }\r\n\r\n      if (this.rows.length > 0) {\r\n        this.rows.push('');\r\n        this.rowIdx++;\r\n      } // Show all virtual rows since there's no visible scrolling\r\n\r\n\r\n      while (this.rows.length > this.virtualRowCount) {\r\n        this.rows.shift();\r\n        this.rowIdx--;\r\n      }\r\n    };\r\n\r\n    Cea708Window.prototype.isEmpty = function () {\r\n      if (this.rows.length === 0) {\r\n        return true;\r\n      } else if (this.rows.length === 1) {\r\n        return this.rows[0] === '';\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    Cea708Window.prototype.addText = function (text) {\r\n      this.rows[this.rowIdx] += text;\r\n    };\r\n\r\n    Cea708Window.prototype.backspace = function () {\r\n      if (!this.isEmpty()) {\r\n        var row = this.rows[this.rowIdx];\r\n        this.rows[this.rowIdx] = row.substr(0, row.length - 1);\r\n      }\r\n    };\r\n\r\n    var Cea708Service = function Cea708Service(serviceNum, encoding, stream) {\r\n      this.serviceNum = serviceNum;\r\n      this.text = '';\r\n      this.currentWindow = new Cea708Window(-1);\r\n      this.windows = [];\r\n      this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\r\n\r\n      if (typeof encoding === 'string') {\r\n        this.createTextDecoder(encoding);\r\n      }\r\n    };\r\n    /**\r\n     * Initialize service windows\r\n     * Must be run before service use\r\n     *\r\n     * @param  {Integer}  pts               PTS value\r\n     * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\r\n     */\r\n\r\n\r\n    Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\r\n      this.startPts = pts;\r\n\r\n      for (var win = 0; win < 8; win++) {\r\n        this.windows[win] = new Cea708Window(win);\r\n\r\n        if (typeof beforeRowOverflow === 'function') {\r\n          this.windows[win].beforeRowOverflow = beforeRowOverflow;\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * Set current window of service to be affected by commands\r\n     *\r\n     * @param  {Integer} windowNum Window number\r\n     */\r\n\r\n\r\n    Cea708Service.prototype.setCurrentWindow = function (windowNum) {\r\n      this.currentWindow = this.windows[windowNum];\r\n    };\r\n    /**\r\n     * Try to create a TextDecoder if it is natively supported\r\n     */\r\n\r\n\r\n    Cea708Service.prototype.createTextDecoder = function (encoding) {\r\n      if (typeof TextDecoder === 'undefined') {\r\n        this.stream.trigger('log', {\r\n          level: 'warn',\r\n          message: 'The `encoding` option is unsupported without TextDecoder support'\r\n        });\r\n      } else {\r\n        try {\r\n          this.textDecoder_ = new TextDecoder(encoding);\r\n        } catch (error) {\r\n          this.stream.trigger('log', {\r\n            level: 'warn',\r\n            message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\r\n          });\r\n        }\r\n      }\r\n    };\r\n\r\n    var Cea708Stream = function Cea708Stream(options) {\r\n      options = options || {};\r\n      Cea708Stream.prototype.init.call(this);\r\n      var self = this;\r\n      var captionServices = options.captionServices || {};\r\n      var captionServiceEncodings = {};\r\n      var serviceProps; // Get service encodings from captionServices option block\r\n\r\n      Object.keys(captionServices).forEach(function (serviceName) {\r\n        serviceProps = captionServices[serviceName];\r\n\r\n        if (/^SERVICE/.test(serviceName)) {\r\n          captionServiceEncodings[serviceName] = serviceProps.encoding;\r\n        }\r\n      });\r\n      this.serviceEncodings = captionServiceEncodings;\r\n      this.current708Packet = null;\r\n      this.services = {};\r\n\r\n      this.push = function (packet) {\r\n        if (packet.type === 3) {\r\n          // 708 packet start\r\n          self.new708Packet();\r\n          self.add708Bytes(packet);\r\n        } else {\r\n          if (self.current708Packet === null) {\r\n            // This should only happen at the start of a file if there's no packet start.\r\n            self.new708Packet();\r\n          }\r\n\r\n          self.add708Bytes(packet);\r\n        }\r\n      };\r\n    };\r\n\r\n    Cea708Stream.prototype = new stream();\r\n    /**\r\n     * Push current 708 packet, create new 708 packet.\r\n     */\r\n\r\n    Cea708Stream.prototype.new708Packet = function () {\r\n      if (this.current708Packet !== null) {\r\n        this.push708Packet();\r\n      }\r\n\r\n      this.current708Packet = {\r\n        data: [],\r\n        ptsVals: []\r\n      };\r\n    };\r\n    /**\r\n     * Add pts and both bytes from packet into current 708 packet.\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.add708Bytes = function (packet) {\r\n      var data = packet.ccData;\r\n      var byte0 = data >>> 8;\r\n      var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\r\n      // that service blocks will always line up with byte pairs.\r\n\r\n      this.current708Packet.ptsVals.push(packet.pts);\r\n      this.current708Packet.data.push(byte0);\r\n      this.current708Packet.data.push(byte1);\r\n    };\r\n    /**\r\n     * Parse completed 708 packet into service blocks and push each service block.\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.push708Packet = function () {\r\n      var packet708 = this.current708Packet;\r\n      var packetData = packet708.data;\r\n      var serviceNum = null;\r\n      var blockSize = null;\r\n      var i = 0;\r\n      var b = packetData[i++];\r\n      packet708.seq = b >> 6;\r\n      packet708.sizeCode = b & 0x3f; // 0b00111111;\r\n\r\n      for (; i < packetData.length; i++) {\r\n        b = packetData[i++];\r\n        serviceNum = b >> 5;\r\n        blockSize = b & 0x1f; // 0b00011111\r\n\r\n        if (serviceNum === 7 && blockSize > 0) {\r\n          // Extended service num\r\n          b = packetData[i++];\r\n          serviceNum = b;\r\n        }\r\n\r\n        this.pushServiceBlock(serviceNum, i, blockSize);\r\n\r\n        if (blockSize > 0) {\r\n          i += blockSize - 1;\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * Parse service block, execute commands, read text.\r\n     *\r\n     * Note: While many of these commands serve important purposes,\r\n     * many others just parse out the parameters or attributes, but\r\n     * nothing is done with them because this is not a full and complete\r\n     * implementation of the entire 708 spec.\r\n     *\r\n     * @param  {Integer} serviceNum Service number\r\n     * @param  {Integer} start      Start index of the 708 packet data\r\n     * @param  {Integer} size       Block size\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\r\n      var b;\r\n      var i = start;\r\n      var packetData = this.current708Packet.data;\r\n      var service = this.services[serviceNum];\r\n\r\n      if (!service) {\r\n        service = this.initService(serviceNum, i);\r\n      }\r\n\r\n      for (; i < start + size && i < packetData.length; i++) {\r\n        b = packetData[i];\r\n\r\n        if (within708TextBlock(b)) {\r\n          i = this.handleText(i, service);\r\n        } else if (b === 0x18) {\r\n          i = this.multiByteCharacter(i, service);\r\n        } else if (b === 0x10) {\r\n          i = this.extendedCommands(i, service);\r\n        } else if (0x80 <= b && b <= 0x87) {\r\n          i = this.setCurrentWindow(i, service);\r\n        } else if (0x98 <= b && b <= 0x9f) {\r\n          i = this.defineWindow(i, service);\r\n        } else if (b === 0x88) {\r\n          i = this.clearWindows(i, service);\r\n        } else if (b === 0x8c) {\r\n          i = this.deleteWindows(i, service);\r\n        } else if (b === 0x89) {\r\n          i = this.displayWindows(i, service);\r\n        } else if (b === 0x8a) {\r\n          i = this.hideWindows(i, service);\r\n        } else if (b === 0x8b) {\r\n          i = this.toggleWindows(i, service);\r\n        } else if (b === 0x97) {\r\n          i = this.setWindowAttributes(i, service);\r\n        } else if (b === 0x90) {\r\n          i = this.setPenAttributes(i, service);\r\n        } else if (b === 0x91) {\r\n          i = this.setPenColor(i, service);\r\n        } else if (b === 0x92) {\r\n          i = this.setPenLocation(i, service);\r\n        } else if (b === 0x8f) {\r\n          service = this.reset(i, service);\r\n        } else if (b === 0x08) {\r\n          // BS: Backspace\r\n          service.currentWindow.backspace();\r\n        } else if (b === 0x0c) {\r\n          // FF: Form feed\r\n          service.currentWindow.clearText();\r\n        } else if (b === 0x0d) {\r\n          // CR: Carriage return\r\n          service.currentWindow.pendingNewLine = true;\r\n        } else if (b === 0x0e) {\r\n          // HCR: Horizontal carriage return\r\n          service.currentWindow.clearText();\r\n        } else if (b === 0x8d) {\r\n          // DLY: Delay, nothing to do\r\n          i++;\r\n        } else ;\r\n      }\r\n    };\r\n    /**\r\n     * Execute an extended command\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.extendedCommands = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[++i];\r\n\r\n      if (within708TextBlock(b)) {\r\n        i = this.handleText(i, service, {\r\n          isExtended: true\r\n        });\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Get PTS value of a given byte index\r\n     *\r\n     * @param  {Integer} byteIndex  Index of the byte\r\n     * @return {Integer}            PTS\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.getPts = function (byteIndex) {\r\n      // There's 1 pts value per 2 bytes\r\n      return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\r\n    };\r\n    /**\r\n     * Initializes a service\r\n     *\r\n     * @param  {Integer} serviceNum Service number\r\n     * @return {Service}            Initialized service object\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.initService = function (serviceNum, i) {\r\n      var serviceName = 'SERVICE' + serviceNum;\r\n      var self = this;\r\n      var serviceName;\r\n      var encoding;\r\n\r\n      if (serviceName in this.serviceEncodings) {\r\n        encoding = this.serviceEncodings[serviceName];\r\n      }\r\n\r\n      this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\r\n      this.services[serviceNum].init(this.getPts(i), function (pts) {\r\n        self.flushDisplayed(pts, self.services[serviceNum]);\r\n      });\r\n      return this.services[serviceNum];\r\n    };\r\n    /**\r\n     * Execute text writing to current window\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.handleText = function (i, service, options) {\r\n      var isExtended = options && options.isExtended;\r\n      var isMultiByte = options && options.isMultiByte;\r\n      var packetData = this.current708Packet.data;\r\n      var extended = isExtended ? 0x1000 : 0x0000;\r\n      var currentByte = packetData[i];\r\n      var nextByte = packetData[i + 1];\r\n      var win = service.currentWindow;\r\n\r\n      var _char;\r\n\r\n      var charCodeArray; // Use the TextDecoder if one was created for this service\r\n\r\n      if (service.textDecoder_ && !isExtended) {\r\n        if (isMultiByte) {\r\n          charCodeArray = [currentByte, nextByte];\r\n          i++;\r\n        } else {\r\n          charCodeArray = [currentByte];\r\n        }\r\n\r\n        _char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\r\n      } else {\r\n        _char = get708CharFromCode(extended | currentByte);\r\n      }\r\n\r\n      if (win.pendingNewLine && !win.isEmpty()) {\r\n        win.newLine(this.getPts(i));\r\n      }\r\n\r\n      win.pendingNewLine = false;\r\n      win.addText(_char);\r\n      return i;\r\n    };\r\n    /**\r\n     * Handle decoding of multibyte character\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.multiByteCharacter = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var firstByte = packetData[i + 1];\r\n      var secondByte = packetData[i + 2];\r\n\r\n      if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\r\n        i = this.handleText(++i, service, {\r\n          isMultiByte: true\r\n        });\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the CW# command.\r\n     *\r\n     * Set the current window.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.setCurrentWindow = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[i];\r\n      var windowNum = b & 0x07;\r\n      service.setCurrentWindow(windowNum);\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the DF# command.\r\n     *\r\n     * Define a window and set it as the current window.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.defineWindow = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[i];\r\n      var windowNum = b & 0x07;\r\n      service.setCurrentWindow(windowNum);\r\n      var win = service.currentWindow;\r\n      b = packetData[++i];\r\n      win.visible = (b & 0x20) >> 5; // v\r\n\r\n      win.rowLock = (b & 0x10) >> 4; // rl\r\n\r\n      win.columnLock = (b & 0x08) >> 3; // cl\r\n\r\n      win.priority = b & 0x07; // p\r\n\r\n      b = packetData[++i];\r\n      win.relativePositioning = (b & 0x80) >> 7; // rp\r\n\r\n      win.anchorVertical = b & 0x7f; // av\r\n\r\n      b = packetData[++i];\r\n      win.anchorHorizontal = b; // ah\r\n\r\n      b = packetData[++i];\r\n      win.anchorPoint = (b & 0xf0) >> 4; // ap\r\n\r\n      win.rowCount = b & 0x0f; // rc\r\n\r\n      b = packetData[++i];\r\n      win.columnCount = b & 0x3f; // cc\r\n\r\n      b = packetData[++i];\r\n      win.windowStyle = (b & 0x38) >> 3; // ws\r\n\r\n      win.penStyle = b & 0x07; // ps\r\n      // The spec says there are (rowCount+1) \"virtual rows\"\r\n\r\n      win.virtualRowCount = win.rowCount + 1;\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the SWA command.\r\n     *\r\n     * Set attributes of the current window.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.setWindowAttributes = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[i];\r\n      var winAttr = service.currentWindow.winAttr;\r\n      b = packetData[++i];\r\n      winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\r\n\r\n      winAttr.fillRed = (b & 0x30) >> 4; // fr\r\n\r\n      winAttr.fillGreen = (b & 0x0c) >> 2; // fg\r\n\r\n      winAttr.fillBlue = b & 0x03; // fb\r\n\r\n      b = packetData[++i];\r\n      winAttr.borderType = (b & 0xc0) >> 6; // bt\r\n\r\n      winAttr.borderRed = (b & 0x30) >> 4; // br\r\n\r\n      winAttr.borderGreen = (b & 0x0c) >> 2; // bg\r\n\r\n      winAttr.borderBlue = b & 0x03; // bb\r\n\r\n      b = packetData[++i];\r\n      winAttr.borderType += (b & 0x80) >> 5; // bt\r\n\r\n      winAttr.wordWrap = (b & 0x40) >> 6; // ww\r\n\r\n      winAttr.printDirection = (b & 0x30) >> 4; // pd\r\n\r\n      winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\r\n\r\n      winAttr.justify = b & 0x03; // j\r\n\r\n      b = packetData[++i];\r\n      winAttr.effectSpeed = (b & 0xf0) >> 4; // es\r\n\r\n      winAttr.effectDirection = (b & 0x0c) >> 2; // ed\r\n\r\n      winAttr.displayEffect = b & 0x03; // de\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Gather text from all displayed windows and push a caption to output.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.flushDisplayed = function (pts, service) {\r\n      var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\r\n      // display text in the correct order, but sample files so far have not shown any issue.\r\n\r\n      for (var winId = 0; winId < 8; winId++) {\r\n        if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\r\n          displayedText.push(service.windows[winId].getText());\r\n        }\r\n      }\r\n\r\n      service.endPts = pts;\r\n      service.text = displayedText.join('\\n\\n');\r\n      this.pushCaption(service);\r\n      service.startPts = pts;\r\n    };\r\n    /**\r\n     * Push a caption to output if the caption contains text.\r\n     *\r\n     * @param  {Service} service  The service object to be affected\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.pushCaption = function (service) {\r\n      if (service.text !== '') {\r\n        this.trigger('data', {\r\n          startPts: service.startPts,\r\n          endPts: service.endPts,\r\n          text: service.text,\r\n          stream: 'cc708_' + service.serviceNum\r\n        });\r\n        service.text = '';\r\n        service.startPts = service.endPts;\r\n      }\r\n    };\r\n    /**\r\n     * Parse and execute the DSW command.\r\n     *\r\n     * Set visible property of windows based on the parsed bitmask.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.displayWindows = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[++i];\r\n      var pts = this.getPts(i);\r\n      this.flushDisplayed(pts, service);\r\n\r\n      for (var winId = 0; winId < 8; winId++) {\r\n        if (b & 0x01 << winId) {\r\n          service.windows[winId].visible = 1;\r\n        }\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the HDW command.\r\n     *\r\n     * Set visible property of windows based on the parsed bitmask.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.hideWindows = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[++i];\r\n      var pts = this.getPts(i);\r\n      this.flushDisplayed(pts, service);\r\n\r\n      for (var winId = 0; winId < 8; winId++) {\r\n        if (b & 0x01 << winId) {\r\n          service.windows[winId].visible = 0;\r\n        }\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the TGW command.\r\n     *\r\n     * Set visible property of windows based on the parsed bitmask.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.toggleWindows = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[++i];\r\n      var pts = this.getPts(i);\r\n      this.flushDisplayed(pts, service);\r\n\r\n      for (var winId = 0; winId < 8; winId++) {\r\n        if (b & 0x01 << winId) {\r\n          service.windows[winId].visible ^= 1;\r\n        }\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the CLW command.\r\n     *\r\n     * Clear text of windows based on the parsed bitmask.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.clearWindows = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[++i];\r\n      var pts = this.getPts(i);\r\n      this.flushDisplayed(pts, service);\r\n\r\n      for (var winId = 0; winId < 8; winId++) {\r\n        if (b & 0x01 << winId) {\r\n          service.windows[winId].clearText();\r\n        }\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the DLW command.\r\n     *\r\n     * Re-initialize windows based on the parsed bitmask.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.deleteWindows = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[++i];\r\n      var pts = this.getPts(i);\r\n      this.flushDisplayed(pts, service);\r\n\r\n      for (var winId = 0; winId < 8; winId++) {\r\n        if (b & 0x01 << winId) {\r\n          service.windows[winId].reset();\r\n        }\r\n      }\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the SPA command.\r\n     *\r\n     * Set pen attributes of the current window.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.setPenAttributes = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[i];\r\n      var penAttr = service.currentWindow.penAttr;\r\n      b = packetData[++i];\r\n      penAttr.textTag = (b & 0xf0) >> 4; // tt\r\n\r\n      penAttr.offset = (b & 0x0c) >> 2; // o\r\n\r\n      penAttr.penSize = b & 0x03; // s\r\n\r\n      b = packetData[++i];\r\n      penAttr.italics = (b & 0x80) >> 7; // i\r\n\r\n      penAttr.underline = (b & 0x40) >> 6; // u\r\n\r\n      penAttr.edgeType = (b & 0x38) >> 3; // et\r\n\r\n      penAttr.fontStyle = b & 0x07; // fs\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the SPC command.\r\n     *\r\n     * Set pen color of the current window.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.setPenColor = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[i];\r\n      var penColor = service.currentWindow.penColor;\r\n      b = packetData[++i];\r\n      penColor.fgOpacity = (b & 0xc0) >> 6; // fo\r\n\r\n      penColor.fgRed = (b & 0x30) >> 4; // fr\r\n\r\n      penColor.fgGreen = (b & 0x0c) >> 2; // fg\r\n\r\n      penColor.fgBlue = b & 0x03; // fb\r\n\r\n      b = packetData[++i];\r\n      penColor.bgOpacity = (b & 0xc0) >> 6; // bo\r\n\r\n      penColor.bgRed = (b & 0x30) >> 4; // br\r\n\r\n      penColor.bgGreen = (b & 0x0c) >> 2; // bg\r\n\r\n      penColor.bgBlue = b & 0x03; // bb\r\n\r\n      b = packetData[++i];\r\n      penColor.edgeRed = (b & 0x30) >> 4; // er\r\n\r\n      penColor.edgeGreen = (b & 0x0c) >> 2; // eg\r\n\r\n      penColor.edgeBlue = b & 0x03; // eb\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Parse and execute the SPL command.\r\n     *\r\n     * Set pen location of the current window.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Integer}          New index after parsing\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.setPenLocation = function (i, service) {\r\n      var packetData = this.current708Packet.data;\r\n      var b = packetData[i];\r\n      var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\r\n\r\n      service.currentWindow.pendingNewLine = true;\r\n      b = packetData[++i];\r\n      penLoc.row = b & 0x0f; // r\r\n\r\n      b = packetData[++i];\r\n      penLoc.column = b & 0x3f; // c\r\n\r\n      return i;\r\n    };\r\n    /**\r\n     * Execute the RST command.\r\n     *\r\n     * Reset service to a clean slate. Re-initialize.\r\n     *\r\n     * @param  {Integer} i        Current index in the 708 packet\r\n     * @param  {Service} service  The service object to be affected\r\n     * @return {Service}          Re-initialized service\r\n     */\r\n\r\n\r\n    Cea708Stream.prototype.reset = function (i, service) {\r\n      var pts = this.getPts(i);\r\n      this.flushDisplayed(pts, service);\r\n      return this.initService(service.serviceNum, i);\r\n    }; // This hash maps non-ASCII, special, and extended character codes to their\r\n    // proper Unicode equivalent. The first keys that are only a single byte\r\n    // are the non-standard ASCII characters, which simply map the CEA608 byte\r\n    // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\r\n    // character codes, but have their MSB bitmasked with 0x03 so that a lookup\r\n    // can be performed regardless of the field and data channel on which the\r\n    // character code was received.\r\n\r\n\r\n    var CHARACTER_TRANSLATION = {\r\n      0x2a: 0xe1,\r\n      // \r\n      0x5c: 0xe9,\r\n      // \r\n      0x5e: 0xed,\r\n      // \r\n      0x5f: 0xf3,\r\n      // \r\n      0x60: 0xfa,\r\n      // \r\n      0x7b: 0xe7,\r\n      // \r\n      0x7c: 0xf7,\r\n      // \r\n      0x7d: 0xd1,\r\n      // \r\n      0x7e: 0xf1,\r\n      // \r\n      0x7f: 0x2588,\r\n      // \r\n      0x0130: 0xae,\r\n      // \r\n      0x0131: 0xb0,\r\n      // \r\n      0x0132: 0xbd,\r\n      // \r\n      0x0133: 0xbf,\r\n      // \r\n      0x0134: 0x2122,\r\n      // \r\n      0x0135: 0xa2,\r\n      // \r\n      0x0136: 0xa3,\r\n      // \r\n      0x0137: 0x266a,\r\n      // \r\n      0x0138: 0xe0,\r\n      // \r\n      0x0139: 0xa0,\r\n      //\r\n      0x013a: 0xe8,\r\n      // \r\n      0x013b: 0xe2,\r\n      // \r\n      0x013c: 0xea,\r\n      // \r\n      0x013d: 0xee,\r\n      // \r\n      0x013e: 0xf4,\r\n      // \r\n      0x013f: 0xfb,\r\n      // \r\n      0x0220: 0xc1,\r\n      // \r\n      0x0221: 0xc9,\r\n      // \r\n      0x0222: 0xd3,\r\n      // \r\n      0x0223: 0xda,\r\n      // \r\n      0x0224: 0xdc,\r\n      // \r\n      0x0225: 0xfc,\r\n      // \r\n      0x0226: 0x2018,\r\n      // \r\n      0x0227: 0xa1,\r\n      // \r\n      0x0228: 0x2a,\r\n      // *\r\n      0x0229: 0x27,\r\n      // '\r\n      0x022a: 0x2014,\r\n      // \r\n      0x022b: 0xa9,\r\n      // \r\n      0x022c: 0x2120,\r\n      // \r\n      0x022d: 0x2022,\r\n      // \r\n      0x022e: 0x201c,\r\n      // \r\n      0x022f: 0x201d,\r\n      // \r\n      0x0230: 0xc0,\r\n      // \r\n      0x0231: 0xc2,\r\n      // \r\n      0x0232: 0xc7,\r\n      // \r\n      0x0233: 0xc8,\r\n      // \r\n      0x0234: 0xca,\r\n      // \r\n      0x0235: 0xcb,\r\n      // \r\n      0x0236: 0xeb,\r\n      // \r\n      0x0237: 0xce,\r\n      // \r\n      0x0238: 0xcf,\r\n      // \r\n      0x0239: 0xef,\r\n      // \r\n      0x023a: 0xd4,\r\n      // \r\n      0x023b: 0xd9,\r\n      // \r\n      0x023c: 0xf9,\r\n      // \r\n      0x023d: 0xdb,\r\n      // \r\n      0x023e: 0xab,\r\n      // \r\n      0x023f: 0xbb,\r\n      // \r\n      0x0320: 0xc3,\r\n      // \r\n      0x0321: 0xe3,\r\n      // \r\n      0x0322: 0xcd,\r\n      // \r\n      0x0323: 0xcc,\r\n      // \r\n      0x0324: 0xec,\r\n      // \r\n      0x0325: 0xd2,\r\n      // \r\n      0x0326: 0xf2,\r\n      // \r\n      0x0327: 0xd5,\r\n      // \r\n      0x0328: 0xf5,\r\n      // \r\n      0x0329: 0x7b,\r\n      // {\r\n      0x032a: 0x7d,\r\n      // }\r\n      0x032b: 0x5c,\r\n      // \\\r\n      0x032c: 0x5e,\r\n      // ^\r\n      0x032d: 0x5f,\r\n      // _\r\n      0x032e: 0x7c,\r\n      // |\r\n      0x032f: 0x7e,\r\n      // ~\r\n      0x0330: 0xc4,\r\n      // \r\n      0x0331: 0xe4,\r\n      // \r\n      0x0332: 0xd6,\r\n      // \r\n      0x0333: 0xf6,\r\n      // \r\n      0x0334: 0xdf,\r\n      // \r\n      0x0335: 0xa5,\r\n      // \r\n      0x0336: 0xa4,\r\n      // \r\n      0x0337: 0x2502,\r\n      // \r\n      0x0338: 0xc5,\r\n      // \r\n      0x0339: 0xe5,\r\n      // \r\n      0x033a: 0xd8,\r\n      // \r\n      0x033b: 0xf8,\r\n      // \r\n      0x033c: 0x250c,\r\n      // \r\n      0x033d: 0x2510,\r\n      // \r\n      0x033e: 0x2514,\r\n      // \r\n      0x033f: 0x2518 // \r\n\r\n    };\r\n\r\n    var getCharFromCode = function getCharFromCode(code) {\r\n      if (code === null) {\r\n        return '';\r\n      }\r\n\r\n      code = CHARACTER_TRANSLATION[code] || code;\r\n      return String.fromCharCode(code);\r\n    }; // the index of the last row in a CEA-608 display buffer\r\n\r\n\r\n    var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\r\n    // getting it through bit logic.\r\n\r\n    var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\r\n    // cells. The \"bottom\" row is the last element in the outer array.\r\n\r\n    var createDisplayBuffer = function createDisplayBuffer() {\r\n      var result = [],\r\n          i = BOTTOM_ROW + 1;\r\n\r\n      while (i--) {\r\n        result.push('');\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    var Cea608Stream = function Cea608Stream(field, dataChannel) {\r\n      Cea608Stream.prototype.init.call(this);\r\n      this.field_ = field || 0;\r\n      this.dataChannel_ = dataChannel || 0;\r\n      this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\r\n      this.setConstants();\r\n      this.reset();\r\n\r\n      this.push = function (packet) {\r\n        var data, swap, char0, char1, text; // remove the parity bits\r\n\r\n        data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\r\n\r\n        if (data === this.lastControlCode_) {\r\n          this.lastControlCode_ = null;\r\n          return;\r\n        } // Store control codes\r\n\r\n\r\n        if ((data & 0xf000) === 0x1000) {\r\n          this.lastControlCode_ = data;\r\n        } else if (data !== this.PADDING_) {\r\n          this.lastControlCode_ = null;\r\n        }\r\n\r\n        char0 = data >>> 8;\r\n        char1 = data & 0xff;\r\n\r\n        if (data === this.PADDING_) {\r\n          return;\r\n        } else if (data === this.RESUME_CAPTION_LOADING_) {\r\n          this.mode_ = 'popOn';\r\n        } else if (data === this.END_OF_CAPTION_) {\r\n          // If an EOC is received while in paint-on mode, the displayed caption\r\n          // text should be swapped to non-displayed memory as if it was a pop-on\r\n          // caption. Because of that, we should explicitly switch back to pop-on\r\n          // mode\r\n          this.mode_ = 'popOn';\r\n          this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\r\n\r\n          this.flushDisplayed(packet.pts); // flip memory\r\n\r\n          swap = this.displayed_;\r\n          this.displayed_ = this.nonDisplayed_;\r\n          this.nonDisplayed_ = swap; // start measuring the time to display the caption\r\n\r\n          this.startPts_ = packet.pts;\r\n        } else if (data === this.ROLL_UP_2_ROWS_) {\r\n          this.rollUpRows_ = 2;\r\n          this.setRollUp(packet.pts);\r\n        } else if (data === this.ROLL_UP_3_ROWS_) {\r\n          this.rollUpRows_ = 3;\r\n          this.setRollUp(packet.pts);\r\n        } else if (data === this.ROLL_UP_4_ROWS_) {\r\n          this.rollUpRows_ = 4;\r\n          this.setRollUp(packet.pts);\r\n        } else if (data === this.CARRIAGE_RETURN_) {\r\n          this.clearFormatting(packet.pts);\r\n          this.flushDisplayed(packet.pts);\r\n          this.shiftRowsUp_();\r\n          this.startPts_ = packet.pts;\r\n        } else if (data === this.BACKSPACE_) {\r\n          if (this.mode_ === 'popOn') {\r\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\r\n          } else {\r\n            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\r\n          }\r\n        } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\r\n          this.flushDisplayed(packet.pts);\r\n          this.displayed_ = createDisplayBuffer();\r\n        } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\r\n          this.nonDisplayed_ = createDisplayBuffer();\r\n        } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\r\n          if (this.mode_ !== 'paintOn') {\r\n            // NOTE: This should be removed when proper caption positioning is\r\n            // implemented\r\n            this.flushDisplayed(packet.pts);\r\n            this.displayed_ = createDisplayBuffer();\r\n          }\r\n\r\n          this.mode_ = 'paintOn';\r\n          this.startPts_ = packet.pts; // Append special characters to caption text\r\n        } else if (this.isSpecialCharacter(char0, char1)) {\r\n          // Bitmask char0 so that we can apply character transformations\r\n          // regardless of field and data channel.\r\n          // Then byte-shift to the left and OR with char1 so we can pass the\r\n          // entire character code to `getCharFromCode`.\r\n          char0 = (char0 & 0x03) << 8;\r\n          text = getCharFromCode(char0 | char1);\r\n          this[this.mode_](packet.pts, text);\r\n          this.column_++; // Append extended characters to caption text\r\n        } else if (this.isExtCharacter(char0, char1)) {\r\n          // Extended characters always follow their \"non-extended\" equivalents.\r\n          // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\r\n          // decoders are supposed to drop the \"\", while compliant decoders\r\n          // backspace the \"e\" and insert \"\".\r\n          // Delete the previous character\r\n          if (this.mode_ === 'popOn') {\r\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\r\n          } else {\r\n            this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\r\n          } // Bitmask char0 so that we can apply character transformations\r\n          // regardless of field and data channel.\r\n          // Then byte-shift to the left and OR with char1 so we can pass the\r\n          // entire character code to `getCharFromCode`.\r\n\r\n\r\n          char0 = (char0 & 0x03) << 8;\r\n          text = getCharFromCode(char0 | char1);\r\n          this[this.mode_](packet.pts, text);\r\n          this.column_++; // Process mid-row codes\r\n        } else if (this.isMidRowCode(char0, char1)) {\r\n          // Attributes are not additive, so clear all formatting\r\n          this.clearFormatting(packet.pts); // According to the standard, mid-row codes\r\n          // should be replaced with spaces, so add one now\r\n\r\n          this[this.mode_](packet.pts, ' ');\r\n          this.column_++;\r\n\r\n          if ((char1 & 0xe) === 0xe) {\r\n            this.addFormatting(packet.pts, ['i']);\r\n          }\r\n\r\n          if ((char1 & 0x1) === 0x1) {\r\n            this.addFormatting(packet.pts, ['u']);\r\n          } // Detect offset control codes and adjust cursor\r\n\r\n        } else if (this.isOffsetControlCode(char0, char1)) {\r\n          // Cursor position is set by indent PAC (see below) in 4-column\r\n          // increments, with an additional offset code of 1-3 to reach any\r\n          // of the 32 columns specified by CEA-608. So all we need to do\r\n          // here is increment the column cursor by the given offset.\r\n          this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\r\n        } else if (this.isPAC(char0, char1)) {\r\n          // There's no logic for PAC -> row mapping, so we have to just\r\n          // find the row code in an array and use its index :(\r\n          var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\r\n\r\n          if (this.mode_ === 'rollUp') {\r\n            // This implies that the base row is incorrectly set.\r\n            // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\r\n            // of roll-up rows set.\r\n            if (row - this.rollUpRows_ + 1 < 0) {\r\n              row = this.rollUpRows_ - 1;\r\n            }\r\n\r\n            this.setRollUp(packet.pts, row);\r\n          }\r\n\r\n          if (row !== this.row_) {\r\n            // formatting is only persistent for current row\r\n            this.clearFormatting(packet.pts);\r\n            this.row_ = row;\r\n          } // All PACs can apply underline, so detect and apply\r\n          // (All odd-numbered second bytes set underline)\r\n\r\n\r\n          if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\r\n            this.addFormatting(packet.pts, ['u']);\r\n          }\r\n\r\n          if ((data & 0x10) === 0x10) {\r\n            // We've got an indent level code. Each successive even number\r\n            // increments the column cursor by 4, so we can get the desired\r\n            // column position by bit-shifting to the right (to get n/2)\r\n            // and multiplying by 4.\r\n            this.column_ = ((data & 0xe) >> 1) * 4;\r\n          }\r\n\r\n          if (this.isColorPAC(char1)) {\r\n            // it's a color code, though we only support white, which\r\n            // can be either normal or italicized. white italics can be\r\n            // either 0x4e or 0x6e depending on the row, so we just\r\n            // bitwise-and with 0xe to see if italics should be turned on\r\n            if ((char1 & 0xe) === 0xe) {\r\n              this.addFormatting(packet.pts, ['i']);\r\n            }\r\n          } // We have a normal character in char0, and possibly one in char1\r\n\r\n        } else if (this.isNormalChar(char0)) {\r\n          if (char1 === 0x00) {\r\n            char1 = null;\r\n          }\r\n\r\n          text = getCharFromCode(char0);\r\n          text += getCharFromCode(char1);\r\n          this[this.mode_](packet.pts, text);\r\n          this.column_ += text.length;\r\n        } // finish data processing\r\n\r\n      };\r\n    };\r\n\r\n    Cea608Stream.prototype = new stream(); // Trigger a cue point that captures the current state of the\r\n    // display buffer\r\n\r\n    Cea608Stream.prototype.flushDisplayed = function (pts) {\r\n      var content = this.displayed_ // remove spaces from the start and end of the string\r\n      .map(function (row, index) {\r\n        try {\r\n          return row.trim();\r\n        } catch (e) {\r\n          // Ordinarily, this shouldn't happen. However, caption\r\n          // parsing errors should not throw exceptions and\r\n          // break playback.\r\n          this.trigger('log', {\r\n            level: 'warn',\r\n            message: 'Skipping a malformed 608 caption at index ' + index + '.'\r\n          });\r\n          return '';\r\n        }\r\n      }, this) // combine all text rows to display in one cue\r\n      .join('\\n') // and remove blank rows from the start and end, but not the middle\r\n      .replace(/^\\n+|\\n+$/g, '');\r\n\r\n      if (content.length) {\r\n        this.trigger('data', {\r\n          startPts: this.startPts_,\r\n          endPts: pts,\r\n          text: content,\r\n          stream: this.name_\r\n        });\r\n      }\r\n    };\r\n    /**\r\n     * Zero out the data, used for startup and on seek\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.reset = function () {\r\n      this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\r\n      // actually display captions. If a caption is shifted to a row\r\n      // with a lower index than this, it is cleared from the display\r\n      // buffer\r\n\r\n      this.topRow_ = 0;\r\n      this.startPts_ = 0;\r\n      this.displayed_ = createDisplayBuffer();\r\n      this.nonDisplayed_ = createDisplayBuffer();\r\n      this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\r\n\r\n      this.column_ = 0;\r\n      this.row_ = BOTTOM_ROW;\r\n      this.rollUpRows_ = 2; // This variable holds currently-applied formatting\r\n\r\n      this.formatting_ = [];\r\n    };\r\n    /**\r\n     * Sets up control code and related constants for this instance\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.setConstants = function () {\r\n      // The following attributes have these uses:\r\n      // ext_ :    char0 for mid-row codes, and the base for extended\r\n      //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\r\n      //           extended codes)\r\n      // control_: char0 for control codes, except byte-shifted to the\r\n      //           left so that we can do this.control_ | CONTROL_CODE\r\n      // offset_:  char0 for tab offset codes\r\n      //\r\n      // It's also worth noting that control codes, and _only_ control codes,\r\n      // differ between field 1 and field2. Field 2 control codes are always\r\n      // their field 1 value plus 1. That's why there's the \"| field\" on the\r\n      // control value.\r\n      if (this.dataChannel_ === 0) {\r\n        this.BASE_ = 0x10;\r\n        this.EXT_ = 0x11;\r\n        this.CONTROL_ = (0x14 | this.field_) << 8;\r\n        this.OFFSET_ = 0x17;\r\n      } else if (this.dataChannel_ === 1) {\r\n        this.BASE_ = 0x18;\r\n        this.EXT_ = 0x19;\r\n        this.CONTROL_ = (0x1c | this.field_) << 8;\r\n        this.OFFSET_ = 0x1f;\r\n      } // Constants for the LSByte command codes recognized by Cea608Stream. This\r\n      // list is not exhaustive. For a more comprehensive listing and semantics see\r\n      // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\r\n      // Padding\r\n\r\n\r\n      this.PADDING_ = 0x0000; // Pop-on Mode\r\n\r\n      this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\r\n      this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\r\n\r\n      this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\r\n      this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\r\n      this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\r\n      this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\r\n\r\n      this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\r\n\r\n      this.BACKSPACE_ = this.CONTROL_ | 0x21;\r\n      this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\r\n      this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\r\n    };\r\n    /**\r\n     * Detects if the 2-byte packet data is a special character\r\n     *\r\n     * Special characters have a second byte in the range 0x30 to 0x3f,\r\n     * with the first byte being 0x11 (for data channel 1) or 0x19 (for\r\n     * data channel 2).\r\n     *\r\n     * @param  {Integer} char0 The first byte\r\n     * @param  {Integer} char1 The second byte\r\n     * @return {Boolean}       Whether the 2 bytes are an special character\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\r\n      return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\r\n    };\r\n    /**\r\n     * Detects if the 2-byte packet data is an extended character\r\n     *\r\n     * Extended characters have a second byte in the range 0x20 to 0x3f,\r\n     * with the first byte being 0x12 or 0x13 (for data channel 1) or\r\n     * 0x1a or 0x1b (for data channel 2).\r\n     *\r\n     * @param  {Integer} char0 The first byte\r\n     * @param  {Integer} char1 The second byte\r\n     * @return {Boolean}       Whether the 2 bytes are an extended character\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\r\n      return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\r\n    };\r\n    /**\r\n     * Detects if the 2-byte packet is a mid-row code\r\n     *\r\n     * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\r\n     * the first byte being 0x11 (for data channel 1) or 0x19 (for data\r\n     * channel 2).\r\n     *\r\n     * @param  {Integer} char0 The first byte\r\n     * @param  {Integer} char1 The second byte\r\n     * @return {Boolean}       Whether the 2 bytes are a mid-row code\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\r\n      return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\r\n    };\r\n    /**\r\n     * Detects if the 2-byte packet is an offset control code\r\n     *\r\n     * Offset control codes have a second byte in the range 0x21 to 0x23,\r\n     * with the first byte being 0x17 (for data channel 1) or 0x1f (for\r\n     * data channel 2).\r\n     *\r\n     * @param  {Integer} char0 The first byte\r\n     * @param  {Integer} char1 The second byte\r\n     * @return {Boolean}       Whether the 2 bytes are an offset control code\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\r\n      return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\r\n    };\r\n    /**\r\n     * Detects if the 2-byte packet is a Preamble Address Code\r\n     *\r\n     * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\r\n     * or 0x18 to 0x1f (for data channel 2), with the second byte in the\r\n     * range 0x40 to 0x7f.\r\n     *\r\n     * @param  {Integer} char0 The first byte\r\n     * @param  {Integer} char1 The second byte\r\n     * @return {Boolean}       Whether the 2 bytes are a PAC\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isPAC = function (char0, char1) {\r\n      return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\r\n    };\r\n    /**\r\n     * Detects if a packet's second byte is in the range of a PAC color code\r\n     *\r\n     * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\r\n     * 0x60 to 0x6f.\r\n     *\r\n     * @param  {Integer} char1 The second byte\r\n     * @return {Boolean}       Whether the byte is a color PAC\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isColorPAC = function (char1) {\r\n      return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\r\n    };\r\n    /**\r\n     * Detects if a single byte is in the range of a normal character\r\n     *\r\n     * Normal text bytes are in the range 0x20 to 0x7f.\r\n     *\r\n     * @param  {Integer} char  The byte\r\n     * @return {Boolean}       Whether the byte is a normal character\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.isNormalChar = function (_char2) {\r\n      return _char2 >= 0x20 && _char2 <= 0x7f;\r\n    };\r\n    /**\r\n     * Configures roll-up\r\n     *\r\n     * @param  {Integer} pts         Current PTS\r\n     * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\r\n     *                               a new position\r\n     */\r\n\r\n\r\n    Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\r\n      // Reset the base row to the bottom row when switching modes\r\n      if (this.mode_ !== 'rollUp') {\r\n        this.row_ = BOTTOM_ROW;\r\n        this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\r\n\r\n        this.flushDisplayed(pts);\r\n        this.nonDisplayed_ = createDisplayBuffer();\r\n        this.displayed_ = createDisplayBuffer();\r\n      }\r\n\r\n      if (newBaseRow !== undefined && newBaseRow !== this.row_) {\r\n        // move currently displayed captions (up or down) to the new base row\r\n        for (var i = 0; i < this.rollUpRows_; i++) {\r\n          this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\r\n          this.displayed_[this.row_ - i] = '';\r\n        }\r\n      }\r\n\r\n      if (newBaseRow === undefined) {\r\n        newBaseRow = this.row_;\r\n      }\r\n\r\n      this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\r\n    }; // Adds the opening HTML tag for the passed character to the caption text,\r\n    // and keeps track of it for later closing\r\n\r\n\r\n    Cea608Stream.prototype.addFormatting = function (pts, format) {\r\n      this.formatting_ = this.formatting_.concat(format);\r\n      var text = format.reduce(function (text, format) {\r\n        return text + '<' + format + '>';\r\n      }, '');\r\n      this[this.mode_](pts, text);\r\n    }; // Adds HTML closing tags for current formatting to caption text and\r\n    // clears remembered formatting\r\n\r\n\r\n    Cea608Stream.prototype.clearFormatting = function (pts) {\r\n      if (!this.formatting_.length) {\r\n        return;\r\n      }\r\n\r\n      var text = this.formatting_.reverse().reduce(function (text, format) {\r\n        return text + '</' + format + '>';\r\n      }, '');\r\n      this.formatting_ = [];\r\n      this[this.mode_](pts, text);\r\n    }; // Mode Implementations\r\n\r\n\r\n    Cea608Stream.prototype.popOn = function (pts, text) {\r\n      var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\r\n\r\n      baseRow += text;\r\n      this.nonDisplayed_[this.row_] = baseRow;\r\n    };\r\n\r\n    Cea608Stream.prototype.rollUp = function (pts, text) {\r\n      var baseRow = this.displayed_[this.row_];\r\n      baseRow += text;\r\n      this.displayed_[this.row_] = baseRow;\r\n    };\r\n\r\n    Cea608Stream.prototype.shiftRowsUp_ = function () {\r\n      var i; // clear out inactive rows\r\n\r\n      for (i = 0; i < this.topRow_; i++) {\r\n        this.displayed_[i] = '';\r\n      }\r\n\r\n      for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\r\n        this.displayed_[i] = '';\r\n      } // shift displayed rows up\r\n\r\n\r\n      for (i = this.topRow_; i < this.row_; i++) {\r\n        this.displayed_[i] = this.displayed_[i + 1];\r\n      } // clear out the bottom row\r\n\r\n\r\n      this.displayed_[this.row_] = '';\r\n    };\r\n\r\n    Cea608Stream.prototype.paintOn = function (pts, text) {\r\n      var baseRow = this.displayed_[this.row_];\r\n      baseRow += text;\r\n      this.displayed_[this.row_] = baseRow;\r\n    }; // exports\r\n\r\n\r\n    var captionStream = {\r\n      CaptionStream: CaptionStream$1,\r\n      Cea608Stream: Cea608Stream,\r\n      Cea708Stream: Cea708Stream\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n    var streamTypes = {\r\n      H264_STREAM_TYPE: 0x1B,\r\n      ADTS_STREAM_TYPE: 0x0F,\r\n      METADATA_STREAM_TYPE: 0x15\r\n    };\r\n    var MAX_TS = 8589934592;\r\n    var RO_THRESH = 4294967296;\r\n    var TYPE_SHARED = 'shared';\r\n\r\n    var handleRollover$1 = function handleRollover(value, reference) {\r\n      var direction = 1;\r\n\r\n      if (value > reference) {\r\n        // If the current timestamp value is greater than our reference timestamp and we detect a\r\n        // timestamp rollover, this means the roll over is happening in the opposite direction.\r\n        // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\r\n        // point will be set to a small number, e.g. 1. The user then seeks backwards over the\r\n        // rollover point. In loading this segment, the timestamp values will be very large,\r\n        // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\r\n        // the time stamp to be `value - 2^33`.\r\n        direction = -1;\r\n      } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\r\n      // cause an incorrect adjustment.\r\n\r\n\r\n      while (Math.abs(reference - value) > RO_THRESH) {\r\n        value += direction * MAX_TS;\r\n      }\r\n\r\n      return value;\r\n    };\r\n\r\n    var TimestampRolloverStream$1 = function TimestampRolloverStream(type) {\r\n      var lastDTS, referenceDTS;\r\n      TimestampRolloverStream.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\r\n      // video and audio. We could use `undefined` here, but having a string\r\n      // makes debugging a little clearer.\r\n\r\n      this.type_ = type || TYPE_SHARED;\r\n\r\n      this.push = function (data) {\r\n        // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\r\n        // streams will only accept data that matches their type.\r\n        if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\r\n          return;\r\n        }\r\n\r\n        if (referenceDTS === undefined) {\r\n          referenceDTS = data.dts;\r\n        }\r\n\r\n        data.dts = handleRollover$1(data.dts, referenceDTS);\r\n        data.pts = handleRollover$1(data.pts, referenceDTS);\r\n        lastDTS = data.dts;\r\n        this.trigger('data', data);\r\n      };\r\n\r\n      this.flush = function () {\r\n        referenceDTS = lastDTS;\r\n        this.trigger('done');\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        this.flush();\r\n        this.trigger('endedtimeline');\r\n      };\r\n\r\n      this.discontinuity = function () {\r\n        referenceDTS = void 0;\r\n        lastDTS = void 0;\r\n      };\r\n\r\n      this.reset = function () {\r\n        this.discontinuity();\r\n        this.trigger('reset');\r\n      };\r\n    };\r\n\r\n    TimestampRolloverStream$1.prototype = new stream();\r\n    var timestampRolloverStream = {\r\n      TimestampRolloverStream: TimestampRolloverStream$1,\r\n      handleRollover: handleRollover$1\r\n    };\r\n\r\n    var percentEncode$1 = function percentEncode(bytes, start, end) {\r\n      var i,\r\n          result = '';\r\n\r\n      for (i = start; i < end; i++) {\r\n        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\r\n      }\r\n\r\n      return result;\r\n    },\r\n        // return the string representation of the specified byte range,\r\n    // interpreted as UTf-8.\r\n    parseUtf8 = function parseUtf8(bytes, start, end) {\r\n      return decodeURIComponent(percentEncode$1(bytes, start, end));\r\n    },\r\n        // return the string representation of the specified byte range,\r\n    // interpreted as ISO-8859-1.\r\n    parseIso88591$1 = function parseIso88591(bytes, start, end) {\r\n      return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\r\n    },\r\n        parseSyncSafeInteger$1 = function parseSyncSafeInteger(data) {\r\n      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\r\n    },\r\n        tagParsers = {\r\n      TXXX: function TXXX(tag) {\r\n        var i;\r\n\r\n        if (tag.data[0] !== 3) {\r\n          // ignore frames with unrecognized character encodings\r\n          return;\r\n        }\r\n\r\n        for (i = 1; i < tag.data.length; i++) {\r\n          if (tag.data[i] === 0) {\r\n            // parse the text fields\r\n            tag.description = parseUtf8(tag.data, 1, i); // do not include the null terminator in the tag value\r\n\r\n            tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\r\n            break;\r\n          }\r\n        }\r\n\r\n        tag.data = tag.value;\r\n      },\r\n      WXXX: function WXXX(tag) {\r\n        var i;\r\n\r\n        if (tag.data[0] !== 3) {\r\n          // ignore frames with unrecognized character encodings\r\n          return;\r\n        }\r\n\r\n        for (i = 1; i < tag.data.length; i++) {\r\n          if (tag.data[i] === 0) {\r\n            // parse the description and URL fields\r\n            tag.description = parseUtf8(tag.data, 1, i);\r\n            tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\r\n            break;\r\n          }\r\n        }\r\n      },\r\n      PRIV: function PRIV(tag) {\r\n        var i;\r\n\r\n        for (i = 0; i < tag.data.length; i++) {\r\n          if (tag.data[i] === 0) {\r\n            // parse the description and URL fields\r\n            tag.owner = parseIso88591$1(tag.data, 0, i);\r\n            break;\r\n          }\r\n        }\r\n\r\n        tag.privateData = tag.data.subarray(i + 1);\r\n        tag.data = tag.privateData;\r\n      }\r\n    },\r\n        _MetadataStream;\r\n\r\n    _MetadataStream = function MetadataStream(options) {\r\n      var settings = {\r\n        // the bytes of the program-level descriptor field in MP2T\r\n        // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\r\n        // program element descriptors\"\r\n        descriptor: options && options.descriptor\r\n      },\r\n          // the total size in bytes of the ID3 tag being parsed\r\n      tagSize = 0,\r\n          // tag data that is not complete enough to be parsed\r\n      buffer = [],\r\n          // the total number of bytes currently in the buffer\r\n      bufferSize = 0,\r\n          i;\r\n\r\n      _MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\r\n      // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\r\n\r\n\r\n      this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);\r\n\r\n      if (settings.descriptor) {\r\n        for (i = 0; i < settings.descriptor.length; i++) {\r\n          this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\r\n        }\r\n      }\r\n\r\n      this.push = function (chunk) {\r\n        var tag, frameStart, frameSize, frame, i, frameHeader;\r\n\r\n        if (chunk.type !== 'timed-metadata') {\r\n          return;\r\n        } // if data_alignment_indicator is set in the PES header,\r\n        // we must have the start of a new ID3 tag. Assume anything\r\n        // remaining in the buffer was malformed and throw it out\r\n\r\n\r\n        if (chunk.dataAlignmentIndicator) {\r\n          bufferSize = 0;\r\n          buffer.length = 0;\r\n        } // ignore events that don't look like ID3 data\r\n\r\n\r\n        if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\r\n          this.trigger('log', {\r\n            level: 'warn',\r\n            message: 'Skipping unrecognized metadata packet'\r\n          });\r\n          return;\r\n        } // add this chunk to the data we've collected so far\r\n\r\n\r\n        buffer.push(chunk);\r\n        bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\r\n\r\n        if (buffer.length === 1) {\r\n          // the frame size is transmitted as a 28-bit integer in the\r\n          // last four bytes of the ID3 header.\r\n          // The most significant bit of each byte is dropped and the\r\n          // results concatenated to recover the actual value.\r\n          tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\r\n          // convenient for our comparisons to include it\r\n\r\n          tagSize += 10;\r\n        } // if the entire frame has not arrived, wait for more data\r\n\r\n\r\n        if (bufferSize < tagSize) {\r\n          return;\r\n        } // collect the entire frame so it can be parsed\r\n\r\n\r\n        tag = {\r\n          data: new Uint8Array(tagSize),\r\n          frames: [],\r\n          pts: buffer[0].pts,\r\n          dts: buffer[0].dts\r\n        };\r\n\r\n        for (i = 0; i < tagSize;) {\r\n          tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\r\n          i += buffer[0].data.byteLength;\r\n          bufferSize -= buffer[0].data.byteLength;\r\n          buffer.shift();\r\n        } // find the start of the first frame and the end of the tag\r\n\r\n\r\n        frameStart = 10;\r\n\r\n        if (tag.data[5] & 0x40) {\r\n          // advance the frame start past the extended header\r\n          frameStart += 4; // header size field\r\n\r\n          frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14)); // clip any padding off the end\r\n\r\n          tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));\r\n        } // parse one or more ID3 frames\r\n        // http://id3.org/id3v2.3.0#ID3v2_frame_overview\r\n\r\n\r\n        do {\r\n          // determine the number of bytes in this frame\r\n          frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));\r\n\r\n          if (frameSize < 1) {\r\n            this.trigger('log', {\r\n              level: 'warn',\r\n              message: 'Malformed ID3 frame encountered. Skipping metadata parsing.'\r\n            });\r\n            return;\r\n          }\r\n\r\n          frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\r\n          frame = {\r\n            id: frameHeader,\r\n            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\r\n          };\r\n          frame.key = frame.id;\r\n\r\n          if (tagParsers[frame.id]) {\r\n            tagParsers[frame.id](frame); // handle the special PRIV frame used to indicate the start\r\n            // time for raw AAC data\r\n\r\n            if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\r\n              var d = frame.data,\r\n                  size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\r\n              size *= 4;\r\n              size += d[7] & 0x03;\r\n              frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\r\n              // on the value of this frame\r\n              // we couldn't have known the appropriate pts and dts before\r\n              // parsing this ID3 tag so set those values now\r\n\r\n              if (tag.pts === undefined && tag.dts === undefined) {\r\n                tag.pts = frame.timeStamp;\r\n                tag.dts = frame.timeStamp;\r\n              }\r\n\r\n              this.trigger('timestamp', frame);\r\n            }\r\n          }\r\n\r\n          tag.frames.push(frame);\r\n          frameStart += 10; // advance past the frame header\r\n\r\n          frameStart += frameSize; // advance past the frame body\r\n        } while (frameStart < tagSize);\r\n\r\n        this.trigger('data', tag);\r\n      };\r\n    };\r\n\r\n    _MetadataStream.prototype = new stream();\r\n    var metadataStream = _MetadataStream;\r\n    var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\r\n\r\n    var _TransportPacketStream, _TransportParseStream, _ElementaryStream; // constants\r\n\r\n\r\n    var MP2T_PACKET_LENGTH$1 = 188,\r\n        // bytes\r\n    SYNC_BYTE$1 = 0x47;\r\n    /**\r\n     * Splits an incoming stream of binary data into MPEG-2 Transport\r\n     * Stream packets.\r\n     */\r\n\r\n    _TransportPacketStream = function TransportPacketStream() {\r\n      var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\r\n          bytesInBuffer = 0;\r\n\r\n      _TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\r\n\r\n      /**\r\n       * Split a stream of data into M2TS packets\r\n      **/\r\n\r\n\r\n      this.push = function (bytes) {\r\n        var startIndex = 0,\r\n            endIndex = MP2T_PACKET_LENGTH$1,\r\n            everything; // If there are bytes remaining from the last segment, prepend them to the\r\n        // bytes that were pushed in\r\n\r\n        if (bytesInBuffer) {\r\n          everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\r\n          everything.set(buffer.subarray(0, bytesInBuffer));\r\n          everything.set(bytes, bytesInBuffer);\r\n          bytesInBuffer = 0;\r\n        } else {\r\n          everything = bytes;\r\n        } // While we have enough data for a packet\r\n\r\n\r\n        while (endIndex < everything.byteLength) {\r\n          // Look for a pair of start and end sync bytes in the data..\r\n          if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\r\n            // We found a packet so emit it and jump one whole packet forward in\r\n            // the stream\r\n            this.trigger('data', everything.subarray(startIndex, endIndex));\r\n            startIndex += MP2T_PACKET_LENGTH$1;\r\n            endIndex += MP2T_PACKET_LENGTH$1;\r\n            continue;\r\n          } // If we get here, we have somehow become de-synchronized and we need to step\r\n          // forward one byte at a time until we find a pair of sync bytes that denote\r\n          // a packet\r\n\r\n\r\n          startIndex++;\r\n          endIndex++;\r\n        } // If there was some data left over at the end of the segment that couldn't\r\n        // possibly be a whole packet, keep it because it might be the start of a packet\r\n        // that continues in the next segment\r\n\r\n\r\n        if (startIndex < everything.byteLength) {\r\n          buffer.set(everything.subarray(startIndex), 0);\r\n          bytesInBuffer = everything.byteLength - startIndex;\r\n        }\r\n      };\r\n      /**\r\n       * Passes identified M2TS packets to the TransportParseStream to be parsed\r\n      **/\r\n\r\n\r\n      this.flush = function () {\r\n        // If the buffer contains a whole packet when we are being flushed, emit it\r\n        // and empty the buffer. Otherwise hold onto the data because it may be\r\n        // important for decoding the next segment\r\n        if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\r\n          this.trigger('data', buffer);\r\n          bytesInBuffer = 0;\r\n        }\r\n\r\n        this.trigger('done');\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        this.flush();\r\n        this.trigger('endedtimeline');\r\n      };\r\n\r\n      this.reset = function () {\r\n        bytesInBuffer = 0;\r\n        this.trigger('reset');\r\n      };\r\n    };\r\n\r\n    _TransportPacketStream.prototype = new stream();\r\n    /**\r\n     * Accepts an MP2T TransportPacketStream and emits data events with parsed\r\n     * forms of the individual transport stream packets.\r\n     */\r\n\r\n    _TransportParseStream = function TransportParseStream() {\r\n      var parsePsi, parsePat, parsePmt, self;\r\n\r\n      _TransportParseStream.prototype.init.call(this);\r\n\r\n      self = this;\r\n      this.packetsWaitingForPmt = [];\r\n      this.programMapTable = undefined;\r\n\r\n      parsePsi = function parsePsi(payload, psi) {\r\n        var offset = 0; // PSI packets may be split into multiple sections and those\r\n        // sections may be split into multiple packets. If a PSI\r\n        // section starts in this packet, the payload_unit_start_indicator\r\n        // will be true and the first byte of the payload will indicate\r\n        // the offset from the current position to the start of the\r\n        // section.\r\n\r\n        if (psi.payloadUnitStartIndicator) {\r\n          offset += payload[offset] + 1;\r\n        }\r\n\r\n        if (psi.type === 'pat') {\r\n          parsePat(payload.subarray(offset), psi);\r\n        } else {\r\n          parsePmt(payload.subarray(offset), psi);\r\n        }\r\n      };\r\n\r\n      parsePat = function parsePat(payload, pat) {\r\n        pat.section_number = payload[7]; // eslint-disable-line camelcase\r\n\r\n        pat.last_section_number = payload[8]; // eslint-disable-line camelcase\r\n        // skip the PSI header and parse the first PMT entry\r\n\r\n        self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\r\n        pat.pmtPid = self.pmtPid;\r\n      };\r\n      /**\r\n       * Parse out the relevant fields of a Program Map Table (PMT).\r\n       * @param payload {Uint8Array} the PMT-specific portion of an MP2T\r\n       * packet. The first byte in this array should be the table_id\r\n       * field.\r\n       * @param pmt {object} the object that should be decorated with\r\n       * fields parsed from the PMT.\r\n       */\r\n\r\n\r\n      parsePmt = function parsePmt(payload, pmt) {\r\n        var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\r\n        // take effect. We don't believe this should ever be the case\r\n        // for HLS but we'll ignore \"forward\" PMT declarations if we see\r\n        // them. Future PMT declarations have the current_next_indicator\r\n        // set to zero.\r\n\r\n        if (!(payload[5] & 0x01)) {\r\n          return;\r\n        } // overwrite any existing program map table\r\n\r\n\r\n        self.programMapTable = {\r\n          video: null,\r\n          audio: null,\r\n          'timed-metadata': {}\r\n        }; // the mapping table ends at the end of the current section\r\n\r\n        sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\r\n        tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\r\n        // long the program info descriptors are\r\n\r\n        programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\r\n\r\n        offset = 12 + programInfoLength;\r\n\r\n        while (offset < tableEnd) {\r\n          var streamType = payload[offset];\r\n          var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\r\n          // TODO: should this be done for metadata too? for now maintain behavior of\r\n          //       multiple metadata streams\r\n\r\n          if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\r\n            self.programMapTable.video = pid;\r\n          } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\r\n            self.programMapTable.audio = pid;\r\n          } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {\r\n            // map pid to stream type for metadata streams\r\n            self.programMapTable['timed-metadata'][pid] = streamType;\r\n          } // move to the next table entry\r\n          // skip past the elementary stream descriptors, if present\r\n\r\n\r\n          offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\r\n        } // record the map on the packet as well\r\n\r\n\r\n        pmt.programMapTable = self.programMapTable;\r\n      };\r\n      /**\r\n       * Deliver a new MP2T packet to the next stream in the pipeline.\r\n       */\r\n\r\n\r\n      this.push = function (packet) {\r\n        var result = {},\r\n            offset = 4;\r\n        result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\r\n\r\n        result.pid = packet[1] & 0x1f;\r\n        result.pid <<= 8;\r\n        result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\r\n        // fifth byte of the TS packet header. The adaptation field is\r\n        // used to add stuffing to PES packets that don't fill a complete\r\n        // TS packet, and to specify some forms of timing and control data\r\n        // that we do not currently use.\r\n\r\n        if ((packet[3] & 0x30) >>> 4 > 0x01) {\r\n          offset += packet[offset] + 1;\r\n        } // parse the rest of the packet based on the type\r\n\r\n\r\n        if (result.pid === 0) {\r\n          result.type = 'pat';\r\n          parsePsi(packet.subarray(offset), result);\r\n          this.trigger('data', result);\r\n        } else if (result.pid === this.pmtPid) {\r\n          result.type = 'pmt';\r\n          parsePsi(packet.subarray(offset), result);\r\n          this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\r\n\r\n          while (this.packetsWaitingForPmt.length) {\r\n            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\r\n          }\r\n        } else if (this.programMapTable === undefined) {\r\n          // When we have not seen a PMT yet, defer further processing of\r\n          // PES packets until one has been parsed\r\n          this.packetsWaitingForPmt.push([packet, offset, result]);\r\n        } else {\r\n          this.processPes_(packet, offset, result);\r\n        }\r\n      };\r\n\r\n      this.processPes_ = function (packet, offset, result) {\r\n        // set the appropriate stream type\r\n        if (result.pid === this.programMapTable.video) {\r\n          result.streamType = streamTypes.H264_STREAM_TYPE;\r\n        } else if (result.pid === this.programMapTable.audio) {\r\n          result.streamType = streamTypes.ADTS_STREAM_TYPE;\r\n        } else {\r\n          // if not video or audio, it is timed-metadata or unknown\r\n          // if unknown, streamType will be undefined\r\n          result.streamType = this.programMapTable['timed-metadata'][result.pid];\r\n        }\r\n\r\n        result.type = 'pes';\r\n        result.data = packet.subarray(offset);\r\n        this.trigger('data', result);\r\n      };\r\n    };\r\n\r\n    _TransportParseStream.prototype = new stream();\r\n    _TransportParseStream.STREAM_TYPES = {\r\n      h264: 0x1b,\r\n      adts: 0x0f\r\n    };\r\n    /**\r\n     * Reconsistutes program elementary stream (PES) packets from parsed\r\n     * transport stream packets. That is, if you pipe an\r\n     * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\r\n     * events will be events which capture the bytes for individual PES\r\n     * packets plus relevant metadata that has been extracted from the\r\n     * container.\r\n     */\r\n\r\n    _ElementaryStream = function ElementaryStream() {\r\n      var self = this,\r\n          segmentHadPmt = false,\r\n          // PES packet fragments\r\n      video = {\r\n        data: [],\r\n        size: 0\r\n      },\r\n          audio = {\r\n        data: [],\r\n        size: 0\r\n      },\r\n          timedMetadata = {\r\n        data: [],\r\n        size: 0\r\n      },\r\n          programMapTable,\r\n          parsePes = function parsePes(payload, pes) {\r\n        var ptsDtsFlags;\r\n        var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\r\n\r\n        pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\r\n        // that are frame data that is continuing from the previous fragment. This\r\n        // is to check that the pes data is the start of a new pes payload\r\n\r\n        if (startPrefix !== 1) {\r\n          return;\r\n        } // get the packet length, this will be 0 for video\r\n\r\n\r\n        pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\r\n\r\n        pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\r\n        // and a DTS value. Determine what combination of values is\r\n        // available to work with.\r\n\r\n        ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\r\n        // performs all bitwise operations on 32-bit integers but javascript\r\n        // supports a much greater range (52-bits) of integer using standard\r\n        // mathematical operations.\r\n        // We construct a 31-bit value using bitwise operators over the 31\r\n        // most significant bits and then multiply by 4 (equal to a left-shift\r\n        // of 2) before we add the final 2 least significant bits of the\r\n        // timestamp (equal to an OR.)\r\n\r\n        if (ptsDtsFlags & 0xC0) {\r\n          // the PTS and DTS are not written out directly. For information\r\n          // on how they are encoded, see\r\n          // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\r\n          pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\r\n          pes.pts *= 4; // Left shift by 2\r\n\r\n          pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\r\n\r\n          pes.dts = pes.pts;\r\n\r\n          if (ptsDtsFlags & 0x40) {\r\n            pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\r\n            pes.dts *= 4; // Left shift by 2\r\n\r\n            pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\r\n          }\r\n        } // the data section starts immediately after the PES header.\r\n        // pes_header_data_length specifies the number of header bytes\r\n        // that follow the last byte of the field.\r\n\r\n\r\n        pes.data = payload.subarray(9 + payload[8]);\r\n      },\r\n\r\n      /**\r\n        * Pass completely parsed PES packets to the next stream in the pipeline\r\n       **/\r\n      flushStream = function flushStream(stream, type, forceFlush) {\r\n        var packetData = new Uint8Array(stream.size),\r\n            event = {\r\n          type: type\r\n        },\r\n            i = 0,\r\n            offset = 0,\r\n            packetFlushable = false,\r\n            fragment; // do nothing if there is not enough buffered data for a complete\r\n        // PES header\r\n\r\n        if (!stream.data.length || stream.size < 9) {\r\n          return;\r\n        }\r\n\r\n        event.trackId = stream.data[0].pid; // reassemble the packet\r\n\r\n        for (i = 0; i < stream.data.length; i++) {\r\n          fragment = stream.data[i];\r\n          packetData.set(fragment.data, offset);\r\n          offset += fragment.data.byteLength;\r\n        } // parse assembled packet's PES header\r\n\r\n\r\n        parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\r\n        // check that there is enough stream data to fill the packet\r\n\r\n        packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\r\n\r\n        if (forceFlush || packetFlushable) {\r\n          stream.size = 0;\r\n          stream.data.length = 0;\r\n        } // only emit packets that are complete. this is to avoid assembling\r\n        // incomplete PES packets due to poor segmentation\r\n\r\n\r\n        if (packetFlushable) {\r\n          self.trigger('data', event);\r\n        }\r\n      };\r\n\r\n      _ElementaryStream.prototype.init.call(this);\r\n      /**\r\n       * Identifies M2TS packet types and parses PES packets using metadata\r\n       * parsed from the PMT\r\n       **/\r\n\r\n\r\n      this.push = function (data) {\r\n        ({\r\n          pat: function pat() {// we have to wait for the PMT to arrive as well before we\r\n            // have any meaningful metadata\r\n          },\r\n          pes: function pes() {\r\n            var stream, streamType;\r\n\r\n            switch (data.streamType) {\r\n              case streamTypes.H264_STREAM_TYPE:\r\n                stream = video;\r\n                streamType = 'video';\r\n                break;\r\n\r\n              case streamTypes.ADTS_STREAM_TYPE:\r\n                stream = audio;\r\n                streamType = 'audio';\r\n                break;\r\n\r\n              case streamTypes.METADATA_STREAM_TYPE:\r\n                stream = timedMetadata;\r\n                streamType = 'timed-metadata';\r\n                break;\r\n\r\n              default:\r\n                // ignore unknown stream types\r\n                return;\r\n            } // if a new packet is starting, we can flush the completed\r\n            // packet\r\n\r\n\r\n            if (data.payloadUnitStartIndicator) {\r\n              flushStream(stream, streamType, true);\r\n            } // buffer this fragment until we are sure we've received the\r\n            // complete payload\r\n\r\n\r\n            stream.data.push(data);\r\n            stream.size += data.data.byteLength;\r\n          },\r\n          pmt: function pmt() {\r\n            var event = {\r\n              type: 'metadata',\r\n              tracks: []\r\n            };\r\n            programMapTable = data.programMapTable; // translate audio and video streams to tracks\r\n\r\n            if (programMapTable.video !== null) {\r\n              event.tracks.push({\r\n                timelineStartInfo: {\r\n                  baseMediaDecodeTime: 0\r\n                },\r\n                id: +programMapTable.video,\r\n                codec: 'avc',\r\n                type: 'video'\r\n              });\r\n            }\r\n\r\n            if (programMapTable.audio !== null) {\r\n              event.tracks.push({\r\n                timelineStartInfo: {\r\n                  baseMediaDecodeTime: 0\r\n                },\r\n                id: +programMapTable.audio,\r\n                codec: 'adts',\r\n                type: 'audio'\r\n              });\r\n            }\r\n\r\n            segmentHadPmt = true;\r\n            self.trigger('data', event);\r\n          }\r\n        })[data.type]();\r\n      };\r\n\r\n      this.reset = function () {\r\n        video.size = 0;\r\n        video.data.length = 0;\r\n        audio.size = 0;\r\n        audio.data.length = 0;\r\n        this.trigger('reset');\r\n      };\r\n      /**\r\n       * Flush any remaining input. Video PES packets may be of variable\r\n       * length. Normally, the start of a new video packet can trigger the\r\n       * finalization of the previous packet. That is not possible if no\r\n       * more video is forthcoming, however. In that case, some other\r\n       * mechanism (like the end of the file) has to be employed. When it is\r\n       * clear that no additional data is forthcoming, calling this method\r\n       * will flush the buffered packets.\r\n       */\r\n\r\n\r\n      this.flushStreams_ = function () {\r\n        // !!THIS ORDER IS IMPORTANT!!\r\n        // video first then audio\r\n        flushStream(video, 'video');\r\n        flushStream(audio, 'audio');\r\n        flushStream(timedMetadata, 'timed-metadata');\r\n      };\r\n\r\n      this.flush = function () {\r\n        // if on flush we haven't had a pmt emitted\r\n        // and we have a pmt to emit. emit the pmt\r\n        // so that we trigger a trackinfo downstream.\r\n        if (!segmentHadPmt && programMapTable) {\r\n          var pmt = {\r\n            type: 'metadata',\r\n            tracks: []\r\n          }; // translate audio and video streams to tracks\r\n\r\n          if (programMapTable.video !== null) {\r\n            pmt.tracks.push({\r\n              timelineStartInfo: {\r\n                baseMediaDecodeTime: 0\r\n              },\r\n              id: +programMapTable.video,\r\n              codec: 'avc',\r\n              type: 'video'\r\n            });\r\n          }\r\n\r\n          if (programMapTable.audio !== null) {\r\n            pmt.tracks.push({\r\n              timelineStartInfo: {\r\n                baseMediaDecodeTime: 0\r\n              },\r\n              id: +programMapTable.audio,\r\n              codec: 'adts',\r\n              type: 'audio'\r\n            });\r\n          }\r\n\r\n          self.trigger('data', pmt);\r\n        }\r\n\r\n        segmentHadPmt = false;\r\n        this.flushStreams_();\r\n        this.trigger('done');\r\n      };\r\n    };\r\n\r\n    _ElementaryStream.prototype = new stream();\r\n    var m2ts = {\r\n      PAT_PID: 0x0000,\r\n      MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\r\n      TransportPacketStream: _TransportPacketStream,\r\n      TransportParseStream: _TransportParseStream,\r\n      ElementaryStream: _ElementaryStream,\r\n      TimestampRolloverStream: TimestampRolloverStream,\r\n      CaptionStream: captionStream.CaptionStream,\r\n      Cea608Stream: captionStream.Cea608Stream,\r\n      Cea708Stream: captionStream.Cea708Stream,\r\n      MetadataStream: metadataStream\r\n    };\r\n\r\n    for (var type in streamTypes) {\r\n      if (streamTypes.hasOwnProperty(type)) {\r\n        m2ts[type] = streamTypes[type];\r\n      }\r\n    }\r\n\r\n    var m2ts_1 = m2ts;\r\n    var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS;\r\n\r\n    var _AdtsStream;\r\n\r\n    var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\r\n    /*\r\n     * Accepts a ElementaryStream and emits data events with parsed\r\n     * AAC Audio Frames of the individual packets. Input audio in ADTS\r\n     * format is unpacked and re-emitted as AAC frames.\r\n     *\r\n     * @see http://wiki.multimedia.cx/index.php?title=ADTS\r\n     * @see http://wiki.multimedia.cx/?title=Understanding_AAC\r\n     */\r\n\r\n    _AdtsStream = function AdtsStream(handlePartialSegments) {\r\n      var buffer,\r\n          frameNum = 0;\r\n\r\n      _AdtsStream.prototype.init.call(this);\r\n\r\n      this.skipWarn_ = function (start, end) {\r\n        this.trigger('log', {\r\n          level: 'warn',\r\n          message: \"adts skiping bytes \" + start + \" to \" + end + \" in frame \" + frameNum + \" outside syncword\"\r\n        });\r\n      };\r\n\r\n      this.push = function (packet) {\r\n        var i = 0,\r\n            frameLength,\r\n            protectionSkipBytes,\r\n            oldBuffer,\r\n            sampleCount,\r\n            adtsFrameDuration;\r\n\r\n        if (!handlePartialSegments) {\r\n          frameNum = 0;\r\n        }\r\n\r\n        if (packet.type !== 'audio') {\r\n          // ignore non-audio data\r\n          return;\r\n        } // Prepend any data in the buffer to the input data so that we can parse\r\n        // aac frames the cross a PES packet boundary\r\n\r\n\r\n        if (buffer && buffer.length) {\r\n          oldBuffer = buffer;\r\n          buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\r\n          buffer.set(oldBuffer);\r\n          buffer.set(packet.data, oldBuffer.byteLength);\r\n        } else {\r\n          buffer = packet.data;\r\n        } // unpack any ADTS frames which have been fully received\r\n        // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\r\n\r\n\r\n        var skip; // We use i + 7 here because we want to be able to parse the entire header.\r\n        // If we don't have enough bytes to do that, then we definitely won't have a full frame.\r\n\r\n        while (i + 7 < buffer.length) {\r\n          // Look for the start of an ADTS header..\r\n          if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\r\n            if (typeof skip !== 'number') {\r\n              skip = i;\r\n            } // If a valid header was not found,  jump one forward and attempt to\r\n            // find a valid ADTS header starting at the next byte\r\n\r\n\r\n            i++;\r\n            continue;\r\n          }\r\n\r\n          if (typeof skip === 'number') {\r\n            this.skipWarn_(skip, i);\r\n            skip = null;\r\n          } // The protection skip bit tells us if we have 2 bytes of CRC data at the\r\n          // end of the ADTS header\r\n\r\n\r\n          protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\r\n          // end of the sync sequence\r\n          // NOTE: frame length includes the size of the header\r\n\r\n          frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\r\n          sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\r\n          adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\r\n          // then we have to wait for more data\r\n\r\n          if (buffer.byteLength - i < frameLength) {\r\n            break;\r\n          } // Otherwise, deliver the complete AAC frame\r\n\r\n\r\n          this.trigger('data', {\r\n            pts: packet.pts + frameNum * adtsFrameDuration,\r\n            dts: packet.dts + frameNum * adtsFrameDuration,\r\n            sampleCount: sampleCount,\r\n            audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\r\n            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\r\n            samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\r\n            samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\r\n            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\r\n            samplesize: 16,\r\n            // data is the frame without it's header\r\n            data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\r\n          });\r\n          frameNum++;\r\n          i += frameLength;\r\n        }\r\n\r\n        if (typeof skip === 'number') {\r\n          this.skipWarn_(skip, i);\r\n          skip = null;\r\n        } // remove processed bytes from the buffer.\r\n\r\n\r\n        buffer = buffer.subarray(i);\r\n      };\r\n\r\n      this.flush = function () {\r\n        frameNum = 0;\r\n        this.trigger('done');\r\n      };\r\n\r\n      this.reset = function () {\r\n        buffer = void 0;\r\n        this.trigger('reset');\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        buffer = void 0;\r\n        this.trigger('endedtimeline');\r\n      };\r\n    };\r\n\r\n    _AdtsStream.prototype = new stream();\r\n    var adts = _AdtsStream;\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n    var ExpGolomb;\r\n    /**\r\n     * Parser for exponential Golomb codes, a variable-bitwidth number encoding\r\n     * scheme used by h264.\r\n     */\r\n\r\n    ExpGolomb = function ExpGolomb(workingData) {\r\n      var // the number of bytes left to examine in workingData\r\n      workingBytesAvailable = workingData.byteLength,\r\n          // the current word being examined\r\n      workingWord = 0,\r\n          // :uint\r\n      // the number of bits left to examine in the current word\r\n      workingBitsAvailable = 0; // :uint;\r\n      // ():uint\r\n\r\n      this.length = function () {\r\n        return 8 * workingBytesAvailable;\r\n      }; // ():uint\r\n\r\n\r\n      this.bitsAvailable = function () {\r\n        return 8 * workingBytesAvailable + workingBitsAvailable;\r\n      }; // ():void\r\n\r\n\r\n      this.loadWord = function () {\r\n        var position = workingData.byteLength - workingBytesAvailable,\r\n            workingBytes = new Uint8Array(4),\r\n            availableBytes = Math.min(4, workingBytesAvailable);\r\n\r\n        if (availableBytes === 0) {\r\n          throw new Error('no bytes available');\r\n        }\r\n\r\n        workingBytes.set(workingData.subarray(position, position + availableBytes));\r\n        workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\r\n\r\n        workingBitsAvailable = availableBytes * 8;\r\n        workingBytesAvailable -= availableBytes;\r\n      }; // (count:int):void\r\n\r\n\r\n      this.skipBits = function (count) {\r\n        var skipBytes; // :int\r\n\r\n        if (workingBitsAvailable > count) {\r\n          workingWord <<= count;\r\n          workingBitsAvailable -= count;\r\n        } else {\r\n          count -= workingBitsAvailable;\r\n          skipBytes = Math.floor(count / 8);\r\n          count -= skipBytes * 8;\r\n          workingBytesAvailable -= skipBytes;\r\n          this.loadWord();\r\n          workingWord <<= count;\r\n          workingBitsAvailable -= count;\r\n        }\r\n      }; // (size:int):uint\r\n\r\n\r\n      this.readBits = function (size) {\r\n        var bits = Math.min(workingBitsAvailable, size),\r\n            // :uint\r\n        valu = workingWord >>> 32 - bits; // :uint\r\n        // if size > 31, handle error\r\n\r\n        workingBitsAvailable -= bits;\r\n\r\n        if (workingBitsAvailable > 0) {\r\n          workingWord <<= bits;\r\n        } else if (workingBytesAvailable > 0) {\r\n          this.loadWord();\r\n        }\r\n\r\n        bits = size - bits;\r\n\r\n        if (bits > 0) {\r\n          return valu << bits | this.readBits(bits);\r\n        }\r\n\r\n        return valu;\r\n      }; // ():uint\r\n\r\n\r\n      this.skipLeadingZeros = function () {\r\n        var leadingZeroCount; // :uint\r\n\r\n        for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\r\n          if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\r\n            // the first bit of working word is 1\r\n            workingWord <<= leadingZeroCount;\r\n            workingBitsAvailable -= leadingZeroCount;\r\n            return leadingZeroCount;\r\n          }\r\n        } // we exhausted workingWord and still have not found a 1\r\n\r\n\r\n        this.loadWord();\r\n        return leadingZeroCount + this.skipLeadingZeros();\r\n      }; // ():void\r\n\r\n\r\n      this.skipUnsignedExpGolomb = function () {\r\n        this.skipBits(1 + this.skipLeadingZeros());\r\n      }; // ():void\r\n\r\n\r\n      this.skipExpGolomb = function () {\r\n        this.skipBits(1 + this.skipLeadingZeros());\r\n      }; // ():uint\r\n\r\n\r\n      this.readUnsignedExpGolomb = function () {\r\n        var clz = this.skipLeadingZeros(); // :uint\r\n\r\n        return this.readBits(clz + 1) - 1;\r\n      }; // ():int\r\n\r\n\r\n      this.readExpGolomb = function () {\r\n        var valu = this.readUnsignedExpGolomb(); // :int\r\n\r\n        if (0x01 & valu) {\r\n          // the number is odd if the low order bit is set\r\n          return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\r\n        }\r\n\r\n        return -1 * (valu >>> 1); // divide by two then make it negative\r\n      }; // Some convenience functions\r\n      // :Boolean\r\n\r\n\r\n      this.readBoolean = function () {\r\n        return this.readBits(1) === 1;\r\n      }; // ():int\r\n\r\n\r\n      this.readUnsignedByte = function () {\r\n        return this.readBits(8);\r\n      };\r\n\r\n      this.loadWord();\r\n    };\r\n\r\n    var expGolomb = ExpGolomb;\r\n\r\n    var _H264Stream, _NalByteStream;\r\n\r\n    var PROFILES_WITH_OPTIONAL_SPS_DATA;\r\n    /**\r\n     * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\r\n     */\r\n\r\n    _NalByteStream = function NalByteStream() {\r\n      var syncPoint = 0,\r\n          i,\r\n          buffer;\r\n\r\n      _NalByteStream.prototype.init.call(this);\r\n      /*\r\n       * Scans a byte stream and triggers a data event with the NAL units found.\r\n       * @param {Object} data Event received from H264Stream\r\n       * @param {Uint8Array} data.data The h264 byte stream to be scanned\r\n       *\r\n       * @see H264Stream.push\r\n       */\r\n\r\n\r\n      this.push = function (data) {\r\n        var swapBuffer;\r\n\r\n        if (!buffer) {\r\n          buffer = data.data;\r\n        } else {\r\n          swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\r\n          swapBuffer.set(buffer);\r\n          swapBuffer.set(data.data, buffer.byteLength);\r\n          buffer = swapBuffer;\r\n        }\r\n\r\n        var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\r\n        // scan for NAL unit boundaries\r\n        // a match looks like this:\r\n        // 0 0 1 .. NAL .. 0 0 1\r\n        // ^ sync point        ^ i\r\n        // or this:\r\n        // 0 0 1 .. NAL .. 0 0 0\r\n        // ^ sync point        ^ i\r\n        // advance the sync point to a NAL start, if necessary\r\n\r\n        for (; syncPoint < len - 3; syncPoint++) {\r\n          if (buffer[syncPoint + 2] === 1) {\r\n            // the sync point is properly aligned\r\n            i = syncPoint + 5;\r\n            break;\r\n          }\r\n        }\r\n\r\n        while (i < len) {\r\n          // look at the current byte to determine if we've hit the end of\r\n          // a NAL unit boundary\r\n          switch (buffer[i]) {\r\n            case 0:\r\n              // skip past non-sync sequences\r\n              if (buffer[i - 1] !== 0) {\r\n                i += 2;\r\n                break;\r\n              } else if (buffer[i - 2] !== 0) {\r\n                i++;\r\n                break;\r\n              } // deliver the NAL unit if it isn't empty\r\n\r\n\r\n              if (syncPoint + 3 !== i - 2) {\r\n                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\r\n              } // drop trailing zeroes\r\n\r\n\r\n              do {\r\n                i++;\r\n              } while (buffer[i] !== 1 && i < len);\r\n\r\n              syncPoint = i - 2;\r\n              i += 3;\r\n              break;\r\n\r\n            case 1:\r\n              // skip past non-sync sequences\r\n              if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\r\n                i += 3;\r\n                break;\r\n              } // deliver the NAL unit\r\n\r\n\r\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\r\n              syncPoint = i - 2;\r\n              i += 3;\r\n              break;\r\n\r\n            default:\r\n              // the current byte isn't a one or zero, so it cannot be part\r\n              // of a sync sequence\r\n              i += 3;\r\n              break;\r\n          }\r\n        } // filter out the NAL units that were delivered\r\n\r\n\r\n        buffer = buffer.subarray(syncPoint);\r\n        i -= syncPoint;\r\n        syncPoint = 0;\r\n      };\r\n\r\n      this.reset = function () {\r\n        buffer = null;\r\n        syncPoint = 0;\r\n        this.trigger('reset');\r\n      };\r\n\r\n      this.flush = function () {\r\n        // deliver the last buffered NAL unit\r\n        if (buffer && buffer.byteLength > 3) {\r\n          this.trigger('data', buffer.subarray(syncPoint + 3));\r\n        } // reset the stream state\r\n\r\n\r\n        buffer = null;\r\n        syncPoint = 0;\r\n        this.trigger('done');\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        this.flush();\r\n        this.trigger('endedtimeline');\r\n      };\r\n    };\r\n\r\n    _NalByteStream.prototype = new stream(); // values of profile_idc that indicate additional fields are included in the SPS\r\n    // see Recommendation ITU-T H.264 (4/2013),\r\n    // 7.3.2.1.1 Sequence parameter set data syntax\r\n\r\n    PROFILES_WITH_OPTIONAL_SPS_DATA = {\r\n      100: true,\r\n      110: true,\r\n      122: true,\r\n      244: true,\r\n      44: true,\r\n      83: true,\r\n      86: true,\r\n      118: true,\r\n      128: true,\r\n      // TODO: the three profiles below don't\r\n      // appear to have sps data in the specificiation anymore?\r\n      138: true,\r\n      139: true,\r\n      134: true\r\n    };\r\n    /**\r\n     * Accepts input from a ElementaryStream and produces H.264 NAL unit data\r\n     * events.\r\n     */\r\n\r\n    _H264Stream = function H264Stream() {\r\n      var nalByteStream = new _NalByteStream(),\r\n          self,\r\n          trackId,\r\n          currentPts,\r\n          currentDts,\r\n          discardEmulationPreventionBytes,\r\n          readSequenceParameterSet,\r\n          skipScalingList;\r\n\r\n      _H264Stream.prototype.init.call(this);\r\n\r\n      self = this;\r\n      /*\r\n       * Pushes a packet from a stream onto the NalByteStream\r\n       *\r\n       * @param {Object} packet - A packet received from a stream\r\n       * @param {Uint8Array} packet.data - The raw bytes of the packet\r\n       * @param {Number} packet.dts - Decode timestamp of the packet\r\n       * @param {Number} packet.pts - Presentation timestamp of the packet\r\n       * @param {Number} packet.trackId - The id of the h264 track this packet came from\r\n       * @param {('video'|'audio')} packet.type - The type of packet\r\n       *\r\n       */\r\n\r\n      this.push = function (packet) {\r\n        if (packet.type !== 'video') {\r\n          return;\r\n        }\r\n\r\n        trackId = packet.trackId;\r\n        currentPts = packet.pts;\r\n        currentDts = packet.dts;\r\n        nalByteStream.push(packet);\r\n      };\r\n      /*\r\n       * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\r\n       * for the NALUs to the next stream component.\r\n       * Also, preprocess caption and sequence parameter NALUs.\r\n       *\r\n       * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\r\n       * @see NalByteStream.push\r\n       */\r\n\r\n\r\n      nalByteStream.on('data', function (data) {\r\n        var event = {\r\n          trackId: trackId,\r\n          pts: currentPts,\r\n          dts: currentDts,\r\n          data: data,\r\n          nalUnitTypeCode: data[0] & 0x1f\r\n        };\r\n\r\n        switch (event.nalUnitTypeCode) {\r\n          case 0x05:\r\n            event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\r\n            break;\r\n\r\n          case 0x06:\r\n            event.nalUnitType = 'sei_rbsp';\r\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\r\n            break;\r\n\r\n          case 0x07:\r\n            event.nalUnitType = 'seq_parameter_set_rbsp';\r\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\r\n            event.config = readSequenceParameterSet(event.escapedRBSP);\r\n            break;\r\n\r\n          case 0x08:\r\n            event.nalUnitType = 'pic_parameter_set_rbsp';\r\n            break;\r\n\r\n          case 0x09:\r\n            event.nalUnitType = 'access_unit_delimiter_rbsp';\r\n            break;\r\n        } // This triggers data on the H264Stream\r\n\r\n\r\n        self.trigger('data', event);\r\n      });\r\n      nalByteStream.on('done', function () {\r\n        self.trigger('done');\r\n      });\r\n      nalByteStream.on('partialdone', function () {\r\n        self.trigger('partialdone');\r\n      });\r\n      nalByteStream.on('reset', function () {\r\n        self.trigger('reset');\r\n      });\r\n      nalByteStream.on('endedtimeline', function () {\r\n        self.trigger('endedtimeline');\r\n      });\r\n\r\n      this.flush = function () {\r\n        nalByteStream.flush();\r\n      };\r\n\r\n      this.partialFlush = function () {\r\n        nalByteStream.partialFlush();\r\n      };\r\n\r\n      this.reset = function () {\r\n        nalByteStream.reset();\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        nalByteStream.endTimeline();\r\n      };\r\n      /**\r\n       * Advance the ExpGolomb decoder past a scaling list. The scaling\r\n       * list is optionally transmitted as part of a sequence parameter\r\n       * set and is not relevant to transmuxing.\r\n       * @param count {number} the number of entries in this scaling list\r\n       * @param expGolombDecoder {object} an ExpGolomb pointed to the\r\n       * start of a scaling list\r\n       * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\r\n       */\r\n\r\n\r\n      skipScalingList = function skipScalingList(count, expGolombDecoder) {\r\n        var lastScale = 8,\r\n            nextScale = 8,\r\n            j,\r\n            deltaScale;\r\n\r\n        for (j = 0; j < count; j++) {\r\n          if (nextScale !== 0) {\r\n            deltaScale = expGolombDecoder.readExpGolomb();\r\n            nextScale = (lastScale + deltaScale + 256) % 256;\r\n          }\r\n\r\n          lastScale = nextScale === 0 ? lastScale : nextScale;\r\n        }\r\n      };\r\n      /**\r\n       * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\r\n       * Sequence Payload\"\r\n       * @param data {Uint8Array} the bytes of a RBSP from a NAL\r\n       * unit\r\n       * @return {Uint8Array} the RBSP without any Emulation\r\n       * Prevention Bytes\r\n       */\r\n\r\n\r\n      discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\r\n        var length = data.byteLength,\r\n            emulationPreventionBytesPositions = [],\r\n            i = 1,\r\n            newLength,\r\n            newData; // Find all `Emulation Prevention Bytes`\r\n\r\n        while (i < length - 2) {\r\n          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\r\n            emulationPreventionBytesPositions.push(i + 2);\r\n            i += 2;\r\n          } else {\r\n            i++;\r\n          }\r\n        } // If no Emulation Prevention Bytes were found just return the original\r\n        // array\r\n\r\n\r\n        if (emulationPreventionBytesPositions.length === 0) {\r\n          return data;\r\n        } // Create a new array to hold the NAL unit data\r\n\r\n\r\n        newLength = length - emulationPreventionBytesPositions.length;\r\n        newData = new Uint8Array(newLength);\r\n        var sourceIndex = 0;\r\n\r\n        for (i = 0; i < newLength; sourceIndex++, i++) {\r\n          if (sourceIndex === emulationPreventionBytesPositions[0]) {\r\n            // Skip this byte\r\n            sourceIndex++; // Remove this position index\r\n\r\n            emulationPreventionBytesPositions.shift();\r\n          }\r\n\r\n          newData[i] = data[sourceIndex];\r\n        }\r\n\r\n        return newData;\r\n      };\r\n      /**\r\n       * Read a sequence parameter set and return some interesting video\r\n       * properties. A sequence parameter set is the H264 metadata that\r\n       * describes the properties of upcoming video frames.\r\n       * @param data {Uint8Array} the bytes of a sequence parameter set\r\n       * @return {object} an object with configuration parsed from the\r\n       * sequence parameter set, including the dimensions of the\r\n       * associated video frames.\r\n       */\r\n\r\n\r\n      readSequenceParameterSet = function readSequenceParameterSet(data) {\r\n        var frameCropLeftOffset = 0,\r\n            frameCropRightOffset = 0,\r\n            frameCropTopOffset = 0,\r\n            frameCropBottomOffset = 0,\r\n            expGolombDecoder,\r\n            profileIdc,\r\n            levelIdc,\r\n            profileCompatibility,\r\n            chromaFormatIdc,\r\n            picOrderCntType,\r\n            numRefFramesInPicOrderCntCycle,\r\n            picWidthInMbsMinus1,\r\n            picHeightInMapUnitsMinus1,\r\n            frameMbsOnlyFlag,\r\n            scalingListCount,\r\n            sarRatio = [1, 1],\r\n            aspectRatioIdc,\r\n            i;\r\n        expGolombDecoder = new expGolomb(data);\r\n        profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\r\n\r\n        profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\r\n\r\n        levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\r\n\r\n        expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\r\n        // some profiles have more optional data we don't need\r\n\r\n        if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\r\n          chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\r\n\r\n          if (chromaFormatIdc === 3) {\r\n            expGolombDecoder.skipBits(1); // separate_colour_plane_flag\r\n          }\r\n\r\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\r\n\r\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\r\n\r\n          expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\r\n\r\n          if (expGolombDecoder.readBoolean()) {\r\n            // seq_scaling_matrix_present_flag\r\n            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\r\n\r\n            for (i = 0; i < scalingListCount; i++) {\r\n              if (expGolombDecoder.readBoolean()) {\r\n                // seq_scaling_list_present_flag[ i ]\r\n                if (i < 6) {\r\n                  skipScalingList(16, expGolombDecoder);\r\n                } else {\r\n                  skipScalingList(64, expGolombDecoder);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\r\n\r\n        picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\r\n\r\n        if (picOrderCntType === 0) {\r\n          expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\r\n        } else if (picOrderCntType === 1) {\r\n          expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\r\n\r\n          expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\r\n\r\n          expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\r\n\r\n          numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\r\n\r\n          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\r\n            expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\r\n          }\r\n        }\r\n\r\n        expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\r\n\r\n        expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\r\n\r\n        picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\r\n        picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\r\n        frameMbsOnlyFlag = expGolombDecoder.readBits(1);\r\n\r\n        if (frameMbsOnlyFlag === 0) {\r\n          expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\r\n        }\r\n\r\n        expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\r\n\r\n        if (expGolombDecoder.readBoolean()) {\r\n          // frame_cropping_flag\r\n          frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\r\n          frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\r\n          frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\r\n          frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\r\n        }\r\n\r\n        if (expGolombDecoder.readBoolean()) {\r\n          // vui_parameters_present_flag\r\n          if (expGolombDecoder.readBoolean()) {\r\n            // aspect_ratio_info_present_flag\r\n            aspectRatioIdc = expGolombDecoder.readUnsignedByte();\r\n\r\n            switch (aspectRatioIdc) {\r\n              case 1:\r\n                sarRatio = [1, 1];\r\n                break;\r\n\r\n              case 2:\r\n                sarRatio = [12, 11];\r\n                break;\r\n\r\n              case 3:\r\n                sarRatio = [10, 11];\r\n                break;\r\n\r\n              case 4:\r\n                sarRatio = [16, 11];\r\n                break;\r\n\r\n              case 5:\r\n                sarRatio = [40, 33];\r\n                break;\r\n\r\n              case 6:\r\n                sarRatio = [24, 11];\r\n                break;\r\n\r\n              case 7:\r\n                sarRatio = [20, 11];\r\n                break;\r\n\r\n              case 8:\r\n                sarRatio = [32, 11];\r\n                break;\r\n\r\n              case 9:\r\n                sarRatio = [80, 33];\r\n                break;\r\n\r\n              case 10:\r\n                sarRatio = [18, 11];\r\n                break;\r\n\r\n              case 11:\r\n                sarRatio = [15, 11];\r\n                break;\r\n\r\n              case 12:\r\n                sarRatio = [64, 33];\r\n                break;\r\n\r\n              case 13:\r\n                sarRatio = [160, 99];\r\n                break;\r\n\r\n              case 14:\r\n                sarRatio = [4, 3];\r\n                break;\r\n\r\n              case 15:\r\n                sarRatio = [3, 2];\r\n                break;\r\n\r\n              case 16:\r\n                sarRatio = [2, 1];\r\n                break;\r\n\r\n              case 255:\r\n                {\r\n                  sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\r\n                  break;\r\n                }\r\n            }\r\n\r\n            if (sarRatio) {\r\n              sarRatio[0] / sarRatio[1];\r\n            }\r\n          }\r\n        }\r\n\r\n        return {\r\n          profileIdc: profileIdc,\r\n          levelIdc: levelIdc,\r\n          profileCompatibility: profileCompatibility,\r\n          width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\r\n          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\r\n          // sar is sample aspect ratio\r\n          sarRatio: sarRatio\r\n        };\r\n      };\r\n    };\r\n\r\n    _H264Stream.prototype = new stream();\r\n    var h264 = {\r\n      H264Stream: _H264Stream,\r\n      NalByteStream: _NalByteStream\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     *\r\n     * Utilities to detect basic properties and metadata about Aac data.\r\n     */\r\n\r\n    var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\r\n\r\n    var parseId3TagSize = function parseId3TagSize(header, byteIndex) {\r\n      var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\r\n          flags = header[byteIndex + 5],\r\n          footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\r\n\r\n      returnSize = returnSize >= 0 ? returnSize : 0;\r\n\r\n      if (footerPresent) {\r\n        return returnSize + 20;\r\n      }\r\n\r\n      return returnSize + 10;\r\n    };\r\n\r\n    var getId3Offset = function getId3Offset(data, offset) {\r\n      if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\r\n        return offset;\r\n      }\r\n\r\n      offset += parseId3TagSize(data, offset);\r\n      return getId3Offset(data, offset);\r\n    }; // TODO: use vhs-utils\r\n\r\n\r\n    var isLikelyAacData$1 = function isLikelyAacData(data) {\r\n      var offset = getId3Offset(data, 0);\r\n      return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 && // verify that the 2 layer bits are 0, aka this\r\n      // is not mp3 data but aac data.\r\n      (data[offset + 1] & 0x16) === 0x10;\r\n    };\r\n\r\n    var parseSyncSafeInteger = function parseSyncSafeInteger(data) {\r\n      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\r\n    }; // return a percent-encoded representation of the specified byte range\r\n    // @see http://en.wikipedia.org/wiki/Percent-encoding\r\n\r\n\r\n    var percentEncode = function percentEncode(bytes, start, end) {\r\n      var i,\r\n          result = '';\r\n\r\n      for (i = start; i < end; i++) {\r\n        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\r\n      }\r\n\r\n      return result;\r\n    }; // return the string representation of the specified byte range,\r\n    // interpreted as ISO-8859-1.\r\n\r\n\r\n    var parseIso88591 = function parseIso88591(bytes, start, end) {\r\n      return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\r\n    };\r\n\r\n    var parseAdtsSize = function parseAdtsSize(header, byteIndex) {\r\n      var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\r\n          middle = header[byteIndex + 4] << 3,\r\n          highTwo = header[byteIndex + 3] & 0x3 << 11;\r\n      return highTwo | middle | lowThree;\r\n    };\r\n\r\n    var parseType$2 = function parseType(header, byteIndex) {\r\n      if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\r\n        return 'timed-metadata';\r\n      } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\r\n        return 'audio';\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    var parseSampleRate = function parseSampleRate(packet) {\r\n      var i = 0;\r\n\r\n      while (i + 5 < packet.length) {\r\n        if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\r\n          // If a valid header was not found,  jump one forward and attempt to\r\n          // find a valid ADTS header starting at the next byte\r\n          i++;\r\n          continue;\r\n        }\r\n\r\n        return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    var parseAacTimestamp = function parseAacTimestamp(packet) {\r\n      var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\r\n\r\n      frameStart = 10;\r\n\r\n      if (packet[5] & 0x40) {\r\n        // advance the frame start past the extended header\r\n        frameStart += 4; // header size field\r\n\r\n        frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\r\n      } // parse one or more ID3 frames\r\n      // http://id3.org/id3v2.3.0#ID3v2_frame_overview\r\n\r\n\r\n      do {\r\n        // determine the number of bytes in this frame\r\n        frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\r\n\r\n        if (frameSize < 1) {\r\n          return null;\r\n        }\r\n\r\n        frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\r\n\r\n        if (frameHeader === 'PRIV') {\r\n          frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\r\n\r\n          for (var i = 0; i < frame.byteLength; i++) {\r\n            if (frame[i] === 0) {\r\n              var owner = parseIso88591(frame, 0, i);\r\n\r\n              if (owner === 'com.apple.streaming.transportStreamTimestamp') {\r\n                var d = frame.subarray(i + 1);\r\n                var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\r\n                size *= 4;\r\n                size += d[7] & 0x03;\r\n                return size;\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        frameStart += 10; // advance past the frame header\r\n\r\n        frameStart += frameSize; // advance past the frame body\r\n      } while (frameStart < packet.byteLength);\r\n\r\n      return null;\r\n    };\r\n\r\n    var utils = {\r\n      isLikelyAacData: isLikelyAacData$1,\r\n      parseId3TagSize: parseId3TagSize,\r\n      parseAdtsSize: parseAdtsSize,\r\n      parseType: parseType$2,\r\n      parseSampleRate: parseSampleRate,\r\n      parseAacTimestamp: parseAacTimestamp\r\n    };\r\n\r\n    var _AacStream;\r\n    /**\r\n     * Splits an incoming stream of binary data into ADTS and ID3 Frames.\r\n     */\r\n\r\n\r\n    _AacStream = function AacStream() {\r\n      var everything = new Uint8Array(),\r\n          timeStamp = 0;\r\n\r\n      _AacStream.prototype.init.call(this);\r\n\r\n      this.setTimestamp = function (timestamp) {\r\n        timeStamp = timestamp;\r\n      };\r\n\r\n      this.push = function (bytes) {\r\n        var frameSize = 0,\r\n            byteIndex = 0,\r\n            bytesLeft,\r\n            chunk,\r\n            packet,\r\n            tempLength; // If there are bytes remaining from the last segment, prepend them to the\r\n        // bytes that were pushed in\r\n\r\n        if (everything.length) {\r\n          tempLength = everything.length;\r\n          everything = new Uint8Array(bytes.byteLength + tempLength);\r\n          everything.set(everything.subarray(0, tempLength));\r\n          everything.set(bytes, tempLength);\r\n        } else {\r\n          everything = bytes;\r\n        }\r\n\r\n        while (everything.length - byteIndex >= 3) {\r\n          if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\r\n            // Exit early because we don't have enough to parse\r\n            // the ID3 tag header\r\n            if (everything.length - byteIndex < 10) {\r\n              break;\r\n            } // check framesize\r\n\r\n\r\n            frameSize = utils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\r\n            // to emit a full packet\r\n            // Add to byteIndex to support multiple ID3 tags in sequence\r\n\r\n            if (byteIndex + frameSize > everything.length) {\r\n              break;\r\n            }\r\n\r\n            chunk = {\r\n              type: 'timed-metadata',\r\n              data: everything.subarray(byteIndex, byteIndex + frameSize)\r\n            };\r\n            this.trigger('data', chunk);\r\n            byteIndex += frameSize;\r\n            continue;\r\n          } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\r\n            // Exit early because we don't have enough to parse\r\n            // the ADTS frame header\r\n            if (everything.length - byteIndex < 7) {\r\n              break;\r\n            }\r\n\r\n            frameSize = utils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\r\n            // to emit a full packet\r\n\r\n            if (byteIndex + frameSize > everything.length) {\r\n              break;\r\n            }\r\n\r\n            packet = {\r\n              type: 'audio',\r\n              data: everything.subarray(byteIndex, byteIndex + frameSize),\r\n              pts: timeStamp,\r\n              dts: timeStamp\r\n            };\r\n            this.trigger('data', packet);\r\n            byteIndex += frameSize;\r\n            continue;\r\n          }\r\n\r\n          byteIndex++;\r\n        }\r\n\r\n        bytesLeft = everything.length - byteIndex;\r\n\r\n        if (bytesLeft > 0) {\r\n          everything = everything.subarray(byteIndex);\r\n        } else {\r\n          everything = new Uint8Array();\r\n        }\r\n      };\r\n\r\n      this.reset = function () {\r\n        everything = new Uint8Array();\r\n        this.trigger('reset');\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        everything = new Uint8Array();\r\n        this.trigger('endedtimeline');\r\n      };\r\n    };\r\n\r\n    _AacStream.prototype = new stream();\r\n    var aac = _AacStream; // constants\r\n\r\n    var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\r\n    var audioProperties = AUDIO_PROPERTIES;\r\n    var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\r\n    var videoProperties = VIDEO_PROPERTIES;\r\n    var H264Stream = h264.H264Stream;\r\n    var isLikelyAacData = utils.isLikelyAacData;\r\n    var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS; // object types\r\n\r\n    var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;\r\n\r\n    var retriggerForStream = function retriggerForStream(key, event) {\r\n      event.stream = key;\r\n      this.trigger('log', event);\r\n    };\r\n\r\n    var addPipelineLogRetriggers = function addPipelineLogRetriggers(transmuxer, pipeline) {\r\n      var keys = Object.keys(pipeline);\r\n\r\n      for (var i = 0; i < keys.length; i++) {\r\n        var key = keys[i]; // skip non-stream keys and headOfPipeline\r\n        // which is just a duplicate\r\n\r\n        if (key === 'headOfPipeline' || !pipeline[key].on) {\r\n          continue;\r\n        }\r\n\r\n        pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\r\n      }\r\n    };\r\n    /**\r\n     * Compare two arrays (even typed) for same-ness\r\n     */\r\n\r\n\r\n    var arrayEquals = function arrayEquals(a, b) {\r\n      var i;\r\n\r\n      if (a.length !== b.length) {\r\n        return false;\r\n      } // compare the value of each element in the array\r\n\r\n\r\n      for (i = 0; i < a.length; i++) {\r\n        if (a[i] !== b[i]) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    };\r\n\r\n    var generateSegmentTimingInfo = function generateSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\r\n      var ptsOffsetFromDts = startPts - startDts,\r\n          decodeDuration = endDts - startDts,\r\n          presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\r\n      // however, the player time values will reflect a start from the baseMediaDecodeTime.\r\n      // In order to provide relevant values for the player times, base timing info on the\r\n      // baseMediaDecodeTime and the DTS and PTS durations of the segment.\r\n\r\n      return {\r\n        start: {\r\n          dts: baseMediaDecodeTime,\r\n          pts: baseMediaDecodeTime + ptsOffsetFromDts\r\n        },\r\n        end: {\r\n          dts: baseMediaDecodeTime + decodeDuration,\r\n          pts: baseMediaDecodeTime + presentationDuration\r\n        },\r\n        prependedContentDuration: prependedContentDuration,\r\n        baseMediaDecodeTime: baseMediaDecodeTime\r\n      };\r\n    };\r\n    /**\r\n     * Constructs a single-track, ISO BMFF media segment from AAC data\r\n     * events. The output of this stream can be fed to a SourceBuffer\r\n     * configured with a suitable initialization segment.\r\n     * @param track {object} track metadata configuration\r\n     * @param options {object} transmuxer options object\r\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\r\n     *        in the source; false to adjust the first segment to start at 0.\r\n     */\r\n\r\n\r\n    _AudioSegmentStream = function AudioSegmentStream(track, options) {\r\n      var adtsFrames = [],\r\n          sequenceNumber,\r\n          earliestAllowedDts = 0,\r\n          audioAppendStartTs = 0,\r\n          videoBaseMediaDecodeTime = Infinity;\r\n      options = options || {};\r\n      sequenceNumber = options.firstSequenceNumber || 0;\r\n\r\n      _AudioSegmentStream.prototype.init.call(this);\r\n\r\n      this.push = function (data) {\r\n        trackDecodeInfo.collectDtsInfo(track, data);\r\n\r\n        if (track) {\r\n          audioProperties.forEach(function (prop) {\r\n            track[prop] = data[prop];\r\n          });\r\n        } // buffer audio data until end() is called\r\n\r\n\r\n        adtsFrames.push(data);\r\n      };\r\n\r\n      this.setEarliestDts = function (earliestDts) {\r\n        earliestAllowedDts = earliestDts;\r\n      };\r\n\r\n      this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\r\n        videoBaseMediaDecodeTime = baseMediaDecodeTime;\r\n      };\r\n\r\n      this.setAudioAppendStart = function (timestamp) {\r\n        audioAppendStartTs = timestamp;\r\n      };\r\n\r\n      this.flush = function () {\r\n        var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\r\n\r\n        if (adtsFrames.length === 0) {\r\n          this.trigger('done', 'AudioSegmentStream');\r\n          return;\r\n        }\r\n\r\n        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\r\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\r\n\r\n        videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\r\n        // samples (that is, adts frames) in the audio data\r\n\r\n        track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\r\n\r\n        mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\r\n        adtsFrames = [];\r\n        moof = mp4Generator.moof(sequenceNumber, [track]);\r\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\r\n\r\n        sequenceNumber++;\r\n        boxes.set(moof);\r\n        boxes.set(mdat, moof.byteLength);\r\n        trackDecodeInfo.clearDtsInfo(track);\r\n        frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\r\n        // tests) on adding the timingInfo event. However, it seems unlikely that there's a\r\n        // valid use-case where an init segment/data should be triggered without associated\r\n        // frames. Leaving for now, but should be looked into.\r\n\r\n        if (frames.length) {\r\n          segmentDuration = frames.length * frameDuration;\r\n          this.trigger('segmentTimingInfo', generateSegmentTimingInfo( // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\r\n          // frame info is in video clock cycles. Convert to match expectation of\r\n          // listeners (that all timestamps will be based on video clock cycles).\r\n          clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), // frame times are already in video clock, as is segment duration\r\n          frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\r\n          this.trigger('timingInfo', {\r\n            start: frames[0].pts,\r\n            end: frames[0].pts + segmentDuration\r\n          });\r\n        }\r\n\r\n        this.trigger('data', {\r\n          track: track,\r\n          boxes: boxes\r\n        });\r\n        this.trigger('done', 'AudioSegmentStream');\r\n      };\r\n\r\n      this.reset = function () {\r\n        trackDecodeInfo.clearDtsInfo(track);\r\n        adtsFrames = [];\r\n        this.trigger('reset');\r\n      };\r\n    };\r\n\r\n    _AudioSegmentStream.prototype = new stream();\r\n    /**\r\n     * Constructs a single-track, ISO BMFF media segment from H264 data\r\n     * events. The output of this stream can be fed to a SourceBuffer\r\n     * configured with a suitable initialization segment.\r\n     * @param track {object} track metadata configuration\r\n     * @param options {object} transmuxer options object\r\n     * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\r\n     *        gopsToAlignWith list when attempting to align gop pts\r\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\r\n     *        in the source; false to adjust the first segment to start at 0.\r\n     */\r\n\r\n    _VideoSegmentStream = function VideoSegmentStream(track, options) {\r\n      var sequenceNumber,\r\n          nalUnits = [],\r\n          gopsToAlignWith = [],\r\n          config,\r\n          pps;\r\n      options = options || {};\r\n      sequenceNumber = options.firstSequenceNumber || 0;\r\n\r\n      _VideoSegmentStream.prototype.init.call(this);\r\n\r\n      delete track.minPTS;\r\n      this.gopCache_ = [];\r\n      /**\r\n        * Constructs a ISO BMFF segment given H264 nalUnits\r\n        * @param {Object} nalUnit A data event representing a nalUnit\r\n        * @param {String} nalUnit.nalUnitType\r\n        * @param {Object} nalUnit.config Properties for a mp4 track\r\n        * @param {Uint8Array} nalUnit.data The nalUnit bytes\r\n        * @see lib/codecs/h264.js\r\n       **/\r\n\r\n      this.push = function (nalUnit) {\r\n        trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\r\n\r\n        if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\r\n          config = nalUnit.config;\r\n          track.sps = [nalUnit.data];\r\n          videoProperties.forEach(function (prop) {\r\n            track[prop] = config[prop];\r\n          }, this);\r\n        }\r\n\r\n        if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\r\n          pps = nalUnit.data;\r\n          track.pps = [nalUnit.data];\r\n        } // buffer video until flush() is called\r\n\r\n\r\n        nalUnits.push(nalUnit);\r\n      };\r\n      /**\r\n        * Pass constructed ISO BMFF track and boxes on to the\r\n        * next stream in the pipeline\r\n       **/\r\n\r\n\r\n      this.flush = function () {\r\n        var frames,\r\n            gopForFusion,\r\n            gops,\r\n            moof,\r\n            mdat,\r\n            boxes,\r\n            prependedContentDuration = 0,\r\n            firstGop,\r\n            lastGop; // Throw away nalUnits at the start of the byte stream until\r\n        // we find the first AUD\r\n\r\n        while (nalUnits.length) {\r\n          if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\r\n            break;\r\n          }\r\n\r\n          nalUnits.shift();\r\n        } // Return early if no video data has been observed\r\n\r\n\r\n        if (nalUnits.length === 0) {\r\n          this.resetStream_();\r\n          this.trigger('done', 'VideoSegmentStream');\r\n          return;\r\n        } // Organize the raw nal-units into arrays that represent\r\n        // higher-level constructs such as frames and gops\r\n        // (group-of-pictures)\r\n\r\n\r\n        frames = frameUtils.groupNalsIntoFrames(nalUnits);\r\n        gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\r\n        // a problem since MSE (on Chrome) requires a leading keyframe.\r\n        //\r\n        // We have two approaches to repairing this situation:\r\n        // 1) GOP-FUSION:\r\n        //    This is where we keep track of the GOPS (group-of-pictures)\r\n        //    from previous fragments and attempt to find one that we can\r\n        //    prepend to the current fragment in order to create a valid\r\n        //    fragment.\r\n        // 2) KEYFRAME-PULLING:\r\n        //    Here we search for the first keyframe in the fragment and\r\n        //    throw away all the frames between the start of the fragment\r\n        //    and that keyframe. We then extend the duration and pull the\r\n        //    PTS of the keyframe forward so that it covers the time range\r\n        //    of the frames that were disposed of.\r\n        //\r\n        // #1 is far prefereable over #2 which can cause \"stuttering\" but\r\n        // requires more things to be just right.\r\n\r\n        if (!gops[0][0].keyFrame) {\r\n          // Search for a gop for fusion from our gopCache\r\n          gopForFusion = this.getGopForFusion_(nalUnits[0], track);\r\n\r\n          if (gopForFusion) {\r\n            // in order to provide more accurate timing information about the segment, save\r\n            // the number of seconds prepended to the original segment due to GOP fusion\r\n            prependedContentDuration = gopForFusion.duration;\r\n            gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\r\n            // new gop at the beginning\r\n\r\n            gops.byteLength += gopForFusion.byteLength;\r\n            gops.nalCount += gopForFusion.nalCount;\r\n            gops.pts = gopForFusion.pts;\r\n            gops.dts = gopForFusion.dts;\r\n            gops.duration += gopForFusion.duration;\r\n          } else {\r\n            // If we didn't find a candidate gop fall back to keyframe-pulling\r\n            gops = frameUtils.extendFirstKeyFrame(gops);\r\n          }\r\n        } // Trim gops to align with gopsToAlignWith\r\n\r\n\r\n        if (gopsToAlignWith.length) {\r\n          var alignedGops;\r\n\r\n          if (options.alignGopsAtEnd) {\r\n            alignedGops = this.alignGopsAtEnd_(gops);\r\n          } else {\r\n            alignedGops = this.alignGopsAtStart_(gops);\r\n          }\r\n\r\n          if (!alignedGops) {\r\n            // save all the nals in the last GOP into the gop cache\r\n            this.gopCache_.unshift({\r\n              gop: gops.pop(),\r\n              pps: track.pps,\r\n              sps: track.sps\r\n            }); // Keep a maximum of 6 GOPs in the cache\r\n\r\n            this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\r\n\r\n            nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\r\n\r\n            this.resetStream_();\r\n            this.trigger('done', 'VideoSegmentStream');\r\n            return;\r\n          } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\r\n          // when recalculated before sending off to CoalesceStream\r\n\r\n\r\n          trackDecodeInfo.clearDtsInfo(track);\r\n          gops = alignedGops;\r\n        }\r\n\r\n        trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\r\n        // samples (that is, frames) in the video data\r\n\r\n        track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\r\n\r\n        mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops));\r\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\r\n        this.trigger('processedGopsInfo', gops.map(function (gop) {\r\n          return {\r\n            pts: gop.pts,\r\n            dts: gop.dts,\r\n            byteLength: gop.byteLength\r\n          };\r\n        }));\r\n        firstGop = gops[0];\r\n        lastGop = gops[gops.length - 1];\r\n        this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\r\n        this.trigger('timingInfo', {\r\n          start: gops[0].pts,\r\n          end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\r\n        }); // save all the nals in the last GOP into the gop cache\r\n\r\n        this.gopCache_.unshift({\r\n          gop: gops.pop(),\r\n          pps: track.pps,\r\n          sps: track.sps\r\n        }); // Keep a maximum of 6 GOPs in the cache\r\n\r\n        this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\r\n\r\n        nalUnits = [];\r\n        this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\r\n        this.trigger('timelineStartInfo', track.timelineStartInfo);\r\n        moof = mp4Generator.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\r\n        // throwing away hundreds of media segment fragments\r\n\r\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\r\n\r\n        sequenceNumber++;\r\n        boxes.set(moof);\r\n        boxes.set(mdat, moof.byteLength);\r\n        this.trigger('data', {\r\n          track: track,\r\n          boxes: boxes\r\n        });\r\n        this.resetStream_(); // Continue with the flush process now\r\n\r\n        this.trigger('done', 'VideoSegmentStream');\r\n      };\r\n\r\n      this.reset = function () {\r\n        this.resetStream_();\r\n        nalUnits = [];\r\n        this.gopCache_.length = 0;\r\n        gopsToAlignWith.length = 0;\r\n        this.trigger('reset');\r\n      };\r\n\r\n      this.resetStream_ = function () {\r\n        trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\r\n        // for instance, when we are rendition switching\r\n\r\n        config = undefined;\r\n        pps = undefined;\r\n      }; // Search for a candidate Gop for gop-fusion from the gop cache and\r\n      // return it or return null if no good candidate was found\r\n\r\n\r\n      this.getGopForFusion_ = function (nalUnit) {\r\n        var halfSecond = 45000,\r\n            // Half-a-second in a 90khz clock\r\n        allowableOverlap = 10000,\r\n            // About 3 frames @ 30fps\r\n        nearestDistance = Infinity,\r\n            dtsDistance,\r\n            nearestGopObj,\r\n            currentGop,\r\n            currentGopObj,\r\n            i; // Search for the GOP nearest to the beginning of this nal unit\r\n\r\n        for (i = 0; i < this.gopCache_.length; i++) {\r\n          currentGopObj = this.gopCache_[i];\r\n          currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\r\n\r\n          if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\r\n            continue;\r\n          } // Reject Gops that would require a negative baseMediaDecodeTime\r\n\r\n\r\n          if (currentGop.dts < track.timelineStartInfo.dts) {\r\n            continue;\r\n          } // The distance between the end of the gop and the start of the nalUnit\r\n\r\n\r\n          dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\r\n          // a half-second of the nal unit\r\n\r\n          if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\r\n            // Always use the closest GOP we found if there is more than\r\n            // one candidate\r\n            if (!nearestGopObj || nearestDistance > dtsDistance) {\r\n              nearestGopObj = currentGopObj;\r\n              nearestDistance = dtsDistance;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (nearestGopObj) {\r\n          return nearestGopObj.gop;\r\n        }\r\n\r\n        return null;\r\n      }; // trim gop list to the first gop found that has a matching pts with a gop in the list\r\n      // of gopsToAlignWith starting from the START of the list\r\n\r\n\r\n      this.alignGopsAtStart_ = function (gops) {\r\n        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\r\n        byteLength = gops.byteLength;\r\n        nalCount = gops.nalCount;\r\n        duration = gops.duration;\r\n        alignIndex = gopIndex = 0;\r\n\r\n        while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\r\n          align = gopsToAlignWith[alignIndex];\r\n          gop = gops[gopIndex];\r\n\r\n          if (align.pts === gop.pts) {\r\n            break;\r\n          }\r\n\r\n          if (gop.pts > align.pts) {\r\n            // this current gop starts after the current gop we want to align on, so increment\r\n            // align index\r\n            alignIndex++;\r\n            continue;\r\n          } // current gop starts before the current gop we want to align on. so increment gop\r\n          // index\r\n\r\n\r\n          gopIndex++;\r\n          byteLength -= gop.byteLength;\r\n          nalCount -= gop.nalCount;\r\n          duration -= gop.duration;\r\n        }\r\n\r\n        if (gopIndex === 0) {\r\n          // no gops to trim\r\n          return gops;\r\n        }\r\n\r\n        if (gopIndex === gops.length) {\r\n          // all gops trimmed, skip appending all gops\r\n          return null;\r\n        }\r\n\r\n        alignedGops = gops.slice(gopIndex);\r\n        alignedGops.byteLength = byteLength;\r\n        alignedGops.duration = duration;\r\n        alignedGops.nalCount = nalCount;\r\n        alignedGops.pts = alignedGops[0].pts;\r\n        alignedGops.dts = alignedGops[0].dts;\r\n        return alignedGops;\r\n      }; // trim gop list to the first gop found that has a matching pts with a gop in the list\r\n      // of gopsToAlignWith starting from the END of the list\r\n\r\n\r\n      this.alignGopsAtEnd_ = function (gops) {\r\n        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\r\n        alignIndex = gopsToAlignWith.length - 1;\r\n        gopIndex = gops.length - 1;\r\n        alignEndIndex = null;\r\n        matchFound = false;\r\n\r\n        while (alignIndex >= 0 && gopIndex >= 0) {\r\n          align = gopsToAlignWith[alignIndex];\r\n          gop = gops[gopIndex];\r\n\r\n          if (align.pts === gop.pts) {\r\n            matchFound = true;\r\n            break;\r\n          }\r\n\r\n          if (align.pts > gop.pts) {\r\n            alignIndex--;\r\n            continue;\r\n          }\r\n\r\n          if (alignIndex === gopsToAlignWith.length - 1) {\r\n            // gop.pts is greater than the last alignment candidate. If no match is found\r\n            // by the end of this loop, we still want to append gops that come after this\r\n            // point\r\n            alignEndIndex = gopIndex;\r\n          }\r\n\r\n          gopIndex--;\r\n        }\r\n\r\n        if (!matchFound && alignEndIndex === null) {\r\n          return null;\r\n        }\r\n\r\n        var trimIndex;\r\n\r\n        if (matchFound) {\r\n          trimIndex = gopIndex;\r\n        } else {\r\n          trimIndex = alignEndIndex;\r\n        }\r\n\r\n        if (trimIndex === 0) {\r\n          return gops;\r\n        }\r\n\r\n        var alignedGops = gops.slice(trimIndex);\r\n        var metadata = alignedGops.reduce(function (total, gop) {\r\n          total.byteLength += gop.byteLength;\r\n          total.duration += gop.duration;\r\n          total.nalCount += gop.nalCount;\r\n          return total;\r\n        }, {\r\n          byteLength: 0,\r\n          duration: 0,\r\n          nalCount: 0\r\n        });\r\n        alignedGops.byteLength = metadata.byteLength;\r\n        alignedGops.duration = metadata.duration;\r\n        alignedGops.nalCount = metadata.nalCount;\r\n        alignedGops.pts = alignedGops[0].pts;\r\n        alignedGops.dts = alignedGops[0].dts;\r\n        return alignedGops;\r\n      };\r\n\r\n      this.alignGopsWith = function (newGopsToAlignWith) {\r\n        gopsToAlignWith = newGopsToAlignWith;\r\n      };\r\n    };\r\n\r\n    _VideoSegmentStream.prototype = new stream();\r\n    /**\r\n     * A Stream that can combine multiple streams (ie. audio & video)\r\n     * into a single output segment for MSE. Also supports audio-only\r\n     * and video-only streams.\r\n     * @param options {object} transmuxer options object\r\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\r\n     *        in the source; false to adjust the first segment to start at media timeline start.\r\n     */\r\n\r\n    _CoalesceStream = function CoalesceStream(options, metadataStream) {\r\n      // Number of Tracks per output segment\r\n      // If greater than 1, we combine multiple\r\n      // tracks into a single segment\r\n      this.numberOfTracks = 0;\r\n      this.metadataStream = metadataStream;\r\n      options = options || {};\r\n\r\n      if (typeof options.remux !== 'undefined') {\r\n        this.remuxTracks = !!options.remux;\r\n      } else {\r\n        this.remuxTracks = true;\r\n      }\r\n\r\n      if (typeof options.keepOriginalTimestamps === 'boolean') {\r\n        this.keepOriginalTimestamps = options.keepOriginalTimestamps;\r\n      } else {\r\n        this.keepOriginalTimestamps = false;\r\n      }\r\n\r\n      this.pendingTracks = [];\r\n      this.videoTrack = null;\r\n      this.pendingBoxes = [];\r\n      this.pendingCaptions = [];\r\n      this.pendingMetadata = [];\r\n      this.pendingBytes = 0;\r\n      this.emittedTracks = 0;\r\n\r\n      _CoalesceStream.prototype.init.call(this); // Take output from multiple\r\n\r\n\r\n      this.push = function (output) {\r\n        // buffer incoming captions until the associated video segment\r\n        // finishes\r\n        if (output.text) {\r\n          return this.pendingCaptions.push(output);\r\n        } // buffer incoming id3 tags until the final flush\r\n\r\n\r\n        if (output.frames) {\r\n          return this.pendingMetadata.push(output);\r\n        } // Add this track to the list of pending tracks and store\r\n        // important information required for the construction of\r\n        // the final segment\r\n\r\n\r\n        this.pendingTracks.push(output.track);\r\n        this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\r\n        // We unshift audio and push video because\r\n        // as of Chrome 75 when switching from\r\n        // one init segment to another if the video\r\n        // mdat does not appear after the audio mdat\r\n        // only audio will play for the duration of our transmux.\r\n\r\n        if (output.track.type === 'video') {\r\n          this.videoTrack = output.track;\r\n          this.pendingBoxes.push(output.boxes);\r\n        }\r\n\r\n        if (output.track.type === 'audio') {\r\n          this.audioTrack = output.track;\r\n          this.pendingBoxes.unshift(output.boxes);\r\n        }\r\n      };\r\n    };\r\n\r\n    _CoalesceStream.prototype = new stream();\r\n\r\n    _CoalesceStream.prototype.flush = function (flushSource) {\r\n      var offset = 0,\r\n          event = {\r\n        captions: [],\r\n        captionStreams: {},\r\n        metadata: [],\r\n        info: {}\r\n      },\r\n          caption,\r\n          id3,\r\n          initSegment,\r\n          timelineStartPts = 0,\r\n          i;\r\n\r\n      if (this.pendingTracks.length < this.numberOfTracks) {\r\n        if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\r\n          // Return because we haven't received a flush from a data-generating\r\n          // portion of the segment (meaning that we have only recieved meta-data\r\n          // or captions.)\r\n          return;\r\n        } else if (this.remuxTracks) {\r\n          // Return until we have enough tracks from the pipeline to remux (if we\r\n          // are remuxing audio and video into a single MP4)\r\n          return;\r\n        } else if (this.pendingTracks.length === 0) {\r\n          // In the case where we receive a flush without any data having been\r\n          // received we consider it an emitted track for the purposes of coalescing\r\n          // `done` events.\r\n          // We do this for the case where there is an audio and video track in the\r\n          // segment but no audio data. (seen in several playlists with alternate\r\n          // audio tracks and no audio present in the main TS segments.)\r\n          this.emittedTracks++;\r\n\r\n          if (this.emittedTracks >= this.numberOfTracks) {\r\n            this.trigger('done');\r\n            this.emittedTracks = 0;\r\n          }\r\n\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (this.videoTrack) {\r\n        timelineStartPts = this.videoTrack.timelineStartInfo.pts;\r\n        videoProperties.forEach(function (prop) {\r\n          event.info[prop] = this.videoTrack[prop];\r\n        }, this);\r\n      } else if (this.audioTrack) {\r\n        timelineStartPts = this.audioTrack.timelineStartInfo.pts;\r\n        audioProperties.forEach(function (prop) {\r\n          event.info[prop] = this.audioTrack[prop];\r\n        }, this);\r\n      }\r\n\r\n      if (this.videoTrack || this.audioTrack) {\r\n        if (this.pendingTracks.length === 1) {\r\n          event.type = this.pendingTracks[0].type;\r\n        } else {\r\n          event.type = 'combined';\r\n        }\r\n\r\n        this.emittedTracks += this.pendingTracks.length;\r\n        initSegment = mp4Generator.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\r\n\r\n        event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\r\n        // and track definitions\r\n\r\n        event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\r\n\r\n        event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\r\n\r\n        for (i = 0; i < this.pendingBoxes.length; i++) {\r\n          event.data.set(this.pendingBoxes[i], offset);\r\n          offset += this.pendingBoxes[i].byteLength;\r\n        } // Translate caption PTS times into second offsets to match the\r\n        // video timeline for the segment, and add track info\r\n\r\n\r\n        for (i = 0; i < this.pendingCaptions.length; i++) {\r\n          caption = this.pendingCaptions[i];\r\n          caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\r\n          caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\r\n          event.captionStreams[caption.stream] = true;\r\n          event.captions.push(caption);\r\n        } // Translate ID3 frame PTS times into second offsets to match the\r\n        // video timeline for the segment\r\n\r\n\r\n        for (i = 0; i < this.pendingMetadata.length; i++) {\r\n          id3 = this.pendingMetadata[i];\r\n          id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\r\n          event.metadata.push(id3);\r\n        } // We add this to every single emitted segment even though we only need\r\n        // it for the first\r\n\r\n\r\n        event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\r\n\r\n        this.pendingTracks.length = 0;\r\n        this.videoTrack = null;\r\n        this.pendingBoxes.length = 0;\r\n        this.pendingCaptions.length = 0;\r\n        this.pendingBytes = 0;\r\n        this.pendingMetadata.length = 0; // Emit the built segment\r\n        // We include captions and ID3 tags for backwards compatibility,\r\n        // ideally we should send only video and audio in the data event\r\n\r\n        this.trigger('data', event); // Emit each caption to the outside world\r\n        // Ideally, this would happen immediately on parsing captions,\r\n        // but we need to ensure that video data is sent back first\r\n        // so that caption timing can be adjusted to match video timing\r\n\r\n        for (i = 0; i < event.captions.length; i++) {\r\n          caption = event.captions[i];\r\n          this.trigger('caption', caption);\r\n        } // Emit each id3 tag to the outside world\r\n        // Ideally, this would happen immediately on parsing the tag,\r\n        // but we need to ensure that video data is sent back first\r\n        // so that ID3 frame timing can be adjusted to match video timing\r\n\r\n\r\n        for (i = 0; i < event.metadata.length; i++) {\r\n          id3 = event.metadata[i];\r\n          this.trigger('id3Frame', id3);\r\n        }\r\n      } // Only emit `done` if all tracks have been flushed and emitted\r\n\r\n\r\n      if (this.emittedTracks >= this.numberOfTracks) {\r\n        this.trigger('done');\r\n        this.emittedTracks = 0;\r\n      }\r\n    };\r\n\r\n    _CoalesceStream.prototype.setRemux = function (val) {\r\n      this.remuxTracks = val;\r\n    };\r\n    /**\r\n     * A Stream that expects MP2T binary data as input and produces\r\n     * corresponding media segments, suitable for use with Media Source\r\n     * Extension (MSE) implementations that support the ISO BMFF byte\r\n     * stream format, like Chrome.\r\n     */\r\n\r\n\r\n    _Transmuxer = function Transmuxer(options) {\r\n      var self = this,\r\n          hasFlushed = true,\r\n          videoTrack,\r\n          audioTrack;\r\n\r\n      _Transmuxer.prototype.init.call(this);\r\n\r\n      options = options || {};\r\n      this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\r\n      this.transmuxPipeline_ = {};\r\n\r\n      this.setupAacPipeline = function () {\r\n        var pipeline = {};\r\n        this.transmuxPipeline_ = pipeline;\r\n        pipeline.type = 'aac';\r\n        pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\r\n\r\n        pipeline.aacStream = new aac();\r\n        pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\r\n        pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\r\n        pipeline.adtsStream = new adts();\r\n        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\r\n        pipeline.headOfPipeline = pipeline.aacStream;\r\n        pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\r\n        pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\r\n        pipeline.metadataStream.on('timestamp', function (frame) {\r\n          pipeline.aacStream.setTimestamp(frame.timeStamp);\r\n        });\r\n        pipeline.aacStream.on('data', function (data) {\r\n          if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\r\n            return;\r\n          }\r\n\r\n          audioTrack = audioTrack || {\r\n            timelineStartInfo: {\r\n              baseMediaDecodeTime: self.baseMediaDecodeTime\r\n            },\r\n            codec: 'adts',\r\n            type: 'audio'\r\n          }; // hook up the audio segment stream to the first track with aac data\r\n\r\n          pipeline.coalesceStream.numberOfTracks++;\r\n          pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\r\n          pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\r\n          pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\r\n\r\n          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\r\n\r\n          self.trigger('trackinfo', {\r\n            hasAudio: !!audioTrack,\r\n            hasVideo: !!videoTrack\r\n          });\r\n        }); // Re-emit any data coming from the coalesce stream to the outside world\r\n\r\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\r\n\r\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\r\n        addPipelineLogRetriggers(this, pipeline);\r\n      };\r\n\r\n      this.setupTsPipeline = function () {\r\n        var pipeline = {};\r\n        this.transmuxPipeline_ = pipeline;\r\n        pipeline.type = 'ts';\r\n        pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\r\n\r\n        pipeline.packetStream = new m2ts_1.TransportPacketStream();\r\n        pipeline.parseStream = new m2ts_1.TransportParseStream();\r\n        pipeline.elementaryStream = new m2ts_1.ElementaryStream();\r\n        pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();\r\n        pipeline.adtsStream = new adts();\r\n        pipeline.h264Stream = new H264Stream();\r\n        pipeline.captionStream = new m2ts_1.CaptionStream(options);\r\n        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\r\n        pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\r\n\r\n        pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\r\n        // demux the streams\r\n\r\n        pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\r\n        pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\r\n        pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\r\n\r\n        pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\r\n        pipeline.elementaryStream.on('data', function (data) {\r\n          var i;\r\n\r\n          if (data.type === 'metadata') {\r\n            i = data.tracks.length; // scan the tracks listed in the metadata\r\n\r\n            while (i--) {\r\n              if (!videoTrack && data.tracks[i].type === 'video') {\r\n                videoTrack = data.tracks[i];\r\n                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\r\n              } else if (!audioTrack && data.tracks[i].type === 'audio') {\r\n                audioTrack = data.tracks[i];\r\n                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\r\n              }\r\n            } // hook up the video segment stream to the first track with h264 data\r\n\r\n\r\n            if (videoTrack && !pipeline.videoSegmentStream) {\r\n              pipeline.coalesceStream.numberOfTracks++;\r\n              pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);\r\n              pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\r\n              pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\r\n                // When video emits timelineStartInfo data after a flush, we forward that\r\n                // info to the AudioSegmentStream, if it exists, because video timeline\r\n                // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\r\n                // because this is a particularly subtle form of timestamp alteration.\r\n                if (audioTrack && !options.keepOriginalTimestamps) {\r\n                  audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\r\n                  // very earliest DTS we have seen in video because Chrome will\r\n                  // interpret any video track with a baseMediaDecodeTime that is\r\n                  // non-zero as a gap.\r\n\r\n                  pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\r\n                }\r\n              });\r\n              pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\r\n              pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\r\n              pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\r\n                if (audioTrack) {\r\n                  pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\r\n                }\r\n              });\r\n              pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\r\n\r\n              pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\r\n            }\r\n\r\n            if (audioTrack && !pipeline.audioSegmentStream) {\r\n              // hook up the audio segment stream to the first track with aac data\r\n              pipeline.coalesceStream.numberOfTracks++;\r\n              pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\r\n              pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\r\n              pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\r\n              pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\r\n\r\n              pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\r\n            } // emit pmt info\r\n\r\n\r\n            self.trigger('trackinfo', {\r\n              hasAudio: !!audioTrack,\r\n              hasVideo: !!videoTrack\r\n            });\r\n          }\r\n        }); // Re-emit any data coming from the coalesce stream to the outside world\r\n\r\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\r\n        pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\r\n          id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\r\n          self.trigger('id3Frame', id3Frame);\r\n        });\r\n        pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\r\n\r\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\r\n        addPipelineLogRetriggers(this, pipeline);\r\n      }; // hook up the segment streams once track metadata is delivered\r\n\r\n\r\n      this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\r\n        var pipeline = this.transmuxPipeline_;\r\n\r\n        if (!options.keepOriginalTimestamps) {\r\n          this.baseMediaDecodeTime = baseMediaDecodeTime;\r\n        }\r\n\r\n        if (audioTrack) {\r\n          audioTrack.timelineStartInfo.dts = undefined;\r\n          audioTrack.timelineStartInfo.pts = undefined;\r\n          trackDecodeInfo.clearDtsInfo(audioTrack);\r\n\r\n          if (pipeline.audioTimestampRolloverStream) {\r\n            pipeline.audioTimestampRolloverStream.discontinuity();\r\n          }\r\n        }\r\n\r\n        if (videoTrack) {\r\n          if (pipeline.videoSegmentStream) {\r\n            pipeline.videoSegmentStream.gopCache_ = [];\r\n          }\r\n\r\n          videoTrack.timelineStartInfo.dts = undefined;\r\n          videoTrack.timelineStartInfo.pts = undefined;\r\n          trackDecodeInfo.clearDtsInfo(videoTrack);\r\n          pipeline.captionStream.reset();\r\n        }\r\n\r\n        if (pipeline.timestampRolloverStream) {\r\n          pipeline.timestampRolloverStream.discontinuity();\r\n        }\r\n      };\r\n\r\n      this.setAudioAppendStart = function (timestamp) {\r\n        if (audioTrack) {\r\n          this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\r\n        }\r\n      };\r\n\r\n      this.setRemux = function (val) {\r\n        var pipeline = this.transmuxPipeline_;\r\n        options.remux = val;\r\n\r\n        if (pipeline && pipeline.coalesceStream) {\r\n          pipeline.coalesceStream.setRemux(val);\r\n        }\r\n      };\r\n\r\n      this.alignGopsWith = function (gopsToAlignWith) {\r\n        if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\r\n          this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\r\n        }\r\n      };\r\n\r\n      this.getLogTrigger_ = function (key) {\r\n        var self = this;\r\n        return function (event) {\r\n          event.stream = key;\r\n          self.trigger('log', event);\r\n        };\r\n      }; // feed incoming data to the front of the parsing pipeline\r\n\r\n\r\n      this.push = function (data) {\r\n        if (hasFlushed) {\r\n          var isAac = isLikelyAacData(data);\r\n\r\n          if (isAac && this.transmuxPipeline_.type !== 'aac') {\r\n            this.setupAacPipeline();\r\n          } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\r\n            this.setupTsPipeline();\r\n          }\r\n\r\n          hasFlushed = false;\r\n        }\r\n\r\n        this.transmuxPipeline_.headOfPipeline.push(data);\r\n      }; // flush any buffered data\r\n\r\n\r\n      this.flush = function () {\r\n        hasFlushed = true; // Start at the top of the pipeline and flush all pending work\r\n\r\n        this.transmuxPipeline_.headOfPipeline.flush();\r\n      };\r\n\r\n      this.endTimeline = function () {\r\n        this.transmuxPipeline_.headOfPipeline.endTimeline();\r\n      };\r\n\r\n      this.reset = function () {\r\n        if (this.transmuxPipeline_.headOfPipeline) {\r\n          this.transmuxPipeline_.headOfPipeline.reset();\r\n        }\r\n      }; // Caption data has to be reset when seeking outside buffered range\r\n\r\n\r\n      this.resetCaptions = function () {\r\n        if (this.transmuxPipeline_.captionStream) {\r\n          this.transmuxPipeline_.captionStream.reset();\r\n        }\r\n      };\r\n    };\r\n\r\n    _Transmuxer.prototype = new stream();\r\n    var transmuxer = {\r\n      Transmuxer: _Transmuxer,\r\n      VideoSegmentStream: _VideoSegmentStream,\r\n      AudioSegmentStream: _AudioSegmentStream,\r\n      AUDIO_PROPERTIES: audioProperties,\r\n      VIDEO_PROPERTIES: videoProperties,\r\n      // exported for testing\r\n      generateSegmentTimingInfo: generateSegmentTimingInfo\r\n    };\r\n    /**\r\n     * mux.js\r\n     *\r\n     * Copyright (c) Brightcove\r\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n     */\r\n\r\n    var toUnsigned$3 = function toUnsigned(value) {\r\n      return value >>> 0;\r\n    };\r\n\r\n    var toHexString$1 = function toHexString(value) {\r\n      return ('00' + value.toString(16)).slice(-2);\r\n    };\r\n\r\n    var bin = {\r\n      toUnsigned: toUnsigned$3,\r\n      toHexString: toHexString$1\r\n    };\r\n\r\n    var parseType$1 = function parseType(buffer) {\r\n      var result = '';\r\n      result += String.fromCharCode(buffer[0]);\r\n      result += String.fromCharCode(buffer[1]);\r\n      result += String.fromCharCode(buffer[2]);\r\n      result += String.fromCharCode(buffer[3]);\r\n      return result;\r\n    };\r\n\r\n    var parseType_1 = parseType$1;\r\n    var toUnsigned$2 = bin.toUnsigned;\r\n\r\n    var findBox = function findBox(data, path) {\r\n      var results = [],\r\n          i,\r\n          size,\r\n          type,\r\n          end,\r\n          subresults;\r\n\r\n      if (!path.length) {\r\n        // short-circuit the search for empty paths\r\n        return null;\r\n      }\r\n\r\n      for (i = 0; i < data.byteLength;) {\r\n        size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\r\n        type = parseType_1(data.subarray(i + 4, i + 8));\r\n        end = size > 1 ? i + size : data.byteLength;\r\n\r\n        if (type === path[0]) {\r\n          if (path.length === 1) {\r\n            // this is the end of the path and we've found the box we were\r\n            // looking for\r\n            results.push(data.subarray(i + 8, end));\r\n          } else {\r\n            // recursively search for the next box along the path\r\n            subresults = findBox(data.subarray(i + 8, end), path.slice(1));\r\n\r\n            if (subresults.length) {\r\n              results = results.concat(subresults);\r\n            }\r\n          }\r\n        }\r\n\r\n        i = end;\r\n      } // we've finished searching all of data\r\n\r\n\r\n      return results;\r\n    };\r\n\r\n    var findBox_1 = findBox;\r\n    var toUnsigned$1 = bin.toUnsigned;\r\n    var getUint64$1 = numbers.getUint64;\r\n\r\n    var tfdt = function tfdt(data) {\r\n      var result = {\r\n        version: data[0],\r\n        flags: new Uint8Array(data.subarray(1, 4))\r\n      };\r\n\r\n      if (result.version === 1) {\r\n        result.baseMediaDecodeTime = getUint64$1(data.subarray(4));\r\n      } else {\r\n        result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    var parseTfdt = tfdt;\r\n\r\n    var parseSampleFlags = function parseSampleFlags(flags) {\r\n      return {\r\n        isLeading: (flags[0] & 0x0c) >>> 2,\r\n        dependsOn: flags[0] & 0x03,\r\n        isDependedOn: (flags[1] & 0xc0) >>> 6,\r\n        hasRedundancy: (flags[1] & 0x30) >>> 4,\r\n        paddingValue: (flags[1] & 0x0e) >>> 1,\r\n        isNonSyncSample: flags[1] & 0x01,\r\n        degradationPriority: flags[2] << 8 | flags[3]\r\n      };\r\n    };\r\n\r\n    var parseSampleFlags_1 = parseSampleFlags;\r\n\r\n    var trun = function trun(data) {\r\n      var result = {\r\n        version: data[0],\r\n        flags: new Uint8Array(data.subarray(1, 4)),\r\n        samples: []\r\n      },\r\n          view = new DataView(data.buffer, data.byteOffset, data.byteLength),\r\n          // Flag interpretation\r\n      dataOffsetPresent = result.flags[2] & 0x01,\r\n          // compare with 2nd byte of 0x1\r\n      firstSampleFlagsPresent = result.flags[2] & 0x04,\r\n          // compare with 2nd byte of 0x4\r\n      sampleDurationPresent = result.flags[1] & 0x01,\r\n          // compare with 2nd byte of 0x100\r\n      sampleSizePresent = result.flags[1] & 0x02,\r\n          // compare with 2nd byte of 0x200\r\n      sampleFlagsPresent = result.flags[1] & 0x04,\r\n          // compare with 2nd byte of 0x400\r\n      sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\r\n          // compare with 2nd byte of 0x800\r\n      sampleCount = view.getUint32(4),\r\n          offset = 8,\r\n          sample;\r\n\r\n      if (dataOffsetPresent) {\r\n        // 32 bit signed integer\r\n        result.dataOffset = view.getInt32(offset);\r\n        offset += 4;\r\n      } // Overrides the flags for the first sample only. The order of\r\n      // optional values will be: duration, size, compositionTimeOffset\r\n\r\n\r\n      if (firstSampleFlagsPresent && sampleCount) {\r\n        sample = {\r\n          flags: parseSampleFlags_1(data.subarray(offset, offset + 4))\r\n        };\r\n        offset += 4;\r\n\r\n        if (sampleDurationPresent) {\r\n          sample.duration = view.getUint32(offset);\r\n          offset += 4;\r\n        }\r\n\r\n        if (sampleSizePresent) {\r\n          sample.size = view.getUint32(offset);\r\n          offset += 4;\r\n        }\r\n\r\n        if (sampleCompositionTimeOffsetPresent) {\r\n          if (result.version === 1) {\r\n            sample.compositionTimeOffset = view.getInt32(offset);\r\n          } else {\r\n            sample.compositionTimeOffset = view.getUint32(offset);\r\n          }\r\n\r\n          offset += 4;\r\n        }\r\n\r\n        result.samples.push(sample);\r\n        sampleCount--;\r\n      }\r\n\r\n      while (sampleCount--) {\r\n        sample = {};\r\n\r\n        if (sampleDurationPresent) {\r\n          sample.duration = view.getUint32(offset);\r\n          offset += 4;\r\n        }\r\n\r\n        if (sampleSizePresent) {\r\n          sample.size = view.getUint32(offset);\r\n          offset += 4;\r\n        }\r\n\r\n        if (sampleFlagsPresent) {\r\n          sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));\r\n          offset += 4;\r\n        }\r\n\r\n        if (sampleCompositionTimeOffsetPresent) {\r\n          if (result.version === 1) {\r\n            sample.compositionTimeOffset = view.getInt32(offset);\r\n          } else {\r\n            sample.compositionTimeOffset = view.getUint32(offset);\r\n          }\r\n\r\n          offset += 4;\r\n        }\r\n\r\n        result.samples.push(sample);\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    var parseTrun = trun;\r\n\r\n    var tfhd = function tfhd(data) {\r\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\r\n          result = {\r\n        version: data[0],\r\n        flags: new Uint8Array(data.subarray(1, 4)),\r\n        trackId: view.getUint32(4)\r\n      },\r\n          baseDataOffsetPresent = result.flags[2] & 0x01,\r\n          sampleDescriptionIndexPresent = result.flags[2] & 0x02,\r\n          defaultSampleDurationPresent = result.flags[2] & 0x08,\r\n          defaultSampleSizePresent = result.flags[2] & 0x10,\r\n          defaultSampleFlagsPresent = result.flags[2] & 0x20,\r\n          durationIsEmpty = result.flags[0] & 0x010000,\r\n          defaultBaseIsMoof = result.flags[0] & 0x020000,\r\n          i;\r\n      i = 8;\r\n\r\n      if (baseDataOffsetPresent) {\r\n        i += 4; // truncate top 4 bytes\r\n        // FIXME: should we read the full 64 bits?\r\n\r\n        result.baseDataOffset = view.getUint32(12);\r\n        i += 4;\r\n      }\r\n\r\n      if (sampleDescriptionIndexPresent) {\r\n        result.sampleDescriptionIndex = view.getUint32(i);\r\n        i += 4;\r\n      }\r\n\r\n      if (defaultSampleDurationPresent) {\r\n        result.defaultSampleDuration = view.getUint32(i);\r\n        i += 4;\r\n      }\r\n\r\n      if (defaultSampleSizePresent) {\r\n        result.defaultSampleSize = view.getUint32(i);\r\n        i += 4;\r\n      }\r\n\r\n      if (defaultSampleFlagsPresent) {\r\n        result.defaultSampleFlags = view.getUint32(i);\r\n      }\r\n\r\n      if (durationIsEmpty) {\r\n        result.durationIsEmpty = true;\r\n      }\r\n\r\n      if (!baseDataOffsetPresent && defaultBaseIsMoof) {\r\n        result.baseDataOffsetIsMoof = true;\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    var parseTfhd = tfhd;\r\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\r\n    var win;\r\n\r\n    if (typeof window !== \"undefined\") {\r\n      win = window;\r\n    } else if (typeof commonjsGlobal !== \"undefined\") {\r\n      win = commonjsGlobal;\r\n    } else if (typeof self !== \"undefined\") {\r\n      win = self;\r\n    } else {\r\n      win = {};\r\n    }\r\n\r\n    var window_1 = win;\r\n    var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\r\n    var CaptionStream = captionStream.CaptionStream;\r\n    /**\r\n      * Maps an offset in the mdat to a sample based on the the size of the samples.\r\n      * Assumes that `parseSamples` has been called first.\r\n      *\r\n      * @param {Number} offset - The offset into the mdat\r\n      * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\r\n      * @return {?Object} The matching sample, or null if no match was found.\r\n      *\r\n      * @see ISO-BMFF-12/2015, Section 8.8.8\r\n     **/\r\n\r\n    var mapToSample = function mapToSample(offset, samples) {\r\n      var approximateOffset = offset;\r\n\r\n      for (var i = 0; i < samples.length; i++) {\r\n        var sample = samples[i];\r\n\r\n        if (approximateOffset < sample.size) {\r\n          return sample;\r\n        }\r\n\r\n        approximateOffset -= sample.size;\r\n      }\r\n\r\n      return null;\r\n    };\r\n    /**\r\n      * Finds SEI nal units contained in a Media Data Box.\r\n      * Assumes that `parseSamples` has been called first.\r\n      *\r\n      * @param {Uint8Array} avcStream - The bytes of the mdat\r\n      * @param {Object[]} samples - The samples parsed out by `parseSamples`\r\n      * @param {Number} trackId - The trackId of this video track\r\n      * @return {Object[]} seiNals - the parsed SEI NALUs found.\r\n      *   The contents of the seiNal should match what is expected by\r\n      *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\r\n      *\r\n      * @see ISO-BMFF-12/2015, Section 8.1.1\r\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\r\n     **/\r\n\r\n\r\n    var findSeiNals = function findSeiNals(avcStream, samples, trackId) {\r\n      var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\r\n          result = {\r\n        logs: [],\r\n        seiNals: []\r\n      },\r\n          seiNal,\r\n          i,\r\n          length,\r\n          lastMatchedSample;\r\n\r\n      for (i = 0; i + 4 < avcStream.length; i += length) {\r\n        length = avcView.getUint32(i);\r\n        i += 4; // Bail if this doesn't appear to be an H264 stream\r\n\r\n        if (length <= 0) {\r\n          continue;\r\n        }\r\n\r\n        switch (avcStream[i] & 0x1F) {\r\n          case 0x06:\r\n            var data = avcStream.subarray(i + 1, i + 1 + length);\r\n            var matchingSample = mapToSample(i, samples);\r\n            seiNal = {\r\n              nalUnitType: 'sei_rbsp',\r\n              size: length,\r\n              data: data,\r\n              escapedRBSP: discardEmulationPreventionBytes(data),\r\n              trackId: trackId\r\n            };\r\n\r\n            if (matchingSample) {\r\n              seiNal.pts = matchingSample.pts;\r\n              seiNal.dts = matchingSample.dts;\r\n              lastMatchedSample = matchingSample;\r\n            } else if (lastMatchedSample) {\r\n              // If a matching sample cannot be found, use the last\r\n              // sample's values as they should be as close as possible\r\n              seiNal.pts = lastMatchedSample.pts;\r\n              seiNal.dts = lastMatchedSample.dts;\r\n            } else {\r\n              result.logs.push({\r\n                level: 'warn',\r\n                message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\r\n              });\r\n              break;\r\n            }\r\n\r\n            result.seiNals.push(seiNal);\r\n            break;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n    /**\r\n      * Parses sample information out of Track Run Boxes and calculates\r\n      * the absolute presentation and decode timestamps of each sample.\r\n      *\r\n      * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\r\n      * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\r\n          @see ISO-BMFF-12/2015, Section 8.8.12\r\n      * @param {Object} tfhd - The parsed Track Fragment Header\r\n      *   @see inspect.parseTfhd\r\n      * @return {Object[]} the parsed samples\r\n      *\r\n      * @see ISO-BMFF-12/2015, Section 8.8.8\r\n     **/\r\n\r\n\r\n    var parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\r\n      var currentDts = baseMediaDecodeTime;\r\n      var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\r\n      var defaultSampleSize = tfhd.defaultSampleSize || 0;\r\n      var trackId = tfhd.trackId;\r\n      var allSamples = [];\r\n      truns.forEach(function (trun) {\r\n        // Note: We currently do not parse the sample table as well\r\n        // as the trun. It's possible some sources will require this.\r\n        // moov > trak > mdia > minf > stbl\r\n        var trackRun = parseTrun(trun);\r\n        var samples = trackRun.samples;\r\n        samples.forEach(function (sample) {\r\n          if (sample.duration === undefined) {\r\n            sample.duration = defaultSampleDuration;\r\n          }\r\n\r\n          if (sample.size === undefined) {\r\n            sample.size = defaultSampleSize;\r\n          }\r\n\r\n          sample.trackId = trackId;\r\n          sample.dts = currentDts;\r\n\r\n          if (sample.compositionTimeOffset === undefined) {\r\n            sample.compositionTimeOffset = 0;\r\n          }\r\n\r\n          if (typeof currentDts === 'bigint') {\r\n            sample.pts = currentDts + window_1.BigInt(sample.compositionTimeOffset);\r\n            currentDts += window_1.BigInt(sample.duration);\r\n          } else {\r\n            sample.pts = currentDts + sample.compositionTimeOffset;\r\n            currentDts += sample.duration;\r\n          }\r\n        });\r\n        allSamples = allSamples.concat(samples);\r\n      });\r\n      return allSamples;\r\n    };\r\n    /**\r\n      * Parses out caption nals from an FMP4 segment's video tracks.\r\n      *\r\n      * @param {Uint8Array} segment - The bytes of a single segment\r\n      * @param {Number} videoTrackId - The trackId of a video track in the segment\r\n      * @return {Object.<Number, Object[]>} A mapping of video trackId to\r\n      *   a list of seiNals found in that track\r\n     **/\r\n\r\n\r\n    var parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\r\n      // To get the samples\r\n      var trafs = findBox_1(segment, ['moof', 'traf']); // To get SEI NAL units\r\n\r\n      var mdats = findBox_1(segment, ['mdat']);\r\n      var captionNals = {};\r\n      var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\r\n\r\n      mdats.forEach(function (mdat, index) {\r\n        var matchingTraf = trafs[index];\r\n        mdatTrafPairs.push({\r\n          mdat: mdat,\r\n          traf: matchingTraf\r\n        });\r\n      });\r\n      mdatTrafPairs.forEach(function (pair) {\r\n        var mdat = pair.mdat;\r\n        var traf = pair.traf;\r\n        var tfhd = findBox_1(traf, ['tfhd']); // Exactly 1 tfhd per traf\r\n\r\n        var headerInfo = parseTfhd(tfhd[0]);\r\n        var trackId = headerInfo.trackId;\r\n        var tfdt = findBox_1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\r\n\r\n        var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\r\n        var truns = findBox_1(traf, ['trun']);\r\n        var samples;\r\n        var result; // Only parse video data for the chosen video track\r\n\r\n        if (videoTrackId === trackId && truns.length > 0) {\r\n          samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\r\n          result = findSeiNals(mdat, samples, trackId);\r\n\r\n          if (!captionNals[trackId]) {\r\n            captionNals[trackId] = {\r\n              seiNals: [],\r\n              logs: []\r\n            };\r\n          }\r\n\r\n          captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\r\n          captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\r\n        }\r\n      });\r\n      return captionNals;\r\n    };\r\n    /**\r\n      * Parses out inband captions from an MP4 container and returns\r\n      * caption objects that can be used by WebVTT and the TextTrack API.\r\n      * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\r\n      * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\r\n      * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\r\n      *\r\n      * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\r\n      * @param {Number} trackId - The id of the video track to parse\r\n      * @param {Number} timescale - The timescale for the video track from the init segment\r\n      *\r\n      * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\r\n      * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\r\n      * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\r\n      * @return {String} parsedCaptions[].text - The visible content of the caption\r\n     **/\r\n\r\n\r\n    var parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\r\n      var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\r\n\r\n      if (trackId === null) {\r\n        return null;\r\n      }\r\n\r\n      captionNals = parseCaptionNals(segment, trackId);\r\n      var trackNals = captionNals[trackId] || {};\r\n      return {\r\n        seiNals: trackNals.seiNals,\r\n        logs: trackNals.logs,\r\n        timescale: timescale\r\n      };\r\n    };\r\n    /**\r\n      * Converts SEI NALUs into captions that can be used by video.js\r\n     **/\r\n\r\n\r\n    var CaptionParser = function CaptionParser() {\r\n      var isInitialized = false;\r\n      var captionStream; // Stores segments seen before trackId and timescale are set\r\n\r\n      var segmentCache; // Stores video track ID of the track being parsed\r\n\r\n      var trackId; // Stores the timescale of the track being parsed\r\n\r\n      var timescale; // Stores captions parsed so far\r\n\r\n      var parsedCaptions; // Stores whether we are receiving partial data or not\r\n\r\n      var parsingPartial;\r\n      /**\r\n        * A method to indicate whether a CaptionParser has been initalized\r\n        * @returns {Boolean}\r\n       **/\r\n\r\n      this.isInitialized = function () {\r\n        return isInitialized;\r\n      };\r\n      /**\r\n        * Initializes the underlying CaptionStream, SEI NAL parsing\r\n        * and management, and caption collection\r\n       **/\r\n\r\n\r\n      this.init = function (options) {\r\n        captionStream = new CaptionStream();\r\n        isInitialized = true;\r\n        parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\r\n\r\n        captionStream.on('data', function (event) {\r\n          // Convert to seconds in the source's timescale\r\n          event.startTime = event.startPts / timescale;\r\n          event.endTime = event.endPts / timescale;\r\n          parsedCaptions.captions.push(event);\r\n          parsedCaptions.captionStreams[event.stream] = true;\r\n        });\r\n        captionStream.on('log', function (log) {\r\n          parsedCaptions.logs.push(log);\r\n        });\r\n      };\r\n      /**\r\n        * Determines if a new video track will be selected\r\n        * or if the timescale changed\r\n        * @return {Boolean}\r\n       **/\r\n\r\n\r\n      this.isNewInit = function (videoTrackIds, timescales) {\r\n        if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\r\n          return false;\r\n        }\r\n\r\n        return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\r\n      };\r\n      /**\r\n        * Parses out SEI captions and interacts with underlying\r\n        * CaptionStream to return dispatched captions\r\n        *\r\n        * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\r\n        * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\r\n        * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\r\n        * @see parseEmbeddedCaptions\r\n        * @see m2ts/caption-stream.js\r\n       **/\r\n\r\n\r\n      this.parse = function (segment, videoTrackIds, timescales) {\r\n        var parsedData;\r\n\r\n        if (!this.isInitialized()) {\r\n          return null; // This is not likely to be a video segment\r\n        } else if (!videoTrackIds || !timescales) {\r\n          return null;\r\n        } else if (this.isNewInit(videoTrackIds, timescales)) {\r\n          // Use the first video track only as there is no\r\n          // mechanism to switch to other video tracks\r\n          trackId = videoTrackIds[0];\r\n          timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\r\n          // data until we have one.\r\n          // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\r\n        } else if (trackId === null || !timescale) {\r\n          segmentCache.push(segment);\r\n          return null;\r\n        } // Now that a timescale and trackId is set, parse cached segments\r\n\r\n\r\n        while (segmentCache.length > 0) {\r\n          var cachedSegment = segmentCache.shift();\r\n          this.parse(cachedSegment, videoTrackIds, timescales);\r\n        }\r\n\r\n        parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\r\n\r\n        if (parsedData && parsedData.logs) {\r\n          parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\r\n        }\r\n\r\n        if (parsedData === null || !parsedData.seiNals) {\r\n          if (parsedCaptions.logs.length) {\r\n            return {\r\n              logs: parsedCaptions.logs,\r\n              captions: [],\r\n              captionStreams: []\r\n            };\r\n          }\r\n\r\n          return null;\r\n        }\r\n\r\n        this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\r\n\r\n        this.flushStream();\r\n        return parsedCaptions;\r\n      };\r\n      /**\r\n        * Pushes SEI NALUs onto CaptionStream\r\n        * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\r\n        * Assumes that `parseCaptionNals` has been called first\r\n        * @see m2ts/caption-stream.js\r\n        **/\r\n\r\n\r\n      this.pushNals = function (nals) {\r\n        if (!this.isInitialized() || !nals || nals.length === 0) {\r\n          return null;\r\n        }\r\n\r\n        nals.forEach(function (nal) {\r\n          captionStream.push(nal);\r\n        });\r\n      };\r\n      /**\r\n        * Flushes underlying CaptionStream to dispatch processed, displayable captions\r\n        * @see m2ts/caption-stream.js\r\n       **/\r\n\r\n\r\n      this.flushStream = function () {\r\n        if (!this.isInitialized()) {\r\n          return null;\r\n        }\r\n\r\n        if (!parsingPartial) {\r\n          captionStream.flush();\r\n        } else {\r\n          captionStream.partialFlush();\r\n        }\r\n      };\r\n      /**\r\n        * Reset caption buckets for new data\r\n       **/\r\n\r\n\r\n      this.clearParsedCaptions = function () {\r\n        parsedCaptions.captions = [];\r\n        parsedCaptions.captionStreams = {};\r\n        parsedCaptions.logs = [];\r\n      };\r\n      /**\r\n        * Resets underlying CaptionStream\r\n        * @see m2ts/caption-stream.js\r\n       **/\r\n\r\n\r\n      this.resetCaptionStream = function () {\r\n        if (!this.isInitialized()) {\r\n          return null;\r\n        }\r\n\r\n        captionStream.reset();\r\n      };\r\n      /**\r\n        * Convenience method to clear all captions flushed from the\r\n        * CaptionStream and still being parsed\r\n        * @see m2ts/caption-stream.js\r\n       **/\r\n\r\n\r\n      this.clearAllCaptions = function () {\r\n        this.clearParsedCaptions();\r\n        this.resetCaptionStream();\r\n      };\r\n      /**\r\n        * Reset caption parser\r\n       **/\r\n\r\n\r\n      this.reset = function () {\r\n        segmentCache = [];\r\n        trackId = null;\r\n        timescale = null;\r\n\r\n        if (!parsedCaptions) {\r\n          parsedCaptions = {\r\n            captions: [],\r\n            // CC1, CC2, CC3, CC4\r\n            captionStreams: {},\r\n            logs: []\r\n          };\r\n        } else {\r\n          this.clearParsedCaptions();\r\n        }\r\n\r\n        this.resetCaptionStream();\r\n      };\r\n\r\n      this.reset();\r\n    };\r\n\r\n    var captionParser = CaptionParser;\r\n    var toUnsigned = bin.toUnsigned;\r\n    var toHexString = bin.toHexString;\r\n    var getUint64 = numbers.getUint64;\r\n    var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;\r\n    /**\r\n     * Parses an MP4 initialization segment and extracts the timescale\r\n     * values for any declared tracks. Timescale values indicate the\r\n     * number of clock ticks per second to assume for time-based values\r\n     * elsewhere in the MP4.\r\n     *\r\n     * To determine the start time of an MP4, you need two pieces of\r\n     * information: the timescale unit and the earliest base media decode\r\n     * time. Multiple timescales can be specified within an MP4 but the\r\n     * base media decode time is always expressed in the timescale from\r\n     * the media header box for the track:\r\n     * ```\r\n     * moov > trak > mdia > mdhd.timescale\r\n     * ```\r\n     * @param init {Uint8Array} the bytes of the init segment\r\n     * @return {object} a hash of track ids to timescale values or null if\r\n     * the init segment is malformed.\r\n     */\r\n\r\n    timescale = function timescale(init) {\r\n      var result = {},\r\n          traks = findBox_1(init, ['moov', 'trak']); // mdhd timescale\r\n\r\n      return traks.reduce(function (result, trak) {\r\n        var tkhd, version, index, id, mdhd;\r\n        tkhd = findBox_1(trak, ['tkhd'])[0];\r\n\r\n        if (!tkhd) {\r\n          return null;\r\n        }\r\n\r\n        version = tkhd[0];\r\n        index = version === 0 ? 12 : 20;\r\n        id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\r\n        mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\r\n\r\n        if (!mdhd) {\r\n          return null;\r\n        }\r\n\r\n        version = mdhd[0];\r\n        index = version === 0 ? 12 : 20;\r\n        result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\r\n        return result;\r\n      }, result);\r\n    };\r\n    /**\r\n     * Determine the base media decode start time, in seconds, for an MP4\r\n     * fragment. If multiple fragments are specified, the earliest time is\r\n     * returned.\r\n     *\r\n     * The base media decode time can be parsed from track fragment\r\n     * metadata:\r\n     * ```\r\n     * moof > traf > tfdt.baseMediaDecodeTime\r\n     * ```\r\n     * It requires the timescale value from the mdhd to interpret.\r\n     *\r\n     * @param timescale {object} a hash of track ids to timescale values.\r\n     * @return {number} the earliest base media decode start time for the\r\n     * fragment, in seconds\r\n     */\r\n\r\n\r\n    startTime = function startTime(timescale, fragment) {\r\n      var trafs; // we need info from two childrend of each track fragment box\r\n\r\n      trafs = findBox_1(fragment, ['moof', 'traf']); // determine the start times for each track\r\n\r\n      var lowestTime = trafs.reduce(function (acc, traf) {\r\n        var tfhd = findBox_1(traf, ['tfhd'])[0]; // get the track id from the tfhd\r\n\r\n        var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\r\n\r\n        var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\r\n\r\n        var tfdt = findBox_1(traf, ['tfdt'])[0];\r\n        var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\r\n        var baseTime; // version 1 is 64 bit\r\n\r\n        if (tfdt[0] === 1) {\r\n          baseTime = getUint64(tfdt.subarray(4, 12));\r\n        } else {\r\n          baseTime = dv.getUint32(4);\r\n        } // convert base time to seconds if it is a valid number.\r\n\r\n\r\n        var seconds;\r\n\r\n        if (typeof baseTime === 'bigint') {\r\n          seconds = baseTime / window_1.BigInt(scale);\r\n        } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\r\n          seconds = baseTime / scale;\r\n        }\r\n\r\n        if (seconds < Number.MAX_SAFE_INTEGER) {\r\n          seconds = Number(seconds);\r\n        }\r\n\r\n        if (seconds < acc) {\r\n          acc = seconds;\r\n        }\r\n\r\n        return acc;\r\n      }, Infinity);\r\n      return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\r\n    };\r\n    /**\r\n     * Determine the composition start, in seconds, for an MP4\r\n     * fragment.\r\n     *\r\n     * The composition start time of a fragment can be calculated using the base\r\n     * media decode time, composition time offset, and timescale, as follows:\r\n     *\r\n     * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\r\n     *\r\n     * All of the aforementioned information is contained within a media fragment's\r\n     * `traf` box, except for timescale info, which comes from the initialization\r\n     * segment, so a track id (also contained within a `traf`) is also necessary to\r\n     * associate it with a timescale\r\n     *\r\n     *\r\n     * @param timescales {object} - a hash of track ids to timescale values.\r\n     * @param fragment {Unit8Array} - the bytes of a media segment\r\n     * @return {number} the composition start time for the fragment, in seconds\r\n     **/\r\n\r\n\r\n    compositionStartTime = function compositionStartTime(timescales, fragment) {\r\n      var trafBoxes = findBox_1(fragment, ['moof', 'traf']);\r\n      var baseMediaDecodeTime = 0;\r\n      var compositionTimeOffset = 0;\r\n      var trackId;\r\n\r\n      if (trafBoxes && trafBoxes.length) {\r\n        // The spec states that track run samples contained within a `traf` box are contiguous, but\r\n        // it does not explicitly state whether the `traf` boxes themselves are contiguous.\r\n        // We will assume that they are, so we only need the first to calculate start time.\r\n        var tfhd = findBox_1(trafBoxes[0], ['tfhd'])[0];\r\n        var trun = findBox_1(trafBoxes[0], ['trun'])[0];\r\n        var tfdt = findBox_1(trafBoxes[0], ['tfdt'])[0];\r\n\r\n        if (tfhd) {\r\n          var parsedTfhd = parseTfhd(tfhd);\r\n          trackId = parsedTfhd.trackId;\r\n        }\r\n\r\n        if (tfdt) {\r\n          var parsedTfdt = parseTfdt(tfdt);\r\n          baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\r\n        }\r\n\r\n        if (trun) {\r\n          var parsedTrun = parseTrun(trun);\r\n\r\n          if (parsedTrun.samples && parsedTrun.samples.length) {\r\n            compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\r\n          }\r\n        }\r\n      } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\r\n      // specified.\r\n\r\n\r\n      var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\r\n\r\n      if (typeof baseMediaDecodeTime === 'bigint') {\r\n        compositionTimeOffset = window_1.BigInt(compositionTimeOffset);\r\n        timescale = window_1.BigInt(timescale);\r\n      }\r\n\r\n      var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\r\n\r\n      if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\r\n        result = Number(result);\r\n      }\r\n\r\n      return result;\r\n    };\r\n    /**\r\n      * Find the trackIds of the video tracks in this source.\r\n      * Found by parsing the Handler Reference and Track Header Boxes:\r\n      *   moov > trak > mdia > hdlr\r\n      *   moov > trak > tkhd\r\n      *\r\n      * @param {Uint8Array} init - The bytes of the init segment for this source\r\n      * @return {Number[]} A list of trackIds\r\n      *\r\n      * @see ISO-BMFF-12/2015, Section 8.4.3\r\n     **/\r\n\r\n\r\n    getVideoTrackIds = function getVideoTrackIds(init) {\r\n      var traks = findBox_1(init, ['moov', 'trak']);\r\n      var videoTrackIds = [];\r\n      traks.forEach(function (trak) {\r\n        var hdlrs = findBox_1(trak, ['mdia', 'hdlr']);\r\n        var tkhds = findBox_1(trak, ['tkhd']);\r\n        hdlrs.forEach(function (hdlr, index) {\r\n          var handlerType = parseType_1(hdlr.subarray(8, 12));\r\n          var tkhd = tkhds[index];\r\n          var view;\r\n          var version;\r\n          var trackId;\r\n\r\n          if (handlerType === 'vide') {\r\n            view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\r\n            version = view.getUint8(0);\r\n            trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\r\n            videoTrackIds.push(trackId);\r\n          }\r\n        });\r\n      });\r\n      return videoTrackIds;\r\n    };\r\n\r\n    getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader(mdhd) {\r\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\r\n      var version = mdhd[0];\r\n      var index = version === 0 ? 12 : 20;\r\n      return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\r\n    };\r\n    /**\r\n     * Get all the video, audio, and hint tracks from a non fragmented\r\n     * mp4 segment\r\n     */\r\n\r\n\r\n    getTracks = function getTracks(init) {\r\n      var traks = findBox_1(init, ['moov', 'trak']);\r\n      var tracks = [];\r\n      traks.forEach(function (trak) {\r\n        var track = {};\r\n        var tkhd = findBox_1(trak, ['tkhd'])[0];\r\n        var view, tkhdVersion; // id\r\n\r\n        if (tkhd) {\r\n          view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\r\n          tkhdVersion = view.getUint8(0);\r\n          track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\r\n        }\r\n\r\n        var hdlr = findBox_1(trak, ['mdia', 'hdlr'])[0]; // type\r\n\r\n        if (hdlr) {\r\n          var type = parseType_1(hdlr.subarray(8, 12));\r\n\r\n          if (type === 'vide') {\r\n            track.type = 'video';\r\n          } else if (type === 'soun') {\r\n            track.type = 'audio';\r\n          } else {\r\n            track.type = type;\r\n          }\r\n        } // codec\r\n\r\n\r\n        var stsd = findBox_1(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\r\n\r\n        if (stsd) {\r\n          var sampleDescriptions = stsd.subarray(8); // gives the codec type string\r\n\r\n          track.codec = parseType_1(sampleDescriptions.subarray(4, 8));\r\n          var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];\r\n          var codecConfig, codecConfigType;\r\n\r\n          if (codecBox) {\r\n            // https://tools.ietf.org/html/rfc6381#section-3.3\r\n            if (/^[asm]vc[1-9]$/i.test(track.codec)) {\r\n              // we don't need anything but the \"config\" parameter of the\r\n              // avc1 codecBox\r\n              codecConfig = codecBox.subarray(78);\r\n              codecConfigType = parseType_1(codecConfig.subarray(4, 8));\r\n\r\n              if (codecConfigType === 'avcC' && codecConfig.length > 11) {\r\n                track.codec += '.'; // left padded with zeroes for single digit hex\r\n                // profile idc\r\n\r\n                track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\r\n\r\n                track.codec += toHexString(codecConfig[10]); // level idc\r\n\r\n                track.codec += toHexString(codecConfig[11]);\r\n              } else {\r\n                // TODO: show a warning that we couldn't parse the codec\r\n                // and are using the default\r\n                track.codec = 'avc1.4d400d';\r\n              }\r\n            } else if (/^mp4[a,v]$/i.test(track.codec)) {\r\n              // we do not need anything but the streamDescriptor of the mp4a codecBox\r\n              codecConfig = codecBox.subarray(28);\r\n              codecConfigType = parseType_1(codecConfig.subarray(4, 8));\r\n\r\n              if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\r\n                track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\r\n\r\n                track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\r\n              } else {\r\n                // TODO: show a warning that we couldn't parse the codec\r\n                // and are using the default\r\n                track.codec = 'mp4a.40.2';\r\n              }\r\n            } else {\r\n              // flac, opus, etc\r\n              track.codec = track.codec.toLowerCase();\r\n            }\r\n          }\r\n        }\r\n\r\n        var mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\r\n\r\n        if (mdhd) {\r\n          track.timescale = getTimescaleFromMediaHeader(mdhd);\r\n        }\r\n\r\n        tracks.push(track);\r\n      });\r\n      return tracks;\r\n    };\r\n\r\n    var probe$2 = {\r\n      // export mp4 inspector's findBox and parseType for backwards compatibility\r\n      findBox: findBox_1,\r\n      parseType: parseType_1,\r\n      timescale: timescale,\r\n      startTime: startTime,\r\n      compositionStartTime: compositionStartTime,\r\n      videoTrackIds: getVideoTrackIds,\r\n      tracks: getTracks,\r\n      getTimescaleFromMediaHeader: getTimescaleFromMediaHeader\r\n    };\r\n\r\n    var parsePid = function parsePid(packet) {\r\n      var pid = packet[1] & 0x1f;\r\n      pid <<= 8;\r\n      pid |= packet[2];\r\n      return pid;\r\n    };\r\n\r\n    var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator(packet) {\r\n      return !!(packet[1] & 0x40);\r\n    };\r\n\r\n    var parseAdaptionField = function parseAdaptionField(packet) {\r\n      var offset = 0; // if an adaption field is present, its length is specified by the\r\n      // fifth byte of the TS packet header. The adaptation field is\r\n      // used to add stuffing to PES packets that don't fill a complete\r\n      // TS packet, and to specify some forms of timing and control data\r\n      // that we do not currently use.\r\n\r\n      if ((packet[3] & 0x30) >>> 4 > 0x01) {\r\n        offset += packet[4] + 1;\r\n      }\r\n\r\n      return offset;\r\n    };\r\n\r\n    var parseType = function parseType(packet, pmtPid) {\r\n      var pid = parsePid(packet);\r\n\r\n      if (pid === 0) {\r\n        return 'pat';\r\n      } else if (pid === pmtPid) {\r\n        return 'pmt';\r\n      } else if (pmtPid) {\r\n        return 'pes';\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    var parsePat = function parsePat(packet) {\r\n      var pusi = parsePayloadUnitStartIndicator(packet);\r\n      var offset = 4 + parseAdaptionField(packet);\r\n\r\n      if (pusi) {\r\n        offset += packet[offset] + 1;\r\n      }\r\n\r\n      return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\r\n    };\r\n\r\n    var parsePmt = function parsePmt(packet) {\r\n      var programMapTable = {};\r\n      var pusi = parsePayloadUnitStartIndicator(packet);\r\n      var payloadOffset = 4 + parseAdaptionField(packet);\r\n\r\n      if (pusi) {\r\n        payloadOffset += packet[payloadOffset] + 1;\r\n      } // PMTs can be sent ahead of the time when they should actually\r\n      // take effect. We don't believe this should ever be the case\r\n      // for HLS but we'll ignore \"forward\" PMT declarations if we see\r\n      // them. Future PMT declarations have the current_next_indicator\r\n      // set to zero.\r\n\r\n\r\n      if (!(packet[payloadOffset + 5] & 0x01)) {\r\n        return;\r\n      }\r\n\r\n      var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\r\n\r\n      sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\r\n      tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\r\n      // long the program info descriptors are\r\n\r\n      programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\r\n\r\n      var offset = 12 + programInfoLength;\r\n\r\n      while (offset < tableEnd) {\r\n        var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\r\n\r\n        programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\r\n        // skip past the elementary stream descriptors, if present\r\n\r\n        offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\r\n      }\r\n\r\n      return programMapTable;\r\n    };\r\n\r\n    var parsePesType = function parsePesType(packet, programMapTable) {\r\n      var pid = parsePid(packet);\r\n      var type = programMapTable[pid];\r\n\r\n      switch (type) {\r\n        case streamTypes.H264_STREAM_TYPE:\r\n          return 'video';\r\n\r\n        case streamTypes.ADTS_STREAM_TYPE:\r\n          return 'audio';\r\n\r\n        case streamTypes.METADATA_STREAM_TYPE:\r\n          return 'timed-metadata';\r\n\r\n        default:\r\n          return null;\r\n      }\r\n    };\r\n\r\n    var parsePesTime = function parsePesTime(packet) {\r\n      var pusi = parsePayloadUnitStartIndicator(packet);\r\n\r\n      if (!pusi) {\r\n        return null;\r\n      }\r\n\r\n      var offset = 4 + parseAdaptionField(packet);\r\n\r\n      if (offset >= packet.byteLength) {\r\n        // From the H 222.0 MPEG-TS spec\r\n        // \"For transport stream packets carrying PES packets, stuffing is needed when there\r\n        //  is insufficient PES packet data to completely fill the transport stream packet\r\n        //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\r\n        //  the sum of the lengths of the data elements in it, so that the payload bytes\r\n        //  remaining after the adaptation field exactly accommodates the available PES packet\r\n        //  data.\"\r\n        //\r\n        // If the offset is >= the length of the packet, then the packet contains no data\r\n        // and instead is just adaption field stuffing bytes\r\n        return null;\r\n      }\r\n\r\n      var pes = null;\r\n      var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\r\n      // and a DTS value. Determine what combination of values is\r\n      // available to work with.\r\n\r\n      ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\r\n      // performs all bitwise operations on 32-bit integers but javascript\r\n      // supports a much greater range (52-bits) of integer using standard\r\n      // mathematical operations.\r\n      // We construct a 31-bit value using bitwise operators over the 31\r\n      // most significant bits and then multiply by 4 (equal to a left-shift\r\n      // of 2) before we add the final 2 least significant bits of the\r\n      // timestamp (equal to an OR.)\r\n\r\n      if (ptsDtsFlags & 0xC0) {\r\n        pes = {}; // the PTS and DTS are not written out directly. For information\r\n        // on how they are encoded, see\r\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\r\n\r\n        pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\r\n        pes.pts *= 4; // Left shift by 2\r\n\r\n        pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\r\n\r\n        pes.dts = pes.pts;\r\n\r\n        if (ptsDtsFlags & 0x40) {\r\n          pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\r\n          pes.dts *= 4; // Left shift by 2\r\n\r\n          pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\r\n        }\r\n      }\r\n\r\n      return pes;\r\n    };\r\n\r\n    var parseNalUnitType = function parseNalUnitType(type) {\r\n      switch (type) {\r\n        case 0x05:\r\n          return 'slice_layer_without_partitioning_rbsp_idr';\r\n\r\n        case 0x06:\r\n          return 'sei_rbsp';\r\n\r\n        case 0x07:\r\n          return 'seq_parameter_set_rbsp';\r\n\r\n        case 0x08:\r\n          return 'pic_parameter_set_rbsp';\r\n\r\n        case 0x09:\r\n          return 'access_unit_delimiter_rbsp';\r\n\r\n        default:\r\n          return null;\r\n      }\r\n    };\r\n\r\n    var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame(packet) {\r\n      var offset = 4 + parseAdaptionField(packet);\r\n      var frameBuffer = packet.subarray(offset);\r\n      var frameI = 0;\r\n      var frameSyncPoint = 0;\r\n      var foundKeyFrame = false;\r\n      var nalType; // advance the sync point to a NAL start, if necessary\r\n\r\n      for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\r\n        if (frameBuffer[frameSyncPoint + 2] === 1) {\r\n          // the sync point is properly aligned\r\n          frameI = frameSyncPoint + 5;\r\n          break;\r\n        }\r\n      }\r\n\r\n      while (frameI < frameBuffer.byteLength) {\r\n        // look at the current byte to determine if we've hit the end of\r\n        // a NAL unit boundary\r\n        switch (frameBuffer[frameI]) {\r\n          case 0:\r\n            // skip past non-sync sequences\r\n            if (frameBuffer[frameI - 1] !== 0) {\r\n              frameI += 2;\r\n              break;\r\n            } else if (frameBuffer[frameI - 2] !== 0) {\r\n              frameI++;\r\n              break;\r\n            }\r\n\r\n            if (frameSyncPoint + 3 !== frameI - 2) {\r\n              nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\r\n\r\n              if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\r\n                foundKeyFrame = true;\r\n              }\r\n            } // drop trailing zeroes\r\n\r\n\r\n            do {\r\n              frameI++;\r\n            } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\r\n\r\n            frameSyncPoint = frameI - 2;\r\n            frameI += 3;\r\n            break;\r\n\r\n          case 1:\r\n            // skip past non-sync sequences\r\n            if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\r\n              frameI += 3;\r\n              break;\r\n            }\r\n\r\n            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\r\n\r\n            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\r\n              foundKeyFrame = true;\r\n            }\r\n\r\n            frameSyncPoint = frameI - 2;\r\n            frameI += 3;\r\n            break;\r\n\r\n          default:\r\n            // the current byte isn't a one or zero, so it cannot be part\r\n            // of a sync sequence\r\n            frameI += 3;\r\n            break;\r\n        }\r\n      }\r\n\r\n      frameBuffer = frameBuffer.subarray(frameSyncPoint);\r\n      frameI -= frameSyncPoint;\r\n      frameSyncPoint = 0; // parse the final nal\r\n\r\n      if (frameBuffer && frameBuffer.byteLength > 3) {\r\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\r\n\r\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\r\n          foundKeyFrame = true;\r\n        }\r\n      }\r\n\r\n      return foundKeyFrame;\r\n    };\r\n\r\n    var probe$1 = {\r\n      parseType: parseType,\r\n      parsePat: parsePat,\r\n      parsePmt: parsePmt,\r\n      parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\r\n      parsePesType: parsePesType,\r\n      parsePesTime: parsePesTime,\r\n      videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\r\n    };\r\n    var handleRollover = timestampRolloverStream.handleRollover;\r\n    var probe = {};\r\n    probe.ts = probe$1;\r\n    probe.aac = utils;\r\n    var ONE_SECOND_IN_TS = clock.ONE_SECOND_IN_TS;\r\n    var MP2T_PACKET_LENGTH = 188,\r\n        // bytes\r\n    SYNC_BYTE = 0x47;\r\n    /**\r\n     * walks through segment data looking for pat and pmt packets to parse out\r\n     * program map table information\r\n     */\r\n\r\n    var parsePsi_ = function parsePsi_(bytes, pmt) {\r\n      var startIndex = 0,\r\n          endIndex = MP2T_PACKET_LENGTH,\r\n          packet,\r\n          type;\r\n\r\n      while (endIndex < bytes.byteLength) {\r\n        // Look for a pair of start and end sync bytes in the data..\r\n        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\r\n          // We found a packet\r\n          packet = bytes.subarray(startIndex, endIndex);\r\n          type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n          switch (type) {\r\n            case 'pat':\r\n              pmt.pid = probe.ts.parsePat(packet);\r\n              break;\r\n\r\n            case 'pmt':\r\n              var table = probe.ts.parsePmt(packet);\r\n              pmt.table = pmt.table || {};\r\n              Object.keys(table).forEach(function (key) {\r\n                pmt.table[key] = table[key];\r\n              });\r\n              break;\r\n          }\r\n\r\n          startIndex += MP2T_PACKET_LENGTH;\r\n          endIndex += MP2T_PACKET_LENGTH;\r\n          continue;\r\n        } // If we get here, we have somehow become de-synchronized and we need to step\r\n        // forward one byte at a time until we find a pair of sync bytes that denote\r\n        // a packet\r\n\r\n\r\n        startIndex++;\r\n        endIndex++;\r\n      }\r\n    };\r\n    /**\r\n     * walks through the segment data from the start and end to get timing information\r\n     * for the first and last audio pes packets\r\n     */\r\n\r\n\r\n    var parseAudioPes_ = function parseAudioPes_(bytes, pmt, result) {\r\n      var startIndex = 0,\r\n          endIndex = MP2T_PACKET_LENGTH,\r\n          packet,\r\n          type,\r\n          pesType,\r\n          pusi,\r\n          parsed;\r\n      var endLoop = false; // Start walking from start of segment to get first audio packet\r\n\r\n      while (endIndex <= bytes.byteLength) {\r\n        // Look for a pair of start and end sync bytes in the data..\r\n        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\r\n          // We found a packet\r\n          packet = bytes.subarray(startIndex, endIndex);\r\n          type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n          switch (type) {\r\n            case 'pes':\r\n              pesType = probe.ts.parsePesType(packet, pmt.table);\r\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n\r\n              if (pesType === 'audio' && pusi) {\r\n                parsed = probe.ts.parsePesTime(packet);\r\n\r\n                if (parsed) {\r\n                  parsed.type = 'audio';\r\n                  result.audio.push(parsed);\r\n                  endLoop = true;\r\n                }\r\n              }\r\n\r\n              break;\r\n          }\r\n\r\n          if (endLoop) {\r\n            break;\r\n          }\r\n\r\n          startIndex += MP2T_PACKET_LENGTH;\r\n          endIndex += MP2T_PACKET_LENGTH;\r\n          continue;\r\n        } // If we get here, we have somehow become de-synchronized and we need to step\r\n        // forward one byte at a time until we find a pair of sync bytes that denote\r\n        // a packet\r\n\r\n\r\n        startIndex++;\r\n        endIndex++;\r\n      } // Start walking from end of segment to get last audio packet\r\n\r\n\r\n      endIndex = bytes.byteLength;\r\n      startIndex = endIndex - MP2T_PACKET_LENGTH;\r\n      endLoop = false;\r\n\r\n      while (startIndex >= 0) {\r\n        // Look for a pair of start and end sync bytes in the data..\r\n        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\r\n          // We found a packet\r\n          packet = bytes.subarray(startIndex, endIndex);\r\n          type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n          switch (type) {\r\n            case 'pes':\r\n              pesType = probe.ts.parsePesType(packet, pmt.table);\r\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n\r\n              if (pesType === 'audio' && pusi) {\r\n                parsed = probe.ts.parsePesTime(packet);\r\n\r\n                if (parsed) {\r\n                  parsed.type = 'audio';\r\n                  result.audio.push(parsed);\r\n                  endLoop = true;\r\n                }\r\n              }\r\n\r\n              break;\r\n          }\r\n\r\n          if (endLoop) {\r\n            break;\r\n          }\r\n\r\n          startIndex -= MP2T_PACKET_LENGTH;\r\n          endIndex -= MP2T_PACKET_LENGTH;\r\n          continue;\r\n        } // If we get here, we have somehow become de-synchronized and we need to step\r\n        // forward one byte at a time until we find a pair of sync bytes that denote\r\n        // a packet\r\n\r\n\r\n        startIndex--;\r\n        endIndex--;\r\n      }\r\n    };\r\n    /**\r\n     * walks through the segment data from the start and end to get timing information\r\n     * for the first and last video pes packets as well as timing information for the first\r\n     * key frame.\r\n     */\r\n\r\n\r\n    var parseVideoPes_ = function parseVideoPes_(bytes, pmt, result) {\r\n      var startIndex = 0,\r\n          endIndex = MP2T_PACKET_LENGTH,\r\n          packet,\r\n          type,\r\n          pesType,\r\n          pusi,\r\n          parsed,\r\n          frame,\r\n          i,\r\n          pes;\r\n      var endLoop = false;\r\n      var currentFrame = {\r\n        data: [],\r\n        size: 0\r\n      }; // Start walking from start of segment to get first video packet\r\n\r\n      while (endIndex < bytes.byteLength) {\r\n        // Look for a pair of start and end sync bytes in the data..\r\n        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\r\n          // We found a packet\r\n          packet = bytes.subarray(startIndex, endIndex);\r\n          type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n          switch (type) {\r\n            case 'pes':\r\n              pesType = probe.ts.parsePesType(packet, pmt.table);\r\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n\r\n              if (pesType === 'video') {\r\n                if (pusi && !endLoop) {\r\n                  parsed = probe.ts.parsePesTime(packet);\r\n\r\n                  if (parsed) {\r\n                    parsed.type = 'video';\r\n                    result.video.push(parsed);\r\n                    endLoop = true;\r\n                  }\r\n                }\r\n\r\n                if (!result.firstKeyFrame) {\r\n                  if (pusi) {\r\n                    if (currentFrame.size !== 0) {\r\n                      frame = new Uint8Array(currentFrame.size);\r\n                      i = 0;\r\n\r\n                      while (currentFrame.data.length) {\r\n                        pes = currentFrame.data.shift();\r\n                        frame.set(pes, i);\r\n                        i += pes.byteLength;\r\n                      }\r\n\r\n                      if (probe.ts.videoPacketContainsKeyFrame(frame)) {\r\n                        var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\r\n                        // the keyframe seems to work fine with HLS playback\r\n                        // and definitely preferable to a crash with TypeError...\r\n\r\n                        if (firstKeyFrame) {\r\n                          result.firstKeyFrame = firstKeyFrame;\r\n                          result.firstKeyFrame.type = 'video';\r\n                        } else {\r\n                          // eslint-disable-next-line\r\n                          console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\r\n                        }\r\n                      }\r\n\r\n                      currentFrame.size = 0;\r\n                    }\r\n                  }\r\n\r\n                  currentFrame.data.push(packet);\r\n                  currentFrame.size += packet.byteLength;\r\n                }\r\n              }\r\n\r\n              break;\r\n          }\r\n\r\n          if (endLoop && result.firstKeyFrame) {\r\n            break;\r\n          }\r\n\r\n          startIndex += MP2T_PACKET_LENGTH;\r\n          endIndex += MP2T_PACKET_LENGTH;\r\n          continue;\r\n        } // If we get here, we have somehow become de-synchronized and we need to step\r\n        // forward one byte at a time until we find a pair of sync bytes that denote\r\n        // a packet\r\n\r\n\r\n        startIndex++;\r\n        endIndex++;\r\n      } // Start walking from end of segment to get last video packet\r\n\r\n\r\n      endIndex = bytes.byteLength;\r\n      startIndex = endIndex - MP2T_PACKET_LENGTH;\r\n      endLoop = false;\r\n\r\n      while (startIndex >= 0) {\r\n        // Look for a pair of start and end sync bytes in the data..\r\n        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\r\n          // We found a packet\r\n          packet = bytes.subarray(startIndex, endIndex);\r\n          type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n          switch (type) {\r\n            case 'pes':\r\n              pesType = probe.ts.parsePesType(packet, pmt.table);\r\n              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n\r\n              if (pesType === 'video' && pusi) {\r\n                parsed = probe.ts.parsePesTime(packet);\r\n\r\n                if (parsed) {\r\n                  parsed.type = 'video';\r\n                  result.video.push(parsed);\r\n                  endLoop = true;\r\n                }\r\n              }\r\n\r\n              break;\r\n          }\r\n\r\n          if (endLoop) {\r\n            break;\r\n          }\r\n\r\n          startIndex -= MP2T_PACKET_LENGTH;\r\n          endIndex -= MP2T_PACKET_LENGTH;\r\n          continue;\r\n        } // If we get here, we have somehow become de-synchronized and we need to step\r\n        // forward one byte at a time until we find a pair of sync bytes that denote\r\n        // a packet\r\n\r\n\r\n        startIndex--;\r\n        endIndex--;\r\n      }\r\n    };\r\n    /**\r\n     * Adjusts the timestamp information for the segment to account for\r\n     * rollover and convert to seconds based on pes packet timescale (90khz clock)\r\n     */\r\n\r\n\r\n    var adjustTimestamp_ = function adjustTimestamp_(segmentInfo, baseTimestamp) {\r\n      if (segmentInfo.audio && segmentInfo.audio.length) {\r\n        var audioBaseTimestamp = baseTimestamp;\r\n\r\n        if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\r\n          audioBaseTimestamp = segmentInfo.audio[0].dts;\r\n        }\r\n\r\n        segmentInfo.audio.forEach(function (info) {\r\n          info.dts = handleRollover(info.dts, audioBaseTimestamp);\r\n          info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\r\n\r\n          info.dtsTime = info.dts / ONE_SECOND_IN_TS;\r\n          info.ptsTime = info.pts / ONE_SECOND_IN_TS;\r\n        });\r\n      }\r\n\r\n      if (segmentInfo.video && segmentInfo.video.length) {\r\n        var videoBaseTimestamp = baseTimestamp;\r\n\r\n        if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\r\n          videoBaseTimestamp = segmentInfo.video[0].dts;\r\n        }\r\n\r\n        segmentInfo.video.forEach(function (info) {\r\n          info.dts = handleRollover(info.dts, videoBaseTimestamp);\r\n          info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\r\n\r\n          info.dtsTime = info.dts / ONE_SECOND_IN_TS;\r\n          info.ptsTime = info.pts / ONE_SECOND_IN_TS;\r\n        });\r\n\r\n        if (segmentInfo.firstKeyFrame) {\r\n          var frame = segmentInfo.firstKeyFrame;\r\n          frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\r\n          frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\r\n\r\n          frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\r\n          frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * inspects the aac data stream for start and end time information\r\n     */\r\n\r\n\r\n    var inspectAac_ = function inspectAac_(bytes) {\r\n      var endLoop = false,\r\n          audioCount = 0,\r\n          sampleRate = null,\r\n          timestamp = null,\r\n          frameSize = 0,\r\n          byteIndex = 0,\r\n          packet;\r\n\r\n      while (bytes.length - byteIndex >= 3) {\r\n        var type = probe.aac.parseType(bytes, byteIndex);\r\n\r\n        switch (type) {\r\n          case 'timed-metadata':\r\n            // Exit early because we don't have enough to parse\r\n            // the ID3 tag header\r\n            if (bytes.length - byteIndex < 10) {\r\n              endLoop = true;\r\n              break;\r\n            }\r\n\r\n            frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\r\n            // to emit a full packet\r\n\r\n            if (frameSize > bytes.length) {\r\n              endLoop = true;\r\n              break;\r\n            }\r\n\r\n            if (timestamp === null) {\r\n              packet = bytes.subarray(byteIndex, byteIndex + frameSize);\r\n              timestamp = probe.aac.parseAacTimestamp(packet);\r\n            }\r\n\r\n            byteIndex += frameSize;\r\n            break;\r\n\r\n          case 'audio':\r\n            // Exit early because we don't have enough to parse\r\n            // the ADTS frame header\r\n            if (bytes.length - byteIndex < 7) {\r\n              endLoop = true;\r\n              break;\r\n            }\r\n\r\n            frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\r\n            // to emit a full packet\r\n\r\n            if (frameSize > bytes.length) {\r\n              endLoop = true;\r\n              break;\r\n            }\r\n\r\n            if (sampleRate === null) {\r\n              packet = bytes.subarray(byteIndex, byteIndex + frameSize);\r\n              sampleRate = probe.aac.parseSampleRate(packet);\r\n            }\r\n\r\n            audioCount++;\r\n            byteIndex += frameSize;\r\n            break;\r\n\r\n          default:\r\n            byteIndex++;\r\n            break;\r\n        }\r\n\r\n        if (endLoop) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      if (sampleRate === null || timestamp === null) {\r\n        return null;\r\n      }\r\n\r\n      var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\r\n      var result = {\r\n        audio: [{\r\n          type: 'audio',\r\n          dts: timestamp,\r\n          pts: timestamp\r\n        }, {\r\n          type: 'audio',\r\n          dts: timestamp + audioCount * 1024 * audioTimescale,\r\n          pts: timestamp + audioCount * 1024 * audioTimescale\r\n        }]\r\n      };\r\n      return result;\r\n    };\r\n    /**\r\n     * inspects the transport stream segment data for start and end time information\r\n     * of the audio and video tracks (when present) as well as the first key frame's\r\n     * start time.\r\n     */\r\n\r\n\r\n    var inspectTs_ = function inspectTs_(bytes) {\r\n      var pmt = {\r\n        pid: null,\r\n        table: null\r\n      };\r\n      var result = {};\r\n      parsePsi_(bytes, pmt);\r\n\r\n      for (var pid in pmt.table) {\r\n        if (pmt.table.hasOwnProperty(pid)) {\r\n          var type = pmt.table[pid];\r\n\r\n          switch (type) {\r\n            case streamTypes.H264_STREAM_TYPE:\r\n              result.video = [];\r\n              parseVideoPes_(bytes, pmt, result);\r\n\r\n              if (result.video.length === 0) {\r\n                delete result.video;\r\n              }\r\n\r\n              break;\r\n\r\n            case streamTypes.ADTS_STREAM_TYPE:\r\n              result.audio = [];\r\n              parseAudioPes_(bytes, pmt, result);\r\n\r\n              if (result.audio.length === 0) {\r\n                delete result.audio;\r\n              }\r\n\r\n              break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n    /**\r\n     * Inspects segment byte data and returns an object with start and end timing information\r\n     *\r\n     * @param {Uint8Array} bytes The segment byte data\r\n     * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\r\n     *  timestamps for rollover. This value must be in 90khz clock.\r\n     * @return {Object} Object containing start and end frame timing info of segment.\r\n     */\r\n\r\n\r\n    var inspect = function inspect(bytes, baseTimestamp) {\r\n      var isAacData = probe.aac.isLikelyAacData(bytes);\r\n      var result;\r\n\r\n      if (isAacData) {\r\n        result = inspectAac_(bytes);\r\n      } else {\r\n        result = inspectTs_(bytes);\r\n      }\r\n\r\n      if (!result || !result.audio && !result.video) {\r\n        return null;\r\n      }\r\n\r\n      adjustTimestamp_(result, baseTimestamp);\r\n      return result;\r\n    };\r\n\r\n    var tsInspector = {\r\n      inspect: inspect,\r\n      parseAudioPes_: parseAudioPes_\r\n    };\r\n    /* global self */\r\n\r\n    /**\r\n     * Re-emits transmuxer events by converting them into messages to the\r\n     * world outside the worker.\r\n     *\r\n     * @param {Object} transmuxer the transmuxer to wire events on\r\n     * @private\r\n     */\r\n\r\n    var wireTransmuxerEvents = function wireTransmuxerEvents(self, transmuxer) {\r\n      transmuxer.on('data', function (segment) {\r\n        // transfer ownership of the underlying ArrayBuffer\r\n        // instead of doing a copy to save memory\r\n        // ArrayBuffers are transferable but generic TypedArrays are not\r\n        // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\r\n        var initArray = segment.initSegment;\r\n        segment.initSegment = {\r\n          data: initArray.buffer,\r\n          byteOffset: initArray.byteOffset,\r\n          byteLength: initArray.byteLength\r\n        };\r\n        var typedArray = segment.data;\r\n        segment.data = typedArray.buffer;\r\n        self.postMessage({\r\n          action: 'data',\r\n          segment: segment,\r\n          byteOffset: typedArray.byteOffset,\r\n          byteLength: typedArray.byteLength\r\n        }, [segment.data]);\r\n      });\r\n      transmuxer.on('done', function (data) {\r\n        self.postMessage({\r\n          action: 'done'\r\n        });\r\n      });\r\n      transmuxer.on('gopInfo', function (gopInfo) {\r\n        self.postMessage({\r\n          action: 'gopInfo',\r\n          gopInfo: gopInfo\r\n        });\r\n      });\r\n      transmuxer.on('videoSegmentTimingInfo', function (timingInfo) {\r\n        var videoSegmentTimingInfo = {\r\n          start: {\r\n            decode: clock.videoTsToSeconds(timingInfo.start.dts),\r\n            presentation: clock.videoTsToSeconds(timingInfo.start.pts)\r\n          },\r\n          end: {\r\n            decode: clock.videoTsToSeconds(timingInfo.end.dts),\r\n            presentation: clock.videoTsToSeconds(timingInfo.end.pts)\r\n          },\r\n          baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\r\n        };\r\n\r\n        if (timingInfo.prependedContentDuration) {\r\n          videoSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);\r\n        }\r\n\r\n        self.postMessage({\r\n          action: 'videoSegmentTimingInfo',\r\n          videoSegmentTimingInfo: videoSegmentTimingInfo\r\n        });\r\n      });\r\n      transmuxer.on('audioSegmentTimingInfo', function (timingInfo) {\r\n        // Note that all times for [audio/video]SegmentTimingInfo events are in video clock\r\n        var audioSegmentTimingInfo = {\r\n          start: {\r\n            decode: clock.videoTsToSeconds(timingInfo.start.dts),\r\n            presentation: clock.videoTsToSeconds(timingInfo.start.pts)\r\n          },\r\n          end: {\r\n            decode: clock.videoTsToSeconds(timingInfo.end.dts),\r\n            presentation: clock.videoTsToSeconds(timingInfo.end.pts)\r\n          },\r\n          baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\r\n        };\r\n\r\n        if (timingInfo.prependedContentDuration) {\r\n          audioSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);\r\n        }\r\n\r\n        self.postMessage({\r\n          action: 'audioSegmentTimingInfo',\r\n          audioSegmentTimingInfo: audioSegmentTimingInfo\r\n        });\r\n      });\r\n      transmuxer.on('id3Frame', function (id3Frame) {\r\n        self.postMessage({\r\n          action: 'id3Frame',\r\n          id3Frame: id3Frame\r\n        });\r\n      });\r\n      transmuxer.on('caption', function (caption) {\r\n        self.postMessage({\r\n          action: 'caption',\r\n          caption: caption\r\n        });\r\n      });\r\n      transmuxer.on('trackinfo', function (trackInfo) {\r\n        self.postMessage({\r\n          action: 'trackinfo',\r\n          trackInfo: trackInfo\r\n        });\r\n      });\r\n      transmuxer.on('audioTimingInfo', function (audioTimingInfo) {\r\n        // convert to video TS since we prioritize video time over audio\r\n        self.postMessage({\r\n          action: 'audioTimingInfo',\r\n          audioTimingInfo: {\r\n            start: clock.videoTsToSeconds(audioTimingInfo.start),\r\n            end: clock.videoTsToSeconds(audioTimingInfo.end)\r\n          }\r\n        });\r\n      });\r\n      transmuxer.on('videoTimingInfo', function (videoTimingInfo) {\r\n        self.postMessage({\r\n          action: 'videoTimingInfo',\r\n          videoTimingInfo: {\r\n            start: clock.videoTsToSeconds(videoTimingInfo.start),\r\n            end: clock.videoTsToSeconds(videoTimingInfo.end)\r\n          }\r\n        });\r\n      });\r\n      transmuxer.on('log', function (log) {\r\n        self.postMessage({\r\n          action: 'log',\r\n          log: log\r\n        });\r\n      });\r\n    };\r\n    /**\r\n     * All incoming messages route through this hash. If no function exists\r\n     * to handle an incoming message, then we ignore the message.\r\n     *\r\n     * @class MessageHandlers\r\n     * @param {Object} options the options to initialize with\r\n     */\r\n\r\n\r\n    var MessageHandlers = /*#__PURE__*/function () {\r\n      function MessageHandlers(self, options) {\r\n        this.options = options || {};\r\n        this.self = self;\r\n        this.init();\r\n      }\r\n      /**\r\n       * initialize our web worker and wire all the events.\r\n       */\r\n\r\n\r\n      var _proto = MessageHandlers.prototype;\r\n\r\n      _proto.init = function init() {\r\n        if (this.transmuxer) {\r\n          this.transmuxer.dispose();\r\n        }\r\n\r\n        this.transmuxer = new transmuxer.Transmuxer(this.options);\r\n        wireTransmuxerEvents(this.self, this.transmuxer);\r\n      };\r\n\r\n      _proto.pushMp4Captions = function pushMp4Captions(data) {\r\n        if (!this.captionParser) {\r\n          this.captionParser = new captionParser();\r\n          this.captionParser.init();\r\n        }\r\n\r\n        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\r\n        var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);\r\n        this.self.postMessage({\r\n          action: 'mp4Captions',\r\n          captions: parsed && parsed.captions || [],\r\n          logs: parsed && parsed.logs || [],\r\n          data: segment.buffer\r\n        }, [segment.buffer]);\r\n      };\r\n\r\n      _proto.probeMp4StartTime = function probeMp4StartTime(_ref) {\r\n        var timescales = _ref.timescales,\r\n            data = _ref.data;\r\n        var startTime = probe$2.startTime(timescales, data);\r\n        this.self.postMessage({\r\n          action: 'probeMp4StartTime',\r\n          startTime: startTime,\r\n          data: data\r\n        }, [data.buffer]);\r\n      };\r\n\r\n      _proto.probeMp4Tracks = function probeMp4Tracks(_ref2) {\r\n        var data = _ref2.data;\r\n        var tracks = probe$2.tracks(data);\r\n        this.self.postMessage({\r\n          action: 'probeMp4Tracks',\r\n          tracks: tracks,\r\n          data: data\r\n        }, [data.buffer]);\r\n      }\r\n      /**\r\n       * Probe an mpeg2-ts segment to determine the start time of the segment in it's\r\n       * internal \"media time,\" as well as whether it contains video and/or audio.\r\n       *\r\n       * @private\r\n       * @param {Uint8Array} bytes - segment bytes\r\n       * @param {number} baseStartTime\r\n       *        Relative reference timestamp used when adjusting frame timestamps for rollover.\r\n       *        This value should be in seconds, as it's converted to a 90khz clock within the\r\n       *        function body.\r\n       * @return {Object} The start time of the current segment in \"media time\" as well as\r\n       *                  whether it contains video and/or audio\r\n       */\r\n      ;\r\n\r\n      _proto.probeTs = function probeTs(_ref3) {\r\n        var data = _ref3.data,\r\n            baseStartTime = _ref3.baseStartTime;\r\n        var tsStartTime = typeof baseStartTime === 'number' && !isNaN(baseStartTime) ? baseStartTime * clock.ONE_SECOND_IN_TS : void 0;\r\n        var timeInfo = tsInspector.inspect(data, tsStartTime);\r\n        var result = null;\r\n\r\n        if (timeInfo) {\r\n          result = {\r\n            // each type's time info comes back as an array of 2 times, start and end\r\n            hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,\r\n            hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false\r\n          };\r\n\r\n          if (result.hasVideo) {\r\n            result.videoStart = timeInfo.video[0].ptsTime;\r\n          }\r\n\r\n          if (result.hasAudio) {\r\n            result.audioStart = timeInfo.audio[0].ptsTime;\r\n          }\r\n        }\r\n\r\n        this.self.postMessage({\r\n          action: 'probeTs',\r\n          result: result,\r\n          data: data\r\n        }, [data.buffer]);\r\n      };\r\n\r\n      _proto.clearAllMp4Captions = function clearAllMp4Captions() {\r\n        if (this.captionParser) {\r\n          this.captionParser.clearAllCaptions();\r\n        }\r\n      };\r\n\r\n      _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {\r\n        if (this.captionParser) {\r\n          this.captionParser.clearParsedCaptions();\r\n        }\r\n      }\r\n      /**\r\n       * Adds data (a ts segment) to the start of the transmuxer pipeline for\r\n       * processing.\r\n       *\r\n       * @param {ArrayBuffer} data data to push into the muxer\r\n       */\r\n      ;\r\n\r\n      _proto.push = function push(data) {\r\n        // Cast array buffer to correct type for transmuxer\r\n        var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\r\n        this.transmuxer.push(segment);\r\n      }\r\n      /**\r\n       * Recreate the transmuxer so that the next segment added via `push`\r\n       * start with a fresh transmuxer.\r\n       */\r\n      ;\r\n\r\n      _proto.reset = function reset() {\r\n        this.transmuxer.reset();\r\n      }\r\n      /**\r\n       * Set the value that will be used as the `baseMediaDecodeTime` time for the\r\n       * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\r\n       * set relative to the first based on the PTS values.\r\n       *\r\n       * @param {Object} data used to set the timestamp offset in the muxer\r\n       */\r\n      ;\r\n\r\n      _proto.setTimestampOffset = function setTimestampOffset(data) {\r\n        var timestampOffset = data.timestampOffset || 0;\r\n        this.transmuxer.setBaseMediaDecodeTime(Math.round(clock.secondsToVideoTs(timestampOffset)));\r\n      };\r\n\r\n      _proto.setAudioAppendStart = function setAudioAppendStart(data) {\r\n        this.transmuxer.setAudioAppendStart(Math.ceil(clock.secondsToVideoTs(data.appendStart)));\r\n      };\r\n\r\n      _proto.setRemux = function setRemux(data) {\r\n        this.transmuxer.setRemux(data.remux);\r\n      }\r\n      /**\r\n       * Forces the pipeline to finish processing the last segment and emit it's\r\n       * results.\r\n       *\r\n       * @param {Object} data event data, not really used\r\n       */\r\n      ;\r\n\r\n      _proto.flush = function flush(data) {\r\n        this.transmuxer.flush(); // transmuxed done action is fired after both audio/video pipelines are flushed\r\n\r\n        self.postMessage({\r\n          action: 'done',\r\n          type: 'transmuxed'\r\n        });\r\n      };\r\n\r\n      _proto.endTimeline = function endTimeline() {\r\n        this.transmuxer.endTimeline(); // transmuxed endedtimeline action is fired after both audio/video pipelines end their\r\n        // timelines\r\n\r\n        self.postMessage({\r\n          action: 'endedtimeline',\r\n          type: 'transmuxed'\r\n        });\r\n      };\r\n\r\n      _proto.alignGopsWith = function alignGopsWith(data) {\r\n        this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\r\n      };\r\n\r\n      return MessageHandlers;\r\n    }();\r\n    /**\r\n     * Our web worker interface so that things can talk to mux.js\r\n     * that will be running in a web worker. the scope is passed to this by\r\n     * webworkify.\r\n     *\r\n     * @param {Object} self the scope for the web worker\r\n     */\r\n\r\n\r\n    self.onmessage = function (event) {\r\n      if (event.data.action === 'init' && event.data.options) {\r\n        this.messageHandlers = new MessageHandlers(self, event.data.options);\r\n        return;\r\n      }\r\n\r\n      if (!this.messageHandlers) {\r\n        this.messageHandlers = new MessageHandlers(self);\r\n      }\r\n\r\n      if (event.data && event.data.action && event.data.action !== 'init') {\r\n        if (this.messageHandlers[event.data.action]) {\r\n          this.messageHandlers[event.data.action](event.data);\r\n        }\r\n      }\r\n    };\r\n  }));\r\n  var TransmuxWorker = factory(workerCode$1);\r\n  /* rollup-plugin-worker-factory end for worker!/Users/abarstow/videojs/http-streaming/src/transmuxer-worker.js */\r\n\r\n  var handleData_ = function handleData_(event, transmuxedData, callback) {\r\n    var _event$data$segment = event.data.segment,\r\n        type = _event$data$segment.type,\r\n        initSegment = _event$data$segment.initSegment,\r\n        captions = _event$data$segment.captions,\r\n        captionStreams = _event$data$segment.captionStreams,\r\n        metadata = _event$data$segment.metadata,\r\n        videoFrameDtsTime = _event$data$segment.videoFrameDtsTime,\r\n        videoFramePtsTime = _event$data$segment.videoFramePtsTime;\r\n    transmuxedData.buffer.push({\r\n      captions: captions,\r\n      captionStreams: captionStreams,\r\n      metadata: metadata\r\n    });\r\n    var boxes = event.data.segment.boxes || {\r\n      data: event.data.segment.data\r\n    };\r\n    var result = {\r\n      type: type,\r\n      // cast ArrayBuffer to TypedArray\r\n      data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),\r\n      initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)\r\n    };\r\n\r\n    if (typeof videoFrameDtsTime !== 'undefined') {\r\n      result.videoFrameDtsTime = videoFrameDtsTime;\r\n    }\r\n\r\n    if (typeof videoFramePtsTime !== 'undefined') {\r\n      result.videoFramePtsTime = videoFramePtsTime;\r\n    }\r\n\r\n    callback(result);\r\n  };\r\n\r\n  var handleDone_ = function handleDone_(_ref) {\r\n    var transmuxedData = _ref.transmuxedData,\r\n        callback = _ref.callback; // Previously we only returned data on data events,\r\n    // not on done events. Clear out the buffer to keep that consistent.\r\n\r\n    transmuxedData.buffer = []; // all buffers should have been flushed from the muxer, so start processing anything we\r\n    // have received\r\n\r\n    callback(transmuxedData);\r\n  };\r\n\r\n  var handleGopInfo_ = function handleGopInfo_(event, transmuxedData) {\r\n    transmuxedData.gopInfo = event.data.gopInfo;\r\n  };\r\n\r\n  var processTransmux = function processTransmux(options) {\r\n    var transmuxer = options.transmuxer,\r\n        bytes = options.bytes,\r\n        audioAppendStart = options.audioAppendStart,\r\n        gopsToAlignWith = options.gopsToAlignWith,\r\n        remux = options.remux,\r\n        onData = options.onData,\r\n        onTrackInfo = options.onTrackInfo,\r\n        onAudioTimingInfo = options.onAudioTimingInfo,\r\n        onVideoTimingInfo = options.onVideoTimingInfo,\r\n        onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo,\r\n        onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo,\r\n        onId3 = options.onId3,\r\n        onCaptions = options.onCaptions,\r\n        onDone = options.onDone,\r\n        onEndedTimeline = options.onEndedTimeline,\r\n        onTransmuxerLog = options.onTransmuxerLog,\r\n        isEndOfTimeline = options.isEndOfTimeline;\r\n    var transmuxedData = {\r\n      buffer: []\r\n    };\r\n    var waitForEndedTimelineEvent = isEndOfTimeline;\r\n\r\n    var handleMessage = function handleMessage(event) {\r\n      if (transmuxer.currentTransmux !== options) {\r\n        // disposed\r\n        return;\r\n      }\r\n\r\n      if (event.data.action === 'data') {\r\n        handleData_(event, transmuxedData, onData);\r\n      }\r\n\r\n      if (event.data.action === 'trackinfo') {\r\n        onTrackInfo(event.data.trackInfo);\r\n      }\r\n\r\n      if (event.data.action === 'gopInfo') {\r\n        handleGopInfo_(event, transmuxedData);\r\n      }\r\n\r\n      if (event.data.action === 'audioTimingInfo') {\r\n        onAudioTimingInfo(event.data.audioTimingInfo);\r\n      }\r\n\r\n      if (event.data.action === 'videoTimingInfo') {\r\n        onVideoTimingInfo(event.data.videoTimingInfo);\r\n      }\r\n\r\n      if (event.data.action === 'videoSegmentTimingInfo') {\r\n        onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);\r\n      }\r\n\r\n      if (event.data.action === 'audioSegmentTimingInfo') {\r\n        onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);\r\n      }\r\n\r\n      if (event.data.action === 'id3Frame') {\r\n        onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);\r\n      }\r\n\r\n      if (event.data.action === 'caption') {\r\n        onCaptions(event.data.caption);\r\n      }\r\n\r\n      if (event.data.action === 'endedtimeline') {\r\n        waitForEndedTimelineEvent = false;\r\n        onEndedTimeline();\r\n      }\r\n\r\n      if (event.data.action === 'log') {\r\n        onTransmuxerLog(event.data.log);\r\n      } // wait for the transmuxed event since we may have audio and video\r\n\r\n\r\n      if (event.data.type !== 'transmuxed') {\r\n        return;\r\n      } // If the \"endedtimeline\" event has not yet fired, and this segment represents the end\r\n      // of a timeline, that means there may still be data events before the segment\r\n      // processing can be considerred complete. In that case, the final event should be\r\n      // an \"endedtimeline\" event with the type \"transmuxed.\"\r\n\r\n\r\n      if (waitForEndedTimelineEvent) {\r\n        return;\r\n      }\r\n\r\n      transmuxer.onmessage = null;\r\n      handleDone_({\r\n        transmuxedData: transmuxedData,\r\n        callback: onDone\r\n      });\r\n      /* eslint-disable no-use-before-define */\r\n\r\n      dequeue(transmuxer);\r\n      /* eslint-enable */\r\n    };\r\n\r\n    transmuxer.onmessage = handleMessage;\r\n\r\n    if (audioAppendStart) {\r\n      transmuxer.postMessage({\r\n        action: 'setAudioAppendStart',\r\n        appendStart: audioAppendStart\r\n      });\r\n    } // allow empty arrays to be passed to clear out GOPs\r\n\r\n\r\n    if (Array.isArray(gopsToAlignWith)) {\r\n      transmuxer.postMessage({\r\n        action: 'alignGopsWith',\r\n        gopsToAlignWith: gopsToAlignWith\r\n      });\r\n    }\r\n\r\n    if (typeof remux !== 'undefined') {\r\n      transmuxer.postMessage({\r\n        action: 'setRemux',\r\n        remux: remux\r\n      });\r\n    }\r\n\r\n    if (bytes.byteLength) {\r\n      var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;\r\n      var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;\r\n      transmuxer.postMessage({\r\n        action: 'push',\r\n        // Send the typed-array of data as an ArrayBuffer so that\r\n        // it can be sent as a \"Transferable\" and avoid the costly\r\n        // memory copy\r\n        data: buffer,\r\n        // To recreate the original typed-array, we need information\r\n        // about what portion of the ArrayBuffer it was a view into\r\n        byteOffset: byteOffset,\r\n        byteLength: bytes.byteLength\r\n      }, [buffer]);\r\n    }\r\n\r\n    if (isEndOfTimeline) {\r\n      transmuxer.postMessage({\r\n        action: 'endTimeline'\r\n      });\r\n    } // even if we didn't push any bytes, we have to make sure we flush in case we reached\r\n    // the end of the segment\r\n\r\n\r\n    transmuxer.postMessage({\r\n      action: 'flush'\r\n    });\r\n  };\r\n\r\n  var dequeue = function dequeue(transmuxer) {\r\n    transmuxer.currentTransmux = null;\r\n\r\n    if (transmuxer.transmuxQueue.length) {\r\n      transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();\r\n\r\n      if (typeof transmuxer.currentTransmux === 'function') {\r\n        transmuxer.currentTransmux();\r\n      } else {\r\n        processTransmux(transmuxer.currentTransmux);\r\n      }\r\n    }\r\n  };\r\n\r\n  var processAction = function processAction(transmuxer, action) {\r\n    transmuxer.postMessage({\r\n      action: action\r\n    });\r\n    dequeue(transmuxer);\r\n  };\r\n\r\n  var enqueueAction = function enqueueAction(action, transmuxer) {\r\n    if (!transmuxer.currentTransmux) {\r\n      transmuxer.currentTransmux = action;\r\n      processAction(transmuxer, action);\r\n      return;\r\n    }\r\n\r\n    transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));\r\n  };\r\n\r\n  var reset = function reset(transmuxer) {\r\n    enqueueAction('reset', transmuxer);\r\n  };\r\n\r\n  var endTimeline = function endTimeline(transmuxer) {\r\n    enqueueAction('endTimeline', transmuxer);\r\n  };\r\n\r\n  var transmux = function transmux(options) {\r\n    if (!options.transmuxer.currentTransmux) {\r\n      options.transmuxer.currentTransmux = options;\r\n      processTransmux(options);\r\n      return;\r\n    }\r\n\r\n    options.transmuxer.transmuxQueue.push(options);\r\n  };\r\n\r\n  var createTransmuxer = function createTransmuxer(options) {\r\n    var transmuxer = new TransmuxWorker();\r\n    transmuxer.currentTransmux = null;\r\n    transmuxer.transmuxQueue = [];\r\n    var term = transmuxer.terminate;\r\n\r\n    transmuxer.terminate = function () {\r\n      transmuxer.currentTransmux = null;\r\n      transmuxer.transmuxQueue.length = 0;\r\n      return term.call(transmuxer);\r\n    };\r\n\r\n    transmuxer.postMessage({\r\n      action: 'init',\r\n      options: options\r\n    });\r\n    return transmuxer;\r\n  };\r\n\r\n  var segmentTransmuxer = {\r\n    reset: reset,\r\n    endTimeline: endTimeline,\r\n    transmux: transmux,\r\n    createTransmuxer: createTransmuxer\r\n  };\r\n\r\n  var workerCallback = function workerCallback(options) {\r\n    var transmuxer = options.transmuxer;\r\n    var endAction = options.endAction || options.action;\r\n    var callback = options.callback;\r\n\r\n    var message = _extends_1({}, options, {\r\n      endAction: null,\r\n      transmuxer: null,\r\n      callback: null\r\n    });\r\n\r\n    var listenForEndEvent = function listenForEndEvent(event) {\r\n      if (event.data.action !== endAction) {\r\n        return;\r\n      }\r\n\r\n      transmuxer.removeEventListener('message', listenForEndEvent); // transfer ownership of bytes back to us.\r\n\r\n      if (event.data.data) {\r\n        event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);\r\n\r\n        if (options.data) {\r\n          options.data = event.data.data;\r\n        }\r\n      }\r\n\r\n      callback(event.data);\r\n    };\r\n\r\n    transmuxer.addEventListener('message', listenForEndEvent);\r\n\r\n    if (options.data) {\r\n      var isArrayBuffer = options.data instanceof ArrayBuffer;\r\n      message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;\r\n      message.byteLength = options.data.byteLength;\r\n      var transfers = [isArrayBuffer ? options.data : options.data.buffer];\r\n      transmuxer.postMessage(message, transfers);\r\n    } else {\r\n      transmuxer.postMessage(message);\r\n    }\r\n  };\r\n\r\n  var REQUEST_ERRORS = {\r\n    FAILURE: 2,\r\n    TIMEOUT: -101,\r\n    ABORTED: -102\r\n  };\r\n  /**\r\n   * Abort all requests\r\n   *\r\n   * @param {Object} activeXhrs - an object that tracks all XHR requests\r\n   */\r\n\r\n  var abortAll = function abortAll(activeXhrs) {\r\n    activeXhrs.forEach(function (xhr) {\r\n      xhr.abort();\r\n    });\r\n  };\r\n  /**\r\n   * Gather important bandwidth stats once a request has completed\r\n   *\r\n   * @param {Object} request - the XHR request from which to gather stats\r\n   */\r\n\r\n\r\n  var getRequestStats = function getRequestStats(request) {\r\n    return {\r\n      bandwidth: request.bandwidth,\r\n      bytesReceived: request.bytesReceived || 0,\r\n      roundTripTime: request.roundTripTime || 0\r\n    };\r\n  };\r\n  /**\r\n   * If possible gather bandwidth stats as a request is in\r\n   * progress\r\n   *\r\n   * @param {Event} progressEvent - an event object from an XHR's progress event\r\n   */\r\n\r\n\r\n  var getProgressStats = function getProgressStats(progressEvent) {\r\n    var request = progressEvent.target;\r\n    var roundTripTime = Date.now() - request.requestTime;\r\n    var stats = {\r\n      bandwidth: Infinity,\r\n      bytesReceived: 0,\r\n      roundTripTime: roundTripTime || 0\r\n    };\r\n    stats.bytesReceived = progressEvent.loaded; // This can result in Infinity if stats.roundTripTime is 0 but that is ok\r\n    // because we should only use bandwidth stats on progress to determine when\r\n    // abort a request early due to insufficient bandwidth\r\n\r\n    stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\r\n    return stats;\r\n  };\r\n  /**\r\n   * Handle all error conditions in one place and return an object\r\n   * with all the information\r\n   *\r\n   * @param {Error|null} error - if non-null signals an error occured with the XHR\r\n   * @param {Object} request -  the XHR request that possibly generated the error\r\n   */\r\n\r\n\r\n  var handleErrors = function handleErrors(error, request) {\r\n    if (request.timedout) {\r\n      return {\r\n        status: request.status,\r\n        message: 'HLS request timed-out at URL: ' + request.uri,\r\n        code: REQUEST_ERRORS.TIMEOUT,\r\n        xhr: request\r\n      };\r\n    }\r\n\r\n    if (request.aborted) {\r\n      return {\r\n        status: request.status,\r\n        message: 'HLS request aborted at URL: ' + request.uri,\r\n        code: REQUEST_ERRORS.ABORTED,\r\n        xhr: request\r\n      };\r\n    }\r\n\r\n    if (error) {\r\n      return {\r\n        status: request.status,\r\n        message: 'HLS request errored at URL: ' + request.uri,\r\n        code: REQUEST_ERRORS.FAILURE,\r\n        xhr: request\r\n      };\r\n    }\r\n\r\n    if (request.responseType === 'arraybuffer' && request.response.byteLength === 0) {\r\n      return {\r\n        status: request.status,\r\n        message: 'Empty HLS response at URL: ' + request.uri,\r\n        code: REQUEST_ERRORS.FAILURE,\r\n        xhr: request\r\n      };\r\n    }\r\n\r\n    return null;\r\n  };\r\n  /**\r\n   * Handle responses for key data and convert the key data to the correct format\r\n   * for the decryption step later\r\n   *\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   * @param {Array} objects - objects to add the key bytes to.\r\n   * @param {Function} finishProcessingFn - a callback to execute to continue processing\r\n   *                                        this request\r\n   */\r\n\r\n\r\n  var handleKeyResponse = function handleKeyResponse(segment, objects, finishProcessingFn) {\r\n    return function (error, request) {\r\n      var response = request.response;\r\n      var errorObj = handleErrors(error, request);\r\n\r\n      if (errorObj) {\r\n        return finishProcessingFn(errorObj, segment);\r\n      }\r\n\r\n      if (response.byteLength !== 16) {\r\n        return finishProcessingFn({\r\n          status: request.status,\r\n          message: 'Invalid HLS key at URL: ' + request.uri,\r\n          code: REQUEST_ERRORS.FAILURE,\r\n          xhr: request\r\n        }, segment);\r\n      }\r\n\r\n      var view = new DataView(response);\r\n      var bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\r\n\r\n      for (var i = 0; i < objects.length; i++) {\r\n        objects[i].bytes = bytes;\r\n      }\r\n\r\n      return finishProcessingFn(null, segment);\r\n    };\r\n  };\r\n\r\n  var parseInitSegment = function parseInitSegment(segment, _callback) {\r\n    var type = detectContainerForBytes(segment.map.bytes); // TODO: We should also handle ts init segments here, but we\r\n    // only know how to parse mp4 init segments at the moment\r\n\r\n    if (type !== 'mp4') {\r\n      var uri = segment.map.resolvedUri || segment.map.uri;\r\n      return _callback({\r\n        internal: true,\r\n        message: \"Found unsupported \" + (type || 'unknown') + \" container for initialization segment at URL: \" + uri,\r\n        code: REQUEST_ERRORS.FAILURE\r\n      });\r\n    }\r\n\r\n    workerCallback({\r\n      action: 'probeMp4Tracks',\r\n      data: segment.map.bytes,\r\n      transmuxer: segment.transmuxer,\r\n      callback: function callback(_ref) {\r\n        var tracks = _ref.tracks,\r\n            data = _ref.data; // transfer bytes back to us\r\n\r\n        segment.map.bytes = data;\r\n        tracks.forEach(function (track) {\r\n          segment.map.tracks = segment.map.tracks || {}; // only support one track of each type for now\r\n\r\n          if (segment.map.tracks[track.type]) {\r\n            return;\r\n          }\r\n\r\n          segment.map.tracks[track.type] = track;\r\n\r\n          if (typeof track.id === 'number' && track.timescale) {\r\n            segment.map.timescales = segment.map.timescales || {};\r\n            segment.map.timescales[track.id] = track.timescale;\r\n          }\r\n        });\r\n        return _callback(null);\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * Handle init-segment responses\r\n   *\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   * @param {Function} finishProcessingFn - a callback to execute to continue processing\r\n   *                                        this request\r\n   */\r\n\r\n\r\n  var handleInitSegmentResponse = function handleInitSegmentResponse(_ref2) {\r\n    var segment = _ref2.segment,\r\n        finishProcessingFn = _ref2.finishProcessingFn;\r\n    return function (error, request) {\r\n      var errorObj = handleErrors(error, request);\r\n\r\n      if (errorObj) {\r\n        return finishProcessingFn(errorObj, segment);\r\n      }\r\n\r\n      var bytes = new Uint8Array(request.response); // init segment is encypted, we will have to wait\r\n      // until the key request is done to decrypt.\r\n\r\n      if (segment.map.key) {\r\n        segment.map.encryptedBytes = bytes;\r\n        return finishProcessingFn(null, segment);\r\n      }\r\n\r\n      segment.map.bytes = bytes;\r\n      parseInitSegment(segment, function (parseError) {\r\n        if (parseError) {\r\n          parseError.xhr = request;\r\n          parseError.status = request.status;\r\n          return finishProcessingFn(parseError, segment);\r\n        }\r\n\r\n        finishProcessingFn(null, segment);\r\n      });\r\n    };\r\n  };\r\n  /**\r\n   * Response handler for segment-requests being sure to set the correct\r\n   * property depending on whether the segment is encryped or not\r\n   * Also records and keeps track of stats that are used for ABR purposes\r\n   *\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   * @param {Function} finishProcessingFn - a callback to execute to continue processing\r\n   *                                        this request\r\n   */\r\n\r\n\r\n  var handleSegmentResponse = function handleSegmentResponse(_ref3) {\r\n    var segment = _ref3.segment,\r\n        finishProcessingFn = _ref3.finishProcessingFn,\r\n        responseType = _ref3.responseType;\r\n    return function (error, request) {\r\n      var errorObj = handleErrors(error, request);\r\n\r\n      if (errorObj) {\r\n        return finishProcessingFn(errorObj, segment);\r\n      }\r\n\r\n      var newBytes = // although responseText \"should\" exist, this guard serves to prevent an error being\r\n      // thrown for two primary cases:\r\n      // 1. the mime type override stops working, or is not implemented for a specific\r\n      //    browser\r\n      // 2. when using mock XHR libraries like sinon that do not allow the override behavior\r\n      responseType === 'arraybuffer' || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));\r\n      segment.stats = getRequestStats(request);\r\n\r\n      if (segment.key) {\r\n        segment.encryptedBytes = new Uint8Array(newBytes);\r\n      } else {\r\n        segment.bytes = new Uint8Array(newBytes);\r\n      }\r\n\r\n      return finishProcessingFn(null, segment);\r\n    };\r\n  };\r\n\r\n  var transmuxAndNotify = function transmuxAndNotify(_ref4) {\r\n    var segment = _ref4.segment,\r\n        bytes = _ref4.bytes,\r\n        trackInfoFn = _ref4.trackInfoFn,\r\n        timingInfoFn = _ref4.timingInfoFn,\r\n        videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn,\r\n        audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn,\r\n        id3Fn = _ref4.id3Fn,\r\n        captionsFn = _ref4.captionsFn,\r\n        isEndOfTimeline = _ref4.isEndOfTimeline,\r\n        endedTimelineFn = _ref4.endedTimelineFn,\r\n        dataFn = _ref4.dataFn,\r\n        doneFn = _ref4.doneFn,\r\n        onTransmuxerLog = _ref4.onTransmuxerLog;\r\n    var fmp4Tracks = segment.map && segment.map.tracks || {};\r\n    var isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video); // Keep references to each function so we can null them out after we're done with them.\r\n    // One reason for this is that in the case of full segments, we want to trust start\r\n    // times from the probe, rather than the transmuxer.\r\n\r\n    var audioStartFn = timingInfoFn.bind(null, segment, 'audio', 'start');\r\n    var audioEndFn = timingInfoFn.bind(null, segment, 'audio', 'end');\r\n    var videoStartFn = timingInfoFn.bind(null, segment, 'video', 'start');\r\n    var videoEndFn = timingInfoFn.bind(null, segment, 'video', 'end');\r\n\r\n    var finish = function finish() {\r\n      return transmux({\r\n        bytes: bytes,\r\n        transmuxer: segment.transmuxer,\r\n        audioAppendStart: segment.audioAppendStart,\r\n        gopsToAlignWith: segment.gopsToAlignWith,\r\n        remux: isMuxed,\r\n        onData: function onData(result) {\r\n          result.type = result.type === 'combined' ? 'video' : result.type;\r\n          dataFn(segment, result);\r\n        },\r\n        onTrackInfo: function onTrackInfo(trackInfo) {\r\n          if (trackInfoFn) {\r\n            if (isMuxed) {\r\n              trackInfo.isMuxed = true;\r\n            }\r\n\r\n            trackInfoFn(segment, trackInfo);\r\n          }\r\n        },\r\n        onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {\r\n          // we only want the first start value we encounter\r\n          if (audioStartFn && typeof audioTimingInfo.start !== 'undefined') {\r\n            audioStartFn(audioTimingInfo.start);\r\n            audioStartFn = null;\r\n          } // we want to continually update the end time\r\n\r\n\r\n          if (audioEndFn && typeof audioTimingInfo.end !== 'undefined') {\r\n            audioEndFn(audioTimingInfo.end);\r\n          }\r\n        },\r\n        onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {\r\n          // we only want the first start value we encounter\r\n          if (videoStartFn && typeof videoTimingInfo.start !== 'undefined') {\r\n            videoStartFn(videoTimingInfo.start);\r\n            videoStartFn = null;\r\n          } // we want to continually update the end time\r\n\r\n\r\n          if (videoEndFn && typeof videoTimingInfo.end !== 'undefined') {\r\n            videoEndFn(videoTimingInfo.end);\r\n          }\r\n        },\r\n        onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {\r\n          videoSegmentTimingInfoFn(videoSegmentTimingInfo);\r\n        },\r\n        onAudioSegmentTimingInfo: function onAudioSegmentTimingInfo(audioSegmentTimingInfo) {\r\n          audioSegmentTimingInfoFn(audioSegmentTimingInfo);\r\n        },\r\n        onId3: function onId3(id3Frames, dispatchType) {\r\n          id3Fn(segment, id3Frames, dispatchType);\r\n        },\r\n        onCaptions: function onCaptions(captions) {\r\n          captionsFn(segment, [captions]);\r\n        },\r\n        isEndOfTimeline: isEndOfTimeline,\r\n        onEndedTimeline: function onEndedTimeline() {\r\n          endedTimelineFn();\r\n        },\r\n        onTransmuxerLog: onTransmuxerLog,\r\n        onDone: function onDone(result) {\r\n          if (!doneFn) {\r\n            return;\r\n          }\r\n\r\n          result.type = result.type === 'combined' ? 'video' : result.type;\r\n          doneFn(null, segment, result);\r\n        }\r\n      });\r\n    }; // In the transmuxer, we don't yet have the ability to extract a \"proper\" start time.\r\n    // Meaning cached frame data may corrupt our notion of where this segment\r\n    // really starts. To get around this, probe for the info needed.\r\n\r\n\r\n    workerCallback({\r\n      action: 'probeTs',\r\n      transmuxer: segment.transmuxer,\r\n      data: bytes,\r\n      baseStartTime: segment.baseStartTime,\r\n      callback: function callback(data) {\r\n        segment.bytes = bytes = data.data;\r\n        var probeResult = data.result;\r\n\r\n        if (probeResult) {\r\n          trackInfoFn(segment, {\r\n            hasAudio: probeResult.hasAudio,\r\n            hasVideo: probeResult.hasVideo,\r\n            isMuxed: isMuxed\r\n          });\r\n          trackInfoFn = null;\r\n\r\n          if (probeResult.hasAudio && !isMuxed) {\r\n            audioStartFn(probeResult.audioStart);\r\n          }\r\n\r\n          if (probeResult.hasVideo) {\r\n            videoStartFn(probeResult.videoStart);\r\n          }\r\n\r\n          audioStartFn = null;\r\n          videoStartFn = null;\r\n        }\r\n\r\n        finish();\r\n      }\r\n    });\r\n  };\r\n\r\n  var handleSegmentBytes = function handleSegmentBytes(_ref5) {\r\n    var segment = _ref5.segment,\r\n        bytes = _ref5.bytes,\r\n        trackInfoFn = _ref5.trackInfoFn,\r\n        timingInfoFn = _ref5.timingInfoFn,\r\n        videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn,\r\n        audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn,\r\n        id3Fn = _ref5.id3Fn,\r\n        captionsFn = _ref5.captionsFn,\r\n        isEndOfTimeline = _ref5.isEndOfTimeline,\r\n        endedTimelineFn = _ref5.endedTimelineFn,\r\n        dataFn = _ref5.dataFn,\r\n        doneFn = _ref5.doneFn,\r\n        onTransmuxerLog = _ref5.onTransmuxerLog;\r\n    var bytesAsUint8Array = new Uint8Array(bytes); // TODO:\r\n    // We should have a handler that fetches the number of bytes required\r\n    // to check if something is fmp4. This will allow us to save bandwidth\r\n    // because we can only blacklist a playlist and abort requests\r\n    // by codec after trackinfo triggers.\r\n\r\n    if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {\r\n      segment.isFmp4 = true;\r\n      var tracks = segment.map.tracks;\r\n      var trackInfo = {\r\n        isFmp4: true,\r\n        hasVideo: !!tracks.video,\r\n        hasAudio: !!tracks.audio\r\n      }; // if we have a audio track, with a codec that is not set to\r\n      // encrypted audio\r\n\r\n      if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== 'enca') {\r\n        trackInfo.audioCodec = tracks.audio.codec;\r\n      } // if we have a video track, with a codec that is not set to\r\n      // encrypted video\r\n\r\n\r\n      if (tracks.video && tracks.video.codec && tracks.video.codec !== 'encv') {\r\n        trackInfo.videoCodec = tracks.video.codec;\r\n      }\r\n\r\n      if (tracks.video && tracks.audio) {\r\n        trackInfo.isMuxed = true;\r\n      } // since we don't support appending fmp4 data on progress, we know we have the full\r\n      // segment here\r\n\r\n\r\n      trackInfoFn(segment, trackInfo); // The probe doesn't provide the segment end time, so only callback with the start\r\n      // time. The end time can be roughly calculated by the receiver using the duration.\r\n      //\r\n      // Note that the start time returned by the probe reflects the baseMediaDecodeTime, as\r\n      // that is the true start of the segment (where the playback engine should begin\r\n      // decoding).\r\n\r\n      var finishLoading = function finishLoading(captions) {\r\n        // if the track still has audio at this point it is only possible\r\n        // for it to be audio only. See `tracks.video && tracks.audio` if statement\r\n        // above.\r\n        // we make sure to use segment.bytes here as that\r\n        dataFn(segment, {\r\n          data: bytesAsUint8Array,\r\n          type: trackInfo.hasAudio && !trackInfo.isMuxed ? 'audio' : 'video'\r\n        });\r\n\r\n        if (captions && captions.length) {\r\n          captionsFn(segment, captions);\r\n        }\r\n\r\n        doneFn(null, segment, {});\r\n      };\r\n\r\n      workerCallback({\r\n        action: 'probeMp4StartTime',\r\n        timescales: segment.map.timescales,\r\n        data: bytesAsUint8Array,\r\n        transmuxer: segment.transmuxer,\r\n        callback: function callback(_ref6) {\r\n          var data = _ref6.data,\r\n              startTime = _ref6.startTime; // transfer bytes back to us\r\n\r\n          bytes = data.buffer;\r\n          segment.bytes = bytesAsUint8Array = data;\r\n\r\n          if (trackInfo.hasAudio && !trackInfo.isMuxed) {\r\n            timingInfoFn(segment, 'audio', 'start', startTime);\r\n          }\r\n\r\n          if (trackInfo.hasVideo) {\r\n            timingInfoFn(segment, 'video', 'start', startTime);\r\n          } // Run through the CaptionParser in case there are captions.\r\n          // Initialize CaptionParser if it hasn't been yet\r\n\r\n\r\n          if (!tracks.video || !data.byteLength || !segment.transmuxer) {\r\n            finishLoading();\r\n            return;\r\n          }\r\n\r\n          workerCallback({\r\n            action: 'pushMp4Captions',\r\n            endAction: 'mp4Captions',\r\n            transmuxer: segment.transmuxer,\r\n            data: bytesAsUint8Array,\r\n            timescales: segment.map.timescales,\r\n            trackIds: [tracks.video.id],\r\n            callback: function callback(message) {\r\n              // transfer bytes back to us\r\n              bytes = message.data.buffer;\r\n              segment.bytes = bytesAsUint8Array = message.data;\r\n              message.logs.forEach(function (log) {\r\n                onTransmuxerLog(videojs.mergeOptions(log, {\r\n                  stream: 'mp4CaptionParser'\r\n                }));\r\n              });\r\n              finishLoading(message.captions);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      return;\r\n    } // VTT or other segments that don't need processing\r\n\r\n\r\n    if (!segment.transmuxer) {\r\n      doneFn(null, segment, {});\r\n      return;\r\n    }\r\n\r\n    if (typeof segment.container === 'undefined') {\r\n      segment.container = detectContainerForBytes(bytesAsUint8Array);\r\n    }\r\n\r\n    if (segment.container !== 'ts' && segment.container !== 'aac') {\r\n      trackInfoFn(segment, {\r\n        hasAudio: false,\r\n        hasVideo: false\r\n      });\r\n      doneFn(null, segment, {});\r\n      return;\r\n    } // ts or aac\r\n\r\n\r\n    transmuxAndNotify({\r\n      segment: segment,\r\n      bytes: bytes,\r\n      trackInfoFn: trackInfoFn,\r\n      timingInfoFn: timingInfoFn,\r\n      videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\r\n      audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,\r\n      id3Fn: id3Fn,\r\n      captionsFn: captionsFn,\r\n      isEndOfTimeline: isEndOfTimeline,\r\n      endedTimelineFn: endedTimelineFn,\r\n      dataFn: dataFn,\r\n      doneFn: doneFn,\r\n      onTransmuxerLog: onTransmuxerLog\r\n    });\r\n  };\r\n\r\n  var decrypt = function decrypt(_ref7, callback) {\r\n    var id = _ref7.id,\r\n        key = _ref7.key,\r\n        encryptedBytes = _ref7.encryptedBytes,\r\n        decryptionWorker = _ref7.decryptionWorker;\r\n\r\n    var decryptionHandler = function decryptionHandler(event) {\r\n      if (event.data.source === id) {\r\n        decryptionWorker.removeEventListener('message', decryptionHandler);\r\n        var decrypted = event.data.decrypted;\r\n        callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));\r\n      }\r\n    };\r\n\r\n    decryptionWorker.addEventListener('message', decryptionHandler);\r\n    var keyBytes;\r\n\r\n    if (key.bytes.slice) {\r\n      keyBytes = key.bytes.slice();\r\n    } else {\r\n      keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));\r\n    } // incrementally decrypt the bytes\r\n\r\n\r\n    decryptionWorker.postMessage(createTransferableMessage({\r\n      source: id,\r\n      encrypted: encryptedBytes,\r\n      key: keyBytes,\r\n      iv: key.iv\r\n    }), [encryptedBytes.buffer, keyBytes.buffer]);\r\n  };\r\n  /**\r\n   * Decrypt the segment via the decryption web worker\r\n   *\r\n   * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\r\n   *                                       routines\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   * @param {Function} trackInfoFn - a callback that receives track info\r\n   * @param {Function} timingInfoFn - a callback that receives timing info\r\n   * @param {Function} videoSegmentTimingInfoFn\r\n   *                   a callback that receives video timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {Function} audioSegmentTimingInfoFn\r\n   *                   a callback that receives audio timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {boolean}  isEndOfTimeline\r\n   *                   true if this segment represents the last segment in a timeline\r\n   * @param {Function} endedTimelineFn\r\n   *                   a callback made when a timeline is ended, will only be called if\r\n   *                   isEndOfTimeline is true\r\n   * @param {Function} dataFn - a callback that is executed when segment bytes are available\r\n   *                            and ready to use\r\n   * @param {Function} doneFn - a callback that is executed after decryption has completed\r\n   */\r\n\r\n\r\n  var decryptSegment = function decryptSegment(_ref8) {\r\n    var decryptionWorker = _ref8.decryptionWorker,\r\n        segment = _ref8.segment,\r\n        trackInfoFn = _ref8.trackInfoFn,\r\n        timingInfoFn = _ref8.timingInfoFn,\r\n        videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn,\r\n        audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn,\r\n        id3Fn = _ref8.id3Fn,\r\n        captionsFn = _ref8.captionsFn,\r\n        isEndOfTimeline = _ref8.isEndOfTimeline,\r\n        endedTimelineFn = _ref8.endedTimelineFn,\r\n        dataFn = _ref8.dataFn,\r\n        doneFn = _ref8.doneFn,\r\n        onTransmuxerLog = _ref8.onTransmuxerLog;\r\n    decrypt({\r\n      id: segment.requestId,\r\n      key: segment.key,\r\n      encryptedBytes: segment.encryptedBytes,\r\n      decryptionWorker: decryptionWorker\r\n    }, function (decryptedBytes) {\r\n      segment.bytes = decryptedBytes;\r\n      handleSegmentBytes({\r\n        segment: segment,\r\n        bytes: segment.bytes,\r\n        trackInfoFn: trackInfoFn,\r\n        timingInfoFn: timingInfoFn,\r\n        videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\r\n        audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,\r\n        id3Fn: id3Fn,\r\n        captionsFn: captionsFn,\r\n        isEndOfTimeline: isEndOfTimeline,\r\n        endedTimelineFn: endedTimelineFn,\r\n        dataFn: dataFn,\r\n        doneFn: doneFn,\r\n        onTransmuxerLog: onTransmuxerLog\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * This function waits for all XHRs to finish (with either success or failure)\r\n   * before continueing processing via it's callback. The function gathers errors\r\n   * from each request into a single errors array so that the error status for\r\n   * each request can be examined later.\r\n   *\r\n   * @param {Object} activeXhrs - an object that tracks all XHR requests\r\n   * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\r\n   *                                       routines\r\n   * @param {Function} trackInfoFn - a callback that receives track info\r\n   * @param {Function} timingInfoFn - a callback that receives timing info\r\n   * @param {Function} videoSegmentTimingInfoFn\r\n   *                   a callback that receives video timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {Function} audioSegmentTimingInfoFn\r\n   *                   a callback that receives audio timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {Function} id3Fn - a callback that receives ID3 metadata\r\n   * @param {Function} captionsFn - a callback that receives captions\r\n   * @param {boolean}  isEndOfTimeline\r\n   *                   true if this segment represents the last segment in a timeline\r\n   * @param {Function} endedTimelineFn\r\n   *                   a callback made when a timeline is ended, will only be called if\r\n   *                   isEndOfTimeline is true\r\n   * @param {Function} dataFn - a callback that is executed when segment bytes are available\r\n   *                            and ready to use\r\n   * @param {Function} doneFn - a callback that is executed after all resources have been\r\n   *                            downloaded and any decryption completed\r\n   */\r\n\r\n\r\n  var waitForCompletion = function waitForCompletion(_ref9) {\r\n    var activeXhrs = _ref9.activeXhrs,\r\n        decryptionWorker = _ref9.decryptionWorker,\r\n        trackInfoFn = _ref9.trackInfoFn,\r\n        timingInfoFn = _ref9.timingInfoFn,\r\n        videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn,\r\n        audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn,\r\n        id3Fn = _ref9.id3Fn,\r\n        captionsFn = _ref9.captionsFn,\r\n        isEndOfTimeline = _ref9.isEndOfTimeline,\r\n        endedTimelineFn = _ref9.endedTimelineFn,\r\n        dataFn = _ref9.dataFn,\r\n        doneFn = _ref9.doneFn,\r\n        onTransmuxerLog = _ref9.onTransmuxerLog;\r\n    var count = 0;\r\n    var didError = false;\r\n    return function (error, segment) {\r\n      if (didError) {\r\n        return;\r\n      }\r\n\r\n      if (error) {\r\n        didError = true; // If there are errors, we have to abort any outstanding requests\r\n\r\n        abortAll(activeXhrs); // Even though the requests above are aborted, and in theory we could wait until we\r\n        // handle the aborted events from those requests, there are some cases where we may\r\n        // never get an aborted event. For instance, if the network connection is lost and\r\n        // there were two requests, the first may have triggered an error immediately, while\r\n        // the second request remains unsent. In that case, the aborted algorithm will not\r\n        // trigger an abort: see https://xhr.spec.whatwg.org/#the-abort()-method\r\n        //\r\n        // We also can't rely on the ready state of the XHR, since the request that\r\n        // triggered the connection error may also show as a ready state of 0 (unsent).\r\n        // Therefore, we have to finish this group of requests immediately after the first\r\n        // seen error.\r\n\r\n        return doneFn(error, segment);\r\n      }\r\n\r\n      count += 1;\r\n\r\n      if (count === activeXhrs.length) {\r\n        var segmentFinish = function segmentFinish() {\r\n          if (segment.encryptedBytes) {\r\n            return decryptSegment({\r\n              decryptionWorker: decryptionWorker,\r\n              segment: segment,\r\n              trackInfoFn: trackInfoFn,\r\n              timingInfoFn: timingInfoFn,\r\n              videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\r\n              audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,\r\n              id3Fn: id3Fn,\r\n              captionsFn: captionsFn,\r\n              isEndOfTimeline: isEndOfTimeline,\r\n              endedTimelineFn: endedTimelineFn,\r\n              dataFn: dataFn,\r\n              doneFn: doneFn,\r\n              onTransmuxerLog: onTransmuxerLog\r\n            });\r\n          } // Otherwise, everything is ready just continue\r\n\r\n\r\n          handleSegmentBytes({\r\n            segment: segment,\r\n            bytes: segment.bytes,\r\n            trackInfoFn: trackInfoFn,\r\n            timingInfoFn: timingInfoFn,\r\n            videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\r\n            audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,\r\n            id3Fn: id3Fn,\r\n            captionsFn: captionsFn,\r\n            isEndOfTimeline: isEndOfTimeline,\r\n            endedTimelineFn: endedTimelineFn,\r\n            dataFn: dataFn,\r\n            doneFn: doneFn,\r\n            onTransmuxerLog: onTransmuxerLog\r\n          });\r\n        }; // Keep track of when *all* of the requests have completed\r\n\r\n\r\n        segment.endOfAllRequests = Date.now();\r\n\r\n        if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {\r\n          return decrypt({\r\n            decryptionWorker: decryptionWorker,\r\n            // add -init to the \"id\" to differentiate between segment\r\n            // and init segment decryption, just in case they happen\r\n            // at the same time at some point in the future.\r\n            id: segment.requestId + '-init',\r\n            encryptedBytes: segment.map.encryptedBytes,\r\n            key: segment.map.key\r\n          }, function (decryptedBytes) {\r\n            segment.map.bytes = decryptedBytes;\r\n            parseInitSegment(segment, function (parseError) {\r\n              if (parseError) {\r\n                abortAll(activeXhrs);\r\n                return doneFn(parseError, segment);\r\n              }\r\n\r\n              segmentFinish();\r\n            });\r\n          });\r\n        }\r\n\r\n        segmentFinish();\r\n      }\r\n    };\r\n  };\r\n  /**\r\n   * Calls the abort callback if any request within the batch was aborted. Will only call\r\n   * the callback once per batch of requests, even if multiple were aborted.\r\n   *\r\n   * @param {Object} loadendState - state to check to see if the abort function was called\r\n   * @param {Function} abortFn - callback to call for abort\r\n   */\r\n\r\n\r\n  var handleLoadEnd = function handleLoadEnd(_ref10) {\r\n    var loadendState = _ref10.loadendState,\r\n        abortFn = _ref10.abortFn;\r\n    return function (event) {\r\n      var request = event.target;\r\n\r\n      if (request.aborted && abortFn && !loadendState.calledAbortFn) {\r\n        abortFn();\r\n        loadendState.calledAbortFn = true;\r\n      }\r\n    };\r\n  };\r\n  /**\r\n   * Simple progress event callback handler that gathers some stats before\r\n   * executing a provided callback with the `segment` object\r\n   *\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   * @param {Function} progressFn - a callback that is executed each time a progress event\r\n   *                                is received\r\n   * @param {Function} trackInfoFn - a callback that receives track info\r\n   * @param {Function} timingInfoFn - a callback that receives timing info\r\n   * @param {Function} videoSegmentTimingInfoFn\r\n   *                   a callback that receives video timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {Function} audioSegmentTimingInfoFn\r\n   *                   a callback that receives audio timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {boolean}  isEndOfTimeline\r\n   *                   true if this segment represents the last segment in a timeline\r\n   * @param {Function} endedTimelineFn\r\n   *                   a callback made when a timeline is ended, will only be called if\r\n   *                   isEndOfTimeline is true\r\n   * @param {Function} dataFn - a callback that is executed when segment bytes are available\r\n   *                            and ready to use\r\n   * @param {Event} event - the progress event object from XMLHttpRequest\r\n   */\r\n\r\n\r\n  var handleProgress = function handleProgress(_ref11) {\r\n    var segment = _ref11.segment,\r\n        progressFn = _ref11.progressFn;\r\n    _ref11.trackInfoFn;\r\n    _ref11.timingInfoFn;\r\n    _ref11.videoSegmentTimingInfoFn;\r\n    _ref11.audioSegmentTimingInfoFn;\r\n    _ref11.id3Fn;\r\n    _ref11.captionsFn;\r\n    _ref11.isEndOfTimeline;\r\n    _ref11.endedTimelineFn;\r\n    _ref11.dataFn;\r\n    return function (event) {\r\n      var request = event.target;\r\n\r\n      if (request.aborted) {\r\n        return;\r\n      }\r\n\r\n      segment.stats = videojs.mergeOptions(segment.stats, getProgressStats(event)); // record the time that we receive the first byte of data\r\n\r\n      if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\r\n        segment.stats.firstBytesReceivedAt = Date.now();\r\n      }\r\n\r\n      return progressFn(event, segment);\r\n    };\r\n  };\r\n  /**\r\n   * Load all resources and does any processing necessary for a media-segment\r\n   *\r\n   * Features:\r\n   *   decrypts the media-segment if it has a key uri and an iv\r\n   *   aborts *all* requests if *any* one request fails\r\n   *\r\n   * The segment object, at minimum, has the following format:\r\n   * {\r\n   *   resolvedUri: String,\r\n   *   [transmuxer]: Object,\r\n   *   [byterange]: {\r\n   *     offset: Number,\r\n   *     length: Number\r\n   *   },\r\n   *   [key]: {\r\n   *     resolvedUri: String\r\n   *     [byterange]: {\r\n   *       offset: Number,\r\n   *       length: Number\r\n   *     },\r\n   *     iv: {\r\n   *       bytes: Uint32Array\r\n   *     }\r\n   *   },\r\n   *   [map]: {\r\n   *     resolvedUri: String,\r\n   *     [byterange]: {\r\n   *       offset: Number,\r\n   *       length: Number\r\n   *     },\r\n   *     [bytes]: Uint8Array\r\n   *   }\r\n   * }\r\n   * ...where [name] denotes optional properties\r\n   *\r\n   * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\r\n   * @param {Object} xhrOptions - the base options to provide to all xhr requests\r\n   * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\r\n   *                                       decryption routines\r\n   * @param {Object} segment - a simplified copy of the segmentInfo object\r\n   *                           from SegmentLoader\r\n   * @param {Function} abortFn - a callback called (only once) if any piece of a request was\r\n   *                             aborted\r\n   * @param {Function} progressFn - a callback that receives progress events from the main\r\n   *                                segment's xhr request\r\n   * @param {Function} trackInfoFn - a callback that receives track info\r\n   * @param {Function} timingInfoFn - a callback that receives timing info\r\n   * @param {Function} videoSegmentTimingInfoFn\r\n   *                   a callback that receives video timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {Function} audioSegmentTimingInfoFn\r\n   *                   a callback that receives audio timing info based on media times and\r\n   *                   any adjustments made by the transmuxer\r\n   * @param {Function} id3Fn - a callback that receives ID3 metadata\r\n   * @param {Function} captionsFn - a callback that receives captions\r\n   * @param {boolean}  isEndOfTimeline\r\n   *                   true if this segment represents the last segment in a timeline\r\n   * @param {Function} endedTimelineFn\r\n   *                   a callback made when a timeline is ended, will only be called if\r\n   *                   isEndOfTimeline is true\r\n   * @param {Function} dataFn - a callback that receives data from the main segment's xhr\r\n   *                            request, transmuxed if needed\r\n   * @param {Function} doneFn - a callback that is executed only once all requests have\r\n   *                            succeeded or failed\r\n   * @return {Function} a function that, when invoked, immediately aborts all\r\n   *                     outstanding requests\r\n   */\r\n\r\n\r\n  var mediaSegmentRequest = function mediaSegmentRequest(_ref12) {\r\n    var xhr = _ref12.xhr,\r\n        xhrOptions = _ref12.xhrOptions,\r\n        decryptionWorker = _ref12.decryptionWorker,\r\n        segment = _ref12.segment,\r\n        abortFn = _ref12.abortFn,\r\n        progressFn = _ref12.progressFn,\r\n        trackInfoFn = _ref12.trackInfoFn,\r\n        timingInfoFn = _ref12.timingInfoFn,\r\n        videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn,\r\n        audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn,\r\n        id3Fn = _ref12.id3Fn,\r\n        captionsFn = _ref12.captionsFn,\r\n        isEndOfTimeline = _ref12.isEndOfTimeline,\r\n        endedTimelineFn = _ref12.endedTimelineFn,\r\n        dataFn = _ref12.dataFn,\r\n        doneFn = _ref12.doneFn,\r\n        onTransmuxerLog = _ref12.onTransmuxerLog;\r\n    var activeXhrs = [];\r\n    var finishProcessingFn = waitForCompletion({\r\n      activeXhrs: activeXhrs,\r\n      decryptionWorker: decryptionWorker,\r\n      trackInfoFn: trackInfoFn,\r\n      timingInfoFn: timingInfoFn,\r\n      videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\r\n      audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,\r\n      id3Fn: id3Fn,\r\n      captionsFn: captionsFn,\r\n      isEndOfTimeline: isEndOfTimeline,\r\n      endedTimelineFn: endedTimelineFn,\r\n      dataFn: dataFn,\r\n      doneFn: doneFn,\r\n      onTransmuxerLog: onTransmuxerLog\r\n    }); // optionally, request the decryption key\r\n\r\n    if (segment.key && !segment.key.bytes) {\r\n      var objects = [segment.key];\r\n\r\n      if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {\r\n        objects.push(segment.map.key);\r\n      }\r\n\r\n      var keyRequestOptions = videojs.mergeOptions(xhrOptions, {\r\n        uri: segment.key.resolvedUri,\r\n        responseType: 'arraybuffer'\r\n      });\r\n      var keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);\r\n      var keyXhr = xhr(keyRequestOptions, keyRequestCallback);\r\n      activeXhrs.push(keyXhr);\r\n    } // optionally, request the associated media init segment\r\n\r\n\r\n    if (segment.map && !segment.map.bytes) {\r\n      var differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);\r\n\r\n      if (differentMapKey) {\r\n        var mapKeyRequestOptions = videojs.mergeOptions(xhrOptions, {\r\n          uri: segment.map.key.resolvedUri,\r\n          responseType: 'arraybuffer'\r\n        });\r\n        var mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);\r\n        var mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);\r\n        activeXhrs.push(mapKeyXhr);\r\n      }\r\n\r\n      var initSegmentOptions = videojs.mergeOptions(xhrOptions, {\r\n        uri: segment.map.resolvedUri,\r\n        responseType: 'arraybuffer',\r\n        headers: segmentXhrHeaders(segment.map)\r\n      });\r\n      var initSegmentRequestCallback = handleInitSegmentResponse({\r\n        segment: segment,\r\n        finishProcessingFn: finishProcessingFn\r\n      });\r\n      var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\r\n      activeXhrs.push(initSegmentXhr);\r\n    }\r\n\r\n    var segmentRequestOptions = videojs.mergeOptions(xhrOptions, {\r\n      uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,\r\n      responseType: 'arraybuffer',\r\n      headers: segmentXhrHeaders(segment)\r\n    });\r\n    var segmentRequestCallback = handleSegmentResponse({\r\n      segment: segment,\r\n      finishProcessingFn: finishProcessingFn,\r\n      responseType: segmentRequestOptions.responseType\r\n    });\r\n    var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\r\n    segmentXhr.addEventListener('progress', handleProgress({\r\n      segment: segment,\r\n      progressFn: progressFn,\r\n      trackInfoFn: trackInfoFn,\r\n      timingInfoFn: timingInfoFn,\r\n      videoSegmentTimingInfoFn: videoSegmentTimingInfoFn,\r\n      audioSegmentTimingInfoFn: audioSegmentTimingInfoFn,\r\n      id3Fn: id3Fn,\r\n      captionsFn: captionsFn,\r\n      isEndOfTimeline: isEndOfTimeline,\r\n      endedTimelineFn: endedTimelineFn,\r\n      dataFn: dataFn\r\n    }));\r\n    activeXhrs.push(segmentXhr); // since all parts of the request must be considered, but should not make callbacks\r\n    // multiple times, provide a shared state object\r\n\r\n    var loadendState = {};\r\n    activeXhrs.forEach(function (activeXhr) {\r\n      activeXhr.addEventListener('loadend', handleLoadEnd({\r\n        loadendState: loadendState,\r\n        abortFn: abortFn\r\n      }));\r\n    });\r\n    return function () {\r\n      return abortAll(activeXhrs);\r\n    };\r\n  };\r\n  /**\r\n   * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\r\n   * codec strings, or translating codec strings into objects that can be examined.\r\n   */\r\n\r\n\r\n  var logFn$1 = logger('CodecUtils');\r\n  /**\r\n   * Returns a set of codec strings parsed from the playlist or the default\r\n   * codec strings if no codecs were specified in the playlist\r\n   *\r\n   * @param {Playlist} media the current media playlist\r\n   * @return {Object} an object with the video and audio codecs\r\n   */\r\n\r\n  var getCodecs = function getCodecs(media) {\r\n    // if the codecs were explicitly specified, use them instead of the\r\n    // defaults\r\n    var mediaAttributes = media.attributes || {};\r\n\r\n    if (mediaAttributes.CODECS) {\r\n      return parseCodecs(mediaAttributes.CODECS);\r\n    }\r\n  };\r\n\r\n  var isMaat = function isMaat(master, media) {\r\n    var mediaAttributes = media.attributes || {};\r\n    return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\r\n  };\r\n\r\n  var isMuxed = function isMuxed(master, media) {\r\n    if (!isMaat(master, media)) {\r\n      return true;\r\n    }\r\n\r\n    var mediaAttributes = media.attributes || {};\r\n    var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\r\n\r\n    for (var groupId in audioGroup) {\r\n      // If an audio group has a URI (the case for HLS, as HLS will use external playlists),\r\n      // or there are listed playlists (the case for DASH, as the manifest will have already\r\n      // provided all of the details necessary to generate the audio playlist, as opposed to\r\n      // HLS' externally requested playlists), then the content is demuxed.\r\n      if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  var unwrapCodecList = function unwrapCodecList(codecList) {\r\n    var codecs = {};\r\n    codecList.forEach(function (_ref) {\r\n      var mediaType = _ref.mediaType,\r\n          type = _ref.type,\r\n          details = _ref.details;\r\n      codecs[mediaType] = codecs[mediaType] || [];\r\n      codecs[mediaType].push(translateLegacyCodec(\"\" + type + details));\r\n    });\r\n    Object.keys(codecs).forEach(function (mediaType) {\r\n      if (codecs[mediaType].length > 1) {\r\n        logFn$1(\"multiple \" + mediaType + \" codecs found as attributes: \" + codecs[mediaType].join(', ') + \". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.\");\r\n        codecs[mediaType] = null;\r\n        return;\r\n      }\r\n\r\n      codecs[mediaType] = codecs[mediaType][0];\r\n    });\r\n    return codecs;\r\n  };\r\n\r\n  var codecCount = function codecCount(codecObj) {\r\n    var count = 0;\r\n\r\n    if (codecObj.audio) {\r\n      count++;\r\n    }\r\n\r\n    if (codecObj.video) {\r\n      count++;\r\n    }\r\n\r\n    return count;\r\n  };\r\n  /**\r\n   * Calculates the codec strings for a working configuration of\r\n   * SourceBuffers to play variant streams in a master playlist. If\r\n   * there is no possible working configuration, an empty object will be\r\n   * returned.\r\n   *\r\n   * @param master {Object} the m3u8 object for the master playlist\r\n   * @param media {Object} the m3u8 object for the variant playlist\r\n   * @return {Object} the codec strings.\r\n   *\r\n   * @private\r\n   */\r\n\r\n\r\n  var codecsForPlaylist = function codecsForPlaylist(master, media) {\r\n    var mediaAttributes = media.attributes || {};\r\n    var codecInfo = unwrapCodecList(getCodecs(media) || []); // HLS with multiple-audio tracks must always get an audio codec.\r\n    // Put another way, there is no way to have a video-only multiple-audio HLS!\r\n\r\n    if (isMaat(master, media) && !codecInfo.audio) {\r\n      if (!isMuxed(master, media)) {\r\n        // It is possible for codecs to be specified on the audio media group playlist but\r\n        // not on the rendition playlist. This is mostly the case for DASH, where audio and\r\n        // video are always separate (and separately specified).\r\n        var defaultCodecs = unwrapCodecList(codecsFromDefault(master, mediaAttributes.AUDIO) || []);\r\n\r\n        if (defaultCodecs.audio) {\r\n          codecInfo.audio = defaultCodecs.audio;\r\n        }\r\n      }\r\n    }\r\n\r\n    return codecInfo;\r\n  };\r\n\r\n  var logFn = logger('PlaylistSelector');\r\n\r\n  var representationToString = function representationToString(representation) {\r\n    if (!representation || !representation.playlist) {\r\n      return;\r\n    }\r\n\r\n    var playlist = representation.playlist;\r\n    return JSON.stringify({\r\n      id: playlist.id,\r\n      bandwidth: representation.bandwidth,\r\n      width: representation.width,\r\n      height: representation.height,\r\n      codecs: playlist.attributes && playlist.attributes.CODECS || ''\r\n    });\r\n  }; // Utilities\r\n\r\n  /**\r\n   * Returns the CSS value for the specified property on an element\r\n   * using `getComputedStyle`. Firefox has a long-standing issue where\r\n   * getComputedStyle() may return null when running in an iframe with\r\n   * `display: none`.\r\n   *\r\n   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\r\n   * @param {HTMLElement} el the htmlelement to work on\r\n   * @param {string} the proprety to get the style for\r\n   */\r\n\r\n\r\n  var safeGetComputedStyle = function safeGetComputedStyle(el, property) {\r\n    if (!el) {\r\n      return '';\r\n    }\r\n\r\n    var result = window.getComputedStyle(el);\r\n\r\n    if (!result) {\r\n      return '';\r\n    }\r\n\r\n    return result[property];\r\n  };\r\n  /**\r\n   * Resuable stable sort function\r\n   *\r\n   * @param {Playlists} array\r\n   * @param {Function} sortFn Different comparators\r\n   * @function stableSort\r\n   */\r\n\r\n\r\n  var stableSort = function stableSort(array, sortFn) {\r\n    var newArray = array.slice();\r\n    array.sort(function (left, right) {\r\n      var cmp = sortFn(left, right);\r\n\r\n      if (cmp === 0) {\r\n        return newArray.indexOf(left) - newArray.indexOf(right);\r\n      }\r\n\r\n      return cmp;\r\n    });\r\n  };\r\n  /**\r\n   * A comparator function to sort two playlist object by bandwidth.\r\n   *\r\n   * @param {Object} left a media playlist object\r\n   * @param {Object} right a media playlist object\r\n   * @return {number} Greater than zero if the bandwidth attribute of\r\n   * left is greater than the corresponding attribute of right. Less\r\n   * than zero if the bandwidth of right is greater than left and\r\n   * exactly zero if the two are equal.\r\n   */\r\n\r\n\r\n  var comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {\r\n    var leftBandwidth;\r\n    var rightBandwidth;\r\n\r\n    if (left.attributes.BANDWIDTH) {\r\n      leftBandwidth = left.attributes.BANDWIDTH;\r\n    }\r\n\r\n    leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\r\n\r\n    if (right.attributes.BANDWIDTH) {\r\n      rightBandwidth = right.attributes.BANDWIDTH;\r\n    }\r\n\r\n    rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\r\n    return leftBandwidth - rightBandwidth;\r\n  };\r\n  /**\r\n   * A comparator function to sort two playlist object by resolution (width).\r\n   *\r\n   * @param {Object} left a media playlist object\r\n   * @param {Object} right a media playlist object\r\n   * @return {number} Greater than zero if the resolution.width attribute of\r\n   * left is greater than the corresponding attribute of right. Less\r\n   * than zero if the resolution.width of right is greater than left and\r\n   * exactly zero if the two are equal.\r\n   */\r\n\r\n\r\n  var comparePlaylistResolution = function comparePlaylistResolution(left, right) {\r\n    var leftWidth;\r\n    var rightWidth;\r\n\r\n    if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\r\n      leftWidth = left.attributes.RESOLUTION.width;\r\n    }\r\n\r\n    leftWidth = leftWidth || window.Number.MAX_VALUE;\r\n\r\n    if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\r\n      rightWidth = right.attributes.RESOLUTION.width;\r\n    }\r\n\r\n    rightWidth = rightWidth || window.Number.MAX_VALUE; // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\r\n    // have the same media dimensions/ resolution\r\n\r\n    if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\r\n      return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\r\n    }\r\n\r\n    return leftWidth - rightWidth;\r\n  };\r\n  /**\r\n   * Chooses the appropriate media playlist based on bandwidth and player size\r\n   *\r\n   * @param {Object} master\r\n   *        Object representation of the master manifest\r\n   * @param {number} playerBandwidth\r\n   *        Current calculated bandwidth of the player\r\n   * @param {number} playerWidth\r\n   *        Current width of the player element (should account for the device pixel ratio)\r\n   * @param {number} playerHeight\r\n   *        Current height of the player element (should account for the device pixel ratio)\r\n   * @param {boolean} limitRenditionByPlayerDimensions\r\n   *        True if the player width and height should be used during the selection, false otherwise\r\n   * @param {Object} masterPlaylistController\r\n   *        the current masterPlaylistController object\r\n   * @return {Playlist} the highest bitrate playlist less than the\r\n   * currently detected bandwidth, accounting for some amount of\r\n   * bandwidth variance\r\n   */\r\n\r\n\r\n  var simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {\r\n    // If we end up getting called before `master` is available, exit early\r\n    if (!master) {\r\n      return;\r\n    }\r\n\r\n    var options = {\r\n      bandwidth: playerBandwidth,\r\n      width: playerWidth,\r\n      height: playerHeight,\r\n      limitRenditionByPlayerDimensions: limitRenditionByPlayerDimensions\r\n    };\r\n    var playlists = master.playlists; // if playlist is audio only, select between currently active audio group playlists.\r\n\r\n    if (Playlist.isAudioOnly(master)) {\r\n      playlists = masterPlaylistController.getAudioTrackPlaylists_(); // add audioOnly to options so that we log audioOnly: true\r\n      // at the buttom of this function for debugging.\r\n\r\n      options.audioOnly = true;\r\n    } // convert the playlists to an intermediary representation to make comparisons easier\r\n\r\n\r\n    var sortedPlaylistReps = playlists.map(function (playlist) {\r\n      var bandwidth;\r\n      var width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\r\n      var height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\r\n      bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;\r\n      bandwidth = bandwidth || window.Number.MAX_VALUE;\r\n      return {\r\n        bandwidth: bandwidth,\r\n        width: width,\r\n        height: height,\r\n        playlist: playlist\r\n      };\r\n    });\r\n    stableSort(sortedPlaylistReps, function (left, right) {\r\n      return left.bandwidth - right.bandwidth;\r\n    }); // filter out any playlists that have been excluded due to\r\n    // incompatible configurations\r\n\r\n    sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {\r\n      return !Playlist.isIncompatible(rep.playlist);\r\n    }); // filter out any playlists that have been disabled manually through the representations\r\n    // api or blacklisted temporarily due to playback errors.\r\n\r\n    var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\r\n      return Playlist.isEnabled(rep.playlist);\r\n    });\r\n\r\n    if (!enabledPlaylistReps.length) {\r\n      // if there are no enabled playlists, then they have all been blacklisted or disabled\r\n      // by the user through the representations api. In this case, ignore blacklisting and\r\n      // fallback to what the user wants by using playlists the user has not disabled.\r\n      enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\r\n        return !Playlist.isDisabled(rep.playlist);\r\n      });\r\n    } // filter out any variant that has greater effective bitrate\r\n    // than the current estimated bandwidth\r\n\r\n\r\n    var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {\r\n      return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;\r\n    });\r\n    var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1]; // get all of the renditions with the same (highest) bandwidth\r\n    // and then taking the very first element\r\n\r\n    var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {\r\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\r\n    })[0]; // if we're not going to limit renditions by player size, make an early decision.\r\n\r\n    if (limitRenditionByPlayerDimensions === false) {\r\n      var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\r\n\r\n      if (_chosenRep && _chosenRep.playlist) {\r\n        var type = 'sortedPlaylistReps';\r\n\r\n        if (bandwidthBestRep) {\r\n          type = 'bandwidthBestRep';\r\n        }\r\n\r\n        if (enabledPlaylistReps[0]) {\r\n          type = 'enabledPlaylistReps';\r\n        }\r\n\r\n        logFn(\"choosing \" + representationToString(_chosenRep) + \" using \" + type + \" with options\", options);\r\n        return _chosenRep.playlist;\r\n      }\r\n\r\n      logFn('could not choose a playlist with options', options);\r\n      return null;\r\n    } // filter out playlists without resolution information\r\n\r\n\r\n    var haveResolution = bandwidthPlaylistReps.filter(function (rep) {\r\n      return rep.width && rep.height;\r\n    }); // sort variants by resolution\r\n\r\n    stableSort(haveResolution, function (left, right) {\r\n      return left.width - right.width;\r\n    }); // if we have the exact resolution as the player use it\r\n\r\n    var resolutionBestRepList = haveResolution.filter(function (rep) {\r\n      return rep.width === playerWidth && rep.height === playerHeight;\r\n    });\r\n    highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1]; // ensure that we pick the highest bandwidth variant that have exact resolution\r\n\r\n    var resolutionBestRep = resolutionBestRepList.filter(function (rep) {\r\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\r\n    })[0];\r\n    var resolutionPlusOneList;\r\n    var resolutionPlusOneSmallest;\r\n    var resolutionPlusOneRep; // find the smallest variant that is larger than the player\r\n    // if there is no match of exact resolution\r\n\r\n    if (!resolutionBestRep) {\r\n      resolutionPlusOneList = haveResolution.filter(function (rep) {\r\n        return rep.width > playerWidth || rep.height > playerHeight;\r\n      }); // find all the variants have the same smallest resolution\r\n\r\n      resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {\r\n        return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;\r\n      }); // ensure that we also pick the highest bandwidth variant that\r\n      // is just-larger-than the video player\r\n\r\n      highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\r\n      resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {\r\n        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\r\n      })[0];\r\n    }\r\n\r\n    var leastPixelDiffRep; // If this selector proves to be better than others,\r\n    // resolutionPlusOneRep and resolutionBestRep and all\r\n    // the code involving them should be removed.\r\n\r\n    if (masterPlaylistController.experimentalLeastPixelDiffSelector) {\r\n      // find the variant that is closest to the player's pixel size\r\n      var leastPixelDiffList = haveResolution.map(function (rep) {\r\n        rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);\r\n        return rep;\r\n      }); // get the highest bandwidth, closest resolution playlist\r\n\r\n      stableSort(leastPixelDiffList, function (left, right) {\r\n        // sort by highest bandwidth if pixelDiff is the same\r\n        if (left.pixelDiff === right.pixelDiff) {\r\n          return right.bandwidth - left.bandwidth;\r\n        }\r\n\r\n        return left.pixelDiff - right.pixelDiff;\r\n      });\r\n      leastPixelDiffRep = leastPixelDiffList[0];\r\n    } // fallback chain of variants\r\n\r\n\r\n    var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\r\n\r\n    if (chosenRep && chosenRep.playlist) {\r\n      var _type = 'sortedPlaylistReps';\r\n\r\n      if (leastPixelDiffRep) {\r\n        _type = 'leastPixelDiffRep';\r\n      } else if (resolutionPlusOneRep) {\r\n        _type = 'resolutionPlusOneRep';\r\n      } else if (resolutionBestRep) {\r\n        _type = 'resolutionBestRep';\r\n      } else if (bandwidthBestRep) {\r\n        _type = 'bandwidthBestRep';\r\n      } else if (enabledPlaylistReps[0]) {\r\n        _type = 'enabledPlaylistReps';\r\n      }\r\n\r\n      logFn(\"choosing \" + representationToString(chosenRep) + \" using \" + _type + \" with options\", options);\r\n      return chosenRep.playlist;\r\n    }\r\n\r\n    logFn('could not choose a playlist with options', options);\r\n    return null;\r\n  };\r\n  /**\r\n   * Chooses the appropriate media playlist based on the most recent\r\n   * bandwidth estimate and the player size.\r\n   *\r\n   * Expects to be called within the context of an instance of VhsHandler\r\n   *\r\n   * @return {Playlist} the highest bitrate playlist less than the\r\n   * currently detected bandwidth, accounting for some amount of\r\n   * bandwidth variance\r\n   */\r\n\r\n\r\n  var lastBandwidthSelector = function lastBandwidthSelector() {\r\n    var pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\r\n    return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);\r\n  };\r\n  /**\r\n   * Chooses the appropriate media playlist based on an\r\n   * exponential-weighted moving average of the bandwidth after\r\n   * filtering for player size.\r\n   *\r\n   * Expects to be called within the context of an instance of VhsHandler\r\n   *\r\n   * @param {number} decay - a number between 0 and 1. Higher values of\r\n   * this parameter will cause previous bandwidth estimates to lose\r\n   * significance more quickly.\r\n   * @return {Function} a function which can be invoked to create a new\r\n   * playlist selector function.\r\n   * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\r\n   */\r\n\r\n\r\n  var movingAverageBandwidthSelector = function movingAverageBandwidthSelector(decay) {\r\n    var average = -1;\r\n    var lastSystemBandwidth = -1;\r\n\r\n    if (decay < 0 || decay > 1) {\r\n      throw new Error('Moving average bandwidth decay must be between 0 and 1.');\r\n    }\r\n\r\n    return function () {\r\n      var pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\r\n\r\n      if (average < 0) {\r\n        average = this.systemBandwidth;\r\n        lastSystemBandwidth = this.systemBandwidth;\r\n      } // stop the average value from decaying for every 250ms\r\n      // when the systemBandwidth is constant\r\n      // and\r\n      // stop average from setting to a very low value when the\r\n      // systemBandwidth becomes 0 in case of chunk cancellation\r\n\r\n\r\n      if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {\r\n        average = decay * this.systemBandwidth + (1 - decay) * average;\r\n        lastSystemBandwidth = this.systemBandwidth;\r\n      }\r\n\r\n      return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);\r\n    };\r\n  };\r\n  /**\r\n   * Chooses the appropriate media playlist based on the potential to rebuffer\r\n   *\r\n   * @param {Object} settings\r\n   *        Object of information required to use this selector\r\n   * @param {Object} settings.master\r\n   *        Object representation of the master manifest\r\n   * @param {number} settings.currentTime\r\n   *        The current time of the player\r\n   * @param {number} settings.bandwidth\r\n   *        Current measured bandwidth\r\n   * @param {number} settings.duration\r\n   *        Duration of the media\r\n   * @param {number} settings.segmentDuration\r\n   *        Segment duration to be used in round trip time calculations\r\n   * @param {number} settings.timeUntilRebuffer\r\n   *        Time left in seconds until the player has to rebuffer\r\n   * @param {number} settings.currentTimeline\r\n   *        The current timeline segments are being loaded from\r\n   * @param {SyncController} settings.syncController\r\n   *        SyncController for determining if we have a sync point for a given playlist\r\n   * @return {Object|null}\r\n   *         {Object} return.playlist\r\n   *         The highest bandwidth playlist with the least amount of rebuffering\r\n   *         {Number} return.rebufferingImpact\r\n   *         The amount of time in seconds switching to this playlist will rebuffer. A\r\n   *         negative value means that switching will cause zero rebuffering.\r\n   */\r\n\r\n\r\n  var minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {\r\n    var master = settings.master,\r\n        currentTime = settings.currentTime,\r\n        bandwidth = settings.bandwidth,\r\n        duration = settings.duration,\r\n        segmentDuration = settings.segmentDuration,\r\n        timeUntilRebuffer = settings.timeUntilRebuffer,\r\n        currentTimeline = settings.currentTimeline,\r\n        syncController = settings.syncController; // filter out any playlists that have been excluded due to\r\n    // incompatible configurations\r\n\r\n    var compatiblePlaylists = master.playlists.filter(function (playlist) {\r\n      return !Playlist.isIncompatible(playlist);\r\n    }); // filter out any playlists that have been disabled manually through the representations\r\n    // api or blacklisted temporarily due to playback errors.\r\n\r\n    var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);\r\n\r\n    if (!enabledPlaylists.length) {\r\n      // if there are no enabled playlists, then they have all been blacklisted or disabled\r\n      // by the user through the representations api. In this case, ignore blacklisting and\r\n      // fallback to what the user wants by using playlists the user has not disabled.\r\n      enabledPlaylists = compatiblePlaylists.filter(function (playlist) {\r\n        return !Playlist.isDisabled(playlist);\r\n      });\r\n    }\r\n\r\n    var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));\r\n    var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {\r\n      var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime); // If there is no sync point for this playlist, switching to it will require a\r\n      // sync request first. This will double the request time\r\n\r\n      var numRequests = syncPoint ? 1 : 2;\r\n      var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\r\n      var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\r\n      return {\r\n        playlist: playlist,\r\n        rebufferingImpact: rebufferingImpact\r\n      };\r\n    });\r\n    var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {\r\n      return estimate.rebufferingImpact <= 0;\r\n    }); // Sort by bandwidth DESC\r\n\r\n    stableSort(noRebufferingPlaylists, function (a, b) {\r\n      return comparePlaylistBandwidth(b.playlist, a.playlist);\r\n    });\r\n\r\n    if (noRebufferingPlaylists.length) {\r\n      return noRebufferingPlaylists[0];\r\n    }\r\n\r\n    stableSort(rebufferingEstimates, function (a, b) {\r\n      return a.rebufferingImpact - b.rebufferingImpact;\r\n    });\r\n    return rebufferingEstimates[0] || null;\r\n  };\r\n  /**\r\n   * Chooses the appropriate media playlist, which in this case is the lowest bitrate\r\n   * one with video.  If no renditions with video exist, return the lowest audio rendition.\r\n   *\r\n   * Expects to be called within the context of an instance of VhsHandler\r\n   *\r\n   * @return {Object|null}\r\n   *         {Object} return.playlist\r\n   *         The lowest bitrate playlist that contains a video codec.  If no such rendition\r\n   *         exists pick the lowest audio rendition.\r\n   */\r\n\r\n\r\n  var lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {\r\n    var _this = this; // filter out any playlists that have been excluded due to\r\n    // incompatible configurations or playback errors\r\n\r\n\r\n    var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled); // Sort ascending by bitrate\r\n\r\n    stableSort(playlists, function (a, b) {\r\n      return comparePlaylistBandwidth(a, b);\r\n    }); // Parse and assume that playlists with no video codec have no video\r\n    // (this is not necessarily true, although it is generally true).\r\n    //\r\n    // If an entire manifest has no valid videos everything will get filtered\r\n    // out.\r\n\r\n    var playlistsWithVideo = playlists.filter(function (playlist) {\r\n      return !!codecsForPlaylist(_this.playlists.master, playlist).video;\r\n    });\r\n    return playlistsWithVideo[0] || null;\r\n  };\r\n  /**\r\n   * Combine all segments into a single Uint8Array\r\n   *\r\n   * @param {Object} segmentObj\r\n   * @return {Uint8Array} concatenated bytes\r\n   * @private\r\n   */\r\n\r\n\r\n  var concatSegments = function concatSegments(segmentObj) {\r\n    var offset = 0;\r\n    var tempBuffer;\r\n\r\n    if (segmentObj.bytes) {\r\n      tempBuffer = new Uint8Array(segmentObj.bytes); // combine the individual segments into one large typed-array\r\n\r\n      segmentObj.segments.forEach(function (segment) {\r\n        tempBuffer.set(segment, offset);\r\n        offset += segment.byteLength;\r\n      });\r\n    }\r\n\r\n    return tempBuffer;\r\n  };\r\n  /**\r\n   * @file text-tracks.js\r\n   */\r\n\r\n  /**\r\n   * Create captions text tracks on video.js if they do not exist\r\n   *\r\n   * @param {Object} inbandTextTracks a reference to current inbandTextTracks\r\n   * @param {Object} tech the video.js tech\r\n   * @param {Object} captionStream the caption stream to create\r\n   * @private\r\n   */\r\n\r\n\r\n  var createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists(inbandTextTracks, tech, captionStream) {\r\n    if (!inbandTextTracks[captionStream]) {\r\n      tech.trigger({\r\n        type: 'usage',\r\n        name: 'vhs-608'\r\n      });\r\n      tech.trigger({\r\n        type: 'usage',\r\n        name: 'hls-608'\r\n      });\r\n      var instreamId = captionStream; // we need to translate SERVICEn for 708 to how mux.js currently labels them\r\n\r\n      if (/^cc708_/.test(captionStream)) {\r\n        instreamId = 'SERVICE' + captionStream.split('_')[1];\r\n      }\r\n\r\n      var track = tech.textTracks().getTrackById(instreamId);\r\n\r\n      if (track) {\r\n        // Resuse an existing track with a CC# id because this was\r\n        // very likely created by videojs-contrib-hls from information\r\n        // in the m3u8 for us to use\r\n        inbandTextTracks[captionStream] = track;\r\n      } else {\r\n        // This section gets called when we have caption services that aren't specified in the manifest.\r\n        // Manifest level caption services are handled in media-groups.js under CLOSED-CAPTIONS.\r\n        var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\r\n        var label = captionStream;\r\n        var language = captionStream;\r\n        var def = false;\r\n        var captionService = captionServices[instreamId];\r\n\r\n        if (captionService) {\r\n          label = captionService.label;\r\n          language = captionService.language;\r\n          def = captionService[\"default\"];\r\n        } // Otherwise, create a track with the default `CC#` label and\r\n        // without a language\r\n\r\n\r\n        inbandTextTracks[captionStream] = tech.addRemoteTextTrack({\r\n          kind: 'captions',\r\n          id: instreamId,\r\n          // TODO: investigate why this doesn't seem to turn the caption on by default\r\n          \"default\": def,\r\n          label: label,\r\n          language: language\r\n        }, false).track;\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Add caption text track data to a source handler given an array of captions\r\n   *\r\n   * @param {Object}\r\n   *   @param {Object} inbandTextTracks the inband text tracks\r\n   *   @param {number} timestampOffset the timestamp offset of the source buffer\r\n   *   @param {Array} captionArray an array of caption data\r\n   * @private\r\n   */\r\n\r\n\r\n  var addCaptionData = function addCaptionData(_ref) {\r\n    var inbandTextTracks = _ref.inbandTextTracks,\r\n        captionArray = _ref.captionArray,\r\n        timestampOffset = _ref.timestampOffset;\r\n\r\n    if (!captionArray) {\r\n      return;\r\n    }\r\n\r\n    var Cue = window.WebKitDataCue || window.VTTCue;\r\n    captionArray.forEach(function (caption) {\r\n      var track = caption.stream;\r\n      inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));\r\n    });\r\n  };\r\n  /**\r\n   * Define properties on a cue for backwards compatability,\r\n   * but warn the user that the way that they are using it\r\n   * is depricated and will be removed at a later date.\r\n   *\r\n   * @param {Cue} cue the cue to add the properties on\r\n   * @private\r\n   */\r\n\r\n\r\n  var deprecateOldCue = function deprecateOldCue(cue) {\r\n    Object.defineProperties(cue.frame, {\r\n      id: {\r\n        get: function get() {\r\n          videojs.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\r\n          return cue.value.key;\r\n        }\r\n      },\r\n      value: {\r\n        get: function get() {\r\n          videojs.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\r\n          return cue.value.data;\r\n        }\r\n      },\r\n      privateData: {\r\n        get: function get() {\r\n          videojs.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\r\n          return cue.value.data;\r\n        }\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * Add metadata text track data to a source handler given an array of metadata\r\n   *\r\n   * @param {Object}\r\n   *   @param {Object} inbandTextTracks the inband text tracks\r\n   *   @param {Array} metadataArray an array of meta data\r\n   *   @param {number} timestampOffset the timestamp offset of the source buffer\r\n   *   @param {number} videoDuration the duration of the video\r\n   * @private\r\n   */\r\n\r\n\r\n  var addMetadata = function addMetadata(_ref2) {\r\n    var inbandTextTracks = _ref2.inbandTextTracks,\r\n        metadataArray = _ref2.metadataArray,\r\n        timestampOffset = _ref2.timestampOffset,\r\n        videoDuration = _ref2.videoDuration;\r\n\r\n    if (!metadataArray) {\r\n      return;\r\n    }\r\n\r\n    var Cue = window.WebKitDataCue || window.VTTCue;\r\n    var metadataTrack = inbandTextTracks.metadataTrack_;\r\n\r\n    if (!metadataTrack) {\r\n      return;\r\n    }\r\n\r\n    metadataArray.forEach(function (metadata) {\r\n      var time = metadata.cueTime + timestampOffset; // if time isn't a finite number between 0 and Infinity, like NaN,\r\n      // ignore this bit of metadata.\r\n      // This likely occurs when you have an non-timed ID3 tag like TIT2,\r\n      // which is the \"Title/Songname/Content description\" frame\r\n\r\n      if (typeof time !== 'number' || window.isNaN(time) || time < 0 || !(time < Infinity)) {\r\n        return;\r\n      }\r\n\r\n      metadata.frames.forEach(function (frame) {\r\n        var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\r\n        cue.frame = frame;\r\n        cue.value = frame;\r\n        deprecateOldCue(cue);\r\n        metadataTrack.addCue(cue);\r\n      });\r\n    });\r\n\r\n    if (!metadataTrack.cues || !metadataTrack.cues.length) {\r\n      return;\r\n    } // Updating the metadeta cues so that\r\n    // the endTime of each cue is the startTime of the next cue\r\n    // the endTime of last cue is the duration of the video\r\n\r\n\r\n    var cues = metadataTrack.cues;\r\n    var cuesArray = []; // Create a copy of the TextTrackCueList...\r\n    // ...disregarding cues with a falsey value\r\n\r\n    for (var i = 0; i < cues.length; i++) {\r\n      if (cues[i]) {\r\n        cuesArray.push(cues[i]);\r\n      }\r\n    } // Group cues by their startTime value\r\n\r\n\r\n    var cuesGroupedByStartTime = cuesArray.reduce(function (obj, cue) {\r\n      var timeSlot = obj[cue.startTime] || [];\r\n      timeSlot.push(cue);\r\n      obj[cue.startTime] = timeSlot;\r\n      return obj;\r\n    }, {}); // Sort startTimes by ascending order\r\n\r\n    var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function (a, b) {\r\n      return Number(a) - Number(b);\r\n    }); // Map each cue group's endTime to the next group's startTime\r\n\r\n    sortedStartTimes.forEach(function (startTime, idx) {\r\n      var cueGroup = cuesGroupedByStartTime[startTime];\r\n      var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration; // Map each cue's endTime the next group's startTime\r\n\r\n      cueGroup.forEach(function (cue) {\r\n        cue.endTime = nextTime;\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * Create metadata text track on video.js if it does not exist\r\n   *\r\n   * @param {Object} inbandTextTracks a reference to current inbandTextTracks\r\n   * @param {string} dispatchType the inband metadata track dispatch type\r\n   * @param {Object} tech the video.js tech\r\n   * @private\r\n   */\r\n\r\n\r\n  var createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists(inbandTextTracks, dispatchType, tech) {\r\n    if (inbandTextTracks.metadataTrack_) {\r\n      return;\r\n    }\r\n\r\n    inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({\r\n      kind: 'metadata',\r\n      label: 'Timed Metadata'\r\n    }, false).track;\r\n    inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;\r\n  };\r\n  /**\r\n   * Remove cues from a track on video.js.\r\n   *\r\n   * @param {Double} start start of where we should remove the cue\r\n   * @param {Double} end end of where the we should remove the cue\r\n   * @param {Object} track the text track to remove the cues from\r\n   * @private\r\n   */\r\n\r\n\r\n  var removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\r\n    var i;\r\n    var cue;\r\n\r\n    if (!track) {\r\n      return;\r\n    }\r\n\r\n    if (!track.cues) {\r\n      return;\r\n    }\r\n\r\n    i = track.cues.length;\r\n\r\n    while (i--) {\r\n      cue = track.cues[i]; // Remove any cue within the provided start and end time\r\n\r\n      if (cue.startTime >= start && cue.endTime <= end) {\r\n        track.removeCue(cue);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Remove duplicate cues from a track on video.js (a cue is considered a\r\n   * duplicate if it has the same time interval and text as another)\r\n   *\r\n   * @param {Object} track the text track to remove the duplicate cues from\r\n   * @private\r\n   */\r\n\r\n\r\n  var removeDuplicateCuesFromTrack = function removeDuplicateCuesFromTrack(track) {\r\n    var cues = track.cues;\r\n\r\n    if (!cues) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < cues.length; i++) {\r\n      var duplicates = [];\r\n      var occurrences = 0;\r\n\r\n      for (var j = 0; j < cues.length; j++) {\r\n        if (cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text) {\r\n          occurrences++;\r\n\r\n          if (occurrences > 1) {\r\n            duplicates.push(cues[j]);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (duplicates.length) {\r\n        duplicates.forEach(function (dupe) {\r\n          return track.removeCue(dupe);\r\n        });\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\r\n   * front of current time.\r\n   *\r\n   * @param {Array} buffer\r\n   *        The current buffer of gop information\r\n   * @param {number} currentTime\r\n   *        The current time\r\n   * @param {Double} mapping\r\n   *        Offset to map display time to stream presentation time\r\n   * @return {Array}\r\n   *         List of gops considered safe to append over\r\n   */\r\n\r\n\r\n  var gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, currentTime, mapping) {\r\n    if (typeof currentTime === 'undefined' || currentTime === null || !buffer.length) {\r\n      return [];\r\n    } // pts value for current time + 3 seconds to give a bit more wiggle room\r\n\r\n\r\n    var currentTimePts = Math.ceil((currentTime - mapping + 3) * clock_1);\r\n    var i;\r\n\r\n    for (i = 0; i < buffer.length; i++) {\r\n      if (buffer[i].pts > currentTimePts) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return buffer.slice(i);\r\n  };\r\n  /**\r\n   * Appends gop information (timing and byteLength) received by the transmuxer for the\r\n   * gops appended in the last call to appendBuffer\r\n   *\r\n   * @param {Array} buffer\r\n   *        The current buffer of gop information\r\n   * @param {Array} gops\r\n   *        List of new gop information\r\n   * @param {boolean} replace\r\n   *        If true, replace the buffer with the new gop information. If false, append the\r\n   *        new gop information to the buffer in the right location of time.\r\n   * @return {Array}\r\n   *         Updated list of gop information\r\n   */\r\n\r\n\r\n  var updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\r\n    if (!gops.length) {\r\n      return buffer;\r\n    }\r\n\r\n    if (replace) {\r\n      // If we are in safe append mode, then completely overwrite the gop buffer\r\n      // with the most recent appeneded data. This will make sure that when appending\r\n      // future segments, we only try to align with gops that are both ahead of current\r\n      // time and in the last segment appended.\r\n      return gops.slice();\r\n    }\r\n\r\n    var start = gops[0].pts;\r\n    var i = 0;\r\n\r\n    for (i; i < buffer.length; i++) {\r\n      if (buffer[i].pts >= start) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return buffer.slice(0, i).concat(gops);\r\n  };\r\n  /**\r\n   * Removes gop information in buffer that overlaps with provided start and end\r\n   *\r\n   * @param {Array} buffer\r\n   *        The current buffer of gop information\r\n   * @param {Double} start\r\n   *        position to start the remove at\r\n   * @param {Double} end\r\n   *        position to end the remove at\r\n   * @param {Double} mapping\r\n   *        Offset to map display time to stream presentation time\r\n   */\r\n\r\n\r\n  var removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\r\n    var startPts = Math.ceil((start - mapping) * clock_1);\r\n    var endPts = Math.ceil((end - mapping) * clock_1);\r\n    var updatedBuffer = buffer.slice();\r\n    var i = buffer.length;\r\n\r\n    while (i--) {\r\n      if (buffer[i].pts <= endPts) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (i === -1) {\r\n      // no removal because end of remove range is before start of buffer\r\n      return updatedBuffer;\r\n    }\r\n\r\n    var j = i + 1;\r\n\r\n    while (j--) {\r\n      if (buffer[j].pts <= startPts) {\r\n        break;\r\n      }\r\n    } // clamp remove range start to 0 index\r\n\r\n\r\n    j = Math.max(j, 0);\r\n    updatedBuffer.splice(j, i - j + 1);\r\n    return updatedBuffer;\r\n  };\r\n\r\n  var shallowEqual = function shallowEqual(a, b) {\r\n    // if both are undefined\r\n    // or one or the other is undefined\r\n    // they are not equal\r\n    if (!a && !b || !a && b || a && !b) {\r\n      return false;\r\n    } // they are the same object and thus, equal\r\n\r\n\r\n    if (a === b) {\r\n      return true;\r\n    } // sort keys so we can make sure they have\r\n    // all the same keys later.\r\n\r\n\r\n    var akeys = Object.keys(a).sort();\r\n    var bkeys = Object.keys(b).sort(); // different number of keys, not equal\r\n\r\n    if (akeys.length !== bkeys.length) {\r\n      return false;\r\n    }\r\n\r\n    for (var i = 0; i < akeys.length; i++) {\r\n      var key = akeys[i]; // different sorted keys, not equal\r\n\r\n      if (key !== bkeys[i]) {\r\n        return false;\r\n      } // different values, not equal\r\n\r\n\r\n      if (a[key] !== b[key]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }; // https://www.w3.org/TR/WebIDL-1/#quotaexceedederror\r\n\r\n\r\n  var QUOTA_EXCEEDED_ERR = 22;\r\n  /**\r\n   * The segment loader has no recourse except to fetch a segment in the\r\n   * current playlist and use the internal timestamps in that segment to\r\n   * generate a syncPoint. This function returns a good candidate index\r\n   * for that process.\r\n   *\r\n   * @param {Array} segments - the segments array from a playlist.\r\n   * @return {number} An index of a segment from the playlist to load\r\n   */\r\n\r\n  var getSyncSegmentCandidate = function getSyncSegmentCandidate(currentTimeline, segments, targetTime) {\r\n    segments = segments || [];\r\n    var timelineSegments = [];\r\n    var time = 0;\r\n\r\n    for (var i = 0; i < segments.length; i++) {\r\n      var segment = segments[i];\r\n\r\n      if (currentTimeline === segment.timeline) {\r\n        timelineSegments.push(i);\r\n        time += segment.duration;\r\n\r\n        if (time > targetTime) {\r\n          return i;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (timelineSegments.length === 0) {\r\n      return 0;\r\n    } // default to the last timeline segment\r\n\r\n\r\n    return timelineSegments[timelineSegments.length - 1];\r\n  }; // In the event of a quota exceeded error, keep at least one second of back buffer. This\r\n  // number was arbitrarily chosen and may be updated in the future, but seemed reasonable\r\n  // as a start to prevent any potential issues with removing content too close to the\r\n  // playhead.\r\n\r\n\r\n  var MIN_BACK_BUFFER = 1; // in ms\r\n\r\n  var CHECK_BUFFER_DELAY = 500;\r\n\r\n  var finite = function finite(num) {\r\n    return typeof num === 'number' && isFinite(num);\r\n  }; // With most content hovering around 30fps, if a segment has a duration less than a half\r\n  // frame at 30fps or one frame at 60fps, the bandwidth and throughput calculations will\r\n  // not accurately reflect the rest of the content.\r\n\r\n\r\n  var MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;\r\n\r\n  var illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, trackInfo) {\r\n    // Although these checks should most likely cover non 'main' types, for now it narrows\r\n    // the scope of our checks.\r\n    if (loaderType !== 'main' || !startingMedia || !trackInfo) {\r\n      return null;\r\n    }\r\n\r\n    if (!trackInfo.hasAudio && !trackInfo.hasVideo) {\r\n      return 'Neither audio nor video found in segment.';\r\n    }\r\n\r\n    if (startingMedia.hasVideo && !trackInfo.hasVideo) {\r\n      return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\r\n    }\r\n\r\n    if (!startingMedia.hasVideo && trackInfo.hasVideo) {\r\n      return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\r\n    }\r\n\r\n    return null;\r\n  };\r\n  /**\r\n   * Calculates a time value that is safe to remove from the back buffer without interrupting\r\n   * playback.\r\n   *\r\n   * @param {TimeRange} seekable\r\n   *        The current seekable range\r\n   * @param {number} currentTime\r\n   *        The current time of the player\r\n   * @param {number} targetDuration\r\n   *        The target duration of the current playlist\r\n   * @return {number}\r\n   *         Time that is safe to remove from the back buffer without interrupting playback\r\n   */\r\n\r\n\r\n  var safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable, currentTime, targetDuration) {\r\n    // 30 seconds before the playhead provides a safe default for trimming.\r\n    //\r\n    // Choosing a reasonable default is particularly important for high bitrate content and\r\n    // VOD videos/live streams with large windows, as the buffer may end up overfilled and\r\n    // throw an APPEND_BUFFER_ERR.\r\n    var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;\r\n\r\n    if (seekable.length) {\r\n      // Some live playlists may have a shorter window of content than the full allowed back\r\n      // buffer. For these playlists, don't save content that's no longer within the window.\r\n      trimTime = Math.max(trimTime, seekable.start(0));\r\n    } // Don't remove within target duration of the current time to avoid the possibility of\r\n    // removing the GOP currently being played, as removing it can cause playback stalls.\r\n\r\n\r\n    var maxTrimTime = currentTime - targetDuration;\r\n    return Math.min(maxTrimTime, trimTime);\r\n  };\r\n\r\n  var segmentInfoString = function segmentInfoString(segmentInfo) {\r\n    var startOfSegment = segmentInfo.startOfSegment,\r\n        duration = segmentInfo.duration,\r\n        segment = segmentInfo.segment,\r\n        part = segmentInfo.part,\r\n        _segmentInfo$playlist = segmentInfo.playlist,\r\n        seq = _segmentInfo$playlist.mediaSequence,\r\n        id = _segmentInfo$playlist.id,\r\n        _segmentInfo$playlist2 = _segmentInfo$playlist.segments,\r\n        segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2,\r\n        index = segmentInfo.mediaIndex,\r\n        partIndex = segmentInfo.partIndex,\r\n        timeline = segmentInfo.timeline;\r\n    var segmentLen = segments.length - 1;\r\n    var selection = 'mediaIndex/partIndex increment';\r\n\r\n    if (segmentInfo.getMediaInfoForTime) {\r\n      selection = \"getMediaInfoForTime (\" + segmentInfo.getMediaInfoForTime + \")\";\r\n    } else if (segmentInfo.isSyncRequest) {\r\n      selection = 'getSyncSegmentCandidate (isSyncRequest)';\r\n    }\r\n\r\n    if (segmentInfo.independent) {\r\n      selection += \" with independent \" + segmentInfo.independent;\r\n    }\r\n\r\n    var hasPartIndex = typeof partIndex === 'number';\r\n    var name = segmentInfo.segment.uri ? 'segment' : 'pre-segment';\r\n    var zeroBasedPartCount = hasPartIndex ? getKnownPartCount({\r\n      preloadSegment: segment\r\n    }) - 1 : 0;\r\n    return name + \" [\" + (seq + index) + \"/\" + (seq + segmentLen) + \"]\" + (hasPartIndex ? \" part [\" + partIndex + \"/\" + zeroBasedPartCount + \"]\" : '') + (\" segment start/end [\" + segment.start + \" => \" + segment.end + \"]\") + (hasPartIndex ? \" part start/end [\" + part.start + \" => \" + part.end + \"]\" : '') + (\" startOfSegment [\" + startOfSegment + \"]\") + (\" duration [\" + duration + \"]\") + (\" timeline [\" + timeline + \"]\") + (\" selected by [\" + selection + \"]\") + (\" playlist [\" + id + \"]\");\r\n  };\r\n\r\n  var timingInfoPropertyForMedia = function timingInfoPropertyForMedia(mediaType) {\r\n    return mediaType + \"TimingInfo\";\r\n  };\r\n  /**\r\n   * Returns the timestamp offset to use for the segment.\r\n   *\r\n   * @param {number} segmentTimeline\r\n   *        The timeline of the segment\r\n   * @param {number} currentTimeline\r\n   *        The timeline currently being followed by the loader\r\n   * @param {number} startOfSegment\r\n   *        The estimated segment start\r\n   * @param {TimeRange[]} buffered\r\n   *        The loader's buffer\r\n   * @param {boolean} overrideCheck\r\n   *        If true, no checks are made to see if the timestamp offset value should be set,\r\n   *        but sets it directly to a value.\r\n   *\r\n   * @return {number|null}\r\n   *         Either a number representing a new timestamp offset, or null if the segment is\r\n   *         part of the same timeline\r\n   */\r\n\r\n\r\n  var timestampOffsetForSegment = function timestampOffsetForSegment(_ref) {\r\n    var segmentTimeline = _ref.segmentTimeline,\r\n        currentTimeline = _ref.currentTimeline,\r\n        startOfSegment = _ref.startOfSegment,\r\n        buffered = _ref.buffered,\r\n        overrideCheck = _ref.overrideCheck; // Check to see if we are crossing a discontinuity to see if we need to set the\r\n    // timestamp offset on the transmuxer and source buffer.\r\n    //\r\n    // Previously, we changed the timestampOffset if the start of this segment was less than\r\n    // the currently set timestampOffset, but this isn't desirable as it can produce bad\r\n    // behavior, especially around long running live streams.\r\n\r\n    if (!overrideCheck && segmentTimeline === currentTimeline) {\r\n      return null;\r\n    } // When changing renditions, it's possible to request a segment on an older timeline. For\r\n    // instance, given two renditions with the following:\r\n    //\r\n    // #EXTINF:10\r\n    // segment1\r\n    // #EXT-X-DISCONTINUITY\r\n    // #EXTINF:10\r\n    // segment2\r\n    // #EXTINF:10\r\n    // segment3\r\n    //\r\n    // And the current player state:\r\n    //\r\n    // current time: 8\r\n    // buffer: 0 => 20\r\n    //\r\n    // The next segment on the current rendition would be segment3, filling the buffer from\r\n    // 20s onwards. However, if a rendition switch happens after segment2 was requested,\r\n    // then the next segment to be requested will be segment1 from the new rendition in\r\n    // order to fill time 8 and onwards. Using the buffered end would result in repeated\r\n    // content (since it would position segment1 of the new rendition starting at 20s). This\r\n    // case can be identified when the new segment's timeline is a prior value. Instead of\r\n    // using the buffered end, the startOfSegment can be used, which, hopefully, will be\r\n    // more accurate to the actual start time of the segment.\r\n\r\n\r\n    if (segmentTimeline < currentTimeline) {\r\n      return startOfSegment;\r\n    } // segmentInfo.startOfSegment used to be used as the timestamp offset, however, that\r\n    // value uses the end of the last segment if it is available. While this value\r\n    // should often be correct, it's better to rely on the buffered end, as the new\r\n    // content post discontinuity should line up with the buffered end as if it were\r\n    // time 0 for the new content.\r\n\r\n\r\n    return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;\r\n  };\r\n  /**\r\n   * Returns whether or not the loader should wait for a timeline change from the timeline\r\n   * change controller before processing the segment.\r\n   *\r\n   * Primary timing in VHS goes by video. This is different from most media players, as\r\n   * audio is more often used as the primary timing source. For the foreseeable future, VHS\r\n   * will continue to use video as the primary timing source, due to the current logic and\r\n   * expectations built around it.\r\n\r\n   * Since the timing follows video, in order to maintain sync, the video loader is\r\n   * responsible for setting both audio and video source buffer timestamp offsets.\r\n   *\r\n   * Setting different values for audio and video source buffers could lead to\r\n   * desyncing. The following examples demonstrate some of the situations where this\r\n   * distinction is important. Note that all of these cases involve demuxed content. When\r\n   * content is muxed, the audio and video are packaged together, therefore syncing\r\n   * separate media playlists is not an issue.\r\n   *\r\n   * CASE 1: Audio prepares to load a new timeline before video:\r\n   *\r\n   * Timeline:       0                 1\r\n   * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\r\n   * Audio Loader:                     ^\r\n   * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\r\n   * Video Loader              ^\r\n   *\r\n   * In the above example, the audio loader is preparing to load the 6th segment, the first\r\n   * after a discontinuity, while the video loader is still loading the 5th segment, before\r\n   * the discontinuity.\r\n   *\r\n   * If the audio loader goes ahead and loads and appends the 6th segment before the video\r\n   * loader crosses the discontinuity, then when appended, the 6th audio segment will use\r\n   * the timestamp offset from timeline 0. This will likely lead to desyncing. In addition,\r\n   * the audio loader must provide the audioAppendStart value to trim the content in the\r\n   * transmuxer, and that value relies on the audio timestamp offset. Since the audio\r\n   * timestamp offset is set by the video (main) loader, the audio loader shouldn't load the\r\n   * segment until that value is provided.\r\n   *\r\n   * CASE 2: Video prepares to load a new timeline before audio:\r\n   *\r\n   * Timeline:       0                 1\r\n   * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\r\n   * Audio Loader:             ^\r\n   * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\r\n   * Video Loader                      ^\r\n   *\r\n   * In the above example, the video loader is preparing to load the 6th segment, the first\r\n   * after a discontinuity, while the audio loader is still loading the 5th segment, before\r\n   * the discontinuity.\r\n   *\r\n   * If the video loader goes ahead and loads and appends the 6th segment, then once the\r\n   * segment is loaded and processed, both the video and audio timestamp offsets will be\r\n   * set, since video is used as the primary timing source. This is to ensure content lines\r\n   * up appropriately, as any modifications to the video timing are reflected by audio when\r\n   * the video loader sets the audio and video timestamp offsets to the same value. However,\r\n   * setting the timestamp offset for audio before audio has had a chance to change\r\n   * timelines will likely lead to desyncing, as the audio loader will append segment 5 with\r\n   * a timestamp intended to apply to segments from timeline 1 rather than timeline 0.\r\n   *\r\n   * CASE 3: When seeking, audio prepares to load a new timeline before video\r\n   *\r\n   * Timeline:       0                 1\r\n   * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\r\n   * Audio Loader:           ^\r\n   * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\r\n   * Video Loader            ^\r\n   *\r\n   * In the above example, both audio and video loaders are loading segments from timeline\r\n   * 0, but imagine that the seek originated from timeline 1.\r\n   *\r\n   * When seeking to a new timeline, the timestamp offset will be set based on the expected\r\n   * segment start of the loaded video segment. In order to maintain sync, the audio loader\r\n   * must wait for the video loader to load its segment and update both the audio and video\r\n   * timestamp offsets before it may load and append its own segment. This is the case\r\n   * whether the seek results in a mismatched segment request (e.g., the audio loader\r\n   * chooses to load segment 3 and the video loader chooses to load segment 4) or the\r\n   * loaders choose to load the same segment index from each playlist, as the segments may\r\n   * not be aligned perfectly, even for matching segment indexes.\r\n   *\r\n   * @param {Object} timelinechangeController\r\n   * @param {number} currentTimeline\r\n   *        The timeline currently being followed by the loader\r\n   * @param {number} segmentTimeline\r\n   *        The timeline of the segment being loaded\r\n   * @param {('main'|'audio')} loaderType\r\n   *        The loader type\r\n   * @param {boolean} audioDisabled\r\n   *        Whether the audio is disabled for the loader. This should only be true when the\r\n   *        loader may have muxed audio in its segment, but should not append it, e.g., for\r\n   *        the main loader when an alternate audio playlist is active.\r\n   *\r\n   * @return {boolean}\r\n   *         Whether the loader should wait for a timeline change from the timeline change\r\n   *         controller before processing the segment\r\n   */\r\n\r\n\r\n  var shouldWaitForTimelineChange = function shouldWaitForTimelineChange(_ref2) {\r\n    var timelineChangeController = _ref2.timelineChangeController,\r\n        currentTimeline = _ref2.currentTimeline,\r\n        segmentTimeline = _ref2.segmentTimeline,\r\n        loaderType = _ref2.loaderType,\r\n        audioDisabled = _ref2.audioDisabled;\r\n\r\n    if (currentTimeline === segmentTimeline) {\r\n      return false;\r\n    }\r\n\r\n    if (loaderType === 'audio') {\r\n      var lastMainTimelineChange = timelineChangeController.lastTimelineChange({\r\n        type: 'main'\r\n      }); // Audio loader should wait if:\r\n      //\r\n      // * main hasn't had a timeline change yet (thus has not loaded its first segment)\r\n      // * main hasn't yet changed to the timeline audio is looking to load\r\n\r\n      return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;\r\n    } // The main loader only needs to wait for timeline changes if there's demuxed audio.\r\n    // Otherwise, there's nothing to wait for, since audio would be muxed into the main\r\n    // loader's segments (or the content is audio/video only and handled by the main\r\n    // loader).\r\n\r\n\r\n    if (loaderType === 'main' && audioDisabled) {\r\n      var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({\r\n        type: 'audio'\r\n      }); // Main loader should wait for the audio loader if audio is not pending a timeline\r\n      // change to the current timeline.\r\n      //\r\n      // Since the main loader is responsible for setting the timestamp offset for both\r\n      // audio and video, the main loader must wait for audio to be about to change to its\r\n      // timeline before setting the offset, otherwise, if audio is behind in loading,\r\n      // segments from the previous timeline would be adjusted by the new timestamp offset.\r\n      //\r\n      // This requirement means that video will not cross a timeline until the audio is\r\n      // about to cross to it, so that way audio and video will always cross the timeline\r\n      // together.\r\n      //\r\n      // In addition to normal timeline changes, these rules also apply to the start of a\r\n      // stream (going from a non-existent timeline, -1, to timeline 0). It's important\r\n      // that these rules apply to the first timeline change because if they did not, it's\r\n      // possible that the main loader will cross two timelines before the audio loader has\r\n      // crossed one. Logic may be implemented to handle the startup as a special case, but\r\n      // it's easier to simply treat all timeline changes the same.\r\n\r\n      if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  var mediaDuration = function mediaDuration(timingInfos) {\r\n    var maxDuration = 0;\r\n    ['video', 'audio'].forEach(function (type) {\r\n      var typeTimingInfo = timingInfos[type + \"TimingInfo\"];\r\n\r\n      if (!typeTimingInfo) {\r\n        return;\r\n      }\r\n\r\n      var start = typeTimingInfo.start,\r\n          end = typeTimingInfo.end;\r\n      var duration;\r\n\r\n      if (typeof start === 'bigint' || typeof end === 'bigint') {\r\n        duration = window.BigInt(end) - window.BigInt(start);\r\n      } else if (typeof start === 'number' && typeof end === 'number') {\r\n        duration = end - start;\r\n      }\r\n\r\n      if (typeof duration !== 'undefined' && duration > maxDuration) {\r\n        maxDuration = duration;\r\n      }\r\n    }); // convert back to a number if it is lower than MAX_SAFE_INTEGER\r\n    // as we only need BigInt when we are above that.\r\n\r\n    if (typeof maxDuration === 'bigint' && maxDuration < Number.MAX_SAFE_INTEGER) {\r\n      maxDuration = Number(maxDuration);\r\n    }\r\n\r\n    return maxDuration;\r\n  };\r\n\r\n  var segmentTooLong = function segmentTooLong(_ref3) {\r\n    var segmentDuration = _ref3.segmentDuration,\r\n        maxDuration = _ref3.maxDuration; // 0 duration segments are most likely due to metadata only segments or a lack of\r\n    // information.\r\n\r\n    if (!segmentDuration) {\r\n      return false;\r\n    } // For HLS:\r\n    //\r\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1\r\n    // The EXTINF duration of each Media Segment in the Playlist\r\n    // file, when rounded to the nearest integer, MUST be less than or equal\r\n    // to the target duration; longer segments can trigger playback stalls\r\n    // or other errors.\r\n    //\r\n    // For DASH, the mpd-parser uses the largest reported segment duration as the target\r\n    // duration. Although that reported duration is occasionally approximate (i.e., not\r\n    // exact), a strict check may report that a segment is too long more often in DASH.\r\n\r\n\r\n    return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;\r\n  };\r\n\r\n  var getTroublesomeSegmentDurationMessage = function getTroublesomeSegmentDurationMessage(segmentInfo, sourceType) {\r\n    // Right now we aren't following DASH's timing model exactly, so only perform\r\n    // this check for HLS content.\r\n    if (sourceType !== 'hls') {\r\n      return null;\r\n    }\r\n\r\n    var segmentDuration = mediaDuration({\r\n      audioTimingInfo: segmentInfo.audioTimingInfo,\r\n      videoTimingInfo: segmentInfo.videoTimingInfo\r\n    }); // Don't report if we lack information.\r\n    //\r\n    // If the segment has a duration of 0 it is either a lack of information or a\r\n    // metadata only segment and shouldn't be reported here.\r\n\r\n    if (!segmentDuration) {\r\n      return null;\r\n    }\r\n\r\n    var targetDuration = segmentInfo.playlist.targetDuration;\r\n    var isSegmentWayTooLong = segmentTooLong({\r\n      segmentDuration: segmentDuration,\r\n      maxDuration: targetDuration * 2\r\n    });\r\n    var isSegmentSlightlyTooLong = segmentTooLong({\r\n      segmentDuration: segmentDuration,\r\n      maxDuration: targetDuration\r\n    });\r\n    var segmentTooLongMessage = \"Segment with index \" + segmentInfo.mediaIndex + \" \" + (\"from playlist \" + segmentInfo.playlist.id + \" \") + (\"has a duration of \" + segmentDuration + \" \") + (\"when the reported duration is \" + segmentInfo.duration + \" \") + (\"and the target duration is \" + targetDuration + \". \") + 'For HLS content, a duration in excess of the target duration may result in ' + 'playback issues. See the HLS specification section on EXT-X-TARGETDURATION for ' + 'more details: ' + 'https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1';\r\n\r\n    if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {\r\n      return {\r\n        severity: isSegmentWayTooLong ? 'warn' : 'info',\r\n        message: segmentTooLongMessage\r\n      };\r\n    }\r\n\r\n    return null;\r\n  };\r\n  /**\r\n   * An object that manages segment loading and appending.\r\n   *\r\n   * @class SegmentLoader\r\n   * @param {Object} options required and optional options\r\n   * @extends videojs.EventTarget\r\n   */\r\n\r\n\r\n  var SegmentLoader = /*#__PURE__*/function (_videojs$EventTarget) {\r\n    inheritsLoose(SegmentLoader, _videojs$EventTarget);\r\n\r\n    function SegmentLoader(settings, options) {\r\n      var _this;\r\n\r\n      _this = _videojs$EventTarget.call(this) || this; // check pre-conditions\r\n\r\n      if (!settings) {\r\n        throw new TypeError('Initialization settings are required');\r\n      }\r\n\r\n      if (typeof settings.currentTime !== 'function') {\r\n        throw new TypeError('No currentTime getter specified');\r\n      }\r\n\r\n      if (!settings.mediaSource) {\r\n        throw new TypeError('No MediaSource specified');\r\n      } // public properties\r\n\r\n\r\n      _this.bandwidth = settings.bandwidth;\r\n      _this.throughput = {\r\n        rate: 0,\r\n        count: 0\r\n      };\r\n      _this.roundTrip = NaN;\r\n\r\n      _this.resetStats_();\r\n\r\n      _this.mediaIndex = null;\r\n      _this.partIndex = null; // private settings\r\n\r\n      _this.hasPlayed_ = settings.hasPlayed;\r\n      _this.currentTime_ = settings.currentTime;\r\n      _this.seekable_ = settings.seekable;\r\n      _this.seeking_ = settings.seeking;\r\n      _this.duration_ = settings.duration;\r\n      _this.mediaSource_ = settings.mediaSource;\r\n      _this.vhs_ = settings.vhs;\r\n      _this.loaderType_ = settings.loaderType;\r\n      _this.currentMediaInfo_ = void 0;\r\n      _this.startingMediaInfo_ = void 0;\r\n      _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\r\n      _this.goalBufferLength_ = settings.goalBufferLength;\r\n      _this.sourceType_ = settings.sourceType;\r\n      _this.sourceUpdater_ = settings.sourceUpdater;\r\n      _this.inbandTextTracks_ = settings.inbandTextTracks;\r\n      _this.state_ = 'INIT';\r\n      _this.timelineChangeController_ = settings.timelineChangeController;\r\n      _this.shouldSaveSegmentTimingInfo_ = true;\r\n      _this.parse708captions_ = settings.parse708captions;\r\n      _this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;\r\n      _this.captionServices_ = settings.captionServices;\r\n      _this.experimentalExactManifestTimings = settings.experimentalExactManifestTimings; // private instance variables\r\n\r\n      _this.checkBufferTimeout_ = null;\r\n      _this.error_ = void 0;\r\n      _this.currentTimeline_ = -1;\r\n      _this.pendingSegment_ = null;\r\n      _this.xhrOptions_ = null;\r\n      _this.pendingSegments_ = [];\r\n      _this.audioDisabled_ = false;\r\n      _this.isPendingTimestampOffset_ = false; // TODO possibly move gopBuffer and timeMapping info to a separate controller\r\n\r\n      _this.gopBuffer_ = [];\r\n      _this.timeMapping_ = 0;\r\n      _this.safeAppend_ = videojs.browser.IE_VERSION >= 11;\r\n      _this.appendInitSegment_ = {\r\n        audio: true,\r\n        video: true\r\n      };\r\n      _this.playlistOfLastInitSegment_ = {\r\n        audio: null,\r\n        video: null\r\n      };\r\n      _this.callQueue_ = []; // If the segment loader prepares to load a segment, but does not have enough\r\n      // information yet to start the loading process (e.g., if the audio loader wants to\r\n      // load a segment from the next timeline but the main loader hasn't yet crossed that\r\n      // timeline), then the load call will be added to the queue until it is ready to be\r\n      // processed.\r\n\r\n      _this.loadQueue_ = [];\r\n      _this.metadataQueue_ = {\r\n        id3: [],\r\n        caption: []\r\n      };\r\n      _this.waitingOnRemove_ = false;\r\n      _this.quotaExceededErrorRetryTimeout_ = null; // Fragmented mp4 playback\r\n\r\n      _this.activeInitSegmentId_ = null;\r\n      _this.initSegments_ = {}; // HLSe playback\r\n\r\n      _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;\r\n      _this.keyCache_ = {};\r\n      _this.decrypter_ = settings.decrypter; // Manages the tracking and generation of sync-points, mappings\r\n      // between a time in the display time and a segment index within\r\n      // a playlist\r\n\r\n      _this.syncController_ = settings.syncController;\r\n      _this.syncPoint_ = {\r\n        segmentIndex: 0,\r\n        time: 0\r\n      };\r\n      _this.transmuxer_ = _this.createTransmuxer_();\r\n\r\n      _this.triggerSyncInfoUpdate_ = function () {\r\n        return _this.trigger('syncinfoupdate');\r\n      };\r\n\r\n      _this.syncController_.on('syncinfoupdate', _this.triggerSyncInfoUpdate_);\r\n\r\n      _this.mediaSource_.addEventListener('sourceopen', function () {\r\n        if (!_this.isEndOfStream_()) {\r\n          _this.ended_ = false;\r\n        }\r\n      }); // ...for determining the fetch location\r\n\r\n\r\n      _this.fetchAtBuffer_ = false;\r\n      _this.logger_ = logger(\"SegmentLoader[\" + _this.loaderType_ + \"]\");\r\n      Object.defineProperty(assertThisInitialized(_this), 'state', {\r\n        get: function get() {\r\n          return this.state_;\r\n        },\r\n        set: function set(newState) {\r\n          if (newState !== this.state_) {\r\n            this.logger_(this.state_ + \" -> \" + newState);\r\n            this.state_ = newState;\r\n            this.trigger('statechange');\r\n          }\r\n        }\r\n      });\r\n\r\n      _this.sourceUpdater_.on('ready', function () {\r\n        if (_this.hasEnoughInfoToAppend_()) {\r\n          _this.processCallQueue_();\r\n        }\r\n      }); // Only the main loader needs to listen for pending timeline changes, as the main\r\n      // loader should wait for audio to be ready to change its timeline so that both main\r\n      // and audio timelines change together. For more details, see the\r\n      // shouldWaitForTimelineChange function.\r\n\r\n\r\n      if (_this.loaderType_ === 'main') {\r\n        _this.timelineChangeController_.on('pendingtimelinechange', function () {\r\n          if (_this.hasEnoughInfoToAppend_()) {\r\n            _this.processCallQueue_();\r\n          }\r\n        });\r\n      } // The main loader only listens on pending timeline changes, but the audio loader,\r\n      // since its loads follow main, needs to listen on timeline changes. For more details,\r\n      // see the shouldWaitForTimelineChange function.\r\n\r\n\r\n      if (_this.loaderType_ === 'audio') {\r\n        _this.timelineChangeController_.on('timelinechange', function () {\r\n          if (_this.hasEnoughInfoToLoad_()) {\r\n            _this.processLoadQueue_();\r\n          }\r\n\r\n          if (_this.hasEnoughInfoToAppend_()) {\r\n            _this.processCallQueue_();\r\n          }\r\n        });\r\n      }\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = SegmentLoader.prototype;\r\n\r\n    _proto.createTransmuxer_ = function createTransmuxer_() {\r\n      return segmentTransmuxer.createTransmuxer({\r\n        remux: false,\r\n        alignGopsAtEnd: this.safeAppend_,\r\n        keepOriginalTimestamps: true,\r\n        parse708captions: this.parse708captions_,\r\n        captionServices: this.captionServices_\r\n      });\r\n    }\r\n    /**\r\n     * reset all of our media stats\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.resetStats_ = function resetStats_() {\r\n      this.mediaBytesTransferred = 0;\r\n      this.mediaRequests = 0;\r\n      this.mediaRequestsAborted = 0;\r\n      this.mediaRequestsTimedout = 0;\r\n      this.mediaRequestsErrored = 0;\r\n      this.mediaTransferDuration = 0;\r\n      this.mediaSecondsLoaded = 0;\r\n      this.mediaAppends = 0;\r\n    }\r\n    /**\r\n     * dispose of the SegmentLoader and reset to the default state\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.trigger('dispose');\r\n      this.state = 'DISPOSED';\r\n      this.pause();\r\n      this.abort_();\r\n\r\n      if (this.transmuxer_) {\r\n        this.transmuxer_.terminate();\r\n      }\r\n\r\n      this.resetStats_();\r\n\r\n      if (this.checkBufferTimeout_) {\r\n        window.clearTimeout(this.checkBufferTimeout_);\r\n      }\r\n\r\n      if (this.syncController_ && this.triggerSyncInfoUpdate_) {\r\n        this.syncController_.off('syncinfoupdate', this.triggerSyncInfoUpdate_);\r\n      }\r\n\r\n      this.off();\r\n    };\r\n\r\n    _proto.setAudio = function setAudio(enable) {\r\n      this.audioDisabled_ = !enable;\r\n\r\n      if (enable) {\r\n        this.appendInitSegment_.audio = true;\r\n      } else {\r\n        // remove current track audio if it gets disabled\r\n        this.sourceUpdater_.removeAudio(0, this.duration_());\r\n      }\r\n    }\r\n    /**\r\n     * abort anything that is currently doing on with the SegmentLoader\r\n     * and reset to a default state\r\n     */\r\n    ;\r\n\r\n    _proto.abort = function abort() {\r\n      if (this.state !== 'WAITING') {\r\n        if (this.pendingSegment_) {\r\n          this.pendingSegment_ = null;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      this.abort_(); // We aborted the requests we were waiting on, so reset the loader's state to READY\r\n      // since we are no longer \"waiting\" on any requests. XHR callback is not always run\r\n      // when the request is aborted. This will prevent the loader from being stuck in the\r\n      // WAITING state indefinitely.\r\n\r\n      this.state = 'READY'; // don't wait for buffer check timeouts to begin fetching the\r\n      // next segment\r\n\r\n      if (!this.paused()) {\r\n        this.monitorBuffer_();\r\n      }\r\n    }\r\n    /**\r\n     * abort all pending xhr requests and null any pending segements\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.abort_ = function abort_() {\r\n      if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {\r\n        this.pendingSegment_.abortRequests();\r\n      } // clear out the segment being processed\r\n\r\n\r\n      this.pendingSegment_ = null;\r\n      this.callQueue_ = [];\r\n      this.loadQueue_ = [];\r\n      this.metadataQueue_.id3 = [];\r\n      this.metadataQueue_.caption = [];\r\n      this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);\r\n      this.waitingOnRemove_ = false;\r\n      window.clearTimeout(this.quotaExceededErrorRetryTimeout_);\r\n      this.quotaExceededErrorRetryTimeout_ = null;\r\n    };\r\n\r\n    _proto.checkForAbort_ = function checkForAbort_(requestId) {\r\n      // If the state is APPENDING, then aborts will not modify the state, meaning the first\r\n      // callback that happens should reset the state to READY so that loading can continue.\r\n      if (this.state === 'APPENDING' && !this.pendingSegment_) {\r\n        this.state = 'READY';\r\n        return true;\r\n      }\r\n\r\n      if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * set an error on the segment loader and null out any pending segements\r\n     *\r\n     * @param {Error} error the error to set on the SegmentLoader\r\n     * @return {Error} the error that was set or that is currently set\r\n     */\r\n    ;\r\n\r\n    _proto.error = function error(_error) {\r\n      if (typeof _error !== 'undefined') {\r\n        this.logger_('error occurred:', _error);\r\n        this.error_ = _error;\r\n      }\r\n\r\n      this.pendingSegment_ = null;\r\n      return this.error_;\r\n    };\r\n\r\n    _proto.endOfStream = function endOfStream() {\r\n      this.ended_ = true;\r\n\r\n      if (this.transmuxer_) {\r\n        // need to clear out any cached data to prepare for the new segment\r\n        segmentTransmuxer.reset(this.transmuxer_);\r\n      }\r\n\r\n      this.gopBuffer_.length = 0;\r\n      this.pause();\r\n      this.trigger('ended');\r\n    }\r\n    /**\r\n     * Indicates which time ranges are buffered\r\n     *\r\n     * @return {TimeRange}\r\n     *         TimeRange object representing the current buffered ranges\r\n     */\r\n    ;\r\n\r\n    _proto.buffered_ = function buffered_() {\r\n      var trackInfo = this.getMediaInfo_();\r\n\r\n      if (!this.sourceUpdater_ || !trackInfo) {\r\n        return videojs.createTimeRanges();\r\n      }\r\n\r\n      if (this.loaderType_ === 'main') {\r\n        var hasAudio = trackInfo.hasAudio,\r\n            hasVideo = trackInfo.hasVideo,\r\n            isMuxed = trackInfo.isMuxed;\r\n\r\n        if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) {\r\n          return this.sourceUpdater_.buffered();\r\n        }\r\n\r\n        if (hasVideo) {\r\n          return this.sourceUpdater_.videoBuffered();\r\n        }\r\n      } // One case that can be ignored for now is audio only with alt audio,\r\n      // as we don't yet have proper support for that.\r\n\r\n\r\n      return this.sourceUpdater_.audioBuffered();\r\n    }\r\n    /**\r\n     * Gets and sets init segment for the provided map\r\n     *\r\n     * @param {Object} map\r\n     *        The map object representing the init segment to get or set\r\n     * @param {boolean=} set\r\n     *        If true, the init segment for the provided map should be saved\r\n     * @return {Object}\r\n     *         map object for desired init segment\r\n     */\r\n    ;\r\n\r\n    _proto.initSegmentForMap = function initSegmentForMap(map, set) {\r\n      if (set === void 0) {\r\n        set = false;\r\n      }\r\n\r\n      if (!map) {\r\n        return null;\r\n      }\r\n\r\n      var id = initSegmentId(map);\r\n      var storedMap = this.initSegments_[id];\r\n\r\n      if (set && !storedMap && map.bytes) {\r\n        this.initSegments_[id] = storedMap = {\r\n          resolvedUri: map.resolvedUri,\r\n          byterange: map.byterange,\r\n          bytes: map.bytes,\r\n          tracks: map.tracks,\r\n          timescales: map.timescales\r\n        };\r\n      }\r\n\r\n      return storedMap || map;\r\n    }\r\n    /**\r\n     * Gets and sets key for the provided key\r\n     *\r\n     * @param {Object} key\r\n     *        The key object representing the key to get or set\r\n     * @param {boolean=} set\r\n     *        If true, the key for the provided key should be saved\r\n     * @return {Object}\r\n     *         Key object for desired key\r\n     */\r\n    ;\r\n\r\n    _proto.segmentKey = function segmentKey(key, set) {\r\n      if (set === void 0) {\r\n        set = false;\r\n      }\r\n\r\n      if (!key) {\r\n        return null;\r\n      }\r\n\r\n      var id = segmentKeyId(key);\r\n      var storedKey = this.keyCache_[id]; // TODO: We should use the HTTP Expires header to invalidate our cache per\r\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.3\r\n\r\n      if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) {\r\n        this.keyCache_[id] = storedKey = {\r\n          resolvedUri: key.resolvedUri,\r\n          bytes: key.bytes\r\n        };\r\n      }\r\n\r\n      var result = {\r\n        resolvedUri: (storedKey || key).resolvedUri\r\n      };\r\n\r\n      if (storedKey) {\r\n        result.bytes = storedKey.bytes;\r\n      }\r\n\r\n      return result;\r\n    }\r\n    /**\r\n     * Returns true if all configuration required for loading is present, otherwise false.\r\n     *\r\n     * @return {boolean} True if the all configuration is ready for loading\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.couldBeginLoading_ = function couldBeginLoading_() {\r\n      return this.playlist_ && !this.paused();\r\n    }\r\n    /**\r\n     * load a playlist and start to fill the buffer\r\n     */\r\n    ;\r\n\r\n    _proto.load = function load() {\r\n      // un-pause\r\n      this.monitorBuffer_(); // if we don't have a playlist yet, keep waiting for one to be\r\n      // specified\r\n\r\n      if (!this.playlist_) {\r\n        return;\r\n      } // if all the configuration is ready, initialize and begin loading\r\n\r\n\r\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\r\n        return this.init_();\r\n      } // if we're in the middle of processing a segment already, don't\r\n      // kick off an additional segment request\r\n\r\n\r\n      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\r\n        return;\r\n      }\r\n\r\n      this.state = 'READY';\r\n    }\r\n    /**\r\n     * Once all the starting parameters have been specified, begin\r\n     * operation. This method should only be invoked from the INIT\r\n     * state.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.init_ = function init_() {\r\n      this.state = 'READY'; // if this is the audio segment loader, and it hasn't been inited before, then any old\r\n      // audio data from the muxed content should be removed\r\n\r\n      this.resetEverything();\r\n      return this.monitorBuffer_();\r\n    }\r\n    /**\r\n     * set a playlist on the segment loader\r\n     *\r\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\r\n     */\r\n    ;\r\n\r\n    _proto.playlist = function playlist(newPlaylist, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      if (!newPlaylist) {\r\n        return;\r\n      }\r\n\r\n      var oldPlaylist = this.playlist_;\r\n      var segmentInfo = this.pendingSegment_;\r\n      this.playlist_ = newPlaylist;\r\n      this.xhrOptions_ = options; // when we haven't started playing yet, the start of a live playlist\r\n      // is always our zero-time so force a sync update each time the playlist\r\n      // is refreshed from the server\r\n      //\r\n      // Use the INIT state to determine if playback has started, as the playlist sync info\r\n      // should be fixed once requests begin (as sync points are generated based on sync\r\n      // info), but not before then.\r\n\r\n      if (this.state === 'INIT') {\r\n        newPlaylist.syncInfo = {\r\n          mediaSequence: newPlaylist.mediaSequence,\r\n          time: 0\r\n        }; // Setting the date time mapping means mapping the program date time (if available)\r\n        // to time 0 on the player's timeline. The playlist's syncInfo serves a similar\r\n        // purpose, mapping the initial mediaSequence to time zero. Since the syncInfo can\r\n        // be updated as the playlist is refreshed before the loader starts loading, the\r\n        // program date time mapping needs to be updated as well.\r\n        //\r\n        // This mapping is only done for the main loader because a program date time should\r\n        // map equivalently between playlists.\r\n\r\n        if (this.loaderType_ === 'main') {\r\n          this.syncController_.setDateTimeMappingForStart(newPlaylist);\r\n        }\r\n      }\r\n\r\n      var oldId = null;\r\n\r\n      if (oldPlaylist) {\r\n        if (oldPlaylist.id) {\r\n          oldId = oldPlaylist.id;\r\n        } else if (oldPlaylist.uri) {\r\n          oldId = oldPlaylist.uri;\r\n        }\r\n      }\r\n\r\n      this.logger_(\"playlist update [\" + oldId + \" => \" + (newPlaylist.id || newPlaylist.uri) + \"]\"); // in VOD, this is always a rendition switch (or we updated our syncInfo above)\r\n      // in LIVE, we always want to update with new playlists (including refreshes)\r\n\r\n      this.trigger('syncinfoupdate'); // if we were unpaused but waiting for a playlist, start\r\n      // buffering now\r\n\r\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\r\n        return this.init_();\r\n      }\r\n\r\n      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\r\n        if (this.mediaIndex !== null) {\r\n          // we must reset/resync the segment loader when we switch renditions and\r\n          // the segment loader is already synced to the previous rendition\r\n          // on playlist changes we want it to be possible to fetch\r\n          // at the buffer for vod but not for live. So we use resetLoader\r\n          // for live and resyncLoader for vod. We want this because\r\n          // if a playlist uses independent and non-independent segments/parts the\r\n          // buffer may not accurately reflect the next segment that we should try\r\n          // downloading.\r\n          if (!newPlaylist.endList) {\r\n            this.resetLoader();\r\n          } else {\r\n            this.resyncLoader();\r\n          }\r\n        }\r\n\r\n        this.currentMediaInfo_ = void 0;\r\n        this.trigger('playlistupdate'); // the rest of this function depends on `oldPlaylist` being defined\r\n\r\n        return;\r\n      } // we reloaded the same playlist so we are in a live scenario\r\n      // and we will likely need to adjust the mediaIndex\r\n\r\n\r\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\r\n      this.logger_(\"live window shift [\" + mediaSequenceDiff + \"]\"); // update the mediaIndex on the SegmentLoader\r\n      // this is important because we can abort a request and this value must be\r\n      // equal to the last appended mediaIndex\r\n\r\n      if (this.mediaIndex !== null) {\r\n        this.mediaIndex -= mediaSequenceDiff; // this can happen if we are going to load the first segment, but get a playlist\r\n        // update during that. mediaIndex would go from 0 to -1 if mediaSequence in the\r\n        // new playlist was incremented by 1.\r\n\r\n        if (this.mediaIndex < 0) {\r\n          this.mediaIndex = null;\r\n          this.partIndex = null;\r\n        } else {\r\n          var segment = this.playlist_.segments[this.mediaIndex]; // partIndex should remain the same for the same segment\r\n          // unless parts fell off of the playlist for this segment.\r\n          // In that case we need to reset partIndex and resync\r\n\r\n          if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {\r\n            var mediaIndex = this.mediaIndex;\r\n            this.logger_(\"currently processing part (index \" + this.partIndex + \") no longer exists.\");\r\n            this.resetLoader(); // We want to throw away the partIndex and the data associated with it,\r\n            // as the part was dropped from our current playlists segment.\r\n            // The mediaIndex will still be valid so keep that around.\r\n\r\n            this.mediaIndex = mediaIndex;\r\n          }\r\n        }\r\n      } // update the mediaIndex on the SegmentInfo object\r\n      // this is important because we will update this.mediaIndex with this value\r\n      // in `handleAppendsDone_` after the segment has been successfully appended\r\n\r\n\r\n      if (segmentInfo) {\r\n        segmentInfo.mediaIndex -= mediaSequenceDiff;\r\n\r\n        if (segmentInfo.mediaIndex < 0) {\r\n          segmentInfo.mediaIndex = null;\r\n          segmentInfo.partIndex = null;\r\n        } else {\r\n          // we need to update the referenced segment so that timing information is\r\n          // saved for the new playlist's segment, however, if the segment fell off the\r\n          // playlist, we can leave the old reference and just lose the timing info\r\n          if (segmentInfo.mediaIndex >= 0) {\r\n            segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\r\n          }\r\n\r\n          if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {\r\n            segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];\r\n          }\r\n        }\r\n      }\r\n\r\n      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\r\n    }\r\n    /**\r\n     * Prevent the loader from fetching additional segments. If there\r\n     * is a segment request outstanding, it will finish processing\r\n     * before the loader halts. A segment loader can be unpaused by\r\n     * calling load().\r\n     */\r\n    ;\r\n\r\n    _proto.pause = function pause() {\r\n      if (this.checkBufferTimeout_) {\r\n        window.clearTimeout(this.checkBufferTimeout_);\r\n        this.checkBufferTimeout_ = null;\r\n      }\r\n    }\r\n    /**\r\n     * Returns whether the segment loader is fetching additional\r\n     * segments when given the opportunity. This property can be\r\n     * modified through calls to pause() and load().\r\n     */\r\n    ;\r\n\r\n    _proto.paused = function paused() {\r\n      return this.checkBufferTimeout_ === null;\r\n    }\r\n    /**\r\n     * Delete all the buffered data and reset the SegmentLoader\r\n     *\r\n     * @param {Function} [done] an optional callback to be executed when the remove\r\n     * operation is complete\r\n     */\r\n    ;\r\n\r\n    _proto.resetEverything = function resetEverything(done) {\r\n      this.ended_ = false;\r\n      this.appendInitSegment_ = {\r\n        audio: true,\r\n        video: true\r\n      };\r\n      this.resetLoader(); // remove from 0, the earliest point, to Infinity, to signify removal of everything.\r\n      // VTT Segment Loader doesn't need to do anything but in the regular SegmentLoader,\r\n      // we then clamp the value to duration if necessary.\r\n\r\n      this.remove(0, Infinity, done); // clears fmp4 captions\r\n\r\n      if (this.transmuxer_) {\r\n        this.transmuxer_.postMessage({\r\n          action: 'clearAllMp4Captions'\r\n        }); // reset the cache in the transmuxer\r\n\r\n        this.transmuxer_.postMessage({\r\n          action: 'reset'\r\n        });\r\n      }\r\n    }\r\n    /**\r\n     * Force the SegmentLoader to resync and start loading around the currentTime instead\r\n     * of starting at the end of the buffer\r\n     *\r\n     * Useful for fast quality changes\r\n     */\r\n    ;\r\n\r\n    _proto.resetLoader = function resetLoader() {\r\n      this.fetchAtBuffer_ = false;\r\n      this.resyncLoader();\r\n    }\r\n    /**\r\n     * Force the SegmentLoader to restart synchronization and make a conservative guess\r\n     * before returning to the simple walk-forward method\r\n     */\r\n    ;\r\n\r\n    _proto.resyncLoader = function resyncLoader() {\r\n      if (this.transmuxer_) {\r\n        // need to clear out any cached data to prepare for the new segment\r\n        segmentTransmuxer.reset(this.transmuxer_);\r\n      }\r\n\r\n      this.mediaIndex = null;\r\n      this.partIndex = null;\r\n      this.syncPoint_ = null;\r\n      this.isPendingTimestampOffset_ = false;\r\n      this.callQueue_ = [];\r\n      this.loadQueue_ = [];\r\n      this.metadataQueue_.id3 = [];\r\n      this.metadataQueue_.caption = [];\r\n      this.abort();\r\n\r\n      if (this.transmuxer_) {\r\n        this.transmuxer_.postMessage({\r\n          action: 'clearParsedMp4Captions'\r\n        });\r\n      }\r\n    }\r\n    /**\r\n     * Remove any data in the source buffer between start and end times\r\n     *\r\n     * @param {number} start - the start time of the region to remove from the buffer\r\n     * @param {number} end - the end time of the region to remove from the buffer\r\n     * @param {Function} [done] - an optional callback to be executed when the remove\r\n     * @param {boolean} force - force all remove operations to happen\r\n     * operation is complete\r\n     */\r\n    ;\r\n\r\n    _proto.remove = function remove(start, end, done, force) {\r\n      if (done === void 0) {\r\n        done = function done() {};\r\n      }\r\n\r\n      if (force === void 0) {\r\n        force = false;\r\n      } // clamp end to duration if we need to remove everything.\r\n      // This is due to a browser bug that causes issues if we remove to Infinity.\r\n      // videojs/videojs-contrib-hls#1225\r\n\r\n\r\n      if (end === Infinity) {\r\n        end = this.duration_();\r\n      } // skip removes that would throw an error\r\n      // commonly happens during a rendition switch at the start of a video\r\n      // from start 0 to end 0\r\n\r\n\r\n      if (end <= start) {\r\n        this.logger_('skipping remove because end ${end} is <= start ${start}');\r\n        return;\r\n      }\r\n\r\n      if (!this.sourceUpdater_ || !this.getMediaInfo_()) {\r\n        this.logger_('skipping remove because no source updater or starting media info'); // nothing to remove if we haven't processed any media\r\n\r\n        return;\r\n      } // set it to one to complete this function's removes\r\n\r\n\r\n      var removesRemaining = 1;\r\n\r\n      var removeFinished = function removeFinished() {\r\n        removesRemaining--;\r\n\r\n        if (removesRemaining === 0) {\r\n          done();\r\n        }\r\n      };\r\n\r\n      if (force || !this.audioDisabled_) {\r\n        removesRemaining++;\r\n        this.sourceUpdater_.removeAudio(start, end, removeFinished);\r\n      } // While it would be better to only remove video if the main loader has video, this\r\n      // should be safe with audio only as removeVideo will call back even if there's no\r\n      // video buffer.\r\n      //\r\n      // In theory we can check to see if there's video before calling the remove, but in\r\n      // the event that we're switching between renditions and from video to audio only\r\n      // (when we add support for that), we may need to clear the video contents despite\r\n      // what the new media will contain.\r\n\r\n\r\n      if (force || this.loaderType_ === 'main') {\r\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\r\n        removesRemaining++;\r\n        this.sourceUpdater_.removeVideo(start, end, removeFinished);\r\n      } // remove any captions and ID3 tags\r\n\r\n\r\n      for (var track in this.inbandTextTracks_) {\r\n        removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);\r\n      }\r\n\r\n      removeCuesFromTrack(start, end, this.segmentMetadataTrack_); // finished this function's removes\r\n\r\n      removeFinished();\r\n    }\r\n    /**\r\n     * (re-)schedule monitorBufferTick_ to run as soon as possible\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.monitorBuffer_ = function monitorBuffer_() {\r\n      if (this.checkBufferTimeout_) {\r\n        window.clearTimeout(this.checkBufferTimeout_);\r\n      }\r\n\r\n      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1);\r\n    }\r\n    /**\r\n     * As long as the SegmentLoader is in the READY state, periodically\r\n     * invoke fillBuffer_().\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.monitorBufferTick_ = function monitorBufferTick_() {\r\n      if (this.state === 'READY') {\r\n        this.fillBuffer_();\r\n      }\r\n\r\n      if (this.checkBufferTimeout_) {\r\n        window.clearTimeout(this.checkBufferTimeout_);\r\n      }\r\n\r\n      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\r\n    }\r\n    /**\r\n     * fill the buffer with segements unless the sourceBuffers are\r\n     * currently updating\r\n     *\r\n     * Note: this function should only ever be called by monitorBuffer_\r\n     * and never directly\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.fillBuffer_ = function fillBuffer_() {\r\n      // TODO since the source buffer maintains a queue, and we shouldn't call this function\r\n      // except when we're ready for the next segment, this check can most likely be removed\r\n      if (this.sourceUpdater_.updating()) {\r\n        return;\r\n      } // see if we need to begin loading immediately\r\n\r\n\r\n      var segmentInfo = this.chooseNextRequest_();\r\n\r\n      if (!segmentInfo) {\r\n        return;\r\n      }\r\n\r\n      if (typeof segmentInfo.timestampOffset === 'number') {\r\n        this.isPendingTimestampOffset_ = false;\r\n        this.timelineChangeController_.pendingTimelineChange({\r\n          type: this.loaderType_,\r\n          from: this.currentTimeline_,\r\n          to: segmentInfo.timeline\r\n        });\r\n      }\r\n\r\n      this.loadSegment_(segmentInfo);\r\n    }\r\n    /**\r\n     * Determines if we should call endOfStream on the media source based\r\n     * on the state of the buffer or if appened segment was the final\r\n     * segment in the playlist.\r\n     *\r\n     * @param {number} [mediaIndex] the media index of segment we last appended\r\n     * @param {Object} [playlist] a media playlist object\r\n     * @return {boolean} do we need to call endOfStream on the MediaSource\r\n     */\r\n    ;\r\n\r\n    _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist, partIndex) {\r\n      if (mediaIndex === void 0) {\r\n        mediaIndex = this.mediaIndex;\r\n      }\r\n\r\n      if (playlist === void 0) {\r\n        playlist = this.playlist_;\r\n      }\r\n\r\n      if (partIndex === void 0) {\r\n        partIndex = this.partIndex;\r\n      }\r\n\r\n      if (!playlist || !this.mediaSource_) {\r\n        return false;\r\n      }\r\n\r\n      var segment = typeof mediaIndex === 'number' && playlist.segments[mediaIndex]; // mediaIndex is zero based but length is 1 based\r\n\r\n      var appendedLastSegment = mediaIndex + 1 === playlist.segments.length; // true if there are no parts, or this is the last part.\r\n\r\n      var appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length; // if we've buffered to the end of the video, we need to call endOfStream\r\n      // so that MediaSources can trigger the `ended` event when it runs out of\r\n      // buffered data instead of waiting for me\r\n\r\n      return playlist.endList && this.mediaSource_.readyState === 'open' && appendedLastSegment && appendedLastPart;\r\n    }\r\n    /**\r\n     * Determines what request should be made given current segment loader state.\r\n     *\r\n     * @return {Object} a request object that describes the segment/part to load\r\n     */\r\n    ;\r\n\r\n    _proto.chooseNextRequest_ = function chooseNextRequest_() {\r\n      var buffered = this.buffered_();\r\n      var bufferedEnd = lastBufferedEnd(buffered) || 0;\r\n      var bufferedTime = timeAheadOf(buffered, this.currentTime_());\r\n      var preloaded = !this.hasPlayed_() && bufferedTime >= 1;\r\n      var haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();\r\n      var segments = this.playlist_.segments; // return no segment if:\r\n      // 1. we don't have segments\r\n      // 2. The video has not yet played and we already downloaded a segment\r\n      // 3. we already have enough buffered time\r\n\r\n      if (!segments.length || preloaded || haveEnoughBuffer) {\r\n        return null;\r\n      }\r\n\r\n      this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\r\n      var next = {\r\n        partIndex: null,\r\n        mediaIndex: null,\r\n        startOfSegment: null,\r\n        playlist: this.playlist_,\r\n        isSyncRequest: Boolean(!this.syncPoint_)\r\n      };\r\n\r\n      if (next.isSyncRequest) {\r\n        next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);\r\n      } else if (this.mediaIndex !== null) {\r\n        var segment = segments[this.mediaIndex];\r\n        var partIndex = typeof this.partIndex === 'number' ? this.partIndex : -1;\r\n        next.startOfSegment = segment.end ? segment.end : bufferedEnd;\r\n\r\n        if (segment.parts && segment.parts[partIndex + 1]) {\r\n          next.mediaIndex = this.mediaIndex;\r\n          next.partIndex = partIndex + 1;\r\n        } else {\r\n          next.mediaIndex = this.mediaIndex + 1;\r\n        }\r\n      } else {\r\n        // Find the segment containing the end of the buffer or current time.\r\n        var _Playlist$getMediaInf = Playlist.getMediaInfoForTime({\r\n          experimentalExactManifestTimings: this.experimentalExactManifestTimings,\r\n          playlist: this.playlist_,\r\n          currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),\r\n          startingPartIndex: this.syncPoint_.partIndex,\r\n          startingSegmentIndex: this.syncPoint_.segmentIndex,\r\n          startTime: this.syncPoint_.time\r\n        }),\r\n            segmentIndex = _Playlist$getMediaInf.segmentIndex,\r\n            startTime = _Playlist$getMediaInf.startTime,\r\n            _partIndex = _Playlist$getMediaInf.partIndex;\r\n\r\n        next.getMediaInfoForTime = this.fetchAtBuffer_ ? \"bufferedEnd \" + bufferedEnd : \"currentTime \" + this.currentTime_();\r\n        next.mediaIndex = segmentIndex;\r\n        next.startOfSegment = startTime;\r\n        next.partIndex = _partIndex;\r\n      }\r\n\r\n      var nextSegment = segments[next.mediaIndex];\r\n      var nextPart = nextSegment && typeof next.partIndex === 'number' && nextSegment.parts && nextSegment.parts[next.partIndex]; // if the next segment index is invalid or\r\n      // the next partIndex is invalid do not choose a next segment.\r\n\r\n      if (!nextSegment || typeof next.partIndex === 'number' && !nextPart) {\r\n        return null;\r\n      } // if the next segment has parts, and we don't have a partIndex.\r\n      // Set partIndex to 0\r\n\r\n\r\n      if (typeof next.partIndex !== 'number' && nextSegment.parts) {\r\n        next.partIndex = 0;\r\n        nextPart = nextSegment.parts[0];\r\n      } // if we have no buffered data then we need to make sure\r\n      // that the next part we append is \"independent\" if possible.\r\n      // So we check if the previous part is independent, and request\r\n      // it if it is.\r\n\r\n\r\n      if (!bufferedTime && nextPart && !nextPart.independent) {\r\n        if (next.partIndex === 0) {\r\n          var lastSegment = segments[next.mediaIndex - 1];\r\n          var lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];\r\n\r\n          if (lastSegmentLastPart && lastSegmentLastPart.independent) {\r\n            next.mediaIndex -= 1;\r\n            next.partIndex = lastSegment.parts.length - 1;\r\n            next.independent = 'previous segment';\r\n          }\r\n        } else if (nextSegment.parts[next.partIndex - 1].independent) {\r\n          next.partIndex -= 1;\r\n          next.independent = 'previous part';\r\n        }\r\n      }\r\n\r\n      var ended = this.mediaSource_ && this.mediaSource_.readyState === 'ended'; // do not choose a next segment if all of the following:\r\n      // 1. this is the last segment in the playlist\r\n      // 2. end of stream has been called on the media source already\r\n      // 3. the player is not seeking\r\n\r\n      if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {\r\n        return null;\r\n      }\r\n\r\n      return this.generateSegmentInfo_(next);\r\n    };\r\n\r\n    _proto.generateSegmentInfo_ = function generateSegmentInfo_(options) {\r\n      var independent = options.independent,\r\n          playlist = options.playlist,\r\n          mediaIndex = options.mediaIndex,\r\n          startOfSegment = options.startOfSegment,\r\n          isSyncRequest = options.isSyncRequest,\r\n          partIndex = options.partIndex,\r\n          forceTimestampOffset = options.forceTimestampOffset,\r\n          getMediaInfoForTime = options.getMediaInfoForTime;\r\n      var segment = playlist.segments[mediaIndex];\r\n      var part = typeof partIndex === 'number' && segment.parts[partIndex];\r\n      var segmentInfo = {\r\n        requestId: 'segment-loader-' + Math.random(),\r\n        // resolve the segment URL relative to the playlist\r\n        uri: part && part.resolvedUri || segment.resolvedUri,\r\n        // the segment's mediaIndex at the time it was requested\r\n        mediaIndex: mediaIndex,\r\n        partIndex: part ? partIndex : null,\r\n        // whether or not to update the SegmentLoader's state with this\r\n        // segment's mediaIndex\r\n        isSyncRequest: isSyncRequest,\r\n        startOfSegment: startOfSegment,\r\n        // the segment's playlist\r\n        playlist: playlist,\r\n        // unencrypted bytes of the segment\r\n        bytes: null,\r\n        // when a key is defined for this segment, the encrypted bytes\r\n        encryptedBytes: null,\r\n        // The target timestampOffset for this segment when we append it\r\n        // to the source buffer\r\n        timestampOffset: null,\r\n        // The timeline that the segment is in\r\n        timeline: segment.timeline,\r\n        // The expected duration of the segment in seconds\r\n        duration: part && part.duration || segment.duration,\r\n        // retain the segment in case the playlist updates while doing an async process\r\n        segment: segment,\r\n        part: part,\r\n        byteLength: 0,\r\n        transmuxer: this.transmuxer_,\r\n        // type of getMediaInfoForTime that was used to get this segment\r\n        getMediaInfoForTime: getMediaInfoForTime,\r\n        independent: independent\r\n      };\r\n      var overrideCheck = typeof forceTimestampOffset !== 'undefined' ? forceTimestampOffset : this.isPendingTimestampOffset_;\r\n      segmentInfo.timestampOffset = this.timestampOffsetForSegment_({\r\n        segmentTimeline: segment.timeline,\r\n        currentTimeline: this.currentTimeline_,\r\n        startOfSegment: startOfSegment,\r\n        buffered: this.buffered_(),\r\n        overrideCheck: overrideCheck\r\n      });\r\n      var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());\r\n\r\n      if (typeof audioBufferedEnd === 'number') {\r\n        // since the transmuxer is using the actual timing values, but the buffer is\r\n        // adjusted by the timestamp offset, we must adjust the value here\r\n        segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();\r\n      }\r\n\r\n      if (this.sourceUpdater_.videoBuffered().length) {\r\n        segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_, // since the transmuxer is using the actual timing values, but the time is\r\n        // adjusted by the timestmap offset, we must adjust the value here\r\n        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);\r\n      }\r\n\r\n      return segmentInfo;\r\n    } // get the timestampoffset for a segment,\r\n    // added so that vtt segment loader can override and prevent\r\n    // adding timestamp offsets.\r\n    ;\r\n\r\n    _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_(options) {\r\n      return timestampOffsetForSegment(options);\r\n    }\r\n    /**\r\n     * Determines if the network has enough bandwidth to complete the current segment\r\n     * request in a timely manner. If not, the request will be aborted early and bandwidth\r\n     * updated to trigger a playlist switch.\r\n     *\r\n     * @param {Object} stats\r\n     *        Object containing stats about the request timing and size\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.earlyAbortWhenNeeded_ = function earlyAbortWhenNeeded_(stats) {\r\n      if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition\r\n      // TODO: Replace using timeout with a boolean indicating whether this playlist is\r\n      //       the lowestEnabledRendition.\r\n      !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes\r\n      !this.playlist_.attributes.BANDWIDTH) {\r\n        return;\r\n      } // Wait at least 1 second since the first byte of data has been received before\r\n      // using the calculated bandwidth from the progress event to allow the bitrate\r\n      // to stabilize\r\n\r\n\r\n      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\r\n        return;\r\n      }\r\n\r\n      var currentTime = this.currentTime_();\r\n      var measuredBandwidth = stats.bandwidth;\r\n      var segmentDuration = this.pendingSegment_.duration;\r\n      var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived); // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\r\n      // if we are only left with less than 1 second when the request completes.\r\n      // A negative timeUntilRebuffering indicates we are already rebuffering\r\n\r\n      var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1; // Only consider aborting early if the estimated time to finish the download\r\n      // is larger than the estimated time until the player runs out of forward buffer\r\n\r\n      if (requestTimeRemaining <= timeUntilRebuffer$1) {\r\n        return;\r\n      }\r\n\r\n      var switchCandidate = minRebufferMaxBandwidthSelector({\r\n        master: this.vhs_.playlists.master,\r\n        currentTime: currentTime,\r\n        bandwidth: measuredBandwidth,\r\n        duration: this.duration_(),\r\n        segmentDuration: segmentDuration,\r\n        timeUntilRebuffer: timeUntilRebuffer$1,\r\n        currentTimeline: this.currentTimeline_,\r\n        syncController: this.syncController_\r\n      });\r\n\r\n      if (!switchCandidate) {\r\n        return;\r\n      }\r\n\r\n      var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;\r\n      var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\r\n      var minimumTimeSaving = 0.5; // If we are already rebuffering, increase the amount of variance we add to the\r\n      // potential round trip time of the new request so that we are not too aggressive\r\n      // with switching to a playlist that might save us a fraction of a second.\r\n\r\n      if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {\r\n        minimumTimeSaving = 1;\r\n      }\r\n\r\n      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\r\n        return;\r\n      } // set the bandwidth to that of the desired playlist being sure to scale by\r\n      // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\r\n      // don't trigger a bandwidthupdate as the bandwidth is artifial\r\n\r\n\r\n      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;\r\n      this.trigger('earlyabort');\r\n    };\r\n\r\n    _proto.handleAbort_ = function handleAbort_(segmentInfo) {\r\n      this.logger_(\"Aborting \" + segmentInfoString(segmentInfo));\r\n      this.mediaRequestsAborted += 1;\r\n    }\r\n    /**\r\n     * XHR `progress` event handler\r\n     *\r\n     * @param {Event}\r\n     *        The XHR `progress` event\r\n     * @param {Object} simpleSegment\r\n     *        A simplified segment object copy\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleProgress_ = function handleProgress_(event, simpleSegment) {\r\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      }\r\n\r\n      this.trigger('progress');\r\n    };\r\n\r\n    _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {\r\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      }\r\n\r\n      if (this.checkForIllegalMediaSwitch(trackInfo)) {\r\n        return;\r\n      }\r\n\r\n      trackInfo = trackInfo || {}; // When we have track info, determine what media types this loader is dealing with.\r\n      // Guard against cases where we're not getting track info at all until we are\r\n      // certain that all streams will provide it.\r\n\r\n      if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {\r\n        this.appendInitSegment_ = {\r\n          audio: true,\r\n          video: true\r\n        };\r\n        this.startingMediaInfo_ = trackInfo;\r\n        this.currentMediaInfo_ = trackInfo;\r\n        this.logger_('trackinfo update', trackInfo);\r\n        this.trigger('trackinfo');\r\n      } // trackinfo may cause an abort if the trackinfo\r\n      // causes a codec change to an unsupported codec.\r\n\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      } // set trackinfo on the pending segment so that\r\n      // it can append.\r\n\r\n\r\n      this.pendingSegment_.trackInfo = trackInfo; // check if any calls were waiting on the track info\r\n\r\n      if (this.hasEnoughInfoToAppend_()) {\r\n        this.processCallQueue_();\r\n      }\r\n    };\r\n\r\n    _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time) {\r\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_;\r\n      var timingInfoProperty = timingInfoPropertyForMedia(mediaType);\r\n      segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};\r\n      segmentInfo[timingInfoProperty][timeType] = time;\r\n      this.logger_(\"timinginfo: \" + mediaType + \" - \" + timeType + \" - \" + time); // check if any calls were waiting on the timing info\r\n\r\n      if (this.hasEnoughInfoToAppend_()) {\r\n        this.processCallQueue_();\r\n      }\r\n    };\r\n\r\n    _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {\r\n      var _this2 = this;\r\n\r\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      } // This could only happen with fmp4 segments, but\r\n      // should still not happen in general\r\n\r\n\r\n      if (captionData.length === 0) {\r\n        this.logger_('SegmentLoader received no captions from a caption event');\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // Wait until we have some video data so that caption timing\r\n      // can be adjusted by the timestamp offset\r\n\r\n      if (!segmentInfo.hasAppendedData_) {\r\n        this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));\r\n        return;\r\n      }\r\n\r\n      var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();\r\n      var captionTracks = {}; // get total start/end and captions for each track/stream\r\n\r\n      captionData.forEach(function (caption) {\r\n        // caption.stream is actually a track name...\r\n        // set to the existing values in tracks or default values\r\n        captionTracks[caption.stream] = captionTracks[caption.stream] || {\r\n          // Infinity, as any other value will be less than this\r\n          startTime: Infinity,\r\n          captions: [],\r\n          // 0 as an other value will be more than this\r\n          endTime: 0\r\n        };\r\n        var captionTrack = captionTracks[caption.stream];\r\n        captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);\r\n        captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);\r\n        captionTrack.captions.push(caption);\r\n      });\r\n      Object.keys(captionTracks).forEach(function (trackName) {\r\n        var _captionTracks$trackN = captionTracks[trackName],\r\n            startTime = _captionTracks$trackN.startTime,\r\n            endTime = _captionTracks$trackN.endTime,\r\n            captions = _captionTracks$trackN.captions;\r\n        var inbandTextTracks = _this2.inbandTextTracks_;\r\n\r\n        _this2.logger_(\"adding cues from \" + startTime + \" -> \" + endTime + \" for \" + trackName);\r\n\r\n        createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName); // clear out any cues that start and end at the same time period for the same track.\r\n        // We do this because a rendition change that also changes the timescale for captions\r\n        // will result in captions being re-parsed for certain segments. If we add them again\r\n        // without clearing we will have two of the same captions visible.\r\n\r\n        removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);\r\n        addCaptionData({\r\n          captionArray: captions,\r\n          inbandTextTracks: inbandTextTracks,\r\n          timestampOffset: timestampOffset\r\n        });\r\n      }); // Reset stored captions since we added parsed\r\n      // captions to a text track at this point\r\n\r\n      if (this.transmuxer_) {\r\n        this.transmuxer_.postMessage({\r\n          action: 'clearParsedMp4Captions'\r\n        });\r\n      }\r\n    };\r\n\r\n    _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {\r\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // we need to have appended data in order for the timestamp offset to be set\r\n\r\n      if (!segmentInfo.hasAppendedData_) {\r\n        this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));\r\n        return;\r\n      }\r\n\r\n      var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(); // There's potentially an issue where we could double add metadata if there's a muxed\r\n      // audio/video source with a metadata track, and an alt audio with a metadata track.\r\n      // However, this probably won't happen, and if it does it can be handled then.\r\n\r\n      createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);\r\n      addMetadata({\r\n        inbandTextTracks: this.inbandTextTracks_,\r\n        metadataArray: id3Frames,\r\n        timestampOffset: timestampOffset,\r\n        videoDuration: this.duration_()\r\n      });\r\n    };\r\n\r\n    _proto.processMetadataQueue_ = function processMetadataQueue_() {\r\n      this.metadataQueue_.id3.forEach(function (fn) {\r\n        return fn();\r\n      });\r\n      this.metadataQueue_.caption.forEach(function (fn) {\r\n        return fn();\r\n      });\r\n      this.metadataQueue_.id3 = [];\r\n      this.metadataQueue_.caption = [];\r\n    };\r\n\r\n    _proto.processCallQueue_ = function processCallQueue_() {\r\n      var callQueue = this.callQueue_; // Clear out the queue before the queued functions are run, since some of the\r\n      // functions may check the length of the load queue and default to pushing themselves\r\n      // back onto the queue.\r\n\r\n      this.callQueue_ = [];\r\n      callQueue.forEach(function (fun) {\r\n        return fun();\r\n      });\r\n    };\r\n\r\n    _proto.processLoadQueue_ = function processLoadQueue_() {\r\n      var loadQueue = this.loadQueue_; // Clear out the queue before the queued functions are run, since some of the\r\n      // functions may check the length of the load queue and default to pushing themselves\r\n      // back onto the queue.\r\n\r\n      this.loadQueue_ = [];\r\n      loadQueue.forEach(function (fun) {\r\n        return fun();\r\n      });\r\n    }\r\n    /**\r\n     * Determines whether the loader has enough info to load the next segment.\r\n     *\r\n     * @return {boolean}\r\n     *         Whether or not the loader has enough info to load the next segment\r\n     */\r\n    ;\r\n\r\n    _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {\r\n      // Since primary timing goes by video, only the audio loader potentially needs to wait\r\n      // to load.\r\n      if (this.loaderType_ !== 'audio') {\r\n        return true;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // A fill buffer must have already run to establish a pending segment before there's\r\n      // enough info to load.\r\n\r\n      if (!segmentInfo) {\r\n        return false;\r\n      } // The first segment can and should be loaded immediately so that source buffers are\r\n      // created together (before appending). Source buffer creation uses the presence of\r\n      // audio and video data to determine whether to create audio/video source buffers, and\r\n      // uses processed (transmuxed or parsed) media to determine the types required.\r\n\r\n\r\n      if (!this.getCurrentMediaInfo_()) {\r\n        return true;\r\n      }\r\n\r\n      if ( // Technically, instead of waiting to load a segment on timeline changes, a segment\r\n      // can be requested and downloaded and only wait before it is transmuxed or parsed.\r\n      // But in practice, there are a few reasons why it is better to wait until a loader\r\n      // is ready to append that segment before requesting and downloading:\r\n      //\r\n      // 1. Because audio and main loaders cross discontinuities together, if this loader\r\n      //    is waiting for the other to catch up, then instead of requesting another\r\n      //    segment and using up more bandwidth, by not yet loading, more bandwidth is\r\n      //    allotted to the loader currently behind.\r\n      // 2. media-segment-request doesn't have to have logic to consider whether a segment\r\n      // is ready to be processed or not, isolating the queueing behavior to the loader.\r\n      // 3. The audio loader bases some of its segment properties on timing information\r\n      //    provided by the main loader, meaning that, if the logic for waiting on\r\n      //    processing was in media-segment-request, then it would also need to know how\r\n      //    to re-generate the segment information after the main loader caught up.\r\n      shouldWaitForTimelineChange({\r\n        timelineChangeController: this.timelineChangeController_,\r\n        currentTimeline: this.currentTimeline_,\r\n        segmentTimeline: segmentInfo.timeline,\r\n        loaderType: this.loaderType_,\r\n        audioDisabled: this.audioDisabled_\r\n      })) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    };\r\n\r\n    _proto.getCurrentMediaInfo_ = function getCurrentMediaInfo_(segmentInfo) {\r\n      if (segmentInfo === void 0) {\r\n        segmentInfo = this.pendingSegment_;\r\n      }\r\n\r\n      return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;\r\n    };\r\n\r\n    _proto.getMediaInfo_ = function getMediaInfo_(segmentInfo) {\r\n      if (segmentInfo === void 0) {\r\n        segmentInfo = this.pendingSegment_;\r\n      }\r\n\r\n      return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;\r\n    };\r\n\r\n    _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {\r\n      if (!this.sourceUpdater_.ready()) {\r\n        return false;\r\n      } // If content needs to be removed or the loader is waiting on an append reattempt,\r\n      // then no additional content should be appended until the prior append is resolved.\r\n\r\n\r\n      if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {\r\n        return false;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_;\r\n      var trackInfo = this.getCurrentMediaInfo_(); // no segment to append any data for or\r\n      // we do not have information on this specific\r\n      // segment yet\r\n\r\n      if (!segmentInfo || !trackInfo) {\r\n        return false;\r\n      }\r\n\r\n      var hasAudio = trackInfo.hasAudio,\r\n          hasVideo = trackInfo.hasVideo,\r\n          isMuxed = trackInfo.isMuxed;\r\n\r\n      if (hasVideo && !segmentInfo.videoTimingInfo) {\r\n        return false;\r\n      } // muxed content only relies on video timing information for now.\r\n\r\n\r\n      if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) {\r\n        return false;\r\n      }\r\n\r\n      if (shouldWaitForTimelineChange({\r\n        timelineChangeController: this.timelineChangeController_,\r\n        currentTimeline: this.currentTimeline_,\r\n        segmentTimeline: segmentInfo.timeline,\r\n        loaderType: this.loaderType_,\r\n        audioDisabled: this.audioDisabled_\r\n      })) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    };\r\n\r\n    _proto.handleData_ = function handleData_(simpleSegment, result) {\r\n      this.earlyAbortWhenNeeded_(simpleSegment.stats);\r\n\r\n      if (this.checkForAbort_(simpleSegment.requestId)) {\r\n        return;\r\n      } // If there's anything in the call queue, then this data came later and should be\r\n      // executed after the calls currently queued.\r\n\r\n\r\n      if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {\r\n        this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // update the time mapping so we can translate from display time to media time\r\n\r\n      this.setTimeMapping_(segmentInfo.timeline); // for tracking overall stats\r\n\r\n      this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment); // Note that the state isn't changed from loading to appending. This is because abort\r\n      // logic may change behavior depending on the state, and changing state too early may\r\n      // inflate our estimates of bandwidth. In the future this should be re-examined to\r\n      // note more granular states.\r\n      // don't process and append data if the mediaSource is closed\r\n\r\n      if (this.mediaSource_.readyState === 'closed') {\r\n        return;\r\n      } // if this request included an initialization segment, save that data\r\n      // to the initSegment cache\r\n\r\n\r\n      if (simpleSegment.map) {\r\n        simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true); // move over init segment properties to media request\r\n\r\n        segmentInfo.segment.map = simpleSegment.map;\r\n      } // if this request included a segment key, save that data in the cache\r\n\r\n\r\n      if (simpleSegment.key) {\r\n        this.segmentKey(simpleSegment.key, true);\r\n      }\r\n\r\n      segmentInfo.isFmp4 = simpleSegment.isFmp4;\r\n      segmentInfo.timingInfo = segmentInfo.timingInfo || {};\r\n\r\n      if (segmentInfo.isFmp4) {\r\n        this.trigger('fmp4');\r\n        segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;\r\n      } else {\r\n        var trackInfo = this.getCurrentMediaInfo_();\r\n        var useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\r\n        var firstVideoFrameTimeForData;\r\n\r\n        if (useVideoTimingInfo) {\r\n          firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;\r\n        } // Segment loader knows more about segment timing than the transmuxer (in certain\r\n        // aspects), so make any changes required for a more accurate start time.\r\n        // Don't set the end time yet, as the segment may not be finished processing.\r\n\r\n\r\n        segmentInfo.timingInfo.start = this.trueSegmentStart_({\r\n          currentStart: segmentInfo.timingInfo.start,\r\n          playlist: segmentInfo.playlist,\r\n          mediaIndex: segmentInfo.mediaIndex,\r\n          currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),\r\n          useVideoTimingInfo: useVideoTimingInfo,\r\n          firstVideoFrameTimeForData: firstVideoFrameTimeForData,\r\n          videoTimingInfo: segmentInfo.videoTimingInfo,\r\n          audioTimingInfo: segmentInfo.audioTimingInfo\r\n        });\r\n      } // Init segments for audio and video only need to be appended in certain cases. Now\r\n      // that data is about to be appended, we can check the final cases to determine\r\n      // whether we should append an init segment.\r\n\r\n\r\n      this.updateAppendInitSegmentStatus(segmentInfo, result.type); // Timestamp offset should be updated once we get new data and have its timing info,\r\n      // as we use the start of the segment to offset the best guess (playlist provided)\r\n      // timestamp offset.\r\n\r\n      this.updateSourceBufferTimestampOffset_(segmentInfo); // if this is a sync request we need to determine whether it should\r\n      // be appended or not.\r\n\r\n      if (segmentInfo.isSyncRequest) {\r\n        // first save/update our timing info for this segment.\r\n        // this is what allows us to choose an accurate segment\r\n        // and the main reason we make a sync request.\r\n        this.updateTimingInfoEnd_(segmentInfo);\r\n        this.syncController_.saveSegmentTimingInfo({\r\n          segmentInfo: segmentInfo,\r\n          shouldSaveTimelineMapping: this.loaderType_ === 'main'\r\n        });\r\n        var next = this.chooseNextRequest_(); // If the sync request isn't the segment that would be requested next\r\n        // after taking into account its timing info, do not append it.\r\n\r\n        if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {\r\n          this.logger_('sync segment was incorrect, not appending');\r\n          return;\r\n        } // otherwise append it like any other segment as our guess was correct.\r\n\r\n\r\n        this.logger_('sync segment was correct, appending');\r\n      } // Save some state so that in the future anything waiting on first append (and/or\r\n      // timestamp offset(s)) can process immediately. While the extra state isn't optimal,\r\n      // we need some notion of whether the timestamp offset or other relevant information\r\n      // has had a chance to be set.\r\n\r\n\r\n      segmentInfo.hasAppendedData_ = true; // Now that the timestamp offset should be set, we can append any waiting ID3 tags.\r\n\r\n      this.processMetadataQueue_();\r\n      this.appendData_(segmentInfo, result);\r\n    };\r\n\r\n    _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type) {\r\n      // alt audio doesn't manage timestamp offset\r\n      if (this.loaderType_ === 'main' && typeof segmentInfo.timestampOffset === 'number' && // in the case that we're handling partial data, we don't want to append an init\r\n      // segment for each chunk\r\n      !segmentInfo.changedTimestampOffset) {\r\n        // if the timestamp offset changed, the timeline may have changed, so we have to re-\r\n        // append init segments\r\n        this.appendInitSegment_ = {\r\n          audio: true,\r\n          video: true\r\n        };\r\n      }\r\n\r\n      if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {\r\n        // make sure we append init segment on playlist changes, in case the media config\r\n        // changed\r\n        this.appendInitSegment_[type] = true;\r\n      }\r\n    };\r\n\r\n    _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref4) {\r\n      var type = _ref4.type,\r\n          initSegment = _ref4.initSegment,\r\n          map = _ref4.map,\r\n          playlist = _ref4.playlist; // \"The EXT-X-MAP tag specifies how to obtain the Media Initialization Section\r\n      // (Section 3) required to parse the applicable Media Segments.  It applies to every\r\n      // Media Segment that appears after it in the Playlist until the next EXT-X-MAP tag\r\n      // or until the end of the playlist.\"\r\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.5\r\n\r\n      if (map) {\r\n        var id = initSegmentId(map);\r\n\r\n        if (this.activeInitSegmentId_ === id) {\r\n          // don't need to re-append the init segment if the ID matches\r\n          return null;\r\n        } // a map-specified init segment takes priority over any transmuxed (or otherwise\r\n        // obtained) init segment\r\n        //\r\n        // this also caches the init segment for later use\r\n\r\n\r\n        initSegment = this.initSegmentForMap(map, true).bytes;\r\n        this.activeInitSegmentId_ = id;\r\n      } // We used to always prepend init segments for video, however, that shouldn't be\r\n      // necessary. Instead, we should only append on changes, similar to what we've always\r\n      // done for audio. This is more important (though may not be that important) for\r\n      // frame-by-frame appending for LHLS, simply because of the increased quantity of\r\n      // appends.\r\n\r\n\r\n      if (initSegment && this.appendInitSegment_[type]) {\r\n        // Make sure we track the playlist that we last used for the init segment, so that\r\n        // we can re-append the init segment in the event that we get data from a new\r\n        // playlist. Discontinuities and track changes are handled in other sections.\r\n        this.playlistOfLastInitSegment_[type] = playlist; // Disable future init segment appends for this type. Until a change is necessary.\r\n\r\n        this.appendInitSegment_[type] = false; // we need to clear out the fmp4 active init segment id, since\r\n        // we are appending the muxer init segment\r\n\r\n        this.activeInitSegmentId_ = null;\r\n        return initSegment;\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    _proto.handleQuotaExceededError_ = function handleQuotaExceededError_(_ref5, error) {\r\n      var _this3 = this;\r\n\r\n      var segmentInfo = _ref5.segmentInfo,\r\n          type = _ref5.type,\r\n          bytes = _ref5.bytes;\r\n      var audioBuffered = this.sourceUpdater_.audioBuffered();\r\n      var videoBuffered = this.sourceUpdater_.videoBuffered(); // For now we're ignoring any notion of gaps in the buffer, but they, in theory,\r\n      // should be cleared out during the buffer removals. However, log in case it helps\r\n      // debug.\r\n\r\n      if (audioBuffered.length > 1) {\r\n        this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: ' + timeRangesToArray(audioBuffered).join(', '));\r\n      }\r\n\r\n      if (videoBuffered.length > 1) {\r\n        this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: ' + timeRangesToArray(videoBuffered).join(', '));\r\n      }\r\n\r\n      var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;\r\n      var audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;\r\n      var videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;\r\n      var videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;\r\n\r\n      if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {\r\n        // Can't remove enough buffer to make room for new segment (or the browser doesn't\r\n        // allow for appends of segments this size). In the future, it may be possible to\r\n        // split up the segment and append in pieces, but for now, error out this playlist\r\n        // in an attempt to switch to a more manageable rendition.\r\n        this.logger_('On QUOTA_EXCEEDED_ERR, single segment too large to append to ' + 'buffer, triggering an error. ' + (\"Appended byte length: \" + bytes.byteLength + \", \") + (\"audio buffer: \" + timeRangesToArray(audioBuffered).join(', ') + \", \") + (\"video buffer: \" + timeRangesToArray(videoBuffered).join(', ') + \", \"));\r\n        this.error({\r\n          message: 'Quota exceeded error with append of a single segment of content',\r\n          excludeUntil: Infinity\r\n        });\r\n        this.trigger('error');\r\n        return;\r\n      } // To try to resolve the quota exceeded error, clear back buffer and retry. This means\r\n      // that the segment-loader should block on future events until this one is handled, so\r\n      // that it doesn't keep moving onto further segments. Adding the call to the call\r\n      // queue will prevent further appends until waitingOnRemove_ and\r\n      // quotaExceededErrorRetryTimeout_ are cleared.\r\n      //\r\n      // Note that this will only block the current loader. In the case of demuxed content,\r\n      // the other load may keep filling as fast as possible. In practice, this should be\r\n      // OK, as it is a rare case when either audio has a high enough bitrate to fill up a\r\n      // source buffer, or video fills without enough room for audio to append (and without\r\n      // the availability of clearing out seconds of back buffer to make room for audio).\r\n      // But it might still be good to handle this case in the future as a TODO.\r\n\r\n\r\n      this.waitingOnRemove_ = true;\r\n      this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {\r\n        segmentInfo: segmentInfo,\r\n        type: type,\r\n        bytes: bytes\r\n      }));\r\n      var currentTime = this.currentTime_(); // Try to remove as much audio and video as possible to make room for new content\r\n      // before retrying.\r\n\r\n      var timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;\r\n      this.logger_(\"On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to \" + timeToRemoveUntil);\r\n      this.remove(0, timeToRemoveUntil, function () {\r\n        _this3.logger_(\"On QUOTA_EXCEEDED_ERR, retrying append in \" + MIN_BACK_BUFFER + \"s\");\r\n\r\n        _this3.waitingOnRemove_ = false; // wait the length of time alotted in the back buffer to prevent wasted\r\n        // attempts (since we can't clear less than the minimum)\r\n\r\n        _this3.quotaExceededErrorRetryTimeout_ = window.setTimeout(function () {\r\n          _this3.logger_('On QUOTA_EXCEEDED_ERR, re-processing call queue');\r\n\r\n          _this3.quotaExceededErrorRetryTimeout_ = null;\r\n\r\n          _this3.processCallQueue_();\r\n        }, MIN_BACK_BUFFER * 1000);\r\n      }, true);\r\n    };\r\n\r\n    _proto.handleAppendError_ = function handleAppendError_(_ref6, error) {\r\n      var segmentInfo = _ref6.segmentInfo,\r\n          type = _ref6.type,\r\n          bytes = _ref6.bytes; // if there's no error, nothing to do\r\n\r\n      if (!error) {\r\n        return;\r\n      }\r\n\r\n      if (error.code === QUOTA_EXCEEDED_ERR) {\r\n        this.handleQuotaExceededError_({\r\n          segmentInfo: segmentInfo,\r\n          type: type,\r\n          bytes: bytes\r\n        }); // A quota exceeded error should be recoverable with a future re-append, so no need\r\n        // to trigger an append error.\r\n\r\n        return;\r\n      }\r\n\r\n      this.logger_('Received non QUOTA_EXCEEDED_ERR on append', error);\r\n      this.error(type + \" append of \" + bytes.length + \"b failed for segment \" + (\"#\" + segmentInfo.mediaIndex + \" in playlist \" + segmentInfo.playlist.id)); // If an append errors, we often can't recover.\r\n      // (see https://w3c.github.io/media-source/#sourcebuffer-append-error).\r\n      //\r\n      // Trigger a special error so that it can be handled separately from normal,\r\n      // recoverable errors.\r\n\r\n      this.trigger('appenderror');\r\n    };\r\n\r\n    _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref7) {\r\n      var segmentInfo = _ref7.segmentInfo,\r\n          type = _ref7.type,\r\n          initSegment = _ref7.initSegment,\r\n          data = _ref7.data,\r\n          bytes = _ref7.bytes; // If this is a re-append, bytes were already created and don't need to be recreated\r\n\r\n      if (!bytes) {\r\n        var segments = [data];\r\n        var byteLength = data.byteLength;\r\n\r\n        if (initSegment) {\r\n          // if the media initialization segment is changing, append it before the content\r\n          // segment\r\n          segments.unshift(initSegment);\r\n          byteLength += initSegment.byteLength;\r\n        } // Technically we should be OK appending the init segment separately, however, we\r\n        // haven't yet tested that, and prepending is how we have always done things.\r\n\r\n\r\n        bytes = concatSegments({\r\n          bytes: byteLength,\r\n          segments: segments\r\n        });\r\n      }\r\n\r\n      this.sourceUpdater_.appendBuffer({\r\n        segmentInfo: segmentInfo,\r\n        type: type,\r\n        bytes: bytes\r\n      }, this.handleAppendError_.bind(this, {\r\n        segmentInfo: segmentInfo,\r\n        type: type,\r\n        bytes: bytes\r\n      }));\r\n    };\r\n\r\n    _proto.handleSegmentTimingInfo_ = function handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {\r\n      if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {\r\n        return;\r\n      }\r\n\r\n      var segment = this.pendingSegment_.segment;\r\n      var timingInfoProperty = type + \"TimingInfo\";\r\n\r\n      if (!segment[timingInfoProperty]) {\r\n        segment[timingInfoProperty] = {};\r\n      }\r\n\r\n      segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;\r\n      segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;\r\n      segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;\r\n      segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;\r\n      segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode; // mainly used as a reference for debugging\r\n\r\n      segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;\r\n    };\r\n\r\n    _proto.appendData_ = function appendData_(segmentInfo, result) {\r\n      var type = result.type,\r\n          data = result.data;\r\n\r\n      if (!data || !data.byteLength) {\r\n        return;\r\n      }\r\n\r\n      if (type === 'audio' && this.audioDisabled_) {\r\n        return;\r\n      }\r\n\r\n      var initSegment = this.getInitSegmentAndUpdateState_({\r\n        type: type,\r\n        initSegment: result.initSegment,\r\n        playlist: segmentInfo.playlist,\r\n        map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null\r\n      });\r\n      this.appendToSourceBuffer_({\r\n        segmentInfo: segmentInfo,\r\n        type: type,\r\n        initSegment: initSegment,\r\n        data: data\r\n      });\r\n    }\r\n    /**\r\n     * load a specific segment from a request into the buffer\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.loadSegment_ = function loadSegment_(segmentInfo) {\r\n      var _this4 = this;\r\n\r\n      this.state = 'WAITING';\r\n      this.pendingSegment_ = segmentInfo;\r\n      this.trimBackBuffer_(segmentInfo);\r\n\r\n      if (typeof segmentInfo.timestampOffset === 'number') {\r\n        if (this.transmuxer_) {\r\n          this.transmuxer_.postMessage({\r\n            action: 'clearAllMp4Captions'\r\n          });\r\n        }\r\n      }\r\n\r\n      if (!this.hasEnoughInfoToLoad_()) {\r\n        this.loadQueue_.push(function () {\r\n          // regenerate the audioAppendStart, timestampOffset, etc as they\r\n          // may have changed since this function was added to the queue.\r\n          var options = _extends_1({}, segmentInfo, {\r\n            forceTimestampOffset: true\r\n          });\r\n\r\n          _extends_1(segmentInfo, _this4.generateSegmentInfo_(options));\r\n\r\n          _this4.isPendingTimestampOffset_ = false;\r\n\r\n          _this4.updateTransmuxerAndRequestSegment_(segmentInfo);\r\n        });\r\n        return;\r\n      }\r\n\r\n      this.updateTransmuxerAndRequestSegment_(segmentInfo);\r\n    };\r\n\r\n    _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {\r\n      var _this5 = this; // We'll update the source buffer's timestamp offset once we have transmuxed data, but\r\n      // the transmuxer still needs to be updated before then.\r\n      //\r\n      // Even though keepOriginalTimestamps is set to true for the transmuxer, timestamp\r\n      // offset must be passed to the transmuxer for stream correcting adjustments.\r\n\r\n\r\n      if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {\r\n        this.gopBuffer_.length = 0; // gopsToAlignWith was set before the GOP buffer was cleared\r\n\r\n        segmentInfo.gopsToAlignWith = [];\r\n        this.timeMapping_ = 0; // reset values in the transmuxer since a discontinuity should start fresh\r\n\r\n        this.transmuxer_.postMessage({\r\n          action: 'reset'\r\n        });\r\n        this.transmuxer_.postMessage({\r\n          action: 'setTimestampOffset',\r\n          timestampOffset: segmentInfo.timestampOffset\r\n        });\r\n      }\r\n\r\n      var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);\r\n      var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);\r\n      var isWalkingForward = this.mediaIndex !== null;\r\n      var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,\r\n      // the first timeline\r\n      segmentInfo.timeline > 0;\r\n      var isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;\r\n      this.logger_(\"Requesting \" + segmentInfoString(segmentInfo)); // If there's an init segment associated with this segment, but it is not cached (identified by a lack of bytes),\r\n      // then this init segment has never been seen before and should be appended.\r\n      //\r\n      // At this point the content type (audio/video or both) is not yet known, but it should be safe to set\r\n      // both to true and leave the decision of whether to append the init segment to append time.\r\n\r\n      if (simpleSegment.map && !simpleSegment.map.bytes) {\r\n        this.logger_('going to request init segment.');\r\n        this.appendInitSegment_ = {\r\n          video: true,\r\n          audio: true\r\n        };\r\n      }\r\n\r\n      segmentInfo.abortRequests = mediaSegmentRequest({\r\n        xhr: this.vhs_.xhr,\r\n        xhrOptions: this.xhrOptions_,\r\n        decryptionWorker: this.decrypter_,\r\n        segment: simpleSegment,\r\n        abortFn: this.handleAbort_.bind(this, segmentInfo),\r\n        progressFn: this.handleProgress_.bind(this),\r\n        trackInfoFn: this.handleTrackInfo_.bind(this),\r\n        timingInfoFn: this.handleTimingInfo_.bind(this),\r\n        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'video', segmentInfo.requestId),\r\n        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'audio', segmentInfo.requestId),\r\n        captionsFn: this.handleCaptions_.bind(this),\r\n        isEndOfTimeline: isEndOfTimeline,\r\n        endedTimelineFn: function endedTimelineFn() {\r\n          _this5.logger_('received endedtimeline callback');\r\n        },\r\n        id3Fn: this.handleId3_.bind(this),\r\n        dataFn: this.handleData_.bind(this),\r\n        doneFn: this.segmentRequestFinished_.bind(this),\r\n        onTransmuxerLog: function onTransmuxerLog(_ref8) {\r\n          var message = _ref8.message,\r\n              level = _ref8.level,\r\n              stream = _ref8.stream;\r\n\r\n          _this5.logger_(segmentInfoString(segmentInfo) + \" logged from transmuxer stream \" + stream + \" as a \" + level + \": \" + message);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * trim the back buffer so that we don't have too much data\r\n     * in the source buffer\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} segmentInfo - the current segment\r\n     */\r\n    ;\r\n\r\n    _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {\r\n      var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); // Chrome has a hard limit of 150MB of\r\n      // buffer and a very conservative \"garbage collector\"\r\n      // We manually clear out the old buffer to ensure\r\n      // we don't trigger the QuotaExceeded error\r\n      // on the source buffer during subsequent appends\r\n\r\n      if (removeToTime > 0) {\r\n        this.remove(0, removeToTime);\r\n      }\r\n    }\r\n    /**\r\n     * created a simplified copy of the segment object with just the\r\n     * information necessary to perform the XHR and decryption\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} segmentInfo - the current segment\r\n     * @return {Object} a simplified segment object copy\r\n     */\r\n    ;\r\n\r\n    _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {\r\n      var segment = segmentInfo.segment;\r\n      var part = segmentInfo.part;\r\n      var simpleSegment = {\r\n        resolvedUri: part ? part.resolvedUri : segment.resolvedUri,\r\n        byterange: part ? part.byterange : segment.byterange,\r\n        requestId: segmentInfo.requestId,\r\n        transmuxer: segmentInfo.transmuxer,\r\n        audioAppendStart: segmentInfo.audioAppendStart,\r\n        gopsToAlignWith: segmentInfo.gopsToAlignWith,\r\n        part: segmentInfo.part\r\n      };\r\n      var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];\r\n\r\n      if (previousSegment && previousSegment.timeline === segment.timeline) {\r\n        // The baseStartTime of a segment is used to handle rollover when probing the TS\r\n        // segment to retrieve timing information. Since the probe only looks at the media's\r\n        // times (e.g., PTS and DTS values of the segment), and doesn't consider the\r\n        // player's time (e.g., player.currentTime()), baseStartTime should reflect the\r\n        // media time as well. transmuxedDecodeEnd represents the end time of a segment, in\r\n        // seconds of media time, so should be used here. The previous segment is used since\r\n        // the end of the previous segment should represent the beginning of the current\r\n        // segment, so long as they are on the same timeline.\r\n        if (previousSegment.videoTimingInfo) {\r\n          simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;\r\n        } else if (previousSegment.audioTimingInfo) {\r\n          simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;\r\n        }\r\n      }\r\n\r\n      if (segment.key) {\r\n        // if the media sequence is greater than 2^32, the IV will be incorrect\r\n        // assuming 10s segments, that would be about 1300 years\r\n        var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\r\n        simpleSegment.key = this.segmentKey(segment.key);\r\n        simpleSegment.key.iv = iv;\r\n      }\r\n\r\n      if (segment.map) {\r\n        simpleSegment.map = this.initSegmentForMap(segment.map);\r\n      }\r\n\r\n      return simpleSegment;\r\n    };\r\n\r\n    _proto.saveTransferStats_ = function saveTransferStats_(stats) {\r\n      // every request counts as a media request even if it has been aborted\r\n      // or canceled due to a timeout\r\n      this.mediaRequests += 1;\r\n\r\n      if (stats) {\r\n        this.mediaBytesTransferred += stats.bytesReceived;\r\n        this.mediaTransferDuration += stats.roundTripTime;\r\n      }\r\n    };\r\n\r\n    _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(duration, stats) {\r\n      // byteLength will be used for throughput, and should be based on bytes receieved,\r\n      // which we only know at the end of the request and should reflect total bytes\r\n      // downloaded rather than just bytes processed from components of the segment\r\n      this.pendingSegment_.byteLength = stats.bytesReceived;\r\n\r\n      if (duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\r\n        this.logger_(\"Ignoring segment's bandwidth because its duration of \" + duration + (\" is less than the min to record \" + MIN_SEGMENT_DURATION_TO_SAVE_STATS));\r\n        return;\r\n      }\r\n\r\n      this.bandwidth = stats.bandwidth;\r\n      this.roundTrip = stats.roundTripTime;\r\n    };\r\n\r\n    _proto.handleTimeout_ = function handleTimeout_() {\r\n      // although the VTT segment loader bandwidth isn't really used, it's good to\r\n      // maintain functinality between segment loaders\r\n      this.mediaRequestsTimedout += 1;\r\n      this.bandwidth = 1;\r\n      this.roundTrip = NaN;\r\n      this.trigger('bandwidthupdate');\r\n    }\r\n    /**\r\n     * Handle the callback from the segmentRequest function and set the\r\n     * associated SegmentLoader state and errors if necessary\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {\r\n      // TODO handle special cases, e.g., muxed audio/video but only audio in the segment\r\n      // check the call queue directly since this function doesn't need to deal with any\r\n      // data, and can continue even if the source buffers are not set up and we didn't get\r\n      // any data from the segment\r\n      if (this.callQueue_.length) {\r\n        this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));\r\n        return;\r\n      }\r\n\r\n      this.saveTransferStats_(simpleSegment.stats); // The request was aborted and the SegmentLoader has already been reset\r\n\r\n      if (!this.pendingSegment_) {\r\n        return;\r\n      } // the request was aborted and the SegmentLoader has already started\r\n      // another request. this can happen when the timeout for an aborted\r\n      // request triggers due to a limitation in the XHR library\r\n      // do not count this as any sort of request or we risk double-counting\r\n\r\n\r\n      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\r\n        return;\r\n      } // an error occurred from the active pendingSegment_ so reset everything\r\n\r\n\r\n      if (error) {\r\n        this.pendingSegment_ = null;\r\n        this.state = 'READY'; // aborts are not a true error condition and nothing corrective needs to be done\r\n\r\n        if (error.code === REQUEST_ERRORS.ABORTED) {\r\n          return;\r\n        }\r\n\r\n        this.pause(); // the error is really just that at least one of the requests timed-out\r\n        // set the bandwidth to a very low value and trigger an ABR switch to\r\n        // take emergency action\r\n\r\n        if (error.code === REQUEST_ERRORS.TIMEOUT) {\r\n          this.handleTimeout_();\r\n          return;\r\n        } // if control-flow has arrived here, then the error is real\r\n        // emit an error event to blacklist the current playlist\r\n\r\n\r\n        this.mediaRequestsErrored += 1;\r\n        this.error(error);\r\n        this.trigger('error');\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // the response was a success so set any bandwidth stats the request\r\n      // generated for ABR purposes\r\n\r\n      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);\r\n      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\r\n\r\n      if (result.gopInfo) {\r\n        this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);\r\n      } // Although we may have already started appending on progress, we shouldn't switch the\r\n      // state away from loading until we are officially done loading the segment data.\r\n\r\n\r\n      this.state = 'APPENDING'; // used for testing\r\n\r\n      this.trigger('appending');\r\n      this.waitForAppendsToComplete_(segmentInfo);\r\n    };\r\n\r\n    _proto.setTimeMapping_ = function setTimeMapping_(timeline) {\r\n      var timelineMapping = this.syncController_.mappingForTimeline(timeline);\r\n\r\n      if (timelineMapping !== null) {\r\n        this.timeMapping_ = timelineMapping;\r\n      }\r\n    };\r\n\r\n    _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {\r\n      if (typeof segment.start === 'number' && typeof segment.end === 'number') {\r\n        this.mediaSecondsLoaded += segment.end - segment.start;\r\n      } else {\r\n        this.mediaSecondsLoaded += segment.duration;\r\n      }\r\n    };\r\n\r\n    _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {\r\n      if (timestampOffset === null) {\r\n        return false;\r\n      } // note that we're potentially using the same timestamp offset for both video and\r\n      // audio\r\n\r\n\r\n      if (this.loaderType_ === 'main' && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\r\n        return true;\r\n      }\r\n\r\n      if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    _proto.trueSegmentStart_ = function trueSegmentStart_(_ref9) {\r\n      var currentStart = _ref9.currentStart,\r\n          playlist = _ref9.playlist,\r\n          mediaIndex = _ref9.mediaIndex,\r\n          firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData,\r\n          currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset,\r\n          useVideoTimingInfo = _ref9.useVideoTimingInfo,\r\n          videoTimingInfo = _ref9.videoTimingInfo,\r\n          audioTimingInfo = _ref9.audioTimingInfo;\r\n\r\n      if (typeof currentStart !== 'undefined') {\r\n        // if start was set once, keep using it\r\n        return currentStart;\r\n      }\r\n\r\n      if (!useVideoTimingInfo) {\r\n        return audioTimingInfo.start;\r\n      }\r\n\r\n      var previousSegment = playlist.segments[mediaIndex - 1]; // The start of a segment should be the start of the first full frame contained\r\n      // within that segment. Since the transmuxer maintains a cache of incomplete data\r\n      // from and/or the last frame seen, the start time may reflect a frame that starts\r\n      // in the previous segment. Check for that case and ensure the start time is\r\n      // accurate for the segment.\r\n\r\n      if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === 'undefined' || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {\r\n        return firstVideoFrameTimeForData;\r\n      }\r\n\r\n      return videoTimingInfo.start;\r\n    };\r\n\r\n    _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {\r\n      var trackInfo = this.getCurrentMediaInfo_(segmentInfo);\r\n\r\n      if (!trackInfo) {\r\n        this.error({\r\n          message: 'No starting media returned, likely due to an unsupported media format.',\r\n          blacklistDuration: Infinity\r\n        });\r\n        this.trigger('error');\r\n        return;\r\n      } // Although transmuxing is done, appends may not yet be finished. Throw a marker\r\n      // on each queue this loader is responsible for to ensure that the appends are\r\n      // complete.\r\n\r\n\r\n      var hasAudio = trackInfo.hasAudio,\r\n          hasVideo = trackInfo.hasVideo,\r\n          isMuxed = trackInfo.isMuxed;\r\n      var waitForVideo = this.loaderType_ === 'main' && hasVideo;\r\n      var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;\r\n      segmentInfo.waitingOnAppends = 0; // segments with no data\r\n\r\n      if (!segmentInfo.hasAppendedData_) {\r\n        if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === 'number') {\r\n          // When there's no audio or video data in the segment, there's no audio or video\r\n          // timing information.\r\n          //\r\n          // If there's no audio or video timing information, then the timestamp offset\r\n          // can't be adjusted to the appropriate value for the transmuxer and source\r\n          // buffers.\r\n          //\r\n          // Therefore, the next segment should be used to set the timestamp offset.\r\n          this.isPendingTimestampOffset_ = true;\r\n        } // override settings for metadata only segments\r\n\r\n\r\n        segmentInfo.timingInfo = {\r\n          start: 0\r\n        };\r\n        segmentInfo.waitingOnAppends++;\r\n\r\n        if (!this.isPendingTimestampOffset_) {\r\n          // update the timestampoffset\r\n          this.updateSourceBufferTimestampOffset_(segmentInfo); // make sure the metadata queue is processed even though we have\r\n          // no video/audio data.\r\n\r\n          this.processMetadataQueue_();\r\n        } // append is \"done\" instantly with no data.\r\n\r\n\r\n        this.checkAppendsDone_(segmentInfo);\r\n        return;\r\n      } // Since source updater could call back synchronously, do the increments first.\r\n\r\n\r\n      if (waitForVideo) {\r\n        segmentInfo.waitingOnAppends++;\r\n      }\r\n\r\n      if (waitForAudio) {\r\n        segmentInfo.waitingOnAppends++;\r\n      }\r\n\r\n      if (waitForVideo) {\r\n        this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\r\n      }\r\n\r\n      if (waitForAudio) {\r\n        this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\r\n      }\r\n    };\r\n\r\n    _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {\r\n      if (this.checkForAbort_(segmentInfo.requestId)) {\r\n        return;\r\n      }\r\n\r\n      segmentInfo.waitingOnAppends--;\r\n\r\n      if (segmentInfo.waitingOnAppends === 0) {\r\n        this.handleAppendsDone_();\r\n      }\r\n    };\r\n\r\n    _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {\r\n      var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);\r\n\r\n      if (illegalMediaSwitchError) {\r\n        this.error({\r\n          message: illegalMediaSwitchError,\r\n          blacklistDuration: Infinity\r\n        });\r\n        this.trigger('error');\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {\r\n      if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has\r\n      // priority, timing-wise, so we must wait\r\n      typeof segmentInfo.timingInfo.start !== 'number' || // already updated the timestamp offset for this segment\r\n      segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset\r\n      this.loaderType_ !== 'main') {\r\n        return;\r\n      }\r\n\r\n      var didChange = false; // Primary timing goes by video, and audio is trimmed in the transmuxer, meaning that\r\n      // the timing info here comes from video. In the event that the audio is longer than\r\n      // the video, this will trim the start of the audio.\r\n      // This also trims any offset from 0 at the beginning of the media\r\n\r\n      segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({\r\n        videoTimingInfo: segmentInfo.segment.videoTimingInfo,\r\n        audioTimingInfo: segmentInfo.segment.audioTimingInfo,\r\n        timingInfo: segmentInfo.timingInfo\r\n      }); // In the event that there are part segment downloads, each will try to update the\r\n      // timestamp offset. Retaining this bit of state prevents us from updating in the\r\n      // future (within the same segment), however, there may be a better way to handle it.\r\n\r\n      segmentInfo.changedTimestampOffset = true;\r\n\r\n      if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\r\n        this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);\r\n        didChange = true;\r\n      }\r\n\r\n      if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\r\n        this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);\r\n        didChange = true;\r\n      }\r\n\r\n      if (didChange) {\r\n        this.trigger('timestampoffset');\r\n      }\r\n    };\r\n\r\n    _proto.getSegmentStartTimeForTimestampOffsetCalculation_ = function getSegmentStartTimeForTimestampOffsetCalculation_(_ref10) {\r\n      var videoTimingInfo = _ref10.videoTimingInfo,\r\n          audioTimingInfo = _ref10.audioTimingInfo,\r\n          timingInfo = _ref10.timingInfo;\r\n\r\n      if (!this.useDtsForTimestampOffset_) {\r\n        return timingInfo.start;\r\n      }\r\n\r\n      if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === 'number') {\r\n        return videoTimingInfo.transmuxedDecodeStart;\r\n      } // handle audio only\r\n\r\n\r\n      if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === 'number') {\r\n        return audioTimingInfo.transmuxedDecodeStart;\r\n      } // handle content not transmuxed (e.g., MP4)\r\n\r\n\r\n      return timingInfo.start;\r\n    };\r\n\r\n    _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {\r\n      segmentInfo.timingInfo = segmentInfo.timingInfo || {};\r\n      var trackInfo = this.getMediaInfo_();\r\n      var useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\r\n      var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;\r\n\r\n      if (!prioritizedTimingInfo) {\r\n        return;\r\n      }\r\n\r\n      segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === 'number' ? // End time may not exist in a case where we aren't parsing the full segment (one\r\n      // current example is the case of fmp4), so use the rough duration to calculate an\r\n      // end time.\r\n      prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;\r\n    }\r\n    /**\r\n     * callback to run when appendBuffer is finished. detects if we are\r\n     * in a good state to do things with the data we got, or if we need\r\n     * to wait for more\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleAppendsDone_ = function handleAppendsDone_() {\r\n      // appendsdone can cause an abort\r\n      if (this.pendingSegment_) {\r\n        this.trigger('appendsdone');\r\n      }\r\n\r\n      if (!this.pendingSegment_) {\r\n        this.state = 'READY'; // TODO should this move into this.checkForAbort to speed up requests post abort in\r\n        // all appending cases?\r\n\r\n        if (!this.paused()) {\r\n          this.monitorBuffer_();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // Now that the end of the segment has been reached, we can set the end time. It's\r\n      // best to wait until all appends are done so we're sure that the primary media is\r\n      // finished (and we have its end time).\r\n\r\n      this.updateTimingInfoEnd_(segmentInfo);\r\n\r\n      if (this.shouldSaveSegmentTimingInfo_) {\r\n        // Timeline mappings should only be saved for the main loader. This is for multiple\r\n        // reasons:\r\n        //\r\n        // 1) Only one mapping is saved per timeline, meaning that if both the audio loader\r\n        //    and the main loader try to save the timeline mapping, whichever comes later\r\n        //    will overwrite the first. In theory this is OK, as the mappings should be the\r\n        //    same, however, it breaks for (2)\r\n        // 2) In the event of a live stream, the initial live point will make for a somewhat\r\n        //    arbitrary mapping. If audio and video streams are not perfectly in-sync, then\r\n        //    the mapping will be off for one of the streams, dependent on which one was\r\n        //    first saved (see (1)).\r\n        // 3) Primary timing goes by video in VHS, so the mapping should be video.\r\n        //\r\n        // Since the audio loader will wait for the main loader to load the first segment,\r\n        // the main loader will save the first timeline mapping, and ensure that there won't\r\n        // be a case where audio loads two segments without saving a mapping (thus leading\r\n        // to missing segment timing info).\r\n        this.syncController_.saveSegmentTimingInfo({\r\n          segmentInfo: segmentInfo,\r\n          shouldSaveTimelineMapping: this.loaderType_ === 'main'\r\n        });\r\n      }\r\n\r\n      var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);\r\n\r\n      if (segmentDurationMessage) {\r\n        if (segmentDurationMessage.severity === 'warn') {\r\n          videojs.log.warn(segmentDurationMessage.message);\r\n        } else {\r\n          this.logger_(segmentDurationMessage.message);\r\n        }\r\n      }\r\n\r\n      this.recordThroughput_(segmentInfo);\r\n      this.pendingSegment_ = null;\r\n      this.state = 'READY';\r\n\r\n      if (segmentInfo.isSyncRequest) {\r\n        this.trigger('syncinfoupdate'); // if the sync request was not appended\r\n        // then it was not the correct segment.\r\n        // throw it away and use the data it gave us\r\n        // to get the correct one.\r\n\r\n        if (!segmentInfo.hasAppendedData_) {\r\n          this.logger_(\"Throwing away un-appended sync request \" + segmentInfoString(segmentInfo));\r\n          return;\r\n        }\r\n      }\r\n\r\n      this.logger_(\"Appended \" + segmentInfoString(segmentInfo));\r\n      this.addSegmentMetadataCue_(segmentInfo);\r\n      this.fetchAtBuffer_ = true;\r\n\r\n      if (this.currentTimeline_ !== segmentInfo.timeline) {\r\n        this.timelineChangeController_.lastTimelineChange({\r\n          type: this.loaderType_,\r\n          from: this.currentTimeline_,\r\n          to: segmentInfo.timeline\r\n        }); // If audio is not disabled, the main segment loader is responsible for updating\r\n        // the audio timeline as well. If the content is video only, this won't have any\r\n        // impact.\r\n\r\n        if (this.loaderType_ === 'main' && !this.audioDisabled_) {\r\n          this.timelineChangeController_.lastTimelineChange({\r\n            type: 'audio',\r\n            from: this.currentTimeline_,\r\n            to: segmentInfo.timeline\r\n          });\r\n        }\r\n      }\r\n\r\n      this.currentTimeline_ = segmentInfo.timeline; // We must update the syncinfo to recalculate the seekable range before\r\n      // the following conditional otherwise it may consider this a bad \"guess\"\r\n      // and attempt to resync when the post-update seekable window and live\r\n      // point would mean that this was the perfect segment to fetch\r\n\r\n      this.trigger('syncinfoupdate');\r\n      var segment = segmentInfo.segment;\r\n      var part = segmentInfo.part;\r\n      var badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;\r\n      var badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3; // If we previously appended a segment/part that ends more than 3 part/targetDurations before\r\n      // the currentTime_ that means that our conservative guess was too conservative.\r\n      // In that case, reset the loader state so that we try to use any information gained\r\n      // from the previous request to create a new, more accurate, sync-point.\r\n\r\n      if (badSegmentGuess || badPartGuess) {\r\n        this.logger_(\"bad \" + (badSegmentGuess ? 'segment' : 'part') + \" \" + segmentInfoString(segmentInfo));\r\n        this.resetEverything();\r\n        return;\r\n      }\r\n\r\n      var isWalkingForward = this.mediaIndex !== null; // Don't do a rendition switch unless we have enough time to get a sync segment\r\n      // and conservatively guess\r\n\r\n      if (isWalkingForward) {\r\n        this.trigger('bandwidthupdate');\r\n      }\r\n\r\n      this.trigger('progress');\r\n      this.mediaIndex = segmentInfo.mediaIndex;\r\n      this.partIndex = segmentInfo.partIndex; // any time an update finishes and the last segment is in the\r\n      // buffer, end the stream. this ensures the \"ended\" event will\r\n      // fire if playback reaches that point.\r\n\r\n      if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {\r\n        this.endOfStream();\r\n      } // used for testing\r\n\r\n\r\n      this.trigger('appended');\r\n\r\n      if (segmentInfo.hasAppendedData_) {\r\n        this.mediaAppends++;\r\n      }\r\n\r\n      if (!this.paused()) {\r\n        this.monitorBuffer_();\r\n      }\r\n    }\r\n    /**\r\n     * Records the current throughput of the decrypt, transmux, and append\r\n     * portion of the semgment pipeline. `throughput.rate` is a the cumulative\r\n     * moving average of the throughput. `throughput.count` is the number of\r\n     * data points in the average.\r\n     *\r\n     * @private\r\n     * @param {Object} segmentInfo the object returned by loadSegment\r\n     */\r\n    ;\r\n\r\n    _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {\r\n      if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\r\n        this.logger_(\"Ignoring segment's throughput because its duration of \" + segmentInfo.duration + (\" is less than the min to record \" + MIN_SEGMENT_DURATION_TO_SAVE_STATS));\r\n        return;\r\n      }\r\n\r\n      var rate = this.throughput.rate; // Add one to the time to ensure that we don't accidentally attempt to divide\r\n      // by zero in the case where the throughput is ridiculously high\r\n\r\n      var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1; // Multiply by 8000 to convert from bytes/millisecond to bits/second\r\n\r\n      var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000); // This is just a cumulative moving average calculation:\r\n      //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\r\n\r\n      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\r\n    }\r\n    /**\r\n     * Adds a cue to the segment-metadata track with some metadata information about the\r\n     * segment\r\n     *\r\n     * @private\r\n     * @param {Object} segmentInfo\r\n     *        the object returned by loadSegment\r\n     * @method addSegmentMetadataCue_\r\n     */\r\n    ;\r\n\r\n    _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {\r\n      if (!this.segmentMetadataTrack_) {\r\n        return;\r\n      }\r\n\r\n      var segment = segmentInfo.segment;\r\n      var start = segment.start;\r\n      var end = segment.end; // Do not try adding the cue if the start and end times are invalid.\r\n\r\n      if (!finite(start) || !finite(end)) {\r\n        return;\r\n      }\r\n\r\n      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\r\n      var Cue = window.WebKitDataCue || window.VTTCue;\r\n      var value = {\r\n        custom: segment.custom,\r\n        dateTimeObject: segment.dateTimeObject,\r\n        dateTimeString: segment.dateTimeString,\r\n        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\r\n        resolution: segmentInfo.playlist.attributes.RESOLUTION,\r\n        codecs: segmentInfo.playlist.attributes.CODECS,\r\n        byteLength: segmentInfo.byteLength,\r\n        uri: segmentInfo.uri,\r\n        timeline: segmentInfo.timeline,\r\n        playlist: segmentInfo.playlist.id,\r\n        start: start,\r\n        end: end\r\n      };\r\n      var data = JSON.stringify(value);\r\n      var cue = new Cue(start, end, data); // Attach the metadata to the value property of the cue to keep consistency between\r\n      // the differences of WebKitDataCue in safari and VTTCue in other browsers\r\n\r\n      cue.value = value;\r\n      this.segmentMetadataTrack_.addCue(cue);\r\n    };\r\n\r\n    return SegmentLoader;\r\n  }(videojs.EventTarget);\r\n\r\n  function noop() {}\r\n\r\n  var toTitleCase = function toTitleCase(string) {\r\n    if (typeof string !== 'string') {\r\n      return string;\r\n    }\r\n\r\n    return string.replace(/./, function (w) {\r\n      return w.toUpperCase();\r\n    });\r\n  };\r\n\r\n  var bufferTypes = ['video', 'audio'];\r\n\r\n  var _updating = function updating(type, sourceUpdater) {\r\n    var sourceBuffer = sourceUpdater[type + \"Buffer\"];\r\n    return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];\r\n  };\r\n\r\n  var nextQueueIndexOfType = function nextQueueIndexOfType(type, queue) {\r\n    for (var i = 0; i < queue.length; i++) {\r\n      var queueEntry = queue[i];\r\n\r\n      if (queueEntry.type === 'mediaSource') {\r\n        // If the next entry is a media source entry (uses multiple source buffers), block\r\n        // processing to allow it to go through first.\r\n        return null;\r\n      }\r\n\r\n      if (queueEntry.type === type) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  var shiftQueue = function shiftQueue(type, sourceUpdater) {\r\n    if (sourceUpdater.queue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    var queueIndex = 0;\r\n    var queueEntry = sourceUpdater.queue[queueIndex];\r\n\r\n    if (queueEntry.type === 'mediaSource') {\r\n      if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== 'closed') {\r\n        sourceUpdater.queue.shift();\r\n        queueEntry.action(sourceUpdater);\r\n\r\n        if (queueEntry.doneFn) {\r\n          queueEntry.doneFn();\r\n        } // Only specific source buffer actions must wait for async updateend events. Media\r\n        // Source actions process synchronously. Therefore, both audio and video source\r\n        // buffers are now clear to process the next queue entries.\r\n\r\n\r\n        shiftQueue('audio', sourceUpdater);\r\n        shiftQueue('video', sourceUpdater);\r\n      } // Media Source actions require both source buffers, so if the media source action\r\n      // couldn't process yet (because one or both source buffers are busy), block other\r\n      // queue actions until both are available and the media source action can process.\r\n\r\n\r\n      return;\r\n    }\r\n\r\n    if (type === 'mediaSource') {\r\n      // If the queue was shifted by a media source action (this happens when pushing a\r\n      // media source action onto the queue), then it wasn't from an updateend event from an\r\n      // audio or video source buffer, so there's no change from previous state, and no\r\n      // processing should be done.\r\n      return;\r\n    } // Media source queue entries don't need to consider whether the source updater is\r\n    // started (i.e., source buffers are created) as they don't need the source buffers, but\r\n    // source buffer queue entries do.\r\n\r\n\r\n    if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === 'closed' || _updating(type, sourceUpdater)) {\r\n      return;\r\n    }\r\n\r\n    if (queueEntry.type !== type) {\r\n      queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);\r\n\r\n      if (queueIndex === null) {\r\n        // Either there's no queue entry that uses this source buffer type in the queue, or\r\n        // there's a media source queue entry before the next entry of this type, in which\r\n        // case wait for that action to process first.\r\n        return;\r\n      }\r\n\r\n      queueEntry = sourceUpdater.queue[queueIndex];\r\n    }\r\n\r\n    sourceUpdater.queue.splice(queueIndex, 1); // Keep a record that this source buffer type is in use.\r\n    //\r\n    // The queue pending operation must be set before the action is performed in the event\r\n    // that the action results in a synchronous event that is acted upon. For instance, if\r\n    // an exception is thrown that can be handled, it's possible that new actions will be\r\n    // appended to an empty queue and immediately executed, but would not have the correct\r\n    // pending information if this property was set after the action was performed.\r\n\r\n    sourceUpdater.queuePending[type] = queueEntry;\r\n    queueEntry.action(type, sourceUpdater);\r\n\r\n    if (!queueEntry.doneFn) {\r\n      // synchronous operation, process next entry\r\n      sourceUpdater.queuePending[type] = null;\r\n      shiftQueue(type, sourceUpdater);\r\n      return;\r\n    }\r\n  };\r\n\r\n  var cleanupBuffer = function cleanupBuffer(type, sourceUpdater) {\r\n    var buffer = sourceUpdater[type + \"Buffer\"];\r\n    var titleType = toTitleCase(type);\r\n\r\n    if (!buffer) {\r\n      return;\r\n    }\r\n\r\n    buffer.removeEventListener('updateend', sourceUpdater[\"on\" + titleType + \"UpdateEnd_\"]);\r\n    buffer.removeEventListener('error', sourceUpdater[\"on\" + titleType + \"Error_\"]);\r\n    sourceUpdater.codecs[type] = null;\r\n    sourceUpdater[type + \"Buffer\"] = null;\r\n  };\r\n\r\n  var inSourceBuffers = function inSourceBuffers(mediaSource, sourceBuffer) {\r\n    return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;\r\n  };\r\n\r\n  var actions = {\r\n    appendBuffer: function appendBuffer(bytes, segmentInfo, onError) {\r\n      return function (type, sourceUpdater) {\r\n        var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\r\n        // or the media source does not contain this source buffer.\r\n\r\n        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"Appending segment \" + segmentInfo.mediaIndex + \"'s \" + bytes.length + \" bytes to \" + type + \"Buffer\");\r\n\r\n        try {\r\n          sourceBuffer.appendBuffer(bytes);\r\n        } catch (e) {\r\n          sourceUpdater.logger_(\"Error with code \" + e.code + \" \" + (e.code === QUOTA_EXCEEDED_ERR ? '(QUOTA_EXCEEDED_ERR) ' : '') + (\"when appending segment \" + segmentInfo.mediaIndex + \" to \" + type + \"Buffer\"));\r\n          sourceUpdater.queuePending[type] = null;\r\n          onError(e);\r\n        }\r\n      };\r\n    },\r\n    remove: function remove(start, end) {\r\n      return function (type, sourceUpdater) {\r\n        var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\r\n        // or the media source does not contain this source buffer.\r\n\r\n        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"Removing \" + start + \" to \" + end + \" from \" + type + \"Buffer\");\r\n\r\n        try {\r\n          sourceBuffer.remove(start, end);\r\n        } catch (e) {\r\n          sourceUpdater.logger_(\"Remove \" + start + \" to \" + end + \" from \" + type + \"Buffer failed\");\r\n        }\r\n      };\r\n    },\r\n    timestampOffset: function timestampOffset(offset) {\r\n      return function (type, sourceUpdater) {\r\n        var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\r\n        // or the media source does not contain this source buffer.\r\n\r\n        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"Setting \" + type + \"timestampOffset to \" + offset);\r\n        sourceBuffer.timestampOffset = offset;\r\n      };\r\n    },\r\n    callback: function callback(_callback) {\r\n      return function (type, sourceUpdater) {\r\n        _callback();\r\n      };\r\n    },\r\n    endOfStream: function endOfStream(error) {\r\n      return function (sourceUpdater) {\r\n        if (sourceUpdater.mediaSource.readyState !== 'open') {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"Calling mediaSource endOfStream(\" + (error || '') + \")\");\r\n\r\n        try {\r\n          sourceUpdater.mediaSource.endOfStream(error);\r\n        } catch (e) {\r\n          videojs.log.warn('Failed to call media source endOfStream', e);\r\n        }\r\n      };\r\n    },\r\n    duration: function duration(_duration) {\r\n      return function (sourceUpdater) {\r\n        sourceUpdater.logger_(\"Setting mediaSource duration to \" + _duration);\r\n\r\n        try {\r\n          sourceUpdater.mediaSource.duration = _duration;\r\n        } catch (e) {\r\n          videojs.log.warn('Failed to set media source duration', e);\r\n        }\r\n      };\r\n    },\r\n    abort: function abort() {\r\n      return function (type, sourceUpdater) {\r\n        if (sourceUpdater.mediaSource.readyState !== 'open') {\r\n          return;\r\n        }\r\n\r\n        var sourceBuffer = sourceUpdater[type + \"Buffer\"]; // can't do anything if the media source / source buffer is null\r\n        // or the media source does not contain this source buffer.\r\n\r\n        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"calling abort on \" + type + \"Buffer\");\r\n\r\n        try {\r\n          sourceBuffer.abort();\r\n        } catch (e) {\r\n          videojs.log.warn(\"Failed to abort on \" + type + \"Buffer\", e);\r\n        }\r\n      };\r\n    },\r\n    addSourceBuffer: function addSourceBuffer(type, codec) {\r\n      return function (sourceUpdater) {\r\n        var titleType = toTitleCase(type);\r\n        var mime = getMimeForCodec(codec);\r\n        sourceUpdater.logger_(\"Adding \" + type + \"Buffer with codec \" + codec + \" to mediaSource\");\r\n        var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);\r\n        sourceBuffer.addEventListener('updateend', sourceUpdater[\"on\" + titleType + \"UpdateEnd_\"]);\r\n        sourceBuffer.addEventListener('error', sourceUpdater[\"on\" + titleType + \"Error_\"]);\r\n        sourceUpdater.codecs[type] = codec;\r\n        sourceUpdater[type + \"Buffer\"] = sourceBuffer;\r\n      };\r\n    },\r\n    removeSourceBuffer: function removeSourceBuffer(type) {\r\n      return function (sourceUpdater) {\r\n        var sourceBuffer = sourceUpdater[type + \"Buffer\"];\r\n        cleanupBuffer(type, sourceUpdater); // can't do anything if the media source / source buffer is null\r\n        // or the media source does not contain this source buffer.\r\n\r\n        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"Removing \" + type + \"Buffer with codec \" + sourceUpdater.codecs[type] + \" from mediaSource\");\r\n\r\n        try {\r\n          sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);\r\n        } catch (e) {\r\n          videojs.log.warn(\"Failed to removeSourceBuffer \" + type + \"Buffer\", e);\r\n        }\r\n      };\r\n    },\r\n    changeType: function changeType(codec) {\r\n      return function (type, sourceUpdater) {\r\n        var sourceBuffer = sourceUpdater[type + \"Buffer\"];\r\n        var mime = getMimeForCodec(codec); // can't do anything if the media source / source buffer is null\r\n        // or the media source does not contain this source buffer.\r\n\r\n        if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\r\n          return;\r\n        } // do not update codec if we don't need to.\r\n\r\n\r\n        if (sourceUpdater.codecs[type] === codec) {\r\n          return;\r\n        }\r\n\r\n        sourceUpdater.logger_(\"changing \" + type + \"Buffer codec from \" + sourceUpdater.codecs[type] + \" to \" + codec);\r\n        sourceBuffer.changeType(mime);\r\n        sourceUpdater.codecs[type] = codec;\r\n      };\r\n    }\r\n  };\r\n\r\n  var pushQueue = function pushQueue(_ref) {\r\n    var type = _ref.type,\r\n        sourceUpdater = _ref.sourceUpdater,\r\n        action = _ref.action,\r\n        doneFn = _ref.doneFn,\r\n        name = _ref.name;\r\n    sourceUpdater.queue.push({\r\n      type: type,\r\n      action: action,\r\n      doneFn: doneFn,\r\n      name: name\r\n    });\r\n    shiftQueue(type, sourceUpdater);\r\n  };\r\n\r\n  var onUpdateend = function onUpdateend(type, sourceUpdater) {\r\n    return function (e) {\r\n      // Although there should, in theory, be a pending action for any updateend receieved,\r\n      // there are some actions that may trigger updateend events without set definitions in\r\n      // the w3c spec. For instance, setting the duration on the media source may trigger\r\n      // updateend events on source buffers. This does not appear to be in the spec. As such,\r\n      // if we encounter an updateend without a corresponding pending action from our queue\r\n      // for that source buffer type, process the next action.\r\n      if (sourceUpdater.queuePending[type]) {\r\n        var doneFn = sourceUpdater.queuePending[type].doneFn;\r\n        sourceUpdater.queuePending[type] = null;\r\n\r\n        if (doneFn) {\r\n          // if there's an error, report it\r\n          doneFn(sourceUpdater[type + \"Error_\"]);\r\n        }\r\n      }\r\n\r\n      shiftQueue(type, sourceUpdater);\r\n    };\r\n  };\r\n  /**\r\n   * A queue of callbacks to be serialized and applied when a\r\n   * MediaSource and its associated SourceBuffers are not in the\r\n   * updating state. It is used by the segment loader to update the\r\n   * underlying SourceBuffers when new data is loaded, for instance.\r\n   *\r\n   * @class SourceUpdater\r\n   * @param {MediaSource} mediaSource the MediaSource to create the SourceBuffer from\r\n   * @param {string} mimeType the desired MIME type of the underlying SourceBuffer\r\n   */\r\n\r\n\r\n  var SourceUpdater = /*#__PURE__*/function (_videojs$EventTarget) {\r\n    inheritsLoose(SourceUpdater, _videojs$EventTarget);\r\n\r\n    function SourceUpdater(mediaSource) {\r\n      var _this;\r\n\r\n      _this = _videojs$EventTarget.call(this) || this;\r\n      _this.mediaSource = mediaSource;\r\n\r\n      _this.sourceopenListener_ = function () {\r\n        return shiftQueue('mediaSource', assertThisInitialized(_this));\r\n      };\r\n\r\n      _this.mediaSource.addEventListener('sourceopen', _this.sourceopenListener_);\r\n\r\n      _this.logger_ = logger('SourceUpdater'); // initial timestamp offset is 0\r\n\r\n      _this.audioTimestampOffset_ = 0;\r\n      _this.videoTimestampOffset_ = 0;\r\n      _this.queue = [];\r\n      _this.queuePending = {\r\n        audio: null,\r\n        video: null\r\n      };\r\n      _this.delayedAudioAppendQueue_ = [];\r\n      _this.videoAppendQueued_ = false;\r\n      _this.codecs = {};\r\n      _this.onVideoUpdateEnd_ = onUpdateend('video', assertThisInitialized(_this));\r\n      _this.onAudioUpdateEnd_ = onUpdateend('audio', assertThisInitialized(_this));\r\n\r\n      _this.onVideoError_ = function (e) {\r\n        // used for debugging\r\n        _this.videoError_ = e;\r\n      };\r\n\r\n      _this.onAudioError_ = function (e) {\r\n        // used for debugging\r\n        _this.audioError_ = e;\r\n      };\r\n\r\n      _this.createdSourceBuffers_ = false;\r\n      _this.initializedEme_ = false;\r\n      _this.triggeredReady_ = false;\r\n      return _this;\r\n    }\r\n\r\n    var _proto = SourceUpdater.prototype;\r\n\r\n    _proto.initializedEme = function initializedEme() {\r\n      this.initializedEme_ = true;\r\n      this.triggerReady();\r\n    };\r\n\r\n    _proto.hasCreatedSourceBuffers = function hasCreatedSourceBuffers() {\r\n      // if false, likely waiting on one of the segment loaders to get enough data to create\r\n      // source buffers\r\n      return this.createdSourceBuffers_;\r\n    };\r\n\r\n    _proto.hasInitializedAnyEme = function hasInitializedAnyEme() {\r\n      return this.initializedEme_;\r\n    };\r\n\r\n    _proto.ready = function ready() {\r\n      return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();\r\n    };\r\n\r\n    _proto.createSourceBuffers = function createSourceBuffers(codecs) {\r\n      if (this.hasCreatedSourceBuffers()) {\r\n        // already created them before\r\n        return;\r\n      } // the intial addOrChangeSourceBuffers will always be\r\n      // two add buffers.\r\n\r\n\r\n      this.addOrChangeSourceBuffers(codecs);\r\n      this.createdSourceBuffers_ = true;\r\n      this.trigger('createdsourcebuffers');\r\n      this.triggerReady();\r\n    };\r\n\r\n    _proto.triggerReady = function triggerReady() {\r\n      // only allow ready to be triggered once, this prevents the case\r\n      // where:\r\n      // 1. we trigger createdsourcebuffers\r\n      // 2. ie 11 synchronously initializates eme\r\n      // 3. the synchronous initialization causes us to trigger ready\r\n      // 4. We go back to the ready check in createSourceBuffers and ready is triggered again.\r\n      if (this.ready() && !this.triggeredReady_) {\r\n        this.triggeredReady_ = true;\r\n        this.trigger('ready');\r\n      }\r\n    }\r\n    /**\r\n     * Add a type of source buffer to the media source.\r\n     *\r\n     * @param {string} type\r\n     *        The type of source buffer to add.\r\n     *\r\n     * @param {string} codec\r\n     *        The codec to add the source buffer with.\r\n     */\r\n    ;\r\n\r\n    _proto.addSourceBuffer = function addSourceBuffer(type, codec) {\r\n      pushQueue({\r\n        type: 'mediaSource',\r\n        sourceUpdater: this,\r\n        action: actions.addSourceBuffer(type, codec),\r\n        name: 'addSourceBuffer'\r\n      });\r\n    }\r\n    /**\r\n     * call abort on a source buffer.\r\n     *\r\n     * @param {string} type\r\n     *        The type of source buffer to call abort on.\r\n     */\r\n    ;\r\n\r\n    _proto.abort = function abort(type) {\r\n      pushQueue({\r\n        type: type,\r\n        sourceUpdater: this,\r\n        action: actions.abort(type),\r\n        name: 'abort'\r\n      });\r\n    }\r\n    /**\r\n     * Call removeSourceBuffer and remove a specific type\r\n     * of source buffer on the mediaSource.\r\n     *\r\n     * @param {string} type\r\n     *        The type of source buffer to remove.\r\n     */\r\n    ;\r\n\r\n    _proto.removeSourceBuffer = function removeSourceBuffer(type) {\r\n      if (!this.canRemoveSourceBuffer()) {\r\n        videojs.log.error('removeSourceBuffer is not supported!');\r\n        return;\r\n      }\r\n\r\n      pushQueue({\r\n        type: 'mediaSource',\r\n        sourceUpdater: this,\r\n        action: actions.removeSourceBuffer(type),\r\n        name: 'removeSourceBuffer'\r\n      });\r\n    }\r\n    /**\r\n     * Whether or not the removeSourceBuffer function is supported\r\n     * on the mediaSource.\r\n     *\r\n     * @return {boolean}\r\n     *          if removeSourceBuffer can be called.\r\n     */\r\n    ;\r\n\r\n    _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {\r\n      // IE reports that it supports removeSourceBuffer, but often throws\r\n      // errors when attempting to use the function. So we report that it\r\n      // does not support removeSourceBuffer. As of Firefox 83 removeSourceBuffer\r\n      // throws errors, so we report that it does not support this as well.\r\n      return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && typeof window.MediaSource.prototype.removeSourceBuffer === 'function';\r\n    }\r\n    /**\r\n     * Whether or not the changeType function is supported\r\n     * on our SourceBuffers.\r\n     *\r\n     * @return {boolean}\r\n     *         if changeType can be called.\r\n     */\r\n    ;\r\n\r\n    SourceUpdater.canChangeType = function canChangeType() {\r\n      return window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.changeType === 'function';\r\n    }\r\n    /**\r\n     * Whether or not the changeType function is supported\r\n     * on our SourceBuffers.\r\n     *\r\n     * @return {boolean}\r\n     *         if changeType can be called.\r\n     */\r\n    ;\r\n\r\n    _proto.canChangeType = function canChangeType() {\r\n      return this.constructor.canChangeType();\r\n    }\r\n    /**\r\n     * Call the changeType function on a source buffer, given the code and type.\r\n     *\r\n     * @param {string} type\r\n     *        The type of source buffer to call changeType on.\r\n     *\r\n     * @param {string} codec\r\n     *        The codec string to change type with on the source buffer.\r\n     */\r\n    ;\r\n\r\n    _proto.changeType = function changeType(type, codec) {\r\n      if (!this.canChangeType()) {\r\n        videojs.log.error('changeType is not supported!');\r\n        return;\r\n      }\r\n\r\n      pushQueue({\r\n        type: type,\r\n        sourceUpdater: this,\r\n        action: actions.changeType(codec),\r\n        name: 'changeType'\r\n      });\r\n    }\r\n    /**\r\n     * Add source buffers with a codec or, if they are already created,\r\n     * call changeType on source buffers using changeType.\r\n     *\r\n     * @param {Object} codecs\r\n     *        Codecs to switch to\r\n     */\r\n    ;\r\n\r\n    _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {\r\n      var _this2 = this;\r\n\r\n      if (!codecs || typeof codecs !== 'object' || Object.keys(codecs).length === 0) {\r\n        throw new Error('Cannot addOrChangeSourceBuffers to undefined codecs');\r\n      }\r\n\r\n      Object.keys(codecs).forEach(function (type) {\r\n        var codec = codecs[type];\r\n\r\n        if (!_this2.hasCreatedSourceBuffers()) {\r\n          return _this2.addSourceBuffer(type, codec);\r\n        }\r\n\r\n        if (_this2.canChangeType()) {\r\n          _this2.changeType(type, codec);\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Queue an update to append an ArrayBuffer.\r\n     *\r\n     * @param {MediaObject} object containing audioBytes and/or videoBytes\r\n     * @param {Function} done the function to call when done\r\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\r\n     */\r\n    ;\r\n\r\n    _proto.appendBuffer = function appendBuffer(options, doneFn) {\r\n      var _this3 = this;\r\n\r\n      var segmentInfo = options.segmentInfo,\r\n          type = options.type,\r\n          bytes = options.bytes;\r\n      this.processedAppend_ = true;\r\n\r\n      if (type === 'audio' && this.videoBuffer && !this.videoAppendQueued_) {\r\n        this.delayedAudioAppendQueue_.push([options, doneFn]);\r\n        this.logger_(\"delayed audio append of \" + bytes.length + \" until video append\");\r\n        return;\r\n      } // In the case of certain errors, for instance, QUOTA_EXCEEDED_ERR, updateend will\r\n      // not be fired. This means that the queue will be blocked until the next action\r\n      // taken by the segment-loader. Provide a mechanism for segment-loader to handle\r\n      // these errors by calling the doneFn with the specific error.\r\n\r\n\r\n      var onError = doneFn;\r\n      pushQueue({\r\n        type: type,\r\n        sourceUpdater: this,\r\n        action: actions.appendBuffer(bytes, segmentInfo || {\r\n          mediaIndex: -1\r\n        }, onError),\r\n        doneFn: doneFn,\r\n        name: 'appendBuffer'\r\n      });\r\n\r\n      if (type === 'video') {\r\n        this.videoAppendQueued_ = true;\r\n\r\n        if (!this.delayedAudioAppendQueue_.length) {\r\n          return;\r\n        }\r\n\r\n        var queue = this.delayedAudioAppendQueue_.slice();\r\n        this.logger_(\"queuing delayed audio \" + queue.length + \" appendBuffers\");\r\n        this.delayedAudioAppendQueue_.length = 0;\r\n        queue.forEach(function (que) {\r\n          _this3.appendBuffer.apply(_this3, que);\r\n        });\r\n      }\r\n    }\r\n    /**\r\n     * Get the audio buffer's buffered timerange.\r\n     *\r\n     * @return {TimeRange}\r\n     *         The audio buffer's buffered time range\r\n     */\r\n    ;\r\n\r\n    _proto.audioBuffered = function audioBuffered() {\r\n      // no media source/source buffer or it isn't in the media sources\r\n      // source buffer list\r\n      if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {\r\n        return videojs.createTimeRange();\r\n      }\r\n\r\n      return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs.createTimeRange();\r\n    }\r\n    /**\r\n     * Get the video buffer's buffered timerange.\r\n     *\r\n     * @return {TimeRange}\r\n     *         The video buffer's buffered time range\r\n     */\r\n    ;\r\n\r\n    _proto.videoBuffered = function videoBuffered() {\r\n      // no media source/source buffer or it isn't in the media sources\r\n      // source buffer list\r\n      if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {\r\n        return videojs.createTimeRange();\r\n      }\r\n\r\n      return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs.createTimeRange();\r\n    }\r\n    /**\r\n     * Get a combined video/audio buffer's buffered timerange.\r\n     *\r\n     * @return {TimeRange}\r\n     *         the combined time range\r\n     */\r\n    ;\r\n\r\n    _proto.buffered = function buffered() {\r\n      var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;\r\n      var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;\r\n\r\n      if (audio && !video) {\r\n        return this.audioBuffered();\r\n      }\r\n\r\n      if (video && !audio) {\r\n        return this.videoBuffered();\r\n      }\r\n\r\n      return bufferIntersection(this.audioBuffered(), this.videoBuffered());\r\n    }\r\n    /**\r\n     * Add a callback to the queue that will set duration on the mediaSource.\r\n     *\r\n     * @param {number} duration\r\n     *        The duration to set\r\n     *\r\n     * @param {Function} [doneFn]\r\n     *        function to run after duration has been set.\r\n     */\r\n    ;\r\n\r\n    _proto.setDuration = function setDuration(duration, doneFn) {\r\n      if (doneFn === void 0) {\r\n        doneFn = noop;\r\n      } // In order to set the duration on the media source, it's necessary to wait for all\r\n      // source buffers to no longer be updating. \"If the updating attribute equals true on\r\n      // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\r\n      // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\r\n\r\n\r\n      pushQueue({\r\n        type: 'mediaSource',\r\n        sourceUpdater: this,\r\n        action: actions.duration(duration),\r\n        name: 'duration',\r\n        doneFn: doneFn\r\n      });\r\n    }\r\n    /**\r\n     * Add a mediaSource endOfStream call to the queue\r\n     *\r\n     * @param {Error} [error]\r\n     *        Call endOfStream with an error\r\n     *\r\n     * @param {Function} [doneFn]\r\n     *        A function that should be called when the\r\n     *        endOfStream call has finished.\r\n     */\r\n    ;\r\n\r\n    _proto.endOfStream = function endOfStream(error, doneFn) {\r\n      if (error === void 0) {\r\n        error = null;\r\n      }\r\n\r\n      if (doneFn === void 0) {\r\n        doneFn = noop;\r\n      }\r\n\r\n      if (typeof error !== 'string') {\r\n        error = undefined;\r\n      } // In order to set the duration on the media source, it's necessary to wait for all\r\n      // source buffers to no longer be updating. \"If the updating attribute equals true on\r\n      // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\r\n      // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\r\n\r\n\r\n      pushQueue({\r\n        type: 'mediaSource',\r\n        sourceUpdater: this,\r\n        action: actions.endOfStream(error),\r\n        name: 'endOfStream',\r\n        doneFn: doneFn\r\n      });\r\n    }\r\n    /**\r\n     * Queue an update to remove a time range from the buffer.\r\n     *\r\n     * @param {number} start where to start the removal\r\n     * @param {number} end where to end the removal\r\n     * @param {Function} [done=noop] optional callback to be executed when the remove\r\n     * operation is complete\r\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\r\n     */\r\n    ;\r\n\r\n    _proto.removeAudio = function removeAudio(start, end, done) {\r\n      if (done === void 0) {\r\n        done = noop;\r\n      }\r\n\r\n      if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {\r\n        done();\r\n        return;\r\n      }\r\n\r\n      pushQueue({\r\n        type: 'audio',\r\n        sourceUpdater: this,\r\n        action: actions.remove(start, end),\r\n        doneFn: done,\r\n        name: 'remove'\r\n      });\r\n    }\r\n    /**\r\n     * Queue an update to remove a time range from the buffer.\r\n     *\r\n     * @param {number} start where to start the removal\r\n     * @param {number} end where to end the removal\r\n     * @param {Function} [done=noop] optional callback to be executed when the remove\r\n     * operation is complete\r\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\r\n     */\r\n    ;\r\n\r\n    _proto.removeVideo = function removeVideo(start, end, done) {\r\n      if (done === void 0) {\r\n        done = noop;\r\n      }\r\n\r\n      if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {\r\n        done();\r\n        return;\r\n      }\r\n\r\n      pushQueue({\r\n        type: 'video',\r\n        sourceUpdater: this,\r\n        action: actions.remove(start, end),\r\n        doneFn: done,\r\n        name: 'remove'\r\n      });\r\n    }\r\n    /**\r\n     * Whether the underlying sourceBuffer is updating or not\r\n     *\r\n     * @return {boolean} the updating status of the SourceBuffer\r\n     */\r\n    ;\r\n\r\n    _proto.updating = function updating() {\r\n      // the audio/video source buffer is updating\r\n      if (_updating('audio', this) || _updating('video', this)) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Set/get the timestampoffset on the audio SourceBuffer\r\n     *\r\n     * @return {number} the timestamp offset\r\n     */\r\n    ;\r\n\r\n    _proto.audioTimestampOffset = function audioTimestampOffset(offset) {\r\n      if (typeof offset !== 'undefined' && this.audioBuffer && // no point in updating if it's the same\r\n      this.audioTimestampOffset_ !== offset) {\r\n        pushQueue({\r\n          type: 'audio',\r\n          sourceUpdater: this,\r\n          action: actions.timestampOffset(offset),\r\n          name: 'timestampOffset'\r\n        });\r\n        this.audioTimestampOffset_ = offset;\r\n      }\r\n\r\n      return this.audioTimestampOffset_;\r\n    }\r\n    /**\r\n     * Set/get the timestampoffset on the video SourceBuffer\r\n     *\r\n     * @return {number} the timestamp offset\r\n     */\r\n    ;\r\n\r\n    _proto.videoTimestampOffset = function videoTimestampOffset(offset) {\r\n      if (typeof offset !== 'undefined' && this.videoBuffer && // no point in updating if it's the same\r\n      this.videoTimestampOffset !== offset) {\r\n        pushQueue({\r\n          type: 'video',\r\n          sourceUpdater: this,\r\n          action: actions.timestampOffset(offset),\r\n          name: 'timestampOffset'\r\n        });\r\n        this.videoTimestampOffset_ = offset;\r\n      }\r\n\r\n      return this.videoTimestampOffset_;\r\n    }\r\n    /**\r\n     * Add a function to the queue that will be called\r\n     * when it is its turn to run in the audio queue.\r\n     *\r\n     * @param {Function} callback\r\n     *        The callback to queue.\r\n     */\r\n    ;\r\n\r\n    _proto.audioQueueCallback = function audioQueueCallback(callback) {\r\n      if (!this.audioBuffer) {\r\n        return;\r\n      }\r\n\r\n      pushQueue({\r\n        type: 'audio',\r\n        sourceUpdater: this,\r\n        action: actions.callback(callback),\r\n        name: 'callback'\r\n      });\r\n    }\r\n    /**\r\n     * Add a function to the queue that will be called\r\n     * when it is its turn to run in the video queue.\r\n     *\r\n     * @param {Function} callback\r\n     *        The callback to queue.\r\n     */\r\n    ;\r\n\r\n    _proto.videoQueueCallback = function videoQueueCallback(callback) {\r\n      if (!this.videoBuffer) {\r\n        return;\r\n      }\r\n\r\n      pushQueue({\r\n        type: 'video',\r\n        sourceUpdater: this,\r\n        action: actions.callback(callback),\r\n        name: 'callback'\r\n      });\r\n    }\r\n    /**\r\n     * dispose of the source updater and the underlying sourceBuffer\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      var _this4 = this;\r\n\r\n      this.trigger('dispose');\r\n      bufferTypes.forEach(function (type) {\r\n        _this4.abort(type);\r\n\r\n        if (_this4.canRemoveSourceBuffer()) {\r\n          _this4.removeSourceBuffer(type);\r\n        } else {\r\n          _this4[type + \"QueueCallback\"](function () {\r\n            return cleanupBuffer(type, _this4);\r\n          });\r\n        }\r\n      });\r\n      this.videoAppendQueued_ = false;\r\n      this.delayedAudioAppendQueue_.length = 0;\r\n\r\n      if (this.sourceopenListener_) {\r\n        this.mediaSource.removeEventListener('sourceopen', this.sourceopenListener_);\r\n      }\r\n\r\n      this.off();\r\n    };\r\n\r\n    return SourceUpdater;\r\n  }(videojs.EventTarget);\r\n\r\n  var uint8ToUtf8 = function uint8ToUtf8(uintArray) {\r\n    return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));\r\n  };\r\n\r\n  var VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(function (_char3) {\r\n    return _char3.charCodeAt(0);\r\n  }));\r\n  /**\r\n   * An object that manages segment loading and appending.\r\n   *\r\n   * @class VTTSegmentLoader\r\n   * @param {Object} options required and optional options\r\n   * @extends videojs.EventTarget\r\n   */\r\n\r\n  var VTTSegmentLoader = /*#__PURE__*/function (_SegmentLoader) {\r\n    inheritsLoose(VTTSegmentLoader, _SegmentLoader);\r\n\r\n    function VTTSegmentLoader(settings, options) {\r\n      var _this;\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      _this = _SegmentLoader.call(this, settings, options) || this; // SegmentLoader requires a MediaSource be specified or it will throw an error;\r\n      // however, VTTSegmentLoader has no need of a media source, so delete the reference\r\n\r\n      _this.mediaSource_ = null;\r\n      _this.subtitlesTrack_ = null;\r\n      _this.loaderType_ = 'subtitle';\r\n      _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks; // The VTT segment will have its own time mappings. Saving VTT segment timing info in\r\n      // the sync controller leads to improper behavior.\r\n\r\n      _this.shouldSaveSegmentTimingInfo_ = false;\r\n      return _this;\r\n    }\r\n\r\n    var _proto = VTTSegmentLoader.prototype;\r\n\r\n    _proto.createTransmuxer_ = function createTransmuxer_() {\r\n      // don't need to transmux any subtitles\r\n      return null;\r\n    }\r\n    /**\r\n     * Indicates which time ranges are buffered\r\n     *\r\n     * @return {TimeRange}\r\n     *         TimeRange object representing the current buffered ranges\r\n     */\r\n    ;\r\n\r\n    _proto.buffered_ = function buffered_() {\r\n      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {\r\n        return videojs.createTimeRanges();\r\n      }\r\n\r\n      var cues = this.subtitlesTrack_.cues;\r\n      var start = cues[0].startTime;\r\n      var end = cues[cues.length - 1].startTime;\r\n      return videojs.createTimeRanges([[start, end]]);\r\n    }\r\n    /**\r\n     * Gets and sets init segment for the provided map\r\n     *\r\n     * @param {Object} map\r\n     *        The map object representing the init segment to get or set\r\n     * @param {boolean=} set\r\n     *        If true, the init segment for the provided map should be saved\r\n     * @return {Object}\r\n     *         map object for desired init segment\r\n     */\r\n    ;\r\n\r\n    _proto.initSegmentForMap = function initSegmentForMap(map, set) {\r\n      if (set === void 0) {\r\n        set = false;\r\n      }\r\n\r\n      if (!map) {\r\n        return null;\r\n      }\r\n\r\n      var id = initSegmentId(map);\r\n      var storedMap = this.initSegments_[id];\r\n\r\n      if (set && !storedMap && map.bytes) {\r\n        // append WebVTT line terminators to the media initialization segment if it exists\r\n        // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\r\n        // requires two or more WebVTT line terminators between the WebVTT header and the\r\n        // rest of the file\r\n        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\r\n        var combinedSegment = new Uint8Array(combinedByteLength);\r\n        combinedSegment.set(map.bytes);\r\n        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\r\n        this.initSegments_[id] = storedMap = {\r\n          resolvedUri: map.resolvedUri,\r\n          byterange: map.byterange,\r\n          bytes: combinedSegment\r\n        };\r\n      }\r\n\r\n      return storedMap || map;\r\n    }\r\n    /**\r\n     * Returns true if all configuration required for loading is present, otherwise false.\r\n     *\r\n     * @return {boolean} True if the all configuration is ready for loading\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.couldBeginLoading_ = function couldBeginLoading_() {\r\n      return this.playlist_ && this.subtitlesTrack_ && !this.paused();\r\n    }\r\n    /**\r\n     * Once all the starting parameters have been specified, begin\r\n     * operation. This method should only be invoked from the INIT\r\n     * state.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.init_ = function init_() {\r\n      this.state = 'READY';\r\n      this.resetEverything();\r\n      return this.monitorBuffer_();\r\n    }\r\n    /**\r\n     * Set a subtitle track on the segment loader to add subtitles to\r\n     *\r\n     * @param {TextTrack=} track\r\n     *        The text track to add loaded subtitles to\r\n     * @return {TextTrack}\r\n     *        Returns the subtitles track\r\n     */\r\n    ;\r\n\r\n    _proto.track = function track(_track) {\r\n      if (typeof _track === 'undefined') {\r\n        return this.subtitlesTrack_;\r\n      }\r\n\r\n      this.subtitlesTrack_ = _track; // if we were unpaused but waiting for a sourceUpdater, start\r\n      // buffering now\r\n\r\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\r\n        this.init_();\r\n      }\r\n\r\n      return this.subtitlesTrack_;\r\n    }\r\n    /**\r\n     * Remove any data in the source buffer between start and end times\r\n     *\r\n     * @param {number} start - the start time of the region to remove from the buffer\r\n     * @param {number} end - the end time of the region to remove from the buffer\r\n     */\r\n    ;\r\n\r\n    _proto.remove = function remove(start, end) {\r\n      removeCuesFromTrack(start, end, this.subtitlesTrack_);\r\n    }\r\n    /**\r\n     * fill the buffer with segements unless the sourceBuffers are\r\n     * currently updating\r\n     *\r\n     * Note: this function should only ever be called by monitorBuffer_\r\n     * and never directly\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.fillBuffer_ = function fillBuffer_() {\r\n      var _this2 = this; // see if we need to begin loading immediately\r\n\r\n\r\n      var segmentInfo = this.chooseNextRequest_();\r\n\r\n      if (!segmentInfo) {\r\n        return;\r\n      }\r\n\r\n      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\r\n        // We don't have the timestamp offset that we need to sync subtitles.\r\n        // Rerun on a timestamp offset or user interaction.\r\n        var checkTimestampOffset = function checkTimestampOffset() {\r\n          _this2.state = 'READY';\r\n\r\n          if (!_this2.paused()) {\r\n            // if not paused, queue a buffer check as soon as possible\r\n            _this2.monitorBuffer_();\r\n          }\r\n        };\r\n\r\n        this.syncController_.one('timestampoffset', checkTimestampOffset);\r\n        this.state = 'WAITING_ON_TIMELINE';\r\n        return;\r\n      }\r\n\r\n      this.loadSegment_(segmentInfo);\r\n    } // never set a timestamp offset for vtt segments.\r\n    ;\r\n\r\n    _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_() {\r\n      return null;\r\n    };\r\n\r\n    _proto.chooseNextRequest_ = function chooseNextRequest_() {\r\n      return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));\r\n    }\r\n    /**\r\n     * Prevents the segment loader from requesting segments we know contain no subtitles\r\n     * by walking forward until we find the next segment that we don't know whether it is\r\n     * empty or not.\r\n     *\r\n     * @param {Object} segmentInfo\r\n     *        a segment info object that describes the current segment\r\n     * @return {Object}\r\n     *         a segment info object that describes the current segment\r\n     */\r\n    ;\r\n\r\n    _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {\r\n      while (segmentInfo && segmentInfo.segment.empty) {\r\n        // stop at the last possible segmentInfo\r\n        if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {\r\n          segmentInfo = null;\r\n          break;\r\n        }\r\n\r\n        segmentInfo = this.generateSegmentInfo_({\r\n          playlist: segmentInfo.playlist,\r\n          mediaIndex: segmentInfo.mediaIndex + 1,\r\n          startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,\r\n          isSyncRequest: segmentInfo.isSyncRequest\r\n        });\r\n      }\r\n\r\n      return segmentInfo;\r\n    };\r\n\r\n    _proto.stopForError = function stopForError(error) {\r\n      this.error(error);\r\n      this.state = 'READY';\r\n      this.pause();\r\n      this.trigger('error');\r\n    }\r\n    /**\r\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {\r\n      var _this3 = this;\r\n\r\n      if (!this.subtitlesTrack_) {\r\n        this.state = 'READY';\r\n        return;\r\n      }\r\n\r\n      this.saveTransferStats_(simpleSegment.stats); // the request was aborted\r\n\r\n      if (!this.pendingSegment_) {\r\n        this.state = 'READY';\r\n        this.mediaRequestsAborted += 1;\r\n        return;\r\n      }\r\n\r\n      if (error) {\r\n        if (error.code === REQUEST_ERRORS.TIMEOUT) {\r\n          this.handleTimeout_();\r\n        }\r\n\r\n        if (error.code === REQUEST_ERRORS.ABORTED) {\r\n          this.mediaRequestsAborted += 1;\r\n        } else {\r\n          this.mediaRequestsErrored += 1;\r\n        }\r\n\r\n        this.stopForError(error);\r\n        return;\r\n      }\r\n\r\n      var segmentInfo = this.pendingSegment_; // although the VTT segment loader bandwidth isn't really used, it's good to\r\n      // maintain functionality between segment loaders\r\n\r\n      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats); // if this request included a segment key, save that data in the cache\r\n\r\n      if (simpleSegment.key) {\r\n        this.segmentKey(simpleSegment.key, true);\r\n      }\r\n\r\n      this.state = 'APPENDING'; // used for tests\r\n\r\n      this.trigger('appending');\r\n      var segment = segmentInfo.segment;\r\n\r\n      if (segment.map) {\r\n        segment.map.bytes = simpleSegment.map.bytes;\r\n      }\r\n\r\n      segmentInfo.bytes = simpleSegment.bytes; // Make sure that vttjs has loaded, otherwise, wait till it finished loading\r\n\r\n      if (typeof window.WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\r\n        var loadHandler;\r\n\r\n        var errorHandler = function errorHandler() {\r\n          _this3.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\r\n\r\n          _this3.stopForError({\r\n            message: 'Error loading vtt.js'\r\n          });\r\n\r\n          return;\r\n        };\r\n\r\n        loadHandler = function loadHandler() {\r\n          _this3.subtitlesTrack_.tech_.off('vttjserror', errorHandler);\r\n\r\n          _this3.segmentRequestFinished_(error, simpleSegment, result);\r\n        };\r\n\r\n        this.state = 'WAITING_ON_VTTJS';\r\n        this.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\r\n        this.subtitlesTrack_.tech_.one('vttjserror', errorHandler);\r\n        return;\r\n      }\r\n\r\n      segment.requested = true;\r\n\r\n      try {\r\n        this.parseVTTCues_(segmentInfo);\r\n      } catch (e) {\r\n        this.stopForError({\r\n          message: e.message\r\n        });\r\n        return;\r\n      }\r\n\r\n      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\r\n\r\n      if (segmentInfo.cues.length) {\r\n        segmentInfo.timingInfo = {\r\n          start: segmentInfo.cues[0].startTime,\r\n          end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime\r\n        };\r\n      } else {\r\n        segmentInfo.timingInfo = {\r\n          start: segmentInfo.startOfSegment,\r\n          end: segmentInfo.startOfSegment + segmentInfo.duration\r\n        };\r\n      }\r\n\r\n      if (segmentInfo.isSyncRequest) {\r\n        this.trigger('syncinfoupdate');\r\n        this.pendingSegment_ = null;\r\n        this.state = 'READY';\r\n        return;\r\n      }\r\n\r\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\r\n      this.mediaSecondsLoaded += segment.duration; // Create VTTCue instances for each cue in the new segment and add them to\r\n      // the subtitle track\r\n\r\n      segmentInfo.cues.forEach(function (cue) {\r\n        _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new window.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);\r\n      }); // Remove any duplicate cues from the subtitle track. The WebVTT spec allows\r\n      // cues to have identical time-intervals, but if the text is also identical\r\n      // we can safely assume it is a duplicate that can be removed (ex. when a cue\r\n      // \"overlaps\" VTT segments)\r\n\r\n      removeDuplicateCuesFromTrack(this.subtitlesTrack_);\r\n      this.handleAppendsDone_();\r\n    };\r\n\r\n    _proto.handleData_ = function handleData_() {// noop as we shouldn't be getting video/audio data captions\r\n      // that we do not support here.\r\n    };\r\n\r\n    _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {// noop\r\n    }\r\n    /**\r\n     * Uses the WebVTT parser to parse the segment response\r\n     *\r\n     * @param {Object} segmentInfo\r\n     *        a segment info object that describes the current segment\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {\r\n      var decoder;\r\n      var decodeBytesToString = false;\r\n\r\n      if (typeof window.TextDecoder === 'function') {\r\n        decoder = new window.TextDecoder('utf8');\r\n      } else {\r\n        decoder = window.WebVTT.StringDecoder();\r\n        decodeBytesToString = true;\r\n      }\r\n\r\n      var parser = new window.WebVTT.Parser(window, window.vttjs, decoder);\r\n      segmentInfo.cues = [];\r\n      segmentInfo.timestampmap = {\r\n        MPEGTS: 0,\r\n        LOCAL: 0\r\n      };\r\n      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\r\n\r\n      parser.ontimestampmap = function (map) {\r\n        segmentInfo.timestampmap = map;\r\n      };\r\n\r\n      parser.onparsingerror = function (error) {\r\n        videojs.log.warn('Error encountered when parsing cues: ' + error.message);\r\n      };\r\n\r\n      if (segmentInfo.segment.map) {\r\n        var mapData = segmentInfo.segment.map.bytes;\r\n\r\n        if (decodeBytesToString) {\r\n          mapData = uint8ToUtf8(mapData);\r\n        }\r\n\r\n        parser.parse(mapData);\r\n      }\r\n\r\n      var segmentData = segmentInfo.bytes;\r\n\r\n      if (decodeBytesToString) {\r\n        segmentData = uint8ToUtf8(segmentData);\r\n      }\r\n\r\n      parser.parse(segmentData);\r\n      parser.flush();\r\n    }\r\n    /**\r\n     * Updates the start and end times of any cues parsed by the WebVTT parser using\r\n     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\r\n     * from the SyncController\r\n     *\r\n     * @param {Object} segmentInfo\r\n     *        a segment info object that describes the current segment\r\n     * @param {Object} mappingObj\r\n     *        object containing a mapping from TS to media time\r\n     * @param {Object} playlist\r\n     *        the playlist object containing the segment\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {\r\n      var segment = segmentInfo.segment;\r\n\r\n      if (!mappingObj) {\r\n        // If the sync controller does not have a mapping of TS to Media Time for the\r\n        // timeline, then we don't have enough information to update the cue\r\n        // start/end times\r\n        return;\r\n      }\r\n\r\n      if (!segmentInfo.cues.length) {\r\n        // If there are no cues, we also do not have enough information to figure out\r\n        // segment timing. Mark that the segment contains no cues so we don't re-request\r\n        // an empty segment.\r\n        segment.empty = true;\r\n        return;\r\n      }\r\n\r\n      var timestampmap = segmentInfo.timestampmap;\r\n      var diff = timestampmap.MPEGTS / clock_1 - timestampmap.LOCAL + mappingObj.mapping;\r\n      segmentInfo.cues.forEach(function (cue) {\r\n        // First convert cue time to TS time using the timestamp-map provided within the vtt\r\n        cue.startTime += diff;\r\n        cue.endTime += diff;\r\n      });\r\n\r\n      if (!playlist.syncInfo) {\r\n        var firstStart = segmentInfo.cues[0].startTime;\r\n        var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\r\n        playlist.syncInfo = {\r\n          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\r\n          time: Math.min(firstStart, lastStart - segment.duration)\r\n        };\r\n      }\r\n    };\r\n\r\n    return VTTSegmentLoader;\r\n  }(SegmentLoader);\r\n  /**\r\n   * @file ad-cue-tags.js\r\n   */\r\n\r\n  /**\r\n   * Searches for an ad cue that overlaps with the given mediaTime\r\n   *\r\n   * @param {Object} track\r\n   *        the track to find the cue for\r\n   *\r\n   * @param {number} mediaTime\r\n   *        the time to find the cue at\r\n   *\r\n   * @return {Object|null}\r\n   *         the found cue or null\r\n   */\r\n\r\n\r\n  var findAdCue = function findAdCue(track, mediaTime) {\r\n    var cues = track.cues;\r\n\r\n    for (var i = 0; i < cues.length; i++) {\r\n      var cue = cues[i];\r\n\r\n      if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\r\n        return cue;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  var updateAdCues = function updateAdCues(media, track, offset) {\r\n    if (offset === void 0) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (!media.segments) {\r\n      return;\r\n    }\r\n\r\n    var mediaTime = offset;\r\n    var cue;\r\n\r\n    for (var i = 0; i < media.segments.length; i++) {\r\n      var segment = media.segments[i];\r\n\r\n      if (!cue) {\r\n        // Since the cues will span for at least the segment duration, adding a fudge\r\n        // factor of half segment duration will prevent duplicate cues from being\r\n        // created when timing info is not exact (e.g. cue start time initialized\r\n        // at 10.006677, but next call mediaTime is 10.003332 )\r\n        cue = findAdCue(track, mediaTime + segment.duration / 2);\r\n      }\r\n\r\n      if (cue) {\r\n        if ('cueIn' in segment) {\r\n          // Found a CUE-IN so end the cue\r\n          cue.endTime = mediaTime;\r\n          cue.adEndTime = mediaTime;\r\n          mediaTime += segment.duration;\r\n          cue = null;\r\n          continue;\r\n        }\r\n\r\n        if (mediaTime < cue.endTime) {\r\n          // Already processed this mediaTime for this cue\r\n          mediaTime += segment.duration;\r\n          continue;\r\n        } // otherwise extend cue until a CUE-IN is found\r\n\r\n\r\n        cue.endTime += segment.duration;\r\n      } else {\r\n        if ('cueOut' in segment) {\r\n          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\r\n          cue.adStartTime = mediaTime; // Assumes tag format to be\r\n          // #EXT-X-CUE-OUT:30\r\n\r\n          cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\r\n          track.addCue(cue);\r\n        }\r\n\r\n        if ('cueOutCont' in segment) {\r\n          // Entered into the middle of an ad cue\r\n          // Assumes tag formate to be\r\n          // #EXT-X-CUE-OUT-CONT:10/30\r\n          var _segment$cueOutCont$s = segment.cueOutCont.split('/').map(parseFloat),\r\n              adOffset = _segment$cueOutCont$s[0],\r\n              adTotal = _segment$cueOutCont$s[1];\r\n\r\n          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, '');\r\n          cue.adStartTime = mediaTime - adOffset;\r\n          cue.adEndTime = cue.adStartTime + adTotal;\r\n          track.addCue(cue);\r\n        }\r\n      }\r\n\r\n      mediaTime += segment.duration;\r\n    }\r\n  }; // synchronize expired playlist segments.\r\n  // the max media sequence diff is 48 hours of live stream\r\n  // content with two second segments. Anything larger than that\r\n  // will likely be invalid.\r\n\r\n\r\n  var MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;\r\n  var syncPointStrategies = [// Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\r\n  //                the equivalence display-time 0 === segment-index 0\r\n  {\r\n    name: 'VOD',\r\n    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\r\n      if (duration !== Infinity) {\r\n        var syncPoint = {\r\n          time: 0,\r\n          segmentIndex: 0,\r\n          partIndex: null\r\n        };\r\n        return syncPoint;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, // Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\r\n  {\r\n    name: 'ProgramDateTime',\r\n    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\r\n      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {\r\n        return null;\r\n      }\r\n\r\n      var syncPoint = null;\r\n      var lastDistance = null;\r\n      var partsAndSegments = getPartsAndSegments(playlist);\r\n      currentTime = currentTime || 0;\r\n\r\n      for (var i = 0; i < partsAndSegments.length; i++) {\r\n        // start from the end and loop backwards for live\r\n        // or start from the front and loop forwards for non-live\r\n        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\r\n        var partAndSegment = partsAndSegments[index];\r\n        var segment = partAndSegment.segment;\r\n        var datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];\r\n\r\n        if (!datetimeMapping || !segment.dateTimeObject) {\r\n          continue;\r\n        }\r\n\r\n        var segmentTime = segment.dateTimeObject.getTime() / 1000;\r\n        var start = segmentTime + datetimeMapping; // take part duration into account.\r\n\r\n        if (segment.parts && typeof partAndSegment.partIndex === 'number') {\r\n          for (var z = 0; z < partAndSegment.partIndex; z++) {\r\n            start += segment.parts[z].duration;\r\n          }\r\n        }\r\n\r\n        var distance = Math.abs(currentTime - start); // Once the distance begins to increase, or if distance is 0, we have passed\r\n        // currentTime and can stop looking for better candidates\r\n\r\n        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {\r\n          break;\r\n        }\r\n\r\n        lastDistance = distance;\r\n        syncPoint = {\r\n          time: start,\r\n          segmentIndex: partAndSegment.segmentIndex,\r\n          partIndex: partAndSegment.partIndex\r\n        };\r\n      }\r\n\r\n      return syncPoint;\r\n    }\r\n  }, // Stategy \"Segment\": We have a known time mapping for a timeline and a\r\n  //                    segment in the current timeline with timing data\r\n  {\r\n    name: 'Segment',\r\n    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\r\n      var syncPoint = null;\r\n      var lastDistance = null;\r\n      currentTime = currentTime || 0;\r\n      var partsAndSegments = getPartsAndSegments(playlist);\r\n\r\n      for (var i = 0; i < partsAndSegments.length; i++) {\r\n        // start from the end and loop backwards for live\r\n        // or start from the front and loop forwards for non-live\r\n        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\r\n        var partAndSegment = partsAndSegments[index];\r\n        var segment = partAndSegment.segment;\r\n        var start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;\r\n\r\n        if (segment.timeline === currentTimeline && typeof start !== 'undefined') {\r\n          var distance = Math.abs(currentTime - start); // Once the distance begins to increase, we have passed\r\n          // currentTime and can stop looking for better candidates\r\n\r\n          if (lastDistance !== null && lastDistance < distance) {\r\n            break;\r\n          }\r\n\r\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\r\n            lastDistance = distance;\r\n            syncPoint = {\r\n              time: start,\r\n              segmentIndex: partAndSegment.segmentIndex,\r\n              partIndex: partAndSegment.partIndex\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      return syncPoint;\r\n    }\r\n  }, // Stategy \"Discontinuity\": We have a discontinuity with a known\r\n  //                          display-time\r\n  {\r\n    name: 'Discontinuity',\r\n    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\r\n      var syncPoint = null;\r\n      currentTime = currentTime || 0;\r\n\r\n      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\r\n        var lastDistance = null;\r\n\r\n        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\r\n          var segmentIndex = playlist.discontinuityStarts[i];\r\n          var discontinuity = playlist.discontinuitySequence + i + 1;\r\n          var discontinuitySync = syncController.discontinuities[discontinuity];\r\n\r\n          if (discontinuitySync) {\r\n            var distance = Math.abs(currentTime - discontinuitySync.time); // Once the distance begins to increase, we have passed\r\n            // currentTime and can stop looking for better candidates\r\n\r\n            if (lastDistance !== null && lastDistance < distance) {\r\n              break;\r\n            }\r\n\r\n            if (!syncPoint || lastDistance === null || lastDistance >= distance) {\r\n              lastDistance = distance;\r\n              syncPoint = {\r\n                time: discontinuitySync.time,\r\n                segmentIndex: segmentIndex,\r\n                partIndex: null\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return syncPoint;\r\n    }\r\n  }, // Stategy \"Playlist\": We have a playlist with a known mapping of\r\n  //                     segment index to display time\r\n  {\r\n    name: 'Playlist',\r\n    run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\r\n      if (playlist.syncInfo) {\r\n        var syncPoint = {\r\n          time: playlist.syncInfo.time,\r\n          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,\r\n          partIndex: null\r\n        };\r\n        return syncPoint;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }];\r\n\r\n  var SyncController = /*#__PURE__*/function (_videojs$EventTarget) {\r\n    inheritsLoose(SyncController, _videojs$EventTarget);\r\n\r\n    function SyncController(options) {\r\n      var _this;\r\n\r\n      _this = _videojs$EventTarget.call(this) || this; // ...for synching across variants\r\n\r\n      _this.timelines = [];\r\n      _this.discontinuities = [];\r\n      _this.timelineToDatetimeMappings = {};\r\n      _this.logger_ = logger('SyncController');\r\n      return _this;\r\n    }\r\n    /**\r\n     * Find a sync-point for the playlist specified\r\n     *\r\n     * A sync-point is defined as a known mapping from display-time to\r\n     * a segment-index in the current playlist.\r\n     *\r\n     * @param {Playlist} playlist\r\n     *        The playlist that needs a sync-point\r\n     * @param {number} duration\r\n     *        Duration of the MediaSource (Infinite if playing a live source)\r\n     * @param {number} currentTimeline\r\n     *        The last timeline from which a segment was loaded\r\n     * @return {Object}\r\n     *          A sync-point object\r\n     */\r\n\r\n\r\n    var _proto = SyncController.prototype;\r\n\r\n    _proto.getSyncPoint = function getSyncPoint(playlist, duration, currentTimeline, currentTime) {\r\n      var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\r\n\r\n      if (!syncPoints.length) {\r\n        // Signal that we need to attempt to get a sync-point manually\r\n        // by fetching a segment in the playlist and constructing\r\n        // a sync-point from that information\r\n        return null;\r\n      } // Now find the sync-point that is closest to the currentTime because\r\n      // that should result in the most accurate guess about which segment\r\n      // to fetch\r\n\r\n\r\n      return this.selectSyncPoint_(syncPoints, {\r\n        key: 'time',\r\n        value: currentTime\r\n      });\r\n    }\r\n    /**\r\n     * Calculate the amount of time that has expired off the playlist during playback\r\n     *\r\n     * @param {Playlist} playlist\r\n     *        Playlist object to calculate expired from\r\n     * @param {number} duration\r\n     *        Duration of the MediaSource (Infinity if playling a live source)\r\n     * @return {number|null}\r\n     *          The amount of time that has expired off the playlist during playback. Null\r\n     *          if no sync-points for the playlist can be found.\r\n     */\r\n    ;\r\n\r\n    _proto.getExpiredTime = function getExpiredTime(playlist, duration) {\r\n      if (!playlist || !playlist.segments) {\r\n        return null;\r\n      }\r\n\r\n      var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0); // Without sync-points, there is not enough information to determine the expired time\r\n\r\n      if (!syncPoints.length) {\r\n        return null;\r\n      }\r\n\r\n      var syncPoint = this.selectSyncPoint_(syncPoints, {\r\n        key: 'segmentIndex',\r\n        value: 0\r\n      }); // If the sync-point is beyond the start of the playlist, we want to subtract the\r\n      // duration from index 0 to syncPoint.segmentIndex instead of adding.\r\n\r\n      if (syncPoint.segmentIndex > 0) {\r\n        syncPoint.time *= -1;\r\n      }\r\n\r\n      return Math.abs(syncPoint.time + sumDurations({\r\n        defaultDuration: playlist.targetDuration,\r\n        durationList: playlist.segments,\r\n        startIndex: syncPoint.segmentIndex,\r\n        endIndex: 0\r\n      }));\r\n    }\r\n    /**\r\n     * Runs each sync-point strategy and returns a list of sync-points returned by the\r\n     * strategies\r\n     *\r\n     * @private\r\n     * @param {Playlist} playlist\r\n     *        The playlist that needs a sync-point\r\n     * @param {number} duration\r\n     *        Duration of the MediaSource (Infinity if playing a live source)\r\n     * @param {number} currentTimeline\r\n     *        The last timeline from which a segment was loaded\r\n     * @return {Array}\r\n     *          A list of sync-point objects\r\n     */\r\n    ;\r\n\r\n    _proto.runStrategies_ = function runStrategies_(playlist, duration, currentTimeline, currentTime) {\r\n      var syncPoints = []; // Try to find a sync-point in by utilizing various strategies...\r\n\r\n      for (var i = 0; i < syncPointStrategies.length; i++) {\r\n        var strategy = syncPointStrategies[i];\r\n        var syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\r\n\r\n        if (syncPoint) {\r\n          syncPoint.strategy = strategy.name;\r\n          syncPoints.push({\r\n            strategy: strategy.name,\r\n            syncPoint: syncPoint\r\n          });\r\n        }\r\n      }\r\n\r\n      return syncPoints;\r\n    }\r\n    /**\r\n     * Selects the sync-point nearest the specified target\r\n     *\r\n     * @private\r\n     * @param {Array} syncPoints\r\n     *        List of sync-points to select from\r\n     * @param {Object} target\r\n     *        Object specifying the property and value we are targeting\r\n     * @param {string} target.key\r\n     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\r\n     * @param {number} target.value\r\n     *        The value to target for the specified key.\r\n     * @return {Object}\r\n     *          The sync-point nearest the target\r\n     */\r\n    ;\r\n\r\n    _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {\r\n      var bestSyncPoint = syncPoints[0].syncPoint;\r\n      var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\r\n      var bestStrategy = syncPoints[0].strategy;\r\n\r\n      for (var i = 1; i < syncPoints.length; i++) {\r\n        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\r\n\r\n        if (newDistance < bestDistance) {\r\n          bestDistance = newDistance;\r\n          bestSyncPoint = syncPoints[i].syncPoint;\r\n          bestStrategy = syncPoints[i].strategy;\r\n        }\r\n      }\r\n\r\n      this.logger_(\"syncPoint for [\" + target.key + \": \" + target.value + \"] chosen with strategy\" + (\" [\" + bestStrategy + \"]: [time:\" + bestSyncPoint.time + \",\") + (\" segmentIndex:\" + bestSyncPoint.segmentIndex) + (typeof bestSyncPoint.partIndex === 'number' ? \",partIndex:\" + bestSyncPoint.partIndex : '') + ']');\r\n      return bestSyncPoint;\r\n    }\r\n    /**\r\n     * Save any meta-data present on the segments when segments leave\r\n     * the live window to the playlist to allow for synchronization at the\r\n     * playlist level later.\r\n     *\r\n     * @param {Playlist} oldPlaylist - The previous active playlist\r\n     * @param {Playlist} newPlaylist - The updated and most current playlist\r\n     */\r\n    ;\r\n\r\n    _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\r\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence; // Ignore large media sequence gaps\r\n\r\n      if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {\r\n        videojs.log.warn(\"Not saving expired segment info. Media sequence gap \" + mediaSequenceDiff + \" is too large.\");\r\n        return;\r\n      } // When a segment expires from the playlist and it has a start time\r\n      // save that information as a possible sync-point reference in future\r\n\r\n\r\n      for (var i = mediaSequenceDiff - 1; i >= 0; i--) {\r\n        var lastRemovedSegment = oldPlaylist.segments[i];\r\n\r\n        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\r\n          newPlaylist.syncInfo = {\r\n            mediaSequence: oldPlaylist.mediaSequence + i,\r\n            time: lastRemovedSegment.start\r\n          };\r\n          this.logger_(\"playlist refresh sync: [time:\" + newPlaylist.syncInfo.time + \",\" + (\" mediaSequence: \" + newPlaylist.syncInfo.mediaSequence + \"]\"));\r\n          this.trigger('syncinfoupdate');\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Save the mapping from playlist's ProgramDateTime to display. This should only happen\r\n     * before segments start to load.\r\n     *\r\n     * @param {Playlist} playlist - The currently active playlist\r\n     */\r\n    ;\r\n\r\n    _proto.setDateTimeMappingForStart = function setDateTimeMappingForStart(playlist) {\r\n      // It's possible for the playlist to be updated before playback starts, meaning time\r\n      // zero is not yet set. If, during these playlist refreshes, a discontinuity is\r\n      // crossed, then the old time zero mapping (for the prior timeline) would be retained\r\n      // unless the mappings are cleared.\r\n      this.timelineToDatetimeMappings = {};\r\n\r\n      if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {\r\n        var firstSegment = playlist.segments[0];\r\n        var playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1000;\r\n        this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;\r\n      }\r\n    }\r\n    /**\r\n     * Calculates and saves timeline mappings, playlist sync info, and segment timing values\r\n     * based on the latest timing information.\r\n     *\r\n     * @param {Object} options\r\n     *        Options object\r\n     * @param {SegmentInfo} options.segmentInfo\r\n     *        The current active request information\r\n     * @param {boolean} options.shouldSaveTimelineMapping\r\n     *        If there's a timeline change, determines if the timeline mapping should be\r\n     *        saved for timeline mapping and program date time mappings.\r\n     */\r\n    ;\r\n\r\n    _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {\r\n      var segmentInfo = _ref.segmentInfo,\r\n          shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;\r\n      var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);\r\n      var segment = segmentInfo.segment;\r\n\r\n      if (didCalculateSegmentTimeMapping) {\r\n        this.saveDiscontinuitySyncInfo_(segmentInfo); // If the playlist does not have sync information yet, record that information\r\n        // now with segment timing information\r\n\r\n        if (!segmentInfo.playlist.syncInfo) {\r\n          segmentInfo.playlist.syncInfo = {\r\n            mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,\r\n            time: segment.start\r\n          };\r\n        }\r\n      }\r\n\r\n      var dateTime = segment.dateTimeObject;\r\n\r\n      if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {\r\n        this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1000);\r\n      }\r\n    };\r\n\r\n    _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {\r\n      if (typeof this.timelines[timeline] === 'undefined') {\r\n        return null;\r\n      }\r\n\r\n      return this.timelines[timeline].time;\r\n    };\r\n\r\n    _proto.mappingForTimeline = function mappingForTimeline(timeline) {\r\n      if (typeof this.timelines[timeline] === 'undefined') {\r\n        return null;\r\n      }\r\n\r\n      return this.timelines[timeline].mapping;\r\n    }\r\n    /**\r\n     * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\r\n     * save that display time to the segment.\r\n     *\r\n     * @private\r\n     * @param {SegmentInfo} segmentInfo\r\n     *        The current active request information\r\n     * @param {Object} timingInfo\r\n     *        The start and end time of the current segment in \"media time\"\r\n     * @param {boolean} shouldSaveTimelineMapping\r\n     *        If there's a timeline change, determines if the timeline mapping should be\r\n     *        saved in timelines.\r\n     * @return {boolean}\r\n     *          Returns false if segment time mapping could not be calculated\r\n     */\r\n    ;\r\n\r\n    _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {\r\n      // TODO: remove side effects\r\n      var segment = segmentInfo.segment;\r\n      var part = segmentInfo.part;\r\n      var mappingObj = this.timelines[segmentInfo.timeline];\r\n      var start;\r\n      var end;\r\n\r\n      if (typeof segmentInfo.timestampOffset === 'number') {\r\n        mappingObj = {\r\n          time: segmentInfo.startOfSegment,\r\n          mapping: segmentInfo.startOfSegment - timingInfo.start\r\n        };\r\n\r\n        if (shouldSaveTimelineMapping) {\r\n          this.timelines[segmentInfo.timeline] = mappingObj;\r\n          this.trigger('timestampoffset');\r\n          this.logger_(\"time mapping for timeline \" + segmentInfo.timeline + \": \" + (\"[time: \" + mappingObj.time + \"] [mapping: \" + mappingObj.mapping + \"]\"));\r\n        }\r\n\r\n        start = segmentInfo.startOfSegment;\r\n        end = timingInfo.end + mappingObj.mapping;\r\n      } else if (mappingObj) {\r\n        start = timingInfo.start + mappingObj.mapping;\r\n        end = timingInfo.end + mappingObj.mapping;\r\n      } else {\r\n        return false;\r\n      }\r\n\r\n      if (part) {\r\n        part.start = start;\r\n        part.end = end;\r\n      } // If we don't have a segment start yet or the start value we got\r\n      // is less than our current segment.start value, save a new start value.\r\n      // We have to do this because parts will have segment timing info saved\r\n      // multiple times and we want segment start to be the earliest part start\r\n      // value for that segment.\r\n\r\n\r\n      if (!segment.start || start < segment.start) {\r\n        segment.start = start;\r\n      }\r\n\r\n      segment.end = end;\r\n      return true;\r\n    }\r\n    /**\r\n     * Each time we have discontinuity in the playlist, attempt to calculate the location\r\n     * in display of the start of the discontinuity and save that. We also save an accuracy\r\n     * value so that we save values with the most accuracy (closest to 0.)\r\n     *\r\n     * @private\r\n     * @param {SegmentInfo} segmentInfo - The current active request information\r\n     */\r\n    ;\r\n\r\n    _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {\r\n      var playlist = segmentInfo.playlist;\r\n      var segment = segmentInfo.segment; // If the current segment is a discontinuity then we know exactly where\r\n      // the start of the range and it's accuracy is 0 (greater accuracy values\r\n      // mean more approximation)\r\n\r\n      if (segment.discontinuity) {\r\n        this.discontinuities[segment.timeline] = {\r\n          time: segment.start,\r\n          accuracy: 0\r\n        };\r\n      } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\r\n        // Search for future discontinuities that we can provide better timing\r\n        // information for and save that information for sync purposes\r\n        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\r\n          var segmentIndex = playlist.discontinuityStarts[i];\r\n          var discontinuity = playlist.discontinuitySequence + i + 1;\r\n          var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\r\n          var accuracy = Math.abs(mediaIndexDiff);\r\n\r\n          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\r\n            var time = void 0;\r\n\r\n            if (mediaIndexDiff < 0) {\r\n              time = segment.start - sumDurations({\r\n                defaultDuration: playlist.targetDuration,\r\n                durationList: playlist.segments,\r\n                startIndex: segmentInfo.mediaIndex,\r\n                endIndex: segmentIndex\r\n              });\r\n            } else {\r\n              time = segment.end + sumDurations({\r\n                defaultDuration: playlist.targetDuration,\r\n                durationList: playlist.segments,\r\n                startIndex: segmentInfo.mediaIndex + 1,\r\n                endIndex: segmentIndex\r\n              });\r\n            }\r\n\r\n            this.discontinuities[discontinuity] = {\r\n              time: time,\r\n              accuracy: accuracy\r\n            };\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.trigger('dispose');\r\n      this.off();\r\n    };\r\n\r\n    return SyncController;\r\n  }(videojs.EventTarget);\r\n  /**\r\n   * The TimelineChangeController acts as a source for segment loaders to listen for and\r\n   * keep track of latest and pending timeline changes. This is useful to ensure proper\r\n   * sync, as each loader may need to make a consideration for what timeline the other\r\n   * loader is on before making changes which could impact the other loader's media.\r\n   *\r\n   * @class TimelineChangeController\r\n   * @extends videojs.EventTarget\r\n   */\r\n\r\n\r\n  var TimelineChangeController = /*#__PURE__*/function (_videojs$EventTarget) {\r\n    inheritsLoose(TimelineChangeController, _videojs$EventTarget);\r\n\r\n    function TimelineChangeController() {\r\n      var _this;\r\n\r\n      _this = _videojs$EventTarget.call(this) || this;\r\n      _this.pendingTimelineChanges_ = {};\r\n      _this.lastTimelineChanges_ = {};\r\n      return _this;\r\n    }\r\n\r\n    var _proto = TimelineChangeController.prototype;\r\n\r\n    _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type) {\r\n      this.pendingTimelineChanges_[type] = null;\r\n      this.trigger('pendingtimelinechange');\r\n    };\r\n\r\n    _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {\r\n      var type = _ref.type,\r\n          from = _ref.from,\r\n          to = _ref.to;\r\n\r\n      if (typeof from === 'number' && typeof to === 'number') {\r\n        this.pendingTimelineChanges_[type] = {\r\n          type: type,\r\n          from: from,\r\n          to: to\r\n        };\r\n        this.trigger('pendingtimelinechange');\r\n      }\r\n\r\n      return this.pendingTimelineChanges_[type];\r\n    };\r\n\r\n    _proto.lastTimelineChange = function lastTimelineChange(_ref2) {\r\n      var type = _ref2.type,\r\n          from = _ref2.from,\r\n          to = _ref2.to;\r\n\r\n      if (typeof from === 'number' && typeof to === 'number') {\r\n        this.lastTimelineChanges_[type] = {\r\n          type: type,\r\n          from: from,\r\n          to: to\r\n        };\r\n        delete this.pendingTimelineChanges_[type];\r\n        this.trigger('timelinechange');\r\n      }\r\n\r\n      return this.lastTimelineChanges_[type];\r\n    };\r\n\r\n    _proto.dispose = function dispose() {\r\n      this.trigger('dispose');\r\n      this.pendingTimelineChanges_ = {};\r\n      this.lastTimelineChanges_ = {};\r\n      this.off();\r\n    };\r\n\r\n    return TimelineChangeController;\r\n  }(videojs.EventTarget);\r\n  /* rollup-plugin-worker-factory start for worker!/Users/abarstow/videojs/http-streaming/src/decrypter-worker.js */\r\n\r\n\r\n  var workerCode = transform(getWorkerString(function () {\r\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\r\n\r\n    function createCommonjsModule(fn, basedir, module) {\r\n      return module = {\r\n        path: basedir,\r\n        exports: {},\r\n        require: function require(path, base) {\r\n          return commonjsRequire(path, base === undefined || base === null ? module.path : base);\r\n        }\r\n      }, fn(module, module.exports), module.exports;\r\n    }\r\n\r\n    function commonjsRequire() {\r\n      throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\r\n    }\r\n\r\n    var createClass = createCommonjsModule(function (module) {\r\n      function _defineProperties(target, props) {\r\n        for (var i = 0; i < props.length; i++) {\r\n          var descriptor = props[i];\r\n          descriptor.enumerable = descriptor.enumerable || false;\r\n          descriptor.configurable = true;\r\n          if (\"value\" in descriptor) descriptor.writable = true;\r\n          Object.defineProperty(target, descriptor.key, descriptor);\r\n        }\r\n      }\r\n\r\n      function _createClass(Constructor, protoProps, staticProps) {\r\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n        if (staticProps) _defineProperties(Constructor, staticProps);\r\n        return Constructor;\r\n      }\r\n\r\n      module.exports = _createClass;\r\n      module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\r\n    });\r\n    var setPrototypeOf = createCommonjsModule(function (module) {\r\n      function _setPrototypeOf(o, p) {\r\n        module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\r\n          o.__proto__ = p;\r\n          return o;\r\n        };\r\n\r\n        module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\r\n        return _setPrototypeOf(o, p);\r\n      }\r\n\r\n      module.exports = _setPrototypeOf;\r\n      module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\r\n    });\r\n    var inheritsLoose = createCommonjsModule(function (module) {\r\n      function _inheritsLoose(subClass, superClass) {\r\n        subClass.prototype = Object.create(superClass.prototype);\r\n        subClass.prototype.constructor = subClass;\r\n        setPrototypeOf(subClass, superClass);\r\n      }\r\n\r\n      module.exports = _inheritsLoose;\r\n      module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\r\n    });\r\n    /**\r\n     * @file stream.js\r\n     */\r\n\r\n    /**\r\n     * A lightweight readable stream implemention that handles event dispatching.\r\n     *\r\n     * @class Stream\r\n     */\r\n\r\n    var Stream = /*#__PURE__*/function () {\r\n      function Stream() {\r\n        this.listeners = {};\r\n      }\r\n      /**\r\n       * Add a listener for a specified event type.\r\n       *\r\n       * @param {string} type the event name\r\n       * @param {Function} listener the callback to be invoked when an event of\r\n       * the specified type occurs\r\n       */\r\n\r\n\r\n      var _proto = Stream.prototype;\r\n\r\n      _proto.on = function on(type, listener) {\r\n        if (!this.listeners[type]) {\r\n          this.listeners[type] = [];\r\n        }\r\n\r\n        this.listeners[type].push(listener);\r\n      }\r\n      /**\r\n       * Remove a listener for a specified event type.\r\n       *\r\n       * @param {string} type the event name\r\n       * @param {Function} listener  a function previously registered for this\r\n       * type of event through `on`\r\n       * @return {boolean} if we could turn it off or not\r\n       */\r\n      ;\r\n\r\n      _proto.off = function off(type, listener) {\r\n        if (!this.listeners[type]) {\r\n          return false;\r\n        }\r\n\r\n        var index = this.listeners[type].indexOf(listener); // TODO: which is better?\r\n        // In Video.js we slice listener functions\r\n        // on trigger so that it does not mess up the order\r\n        // while we loop through.\r\n        //\r\n        // Here we slice on off so that the loop in trigger\r\n        // can continue using it's old reference to loop without\r\n        // messing up the order.\r\n\r\n        this.listeners[type] = this.listeners[type].slice(0);\r\n        this.listeners[type].splice(index, 1);\r\n        return index > -1;\r\n      }\r\n      /**\r\n       * Trigger an event of the specified type on this stream. Any additional\r\n       * arguments to this function are passed as parameters to event listeners.\r\n       *\r\n       * @param {string} type the event name\r\n       */\r\n      ;\r\n\r\n      _proto.trigger = function trigger(type) {\r\n        var callbacks = this.listeners[type];\r\n\r\n        if (!callbacks) {\r\n          return;\r\n        } // Slicing the arguments on every invocation of this method\r\n        // can add a significant amount of overhead. Avoid the\r\n        // intermediate object creation for the common case of a\r\n        // single callback argument\r\n\r\n\r\n        if (arguments.length === 2) {\r\n          var length = callbacks.length;\r\n\r\n          for (var i = 0; i < length; ++i) {\r\n            callbacks[i].call(this, arguments[1]);\r\n          }\r\n        } else {\r\n          var args = Array.prototype.slice.call(arguments, 1);\r\n          var _length = callbacks.length;\r\n\r\n          for (var _i = 0; _i < _length; ++_i) {\r\n            callbacks[_i].apply(this, args);\r\n          }\r\n        }\r\n      }\r\n      /**\r\n       * Destroys the stream and cleans up.\r\n       */\r\n      ;\r\n\r\n      _proto.dispose = function dispose() {\r\n        this.listeners = {};\r\n      }\r\n      /**\r\n       * Forwards all `data` events on this stream to the destination stream. The\r\n       * destination stream should provide a method `push` to receive the data\r\n       * events as they arrive.\r\n       *\r\n       * @param {Stream} destination the stream that will receive all `data` events\r\n       * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n       */\r\n      ;\r\n\r\n      _proto.pipe = function pipe(destination) {\r\n        this.on('data', function (data) {\r\n          destination.push(data);\r\n        });\r\n      };\r\n\r\n      return Stream;\r\n    }();\r\n    /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */\r\n\r\n    /**\r\n     * Returns the subarray of a Uint8Array without PKCS#7 padding.\r\n     *\r\n     * @param padded {Uint8Array} unencrypted bytes that have been padded\r\n     * @return {Uint8Array} the unpadded bytes\r\n     * @see http://tools.ietf.org/html/rfc5652\r\n     */\r\n\r\n\r\n    function unpad(padded) {\r\n      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\r\n    }\r\n    /*! @name aes-decrypter @version 3.1.3 @license Apache-2.0 */\r\n\r\n    /**\r\n     * @file aes.js\r\n     *\r\n     * This file contains an adaptation of the AES decryption algorithm\r\n     * from the Standford Javascript Cryptography Library. That work is\r\n     * covered by the following copyright and permissions notice:\r\n     *\r\n     * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\r\n     * All rights reserved.\r\n     *\r\n     * Redistribution and use in source and binary forms, with or without\r\n     * modification, are permitted provided that the following conditions are\r\n     * met:\r\n     *\r\n     * 1. Redistributions of source code must retain the above copyright\r\n     *    notice, this list of conditions and the following disclaimer.\r\n     *\r\n     * 2. Redistributions in binary form must reproduce the above\r\n     *    copyright notice, this list of conditions and the following\r\n     *    disclaimer in the documentation and/or other materials provided\r\n     *    with the distribution.\r\n     *\r\n     * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\r\n     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n     * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\r\n     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\r\n     * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\r\n     * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n     *\r\n     * The views and conclusions contained in the software and documentation\r\n     * are those of the authors and should not be interpreted as representing\r\n     * official policies, either expressed or implied, of the authors.\r\n     */\r\n\r\n    /**\r\n     * Expand the S-box tables.\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var precompute = function precompute() {\r\n      var tables = [[[], [], [], [], []], [[], [], [], [], []]];\r\n      var encTable = tables[0];\r\n      var decTable = tables[1];\r\n      var sbox = encTable[4];\r\n      var sboxInv = decTable[4];\r\n      var i;\r\n      var x;\r\n      var xInv;\r\n      var d = [];\r\n      var th = [];\r\n      var x2;\r\n      var x4;\r\n      var x8;\r\n      var s;\r\n      var tEnc;\r\n      var tDec; // Compute double and third tables\r\n\r\n      for (i = 0; i < 256; i++) {\r\n        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\r\n      }\r\n\r\n      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\r\n        // Compute sbox\r\n        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\r\n        s = s >> 8 ^ s & 255 ^ 99;\r\n        sbox[x] = s;\r\n        sboxInv[s] = x; // Compute MixColumns\r\n\r\n        x8 = d[x4 = d[x2 = d[x]]];\r\n        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\r\n        tEnc = d[s] * 0x101 ^ s * 0x1010100;\r\n\r\n        for (i = 0; i < 4; i++) {\r\n          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\r\n          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\r\n        }\r\n      } // Compactify. Considerable speedup on Firefox.\r\n\r\n\r\n      for (i = 0; i < 5; i++) {\r\n        encTable[i] = encTable[i].slice(0);\r\n        decTable[i] = decTable[i].slice(0);\r\n      }\r\n\r\n      return tables;\r\n    };\r\n\r\n    var aesTables = null;\r\n    /**\r\n     * Schedule out an AES key for both encryption and decryption. This\r\n     * is a low-level class. Use a cipher mode to do bulk encryption.\r\n     *\r\n     * @class AES\r\n     * @param key {Array} The key as an array of 4, 6 or 8 words.\r\n     */\r\n\r\n    var AES = /*#__PURE__*/function () {\r\n      function AES(key) {\r\n        /**\r\n        * The expanded S-box and inverse S-box tables. These will be computed\r\n        * on the client so that we don't have to send them down the wire.\r\n        *\r\n        * There are two tables, _tables[0] is for encryption and\r\n        * _tables[1] is for decryption.\r\n        *\r\n        * The first 4 sub-tables are the expanded S-box with MixColumns. The\r\n        * last (_tables[01][4]) is the S-box itself.\r\n        *\r\n        * @private\r\n        */\r\n        // if we have yet to precompute the S-box tables\r\n        // do so now\r\n        if (!aesTables) {\r\n          aesTables = precompute();\r\n        } // then make a copy of that object for use\r\n\r\n\r\n        this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\r\n        var i;\r\n        var j;\r\n        var tmp;\r\n        var sbox = this._tables[0][4];\r\n        var decTable = this._tables[1];\r\n        var keyLen = key.length;\r\n        var rcon = 1;\r\n\r\n        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\r\n          throw new Error('Invalid aes key size');\r\n        }\r\n\r\n        var encKey = key.slice(0);\r\n        var decKey = [];\r\n        this._key = [encKey, decKey]; // schedule encryption keys\r\n\r\n        for (i = keyLen; i < 4 * keyLen + 28; i++) {\r\n          tmp = encKey[i - 1]; // apply sbox\r\n\r\n          if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\r\n            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255]; // shift rows and add rcon\r\n\r\n            if (i % keyLen === 0) {\r\n              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\r\n              rcon = rcon << 1 ^ (rcon >> 7) * 283;\r\n            }\r\n          }\r\n\r\n          encKey[i] = encKey[i - keyLen] ^ tmp;\r\n        } // schedule decryption keys\r\n\r\n\r\n        for (j = 0; i; j++, i--) {\r\n          tmp = encKey[j & 3 ? i : i - 4];\r\n\r\n          if (i <= 4 || j < 4) {\r\n            decKey[j] = tmp;\r\n          } else {\r\n            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\r\n          }\r\n        }\r\n      }\r\n      /**\r\n       * Decrypt 16 bytes, specified as four 32-bit words.\r\n       *\r\n       * @param {number} encrypted0 the first word to decrypt\r\n       * @param {number} encrypted1 the second word to decrypt\r\n       * @param {number} encrypted2 the third word to decrypt\r\n       * @param {number} encrypted3 the fourth word to decrypt\r\n       * @param {Int32Array} out the array to write the decrypted words\r\n       * into\r\n       * @param {number} offset the offset into the output array to start\r\n       * writing results\r\n       * @return {Array} The plaintext.\r\n       */\r\n\r\n\r\n      var _proto = AES.prototype;\r\n\r\n      _proto.decrypt = function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\r\n        var key = this._key[1]; // state variables a,b,c,d are loaded with pre-whitened data\r\n\r\n        var a = encrypted0 ^ key[0];\r\n        var b = encrypted3 ^ key[1];\r\n        var c = encrypted2 ^ key[2];\r\n        var d = encrypted1 ^ key[3];\r\n        var a2;\r\n        var b2;\r\n        var c2; // key.length === 2 ?\r\n\r\n        var nInnerRounds = key.length / 4 - 2;\r\n        var i;\r\n        var kIndex = 4;\r\n        var table = this._tables[1]; // load up the tables\r\n\r\n        var table0 = table[0];\r\n        var table1 = table[1];\r\n        var table2 = table[2];\r\n        var table3 = table[3];\r\n        var sbox = table[4]; // Inner rounds. Cribbed from OpenSSL.\r\n\r\n        for (i = 0; i < nInnerRounds; i++) {\r\n          a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\r\n          b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\r\n          c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\r\n          d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\r\n          kIndex += 4;\r\n          a = a2;\r\n          b = b2;\r\n          c = c2;\r\n        } // Last round.\r\n\r\n\r\n        for (i = 0; i < 4; i++) {\r\n          out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\r\n          a2 = a;\r\n          a = b;\r\n          b = c;\r\n          c = d;\r\n          d = a2;\r\n        }\r\n      };\r\n\r\n      return AES;\r\n    }();\r\n    /**\r\n     * A wrapper around the Stream class to use setTimeout\r\n     * and run stream \"jobs\" Asynchronously\r\n     *\r\n     * @class AsyncStream\r\n     * @extends Stream\r\n     */\r\n\r\n\r\n    var AsyncStream = /*#__PURE__*/function (_Stream) {\r\n      inheritsLoose(AsyncStream, _Stream);\r\n\r\n      function AsyncStream() {\r\n        var _this;\r\n\r\n        _this = _Stream.call(this, Stream) || this;\r\n        _this.jobs = [];\r\n        _this.delay = 1;\r\n        _this.timeout_ = null;\r\n        return _this;\r\n      }\r\n      /**\r\n       * process an async job\r\n       *\r\n       * @private\r\n       */\r\n\r\n\r\n      var _proto = AsyncStream.prototype;\r\n\r\n      _proto.processJob_ = function processJob_() {\r\n        this.jobs.shift()();\r\n\r\n        if (this.jobs.length) {\r\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\r\n        } else {\r\n          this.timeout_ = null;\r\n        }\r\n      }\r\n      /**\r\n       * push a job into the stream\r\n       *\r\n       * @param {Function} job the job to push into the stream\r\n       */\r\n      ;\r\n\r\n      _proto.push = function push(job) {\r\n        this.jobs.push(job);\r\n\r\n        if (!this.timeout_) {\r\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\r\n        }\r\n      };\r\n\r\n      return AsyncStream;\r\n    }(Stream);\r\n    /**\r\n     * Convert network-order (big-endian) bytes into their little-endian\r\n     * representation.\r\n     */\r\n\r\n\r\n    var ntoh = function ntoh(word) {\r\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\r\n    };\r\n    /**\r\n     * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\r\n     *\r\n     * @param {Uint8Array} encrypted the encrypted bytes\r\n     * @param {Uint32Array} key the bytes of the decryption key\r\n     * @param {Uint32Array} initVector the initialization vector (IV) to\r\n     * use for the first round of CBC.\r\n     * @return {Uint8Array} the decrypted bytes\r\n     *\r\n     * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\r\n     * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\r\n     * @see https://tools.ietf.org/html/rfc2315\r\n     */\r\n\r\n\r\n    var decrypt = function decrypt(encrypted, key, initVector) {\r\n      // word-level access to the encrypted bytes\r\n      var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\r\n      var decipher = new AES(Array.prototype.slice.call(key)); // byte and word-level access for the decrypted output\r\n\r\n      var decrypted = new Uint8Array(encrypted.byteLength);\r\n      var decrypted32 = new Int32Array(decrypted.buffer); // temporary variables for working with the IV, encrypted, and\r\n      // decrypted data\r\n\r\n      var init0;\r\n      var init1;\r\n      var init2;\r\n      var init3;\r\n      var encrypted0;\r\n      var encrypted1;\r\n      var encrypted2;\r\n      var encrypted3; // iteration variable\r\n\r\n      var wordIx; // pull out the words of the IV to ensure we don't modify the\r\n      // passed-in reference and easier access\r\n\r\n      init0 = initVector[0];\r\n      init1 = initVector[1];\r\n      init2 = initVector[2];\r\n      init3 = initVector[3]; // decrypt four word sequences, applying cipher-block chaining (CBC)\r\n      // to each decrypted block\r\n\r\n      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\r\n        // convert big-endian (network order) words into little-endian\r\n        // (javascript order)\r\n        encrypted0 = ntoh(encrypted32[wordIx]);\r\n        encrypted1 = ntoh(encrypted32[wordIx + 1]);\r\n        encrypted2 = ntoh(encrypted32[wordIx + 2]);\r\n        encrypted3 = ntoh(encrypted32[wordIx + 3]); // decrypt the block\r\n\r\n        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx); // XOR with the IV, and restore network byte-order to obtain the\r\n        // plaintext\r\n\r\n        decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\r\n        decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\r\n        decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\r\n        decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3); // setup the IV for the next round\r\n\r\n        init0 = encrypted0;\r\n        init1 = encrypted1;\r\n        init2 = encrypted2;\r\n        init3 = encrypted3;\r\n      }\r\n\r\n      return decrypted;\r\n    };\r\n    /**\r\n     * The `Decrypter` class that manages decryption of AES\r\n     * data through `AsyncStream` objects and the `decrypt`\r\n     * function\r\n     *\r\n     * @param {Uint8Array} encrypted the encrypted bytes\r\n     * @param {Uint32Array} key the bytes of the decryption key\r\n     * @param {Uint32Array} initVector the initialization vector (IV) to\r\n     * @param {Function} done the function to run when done\r\n     * @class Decrypter\r\n     */\r\n\r\n\r\n    var Decrypter = /*#__PURE__*/function () {\r\n      function Decrypter(encrypted, key, initVector, done) {\r\n        var step = Decrypter.STEP;\r\n        var encrypted32 = new Int32Array(encrypted.buffer);\r\n        var decrypted = new Uint8Array(encrypted.byteLength);\r\n        var i = 0;\r\n        this.asyncStream_ = new AsyncStream(); // split up the encryption job and do the individual chunks asynchronously\r\n\r\n        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\r\n\r\n        for (i = step; i < encrypted32.length; i += step) {\r\n          initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\r\n          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\r\n        } // invoke the done() callback when everything is finished\r\n\r\n\r\n        this.asyncStream_.push(function () {\r\n          // remove pkcs#7 padding from the decrypted bytes\r\n          done(null, unpad(decrypted));\r\n        });\r\n      }\r\n      /**\r\n       * a getter for step the maximum number of bytes to process at one time\r\n       *\r\n       * @return {number} the value of step 32000\r\n       */\r\n\r\n\r\n      var _proto = Decrypter.prototype;\r\n      /**\r\n       * @private\r\n       */\r\n\r\n      _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {\r\n        return function () {\r\n          var bytes = decrypt(encrypted, key, initVector);\r\n          decrypted.set(bytes, encrypted.byteOffset);\r\n        };\r\n      };\r\n\r\n      createClass(Decrypter, null, [{\r\n        key: \"STEP\",\r\n        get: function get() {\r\n          // 4 * 8000;\r\n          return 32000;\r\n        }\r\n      }]);\r\n      return Decrypter;\r\n    }();\r\n\r\n    var win;\r\n\r\n    if (typeof window !== \"undefined\") {\r\n      win = window;\r\n    } else if (typeof commonjsGlobal !== \"undefined\") {\r\n      win = commonjsGlobal;\r\n    } else if (typeof self !== \"undefined\") {\r\n      win = self;\r\n    } else {\r\n      win = {};\r\n    }\r\n\r\n    var window_1 = win;\r\n\r\n    var isArrayBufferView = function isArrayBufferView(obj) {\r\n      if (ArrayBuffer.isView === 'function') {\r\n        return ArrayBuffer.isView(obj);\r\n      }\r\n\r\n      return obj && obj.buffer instanceof ArrayBuffer;\r\n    };\r\n\r\n    var BigInt = window_1.BigInt || Number;\r\n    [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\r\n    /**\r\n     * Creates an object for sending to a web worker modifying properties that are TypedArrays\r\n     * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\r\n     *\r\n     * @param {Object} message\r\n     *        Object of properties and values to send to the web worker\r\n     * @return {Object}\r\n     *         Modified message with TypedArray values expanded\r\n     * @function createTransferableMessage\r\n     */\r\n\r\n\r\n    var createTransferableMessage = function createTransferableMessage(message) {\r\n      var transferable = {};\r\n      Object.keys(message).forEach(function (key) {\r\n        var value = message[key];\r\n\r\n        if (isArrayBufferView(value)) {\r\n          transferable[key] = {\r\n            bytes: value.buffer,\r\n            byteOffset: value.byteOffset,\r\n            byteLength: value.byteLength\r\n          };\r\n        } else {\r\n          transferable[key] = value;\r\n        }\r\n      });\r\n      return transferable;\r\n    };\r\n    /* global self */\r\n\r\n    /**\r\n     * Our web worker interface so that things can talk to aes-decrypter\r\n     * that will be running in a web worker. the scope is passed to this by\r\n     * webworkify.\r\n     */\r\n\r\n\r\n    self.onmessage = function (event) {\r\n      var data = event.data;\r\n      var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\r\n      var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\r\n      var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\r\n      /* eslint-disable no-new, handle-callback-err */\r\n\r\n      new Decrypter(encrypted, key, iv, function (err, bytes) {\r\n        self.postMessage(createTransferableMessage({\r\n          source: data.source,\r\n          decrypted: bytes\r\n        }), [bytes.buffer]);\r\n      });\r\n      /* eslint-enable */\r\n    };\r\n  }));\r\n  var Decrypter = factory(workerCode);\r\n  /* rollup-plugin-worker-factory end for worker!/Users/abarstow/videojs/http-streaming/src/decrypter-worker.js */\r\n\r\n  /**\r\n   * Convert the properties of an HLS track into an audioTrackKind.\r\n   *\r\n   * @private\r\n   */\r\n\r\n  var audioTrackKind_ = function audioTrackKind_(properties) {\r\n    var kind = properties[\"default\"] ? 'main' : 'alternative';\r\n\r\n    if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\r\n      kind = 'main-desc';\r\n    }\r\n\r\n    return kind;\r\n  };\r\n  /**\r\n   * Pause provided segment loader and playlist loader if active\r\n   *\r\n   * @param {SegmentLoader} segmentLoader\r\n   *        SegmentLoader to pause\r\n   * @param {Object} mediaType\r\n   *        Active media type\r\n   * @function stopLoaders\r\n   */\r\n\r\n\r\n  var stopLoaders = function stopLoaders(segmentLoader, mediaType) {\r\n    segmentLoader.abort();\r\n    segmentLoader.pause();\r\n\r\n    if (mediaType && mediaType.activePlaylistLoader) {\r\n      mediaType.activePlaylistLoader.pause();\r\n      mediaType.activePlaylistLoader = null;\r\n    }\r\n  };\r\n  /**\r\n   * Start loading provided segment loader and playlist loader\r\n   *\r\n   * @param {PlaylistLoader} playlistLoader\r\n   *        PlaylistLoader to start loading\r\n   * @param {Object} mediaType\r\n   *        Active media type\r\n   * @function startLoaders\r\n   */\r\n\r\n\r\n  var startLoaders = function startLoaders(playlistLoader, mediaType) {\r\n    // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\r\n    // playlist loader\r\n    mediaType.activePlaylistLoader = playlistLoader;\r\n    playlistLoader.load();\r\n  };\r\n  /**\r\n   * Returns a function to be called when the media group changes. It performs a\r\n   * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\r\n   * change of group is merely a rendition switch of the same content at another encoding,\r\n   * rather than a change of content, such as switching audio from English to Spanish.\r\n   *\r\n   * @param {string} type\r\n   *        MediaGroup type\r\n   * @param {Object} settings\r\n   *        Object containing required information for media groups\r\n   * @return {Function}\r\n   *         Handler for a non-destructive resync of SegmentLoader when the active media\r\n   *         group changes.\r\n   * @function onGroupChanged\r\n   */\r\n\r\n\r\n  var onGroupChanged = function onGroupChanged(type, settings) {\r\n    return function () {\r\n      var _settings$segmentLoad = settings.segmentLoaders,\r\n          segmentLoader = _settings$segmentLoad[type],\r\n          mainSegmentLoader = _settings$segmentLoad.main,\r\n          mediaType = settings.mediaTypes[type];\r\n      var activeTrack = mediaType.activeTrack();\r\n      var activeGroup = mediaType.getActiveGroup();\r\n      var previousActiveLoader = mediaType.activePlaylistLoader;\r\n      var lastGroup = mediaType.lastGroup_; // the group did not change do nothing\r\n\r\n      if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) {\r\n        return;\r\n      }\r\n\r\n      mediaType.lastGroup_ = activeGroup;\r\n      mediaType.lastTrack_ = activeTrack;\r\n      stopLoaders(segmentLoader, mediaType);\r\n\r\n      if (!activeGroup || activeGroup.isMasterPlaylist) {\r\n        // there is no group active or active group is a main playlist and won't change\r\n        return;\r\n      }\r\n\r\n      if (!activeGroup.playlistLoader) {\r\n        if (previousActiveLoader) {\r\n          // The previous group had a playlist loader but the new active group does not\r\n          // this means we are switching from demuxed to muxed audio. In this case we want to\r\n          // do a destructive reset of the main segment loader and not restart the audio\r\n          // loaders.\r\n          mainSegmentLoader.resetEverything();\r\n        }\r\n\r\n        return;\r\n      } // Non-destructive resync\r\n\r\n\r\n      segmentLoader.resyncLoader();\r\n      startLoaders(activeGroup.playlistLoader, mediaType);\r\n    };\r\n  };\r\n\r\n  var onGroupChanging = function onGroupChanging(type, settings) {\r\n    return function () {\r\n      var segmentLoader = settings.segmentLoaders[type],\r\n          mediaType = settings.mediaTypes[type];\r\n      mediaType.lastGroup_ = null;\r\n      segmentLoader.abort();\r\n      segmentLoader.pause();\r\n    };\r\n  };\r\n  /**\r\n   * Returns a function to be called when the media track changes. It performs a\r\n   * destructive reset of the SegmentLoader to ensure we start loading as close to\r\n   * currentTime as possible.\r\n   *\r\n   * @param {string} type\r\n   *        MediaGroup type\r\n   * @param {Object} settings\r\n   *        Object containing required information for media groups\r\n   * @return {Function}\r\n   *         Handler for a destructive reset of SegmentLoader when the active media\r\n   *         track changes.\r\n   * @function onTrackChanged\r\n   */\r\n\r\n\r\n  var onTrackChanged = function onTrackChanged(type, settings) {\r\n    return function () {\r\n      var masterPlaylistLoader = settings.masterPlaylistLoader,\r\n          _settings$segmentLoad2 = settings.segmentLoaders,\r\n          segmentLoader = _settings$segmentLoad2[type],\r\n          mainSegmentLoader = _settings$segmentLoad2.main,\r\n          mediaType = settings.mediaTypes[type];\r\n      var activeTrack = mediaType.activeTrack();\r\n      var activeGroup = mediaType.getActiveGroup();\r\n      var previousActiveLoader = mediaType.activePlaylistLoader;\r\n      var lastTrack = mediaType.lastTrack_; // track did not change, do nothing\r\n\r\n      if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) {\r\n        return;\r\n      }\r\n\r\n      mediaType.lastGroup_ = activeGroup;\r\n      mediaType.lastTrack_ = activeTrack;\r\n      stopLoaders(segmentLoader, mediaType);\r\n\r\n      if (!activeGroup) {\r\n        // there is no group active so we do not want to restart loaders\r\n        return;\r\n      }\r\n\r\n      if (activeGroup.isMasterPlaylist) {\r\n        // track did not change, do nothing\r\n        if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) {\r\n          return;\r\n        }\r\n\r\n        var mpc = settings.vhs.masterPlaylistController_;\r\n        var newPlaylist = mpc.selectPlaylist(); // media will not change do nothing\r\n\r\n        if (mpc.media() === newPlaylist) {\r\n          return;\r\n        }\r\n\r\n        mediaType.logger_(\"track change. Switching master audio from \" + lastTrack.id + \" to \" + activeTrack.id);\r\n        masterPlaylistLoader.pause();\r\n        mainSegmentLoader.resetEverything();\r\n        mpc.fastQualityChange_(newPlaylist);\r\n        return;\r\n      }\r\n\r\n      if (type === 'AUDIO') {\r\n        if (!activeGroup.playlistLoader) {\r\n          // when switching from demuxed audio/video to muxed audio/video (noted by no\r\n          // playlist loader for the audio group), we want to do a destructive reset of the\r\n          // main segment loader and not restart the audio loaders\r\n          mainSegmentLoader.setAudio(true); // don't have to worry about disabling the audio of the audio segment loader since\r\n          // it should be stopped\r\n\r\n          mainSegmentLoader.resetEverything();\r\n          return;\r\n        } // although the segment loader is an audio segment loader, call the setAudio\r\n        // function to ensure it is prepared to re-append the init segment (or handle other\r\n        // config changes)\r\n\r\n\r\n        segmentLoader.setAudio(true);\r\n        mainSegmentLoader.setAudio(false);\r\n      }\r\n\r\n      if (previousActiveLoader === activeGroup.playlistLoader) {\r\n        // Nothing has actually changed. This can happen because track change events can fire\r\n        // multiple times for a \"single\" change. One for enabling the new active track, and\r\n        // one for disabling the track that was active\r\n        startLoaders(activeGroup.playlistLoader, mediaType);\r\n        return;\r\n      }\r\n\r\n      if (segmentLoader.track) {\r\n        // For WebVTT, set the new text track in the segmentloader\r\n        segmentLoader.track(activeTrack);\r\n      } // destructive reset\r\n\r\n\r\n      segmentLoader.resetEverything();\r\n      startLoaders(activeGroup.playlistLoader, mediaType);\r\n    };\r\n  };\r\n\r\n  var onError = {\r\n    /**\r\n     * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\r\n     * an error.\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @return {Function}\r\n     *         Error handler. Logs warning (or error if the playlist is blacklisted) to\r\n     *         console and switches back to default audio track.\r\n     * @function onError.AUDIO\r\n     */\r\n    AUDIO: function AUDIO(type, settings) {\r\n      return function () {\r\n        var segmentLoader = settings.segmentLoaders[type],\r\n            mediaType = settings.mediaTypes[type],\r\n            blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;\r\n        stopLoaders(segmentLoader, mediaType); // switch back to default audio track\r\n\r\n        var activeTrack = mediaType.activeTrack();\r\n        var activeGroup = mediaType.activeGroup();\r\n        var id = (activeGroup.filter(function (group) {\r\n          return group[\"default\"];\r\n        })[0] || activeGroup[0]).id;\r\n        var defaultTrack = mediaType.tracks[id];\r\n\r\n        if (activeTrack === defaultTrack) {\r\n          // Default track encountered an error. All we can do now is blacklist the current\r\n          // rendition and hope another will switch audio groups\r\n          blacklistCurrentPlaylist({\r\n            message: 'Problem encountered loading the default audio track.'\r\n          });\r\n          return;\r\n        }\r\n\r\n        videojs.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\r\n\r\n        for (var trackId in mediaType.tracks) {\r\n          mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\r\n        }\r\n\r\n        mediaType.onTrackChanged();\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\r\n     * an error.\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @return {Function}\r\n     *         Error handler. Logs warning to console and disables the active subtitle track\r\n     * @function onError.SUBTITLES\r\n     */\r\n    SUBTITLES: function SUBTITLES(type, settings) {\r\n      return function () {\r\n        var segmentLoader = settings.segmentLoaders[type],\r\n            mediaType = settings.mediaTypes[type];\r\n        videojs.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\r\n        stopLoaders(segmentLoader, mediaType);\r\n        var track = mediaType.activeTrack();\r\n\r\n        if (track) {\r\n          track.mode = 'disabled';\r\n        }\r\n\r\n        mediaType.onTrackChanged();\r\n      };\r\n    }\r\n  };\r\n  var setupListeners = {\r\n    /**\r\n     * Setup event listeners for audio playlist loader\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {PlaylistLoader|null} playlistLoader\r\n     *        PlaylistLoader to register listeners on\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @function setupListeners.AUDIO\r\n     */\r\n    AUDIO: function AUDIO(type, playlistLoader, settings) {\r\n      if (!playlistLoader) {\r\n        // no playlist loader means audio will be muxed with the video\r\n        return;\r\n      }\r\n\r\n      var tech = settings.tech,\r\n          requestOptions = settings.requestOptions,\r\n          segmentLoader = settings.segmentLoaders[type];\r\n      playlistLoader.on('loadedmetadata', function () {\r\n        var media = playlistLoader.media();\r\n        segmentLoader.playlist(media, requestOptions); // if the video is already playing, or if this isn't a live video and preload\r\n        // permits, start downloading segments\r\n\r\n        if (!tech.paused() || media.endList && tech.preload() !== 'none') {\r\n          segmentLoader.load();\r\n        }\r\n      });\r\n      playlistLoader.on('loadedplaylist', function () {\r\n        segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\r\n\r\n        if (!tech.paused()) {\r\n          segmentLoader.load();\r\n        }\r\n      });\r\n      playlistLoader.on('error', onError[type](type, settings));\r\n    },\r\n\r\n    /**\r\n     * Setup event listeners for subtitle playlist loader\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {PlaylistLoader|null} playlistLoader\r\n     *        PlaylistLoader to register listeners on\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @function setupListeners.SUBTITLES\r\n     */\r\n    SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {\r\n      var tech = settings.tech,\r\n          requestOptions = settings.requestOptions,\r\n          segmentLoader = settings.segmentLoaders[type],\r\n          mediaType = settings.mediaTypes[type];\r\n      playlistLoader.on('loadedmetadata', function () {\r\n        var media = playlistLoader.media();\r\n        segmentLoader.playlist(media, requestOptions);\r\n        segmentLoader.track(mediaType.activeTrack()); // if the video is already playing, or if this isn't a live video and preload\r\n        // permits, start downloading segments\r\n\r\n        if (!tech.paused() || media.endList && tech.preload() !== 'none') {\r\n          segmentLoader.load();\r\n        }\r\n      });\r\n      playlistLoader.on('loadedplaylist', function () {\r\n        segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\r\n\r\n        if (!tech.paused()) {\r\n          segmentLoader.load();\r\n        }\r\n      });\r\n      playlistLoader.on('error', onError[type](type, settings));\r\n    }\r\n  };\r\n  var initialize = {\r\n    /**\r\n     * Setup PlaylistLoaders and AudioTracks for the audio groups\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @function initialize.AUDIO\r\n     */\r\n    'AUDIO': function AUDIO(type, settings) {\r\n      var vhs = settings.vhs,\r\n          sourceType = settings.sourceType,\r\n          segmentLoader = settings.segmentLoaders[type],\r\n          requestOptions = settings.requestOptions,\r\n          mediaGroups = settings.master.mediaGroups,\r\n          _settings$mediaTypes$ = settings.mediaTypes[type],\r\n          groups = _settings$mediaTypes$.groups,\r\n          tracks = _settings$mediaTypes$.tracks,\r\n          logger_ = _settings$mediaTypes$.logger_,\r\n          masterPlaylistLoader = settings.masterPlaylistLoader;\r\n      var audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master); // force a default if we have none\r\n\r\n      if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {\r\n        mediaGroups[type] = {\r\n          main: {\r\n            \"default\": {\r\n              \"default\": true\r\n            }\r\n          }\r\n        };\r\n\r\n        if (audioOnlyMaster) {\r\n          mediaGroups[type].main[\"default\"].playlists = masterPlaylistLoader.master.playlists;\r\n        }\r\n      }\r\n\r\n      for (var groupId in mediaGroups[type]) {\r\n        if (!groups[groupId]) {\r\n          groups[groupId] = [];\r\n        }\r\n\r\n        for (var variantLabel in mediaGroups[type][groupId]) {\r\n          var properties = mediaGroups[type][groupId][variantLabel];\r\n          var playlistLoader = void 0;\r\n\r\n          if (audioOnlyMaster) {\r\n            logger_(\"AUDIO group '\" + groupId + \"' label '\" + variantLabel + \"' is a master playlist\");\r\n            properties.isMasterPlaylist = true;\r\n            playlistLoader = null; // if vhs-json was provided as the source, and the media playlist was resolved,\r\n            // use the resolved media playlist object\r\n          } else if (sourceType === 'vhs-json' && properties.playlists) {\r\n            playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);\r\n          } else if (properties.resolvedUri) {\r\n            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions); // TODO: dash isn't the only type with properties.playlists\r\n            // should we even have properties.playlists in this check.\r\n          } else if (properties.playlists && sourceType === 'dash') {\r\n            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);\r\n          } else {\r\n            // no resolvedUri means the audio is muxed with the video when using this\r\n            // audio track\r\n            playlistLoader = null;\r\n          }\r\n\r\n          properties = videojs.mergeOptions({\r\n            id: variantLabel,\r\n            playlistLoader: playlistLoader\r\n          }, properties);\r\n          setupListeners[type](type, properties.playlistLoader, settings);\r\n          groups[groupId].push(properties);\r\n\r\n          if (typeof tracks[variantLabel] === 'undefined') {\r\n            var track = new videojs.AudioTrack({\r\n              id: variantLabel,\r\n              kind: audioTrackKind_(properties),\r\n              enabled: false,\r\n              language: properties.language,\r\n              \"default\": properties[\"default\"],\r\n              label: variantLabel\r\n            });\r\n            tracks[variantLabel] = track;\r\n          }\r\n        }\r\n      } // setup single error event handler for the segment loader\r\n\r\n\r\n      segmentLoader.on('error', onError[type](type, settings));\r\n    },\r\n\r\n    /**\r\n     * Setup PlaylistLoaders and TextTracks for the subtitle groups\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @function initialize.SUBTITLES\r\n     */\r\n    'SUBTITLES': function SUBTITLES(type, settings) {\r\n      var tech = settings.tech,\r\n          vhs = settings.vhs,\r\n          sourceType = settings.sourceType,\r\n          segmentLoader = settings.segmentLoaders[type],\r\n          requestOptions = settings.requestOptions,\r\n          mediaGroups = settings.master.mediaGroups,\r\n          _settings$mediaTypes$2 = settings.mediaTypes[type],\r\n          groups = _settings$mediaTypes$2.groups,\r\n          tracks = _settings$mediaTypes$2.tracks,\r\n          masterPlaylistLoader = settings.masterPlaylistLoader;\r\n\r\n      for (var groupId in mediaGroups[type]) {\r\n        if (!groups[groupId]) {\r\n          groups[groupId] = [];\r\n        }\r\n\r\n        for (var variantLabel in mediaGroups[type][groupId]) {\r\n          if (mediaGroups[type][groupId][variantLabel].forced) {\r\n            // Subtitle playlists with the forced attribute are not selectable in Safari.\r\n            // According to Apple's HLS Authoring Specification:\r\n            //   If content has forced subtitles and regular subtitles in a given language,\r\n            //   the regular subtitles track in that language MUST contain both the forced\r\n            //   subtitles and the regular subtitles for that language.\r\n            // Because of this requirement and that Safari does not add forced subtitles,\r\n            // forced subtitles are skipped here to maintain consistent experience across\r\n            // all platforms\r\n            continue;\r\n          }\r\n\r\n          var properties = mediaGroups[type][groupId][variantLabel];\r\n          var playlistLoader = void 0;\r\n\r\n          if (sourceType === 'hls') {\r\n            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);\r\n          } else if (sourceType === 'dash') {\r\n            var playlists = properties.playlists.filter(function (p) {\r\n              return p.excludeUntil !== Infinity;\r\n            });\r\n\r\n            if (!playlists.length) {\r\n              return;\r\n            }\r\n\r\n            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);\r\n          } else if (sourceType === 'vhs-json') {\r\n            playlistLoader = new PlaylistLoader( // if the vhs-json object included the media playlist, use the media playlist\r\n            // as provided, otherwise use the resolved URI to load the playlist\r\n            properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);\r\n          }\r\n\r\n          properties = videojs.mergeOptions({\r\n            id: variantLabel,\r\n            playlistLoader: playlistLoader\r\n          }, properties);\r\n          setupListeners[type](type, properties.playlistLoader, settings);\r\n          groups[groupId].push(properties);\r\n\r\n          if (typeof tracks[variantLabel] === 'undefined') {\r\n            var track = tech.addRemoteTextTrack({\r\n              id: variantLabel,\r\n              kind: 'subtitles',\r\n              \"default\": properties[\"default\"] && properties.autoselect,\r\n              language: properties.language,\r\n              label: variantLabel\r\n            }, false).track;\r\n            tracks[variantLabel] = track;\r\n          }\r\n        }\r\n      } // setup single error event handler for the segment loader\r\n\r\n\r\n      segmentLoader.on('error', onError[type](type, settings));\r\n    },\r\n\r\n    /**\r\n     * Setup TextTracks for the closed-caption groups\r\n     *\r\n     * @param {String} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @function initialize['CLOSED-CAPTIONS']\r\n     */\r\n    'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {\r\n      var tech = settings.tech,\r\n          mediaGroups = settings.master.mediaGroups,\r\n          _settings$mediaTypes$3 = settings.mediaTypes[type],\r\n          groups = _settings$mediaTypes$3.groups,\r\n          tracks = _settings$mediaTypes$3.tracks;\r\n\r\n      for (var groupId in mediaGroups[type]) {\r\n        if (!groups[groupId]) {\r\n          groups[groupId] = [];\r\n        }\r\n\r\n        for (var variantLabel in mediaGroups[type][groupId]) {\r\n          var properties = mediaGroups[type][groupId][variantLabel]; // Look for either 608 (CCn) or 708 (SERVICEn) caption services\r\n\r\n          if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {\r\n            continue;\r\n          }\r\n\r\n          var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\r\n          var newProps = {\r\n            label: variantLabel,\r\n            language: properties.language,\r\n            instreamId: properties.instreamId,\r\n            \"default\": properties[\"default\"] && properties.autoselect\r\n          };\r\n\r\n          if (captionServices[newProps.instreamId]) {\r\n            newProps = videojs.mergeOptions(newProps, captionServices[newProps.instreamId]);\r\n          }\r\n\r\n          if (newProps[\"default\"] === undefined) {\r\n            delete newProps[\"default\"];\r\n          } // No PlaylistLoader is required for Closed-Captions because the captions are\r\n          // embedded within the video stream\r\n\r\n\r\n          groups[groupId].push(videojs.mergeOptions({\r\n            id: variantLabel\r\n          }, properties));\r\n\r\n          if (typeof tracks[variantLabel] === 'undefined') {\r\n            var track = tech.addRemoteTextTrack({\r\n              id: newProps.instreamId,\r\n              kind: 'captions',\r\n              \"default\": newProps[\"default\"],\r\n              language: newProps.language,\r\n              label: newProps.label\r\n            }, false).track;\r\n            tracks[variantLabel] = track;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  var groupMatch = function groupMatch(list, media) {\r\n    for (var i = 0; i < list.length; i++) {\r\n      if (playlistMatch(media, list[i])) {\r\n        return true;\r\n      }\r\n\r\n      if (list[i].playlists && groupMatch(list[i].playlists, media)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n  /**\r\n   * Returns a function used to get the active group of the provided type\r\n   *\r\n   * @param {string} type\r\n   *        MediaGroup type\r\n   * @param {Object} settings\r\n   *        Object containing required information for media groups\r\n   * @return {Function}\r\n   *         Function that returns the active media group for the provided type. Takes an\r\n   *         optional parameter {TextTrack} track. If no track is provided, a list of all\r\n   *         variants in the group, otherwise the variant corresponding to the provided\r\n   *         track is returned.\r\n   * @function activeGroup\r\n   */\r\n\r\n\r\n  var activeGroup = function activeGroup(type, settings) {\r\n    return function (track) {\r\n      var masterPlaylistLoader = settings.masterPlaylistLoader,\r\n          groups = settings.mediaTypes[type].groups;\r\n      var media = masterPlaylistLoader.media();\r\n\r\n      if (!media) {\r\n        return null;\r\n      }\r\n\r\n      var variants = null; // set to variants to main media active group\r\n\r\n      if (media.attributes[type]) {\r\n        variants = groups[media.attributes[type]];\r\n      }\r\n\r\n      var groupKeys = Object.keys(groups);\r\n\r\n      if (!variants) {\r\n        // find the masterPlaylistLoader media\r\n        // that is in a media group if we are dealing\r\n        // with audio only\r\n        if (type === 'AUDIO' && groupKeys.length > 1 && isAudioOnly(settings.master)) {\r\n          for (var i = 0; i < groupKeys.length; i++) {\r\n            var groupPropertyList = groups[groupKeys[i]];\r\n\r\n            if (groupMatch(groupPropertyList, media)) {\r\n              variants = groupPropertyList;\r\n              break;\r\n            }\r\n          } // use the main group if it exists\r\n\r\n        } else if (groups.main) {\r\n          variants = groups.main; // only one group, use that one\r\n        } else if (groupKeys.length === 1) {\r\n          variants = groups[groupKeys[0]];\r\n        }\r\n      }\r\n\r\n      if (typeof track === 'undefined') {\r\n        return variants;\r\n      }\r\n\r\n      if (track === null || !variants) {\r\n        // An active track was specified so a corresponding group is expected. track === null\r\n        // means no track is currently active so there is no corresponding group\r\n        return null;\r\n      }\r\n\r\n      return variants.filter(function (props) {\r\n        return props.id === track.id;\r\n      })[0] || null;\r\n    };\r\n  };\r\n\r\n  var activeTrack = {\r\n    /**\r\n     * Returns a function used to get the active track of type provided\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @return {Function}\r\n     *         Function that returns the active media track for the provided type. Returns\r\n     *         null if no track is active\r\n     * @function activeTrack.AUDIO\r\n     */\r\n    AUDIO: function AUDIO(type, settings) {\r\n      return function () {\r\n        var tracks = settings.mediaTypes[type].tracks;\r\n\r\n        for (var id in tracks) {\r\n          if (tracks[id].enabled) {\r\n            return tracks[id];\r\n          }\r\n        }\r\n\r\n        return null;\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns a function used to get the active track of type provided\r\n     *\r\n     * @param {string} type\r\n     *        MediaGroup type\r\n     * @param {Object} settings\r\n     *        Object containing required information for media groups\r\n     * @return {Function}\r\n     *         Function that returns the active media track for the provided type. Returns\r\n     *         null if no track is active\r\n     * @function activeTrack.SUBTITLES\r\n     */\r\n    SUBTITLES: function SUBTITLES(type, settings) {\r\n      return function () {\r\n        var tracks = settings.mediaTypes[type].tracks;\r\n\r\n        for (var id in tracks) {\r\n          if (tracks[id].mode === 'showing' || tracks[id].mode === 'hidden') {\r\n            return tracks[id];\r\n          }\r\n        }\r\n\r\n        return null;\r\n      };\r\n    }\r\n  };\r\n\r\n  var getActiveGroup = function getActiveGroup(type, _ref) {\r\n    var mediaTypes = _ref.mediaTypes;\r\n    return function () {\r\n      var activeTrack_ = mediaTypes[type].activeTrack();\r\n\r\n      if (!activeTrack_) {\r\n        return null;\r\n      }\r\n\r\n      return mediaTypes[type].activeGroup(activeTrack_);\r\n    };\r\n  };\r\n  /**\r\n   * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\r\n   * Closed-Captions) specified in the master manifest.\r\n   *\r\n   * @param {Object} settings\r\n   *        Object containing required information for setting up the media groups\r\n   * @param {Tech} settings.tech\r\n   *        The tech of the player\r\n   * @param {Object} settings.requestOptions\r\n   *        XHR request options used by the segment loaders\r\n   * @param {PlaylistLoader} settings.masterPlaylistLoader\r\n   *        PlaylistLoader for the master source\r\n   * @param {VhsHandler} settings.vhs\r\n   *        VHS SourceHandler\r\n   * @param {Object} settings.master\r\n   *        The parsed master manifest\r\n   * @param {Object} settings.mediaTypes\r\n   *        Object to store the loaders, tracks, and utility methods for each media type\r\n   * @param {Function} settings.blacklistCurrentPlaylist\r\n   *        Blacklists the current rendition and forces a rendition switch.\r\n   * @function setupMediaGroups\r\n   */\r\n\r\n\r\n  var setupMediaGroups = function setupMediaGroups(settings) {\r\n    ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\r\n      initialize[type](type, settings);\r\n    });\r\n    var mediaTypes = settings.mediaTypes,\r\n        masterPlaylistLoader = settings.masterPlaylistLoader,\r\n        tech = settings.tech,\r\n        vhs = settings.vhs,\r\n        _settings$segmentLoad3 = settings.segmentLoaders,\r\n        audioSegmentLoader = _settings$segmentLoad3['AUDIO'],\r\n        mainSegmentLoader = _settings$segmentLoad3.main; // setup active group and track getters and change event handlers\r\n\r\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\r\n      mediaTypes[type].activeGroup = activeGroup(type, settings);\r\n      mediaTypes[type].activeTrack = activeTrack[type](type, settings);\r\n      mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\r\n      mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);\r\n      mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\r\n      mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);\r\n    }); // DO NOT enable the default subtitle or caption track.\r\n    // DO enable the default audio track\r\n\r\n    var audioGroup = mediaTypes.AUDIO.activeGroup();\r\n\r\n    if (audioGroup) {\r\n      var groupId = (audioGroup.filter(function (group) {\r\n        return group[\"default\"];\r\n      })[0] || audioGroup[0]).id;\r\n      mediaTypes.AUDIO.tracks[groupId].enabled = true;\r\n      mediaTypes.AUDIO.onGroupChanged();\r\n      mediaTypes.AUDIO.onTrackChanged();\r\n      var activeAudioGroup = mediaTypes.AUDIO.getActiveGroup(); // a similar check for handling setAudio on each loader is run again each time the\r\n      // track is changed, but needs to be handled here since the track may not be considered\r\n      // changed on the first call to onTrackChanged\r\n\r\n      if (!activeAudioGroup.playlistLoader) {\r\n        // either audio is muxed with video or the stream is audio only\r\n        mainSegmentLoader.setAudio(true);\r\n      } else {\r\n        // audio is demuxed\r\n        mainSegmentLoader.setAudio(false);\r\n        audioSegmentLoader.setAudio(true);\r\n      }\r\n    }\r\n\r\n    masterPlaylistLoader.on('mediachange', function () {\r\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\r\n        return mediaTypes[type].onGroupChanged();\r\n      });\r\n    });\r\n    masterPlaylistLoader.on('mediachanging', function () {\r\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\r\n        return mediaTypes[type].onGroupChanging();\r\n      });\r\n    }); // custom audio track change event handler for usage event\r\n\r\n    var onAudioTrackChanged = function onAudioTrackChanged() {\r\n      mediaTypes.AUDIO.onTrackChanged();\r\n      tech.trigger({\r\n        type: 'usage',\r\n        name: 'vhs-audio-change'\r\n      });\r\n      tech.trigger({\r\n        type: 'usage',\r\n        name: 'hls-audio-change'\r\n      });\r\n    };\r\n\r\n    tech.audioTracks().addEventListener('change', onAudioTrackChanged);\r\n    tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\r\n    vhs.on('dispose', function () {\r\n      tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\r\n      tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\r\n    }); // clear existing audio tracks and add the ones we just created\r\n\r\n    tech.clearTracks('audio');\r\n\r\n    for (var id in mediaTypes.AUDIO.tracks) {\r\n      tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\r\n    }\r\n  };\r\n  /**\r\n   * Creates skeleton object used to store the loaders, tracks, and utility methods for each\r\n   * media type\r\n   *\r\n   * @return {Object}\r\n   *         Object to store the loaders, tracks, and utility methods for each media type\r\n   * @function createMediaTypes\r\n   */\r\n\r\n\r\n  var createMediaTypes = function createMediaTypes() {\r\n    var mediaTypes = {};\r\n    ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\r\n      mediaTypes[type] = {\r\n        groups: {},\r\n        tracks: {},\r\n        activePlaylistLoader: null,\r\n        activeGroup: noop,\r\n        activeTrack: noop,\r\n        getActiveGroup: noop,\r\n        onGroupChanged: noop,\r\n        onTrackChanged: noop,\r\n        lastTrack_: null,\r\n        logger_: logger(\"MediaGroups[\" + type + \"]\")\r\n      };\r\n    });\r\n    return mediaTypes;\r\n  };\r\n\r\n  var ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;\r\n  var Vhs$1; // SegmentLoader stats that need to have each loader's\r\n  // values summed to calculate the final value\r\n\r\n  var loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred', 'mediaAppends'];\r\n\r\n  var sumLoaderStat = function sumLoaderStat(stat) {\r\n    return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\r\n  };\r\n\r\n  var shouldSwitchToMedia = function shouldSwitchToMedia(_ref) {\r\n    var currentPlaylist = _ref.currentPlaylist,\r\n        buffered = _ref.buffered,\r\n        currentTime = _ref.currentTime,\r\n        nextPlaylist = _ref.nextPlaylist,\r\n        bufferLowWaterLine = _ref.bufferLowWaterLine,\r\n        bufferHighWaterLine = _ref.bufferHighWaterLine,\r\n        duration = _ref.duration,\r\n        experimentalBufferBasedABR = _ref.experimentalBufferBasedABR,\r\n        log = _ref.log; // we have no other playlist to switch to\r\n\r\n    if (!nextPlaylist) {\r\n      videojs.log.warn('We received no playlist to switch to. Please check your stream.');\r\n      return false;\r\n    }\r\n\r\n    var sharedLogLine = \"allowing switch \" + (currentPlaylist && currentPlaylist.id || 'null') + \" -> \" + nextPlaylist.id;\r\n\r\n    if (!currentPlaylist) {\r\n      log(sharedLogLine + \" as current playlist is not set\");\r\n      return true;\r\n    } // no need to switch if playlist is the same\r\n\r\n\r\n    if (nextPlaylist.id === currentPlaylist.id) {\r\n      return false;\r\n    } // determine if current time is in a buffered range.\r\n\r\n\r\n    var isBuffered = Boolean(findRange(buffered, currentTime).length); // If the playlist is live, then we want to not take low water line into account.\r\n    // This is because in LIVE, the player plays 3 segments from the end of the\r\n    // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\r\n    // in those segments, a viewer will never experience a rendition upswitch.\r\n\r\n    if (!currentPlaylist.endList) {\r\n      // For LLHLS live streams, don't switch renditions before playback has started, as it almost\r\n      // doubles the time to first playback.\r\n      if (!isBuffered && typeof currentPlaylist.partTargetDuration === 'number') {\r\n        log(\"not \" + sharedLogLine + \" as current playlist is live llhls, but currentTime isn't in buffered.\");\r\n        return false;\r\n      }\r\n\r\n      log(sharedLogLine + \" as current playlist is live\");\r\n      return true;\r\n    }\r\n\r\n    var forwardBuffer = timeAheadOf(buffered, currentTime);\r\n    var maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE; // For the same reason as LIVE, we ignore the low water line when the VOD\r\n    // duration is below the max potential low water line\r\n\r\n    if (duration < maxBufferLowWaterLine) {\r\n      log(sharedLogLine + \" as duration < max low water line (\" + duration + \" < \" + maxBufferLowWaterLine + \")\");\r\n      return true;\r\n    }\r\n\r\n    var nextBandwidth = nextPlaylist.attributes.BANDWIDTH;\r\n    var currBandwidth = currentPlaylist.attributes.BANDWIDTH; // when switching down, if our buffer is lower than the high water line,\r\n    // we can switch down\r\n\r\n    if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {\r\n      var logLine = sharedLogLine + \" as next bandwidth < current bandwidth (\" + nextBandwidth + \" < \" + currBandwidth + \")\";\r\n\r\n      if (experimentalBufferBasedABR) {\r\n        logLine += \" and forwardBuffer < bufferHighWaterLine (\" + forwardBuffer + \" < \" + bufferHighWaterLine + \")\";\r\n      }\r\n\r\n      log(logLine);\r\n      return true;\r\n    } // and if our buffer is higher than the low water line,\r\n    // we can switch up\r\n\r\n\r\n    if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {\r\n      var _logLine = sharedLogLine + \" as forwardBuffer >= bufferLowWaterLine (\" + forwardBuffer + \" >= \" + bufferLowWaterLine + \")\";\r\n\r\n      if (experimentalBufferBasedABR) {\r\n        _logLine += \" and next bandwidth > current bandwidth (\" + nextBandwidth + \" > \" + currBandwidth + \")\";\r\n      }\r\n\r\n      log(_logLine);\r\n      return true;\r\n    }\r\n\r\n    log(\"not \" + sharedLogLine + \" as no switching criteria met\");\r\n    return false;\r\n  };\r\n  /**\r\n   * the master playlist controller controller all interactons\r\n   * between playlists and segmentloaders. At this time this mainly\r\n   * involves a master playlist and a series of audio playlists\r\n   * if they are available\r\n   *\r\n   * @class MasterPlaylistController\r\n   * @extends videojs.EventTarget\r\n   */\r\n\r\n\r\n  var MasterPlaylistController = /*#__PURE__*/function (_videojs$EventTarget) {\r\n    inheritsLoose(MasterPlaylistController, _videojs$EventTarget);\r\n\r\n    function MasterPlaylistController(options) {\r\n      var _this;\r\n\r\n      _this = _videojs$EventTarget.call(this) || this;\r\n      var src = options.src,\r\n          handleManifestRedirects = options.handleManifestRedirects,\r\n          withCredentials = options.withCredentials,\r\n          tech = options.tech,\r\n          bandwidth = options.bandwidth,\r\n          externVhs = options.externVhs,\r\n          useCueTags = options.useCueTags,\r\n          blacklistDuration = options.blacklistDuration,\r\n          enableLowInitialPlaylist = options.enableLowInitialPlaylist,\r\n          sourceType = options.sourceType,\r\n          cacheEncryptionKeys = options.cacheEncryptionKeys,\r\n          experimentalBufferBasedABR = options.experimentalBufferBasedABR,\r\n          experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector,\r\n          captionServices = options.captionServices;\r\n\r\n      if (!src) {\r\n        throw new Error('A non-empty playlist URL or JSON manifest string is required');\r\n      }\r\n\r\n      var maxPlaylistRetries = options.maxPlaylistRetries;\r\n\r\n      if (maxPlaylistRetries === null || typeof maxPlaylistRetries === 'undefined') {\r\n        maxPlaylistRetries = Infinity;\r\n      }\r\n\r\n      Vhs$1 = externVhs;\r\n      _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR);\r\n      _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector);\r\n      _this.withCredentials = withCredentials;\r\n      _this.tech_ = tech;\r\n      _this.vhs_ = tech.vhs;\r\n      _this.sourceType_ = sourceType;\r\n      _this.useCueTags_ = useCueTags;\r\n      _this.blacklistDuration = blacklistDuration;\r\n      _this.maxPlaylistRetries = maxPlaylistRetries;\r\n      _this.enableLowInitialPlaylist = enableLowInitialPlaylist;\r\n\r\n      if (_this.useCueTags_) {\r\n        _this.cueTagsTrack_ = _this.tech_.addTextTrack('metadata', 'ad-cues');\r\n        _this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\r\n      }\r\n\r\n      _this.requestOptions_ = {\r\n        withCredentials: withCredentials,\r\n        handleManifestRedirects: handleManifestRedirects,\r\n        maxPlaylistRetries: maxPlaylistRetries,\r\n        timeout: null\r\n      };\r\n\r\n      _this.on('error', _this.pauseLoading);\r\n\r\n      _this.mediaTypes_ = createMediaTypes();\r\n      _this.mediaSource = new window.MediaSource();\r\n      _this.handleDurationChange_ = _this.handleDurationChange_.bind(assertThisInitialized(_this));\r\n      _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(assertThisInitialized(_this));\r\n      _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(assertThisInitialized(_this));\r\n\r\n      _this.mediaSource.addEventListener('durationchange', _this.handleDurationChange_); // load the media source into the player\r\n\r\n\r\n      _this.mediaSource.addEventListener('sourceopen', _this.handleSourceOpen_);\r\n\r\n      _this.mediaSource.addEventListener('sourceended', _this.handleSourceEnded_); // we don't have to handle sourceclose since dispose will handle termination of\r\n      // everything, and the MediaSource should not be detached without a proper disposal\r\n\r\n\r\n      _this.seekable_ = videojs.createTimeRanges();\r\n      _this.hasPlayed_ = false;\r\n      _this.syncController_ = new SyncController(options);\r\n      _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\r\n        kind: 'metadata',\r\n        label: 'segment-metadata'\r\n      }, false).track;\r\n      _this.decrypter_ = new Decrypter();\r\n      _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);\r\n      _this.inbandTextTracks_ = {};\r\n      _this.timelineChangeController_ = new TimelineChangeController();\r\n      var segmentLoaderSettings = {\r\n        vhs: _this.vhs_,\r\n        parse708captions: options.parse708captions,\r\n        useDtsForTimestampOffset: options.useDtsForTimestampOffset,\r\n        captionServices: captionServices,\r\n        mediaSource: _this.mediaSource,\r\n        currentTime: _this.tech_.currentTime.bind(_this.tech_),\r\n        seekable: function seekable() {\r\n          return _this.seekable();\r\n        },\r\n        seeking: function seeking() {\r\n          return _this.tech_.seeking();\r\n        },\r\n        duration: function duration() {\r\n          return _this.duration();\r\n        },\r\n        hasPlayed: function hasPlayed() {\r\n          return _this.hasPlayed_;\r\n        },\r\n        goalBufferLength: function goalBufferLength() {\r\n          return _this.goalBufferLength();\r\n        },\r\n        bandwidth: bandwidth,\r\n        syncController: _this.syncController_,\r\n        decrypter: _this.decrypter_,\r\n        sourceType: _this.sourceType_,\r\n        inbandTextTracks: _this.inbandTextTracks_,\r\n        cacheEncryptionKeys: cacheEncryptionKeys,\r\n        sourceUpdater: _this.sourceUpdater_,\r\n        timelineChangeController: _this.timelineChangeController_,\r\n        experimentalExactManifestTimings: options.experimentalExactManifestTimings\r\n      }; // The source type check not only determines whether a special DASH playlist loader\r\n      // should be used, but also covers the case where the provided src is a vhs-json\r\n      // manifest object (instead of a URL). In the case of vhs-json, the default\r\n      // PlaylistLoader should be used.\r\n\r\n      _this.masterPlaylistLoader_ = _this.sourceType_ === 'dash' ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_);\r\n\r\n      _this.setupMasterPlaylistLoaderListeners_(); // setup segment loaders\r\n      // combined audio/video or just video when alternate audio track is selected\r\n\r\n\r\n      _this.mainSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {\r\n        segmentMetadataTrack: _this.segmentMetadataTrack_,\r\n        loaderType: 'main'\r\n      }), options); // alternate audio track\r\n\r\n      _this.audioSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {\r\n        loaderType: 'audio'\r\n      }), options);\r\n      _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {\r\n        loaderType: 'vtt',\r\n        featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks\r\n      }), options);\r\n\r\n      _this.setupSegmentLoaderListeners_();\r\n\r\n      if (_this.experimentalBufferBasedABR) {\r\n        _this.masterPlaylistLoader_.one('loadedplaylist', function () {\r\n          return _this.startABRTimer_();\r\n        });\r\n\r\n        _this.tech_.on('pause', function () {\r\n          return _this.stopABRTimer_();\r\n        });\r\n\r\n        _this.tech_.on('play', function () {\r\n          return _this.startABRTimer_();\r\n        });\r\n      } // Create SegmentLoader stat-getters\r\n      // mediaRequests_\r\n      // mediaRequestsAborted_\r\n      // mediaRequestsTimedout_\r\n      // mediaRequestsErrored_\r\n      // mediaTransferDuration_\r\n      // mediaBytesTransferred_\r\n      // mediaAppends_\r\n\r\n\r\n      loaderStats.forEach(function (stat) {\r\n        _this[stat + '_'] = sumLoaderStat.bind(assertThisInitialized(_this), stat);\r\n      });\r\n      _this.logger_ = logger('MPC');\r\n      _this.triggeredFmp4Usage = false;\r\n\r\n      if (_this.tech_.preload() === 'none') {\r\n        _this.loadOnPlay_ = function () {\r\n          _this.loadOnPlay_ = null;\r\n\r\n          _this.masterPlaylistLoader_.load();\r\n        };\r\n\r\n        _this.tech_.one('play', _this.loadOnPlay_);\r\n      } else {\r\n        _this.masterPlaylistLoader_.load();\r\n      }\r\n\r\n      _this.timeToLoadedData__ = -1;\r\n      _this.mainAppendsToLoadedData__ = -1;\r\n      _this.audioAppendsToLoadedData__ = -1;\r\n      var event = _this.tech_.preload() === 'none' ? 'play' : 'loadstart'; // start the first frame timer on loadstart or play (for preload none)\r\n\r\n      _this.tech_.one(event, function () {\r\n        var timeToLoadedDataStart = Date.now();\r\n\r\n        _this.tech_.one('loadeddata', function () {\r\n          _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;\r\n          _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends;\r\n          _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;\r\n        });\r\n      });\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = MasterPlaylistController.prototype;\r\n\r\n    _proto.mainAppendsToLoadedData_ = function mainAppendsToLoadedData_() {\r\n      return this.mainAppendsToLoadedData__;\r\n    };\r\n\r\n    _proto.audioAppendsToLoadedData_ = function audioAppendsToLoadedData_() {\r\n      return this.audioAppendsToLoadedData__;\r\n    };\r\n\r\n    _proto.appendsToLoadedData_ = function appendsToLoadedData_() {\r\n      var main = this.mainAppendsToLoadedData_();\r\n      var audio = this.audioAppendsToLoadedData_();\r\n\r\n      if (main === -1 || audio === -1) {\r\n        return -1;\r\n      }\r\n\r\n      return main + audio;\r\n    };\r\n\r\n    _proto.timeToLoadedData_ = function timeToLoadedData_() {\r\n      return this.timeToLoadedData__;\r\n    }\r\n    /**\r\n     * Run selectPlaylist and switch to the new playlist if we should\r\n     *\r\n     * @private\r\n     *\r\n     */\r\n    ;\r\n\r\n    _proto.checkABR_ = function checkABR_() {\r\n      var nextPlaylist = this.selectPlaylist();\r\n\r\n      if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {\r\n        this.switchMedia_(nextPlaylist, 'abr');\r\n      }\r\n    };\r\n\r\n    _proto.switchMedia_ = function switchMedia_(playlist, cause, delay) {\r\n      var oldMedia = this.media();\r\n      var oldId = oldMedia && (oldMedia.id || oldMedia.uri);\r\n      var newId = playlist.id || playlist.uri;\r\n\r\n      if (oldId && oldId !== newId) {\r\n        this.logger_(\"switch media \" + oldId + \" -> \" + newId + \" from \" + cause);\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: \"vhs-rendition-change-\" + cause\r\n        });\r\n      }\r\n\r\n      this.masterPlaylistLoader_.media(playlist, delay);\r\n    }\r\n    /**\r\n     * Start a timer that periodically calls checkABR_\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.startABRTimer_ = function startABRTimer_() {\r\n      var _this2 = this;\r\n\r\n      this.stopABRTimer_();\r\n      this.abrTimer_ = window.setInterval(function () {\r\n        return _this2.checkABR_();\r\n      }, 250);\r\n    }\r\n    /**\r\n     * Stop the timer that periodically calls checkABR_\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.stopABRTimer_ = function stopABRTimer_() {\r\n      // if we're scrubbing, we don't need to pause.\r\n      // This getter will be added to Video.js in version 7.11.\r\n      if (this.tech_.scrubbing && this.tech_.scrubbing()) {\r\n        return;\r\n      }\r\n\r\n      window.clearInterval(this.abrTimer_);\r\n      this.abrTimer_ = null;\r\n    }\r\n    /**\r\n     * Get a list of playlists for the currently selected audio playlist\r\n     *\r\n     * @return {Array} the array of audio playlists\r\n     */\r\n    ;\r\n\r\n    _proto.getAudioTrackPlaylists_ = function getAudioTrackPlaylists_() {\r\n      var master = this.master();\r\n      var defaultPlaylists = master && master.playlists || []; // if we don't have any audio groups then we can only\r\n      // assume that the audio tracks are contained in masters\r\n      // playlist array, use that or an empty array.\r\n\r\n      if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) {\r\n        return defaultPlaylists;\r\n      }\r\n\r\n      var AUDIO = master.mediaGroups.AUDIO;\r\n      var groupKeys = Object.keys(AUDIO);\r\n      var track; // get the current active track\r\n\r\n      if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {\r\n        track = this.mediaTypes_.AUDIO.activeTrack(); // or get the default track from master if mediaTypes_ isn't setup yet\r\n      } else {\r\n        // default group is `main` or just the first group.\r\n        var defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];\r\n\r\n        for (var label in defaultGroup) {\r\n          if (defaultGroup[label][\"default\"]) {\r\n            track = {\r\n              label: label\r\n            };\r\n            break;\r\n          }\r\n        }\r\n      } // no active track no playlists.\r\n\r\n\r\n      if (!track) {\r\n        return defaultPlaylists;\r\n      }\r\n\r\n      var playlists = []; // get all of the playlists that are possible for the\r\n      // active track.\r\n\r\n      for (var group in AUDIO) {\r\n        if (AUDIO[group][track.label]) {\r\n          var properties = AUDIO[group][track.label];\r\n\r\n          if (properties.playlists && properties.playlists.length) {\r\n            playlists.push.apply(playlists, properties.playlists);\r\n          } else if (properties.uri) {\r\n            playlists.push(properties);\r\n          } else if (master.playlists.length) {\r\n            // if an audio group does not have a uri\r\n            // see if we have main playlists that use it as a group.\r\n            // if we do then add those to the playlists list.\r\n            for (var i = 0; i < master.playlists.length; i++) {\r\n              var playlist = master.playlists[i];\r\n\r\n              if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {\r\n                playlists.push(playlist);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!playlists.length) {\r\n        return defaultPlaylists;\r\n      }\r\n\r\n      return playlists;\r\n    }\r\n    /**\r\n     * Register event handlers on the master playlist loader. A helper\r\n     * function for construction time.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {\r\n      var _this3 = this;\r\n\r\n      this.masterPlaylistLoader_.on('loadedmetadata', function () {\r\n        var media = _this3.masterPlaylistLoader_.media();\r\n\r\n        var requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\r\n        // timeout the request.\r\n\r\n        if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {\r\n          _this3.requestOptions_.timeout = 0;\r\n        } else {\r\n          _this3.requestOptions_.timeout = requestTimeout;\r\n        } // if this isn't a live video and preload permits, start\r\n        // downloading segments\r\n\r\n\r\n        if (media.endList && _this3.tech_.preload() !== 'none') {\r\n          _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);\r\n\r\n          _this3.mainSegmentLoader_.load();\r\n        }\r\n\r\n        setupMediaGroups({\r\n          sourceType: _this3.sourceType_,\r\n          segmentLoaders: {\r\n            AUDIO: _this3.audioSegmentLoader_,\r\n            SUBTITLES: _this3.subtitleSegmentLoader_,\r\n            main: _this3.mainSegmentLoader_\r\n          },\r\n          tech: _this3.tech_,\r\n          requestOptions: _this3.requestOptions_,\r\n          masterPlaylistLoader: _this3.masterPlaylistLoader_,\r\n          vhs: _this3.vhs_,\r\n          master: _this3.master(),\r\n          mediaTypes: _this3.mediaTypes_,\r\n          blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)\r\n        });\r\n\r\n        _this3.triggerPresenceUsage_(_this3.master(), media);\r\n\r\n        _this3.setupFirstPlay();\r\n\r\n        if (!_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media()) {\r\n          _this3.trigger('selectedinitialmedia');\r\n        } else {\r\n          // We must wait for the active audio playlist loader to\r\n          // finish setting up before triggering this event so the\r\n          // representations API and EME setup is correct\r\n          _this3.mediaTypes_.AUDIO.activePlaylistLoader.one('loadedmetadata', function () {\r\n            _this3.trigger('selectedinitialmedia');\r\n          });\r\n        }\r\n      });\r\n      this.masterPlaylistLoader_.on('loadedplaylist', function () {\r\n        if (_this3.loadOnPlay_) {\r\n          _this3.tech_.off('play', _this3.loadOnPlay_);\r\n        }\r\n\r\n        var updatedPlaylist = _this3.masterPlaylistLoader_.media();\r\n\r\n        if (!updatedPlaylist) {\r\n          // exclude any variants that are not supported by the browser before selecting\r\n          // an initial media as the playlist selectors do not consider browser support\r\n          _this3.excludeUnsupportedVariants_();\r\n\r\n          var selectedMedia;\r\n\r\n          if (_this3.enableLowInitialPlaylist) {\r\n            selectedMedia = _this3.selectInitialPlaylist();\r\n          }\r\n\r\n          if (!selectedMedia) {\r\n            selectedMedia = _this3.selectPlaylist();\r\n          }\r\n\r\n          if (!selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia)) {\r\n            return;\r\n          }\r\n\r\n          _this3.initialMedia_ = selectedMedia;\r\n\r\n          _this3.switchMedia_(_this3.initialMedia_, 'initial'); // Under the standard case where a source URL is provided, loadedplaylist will\r\n          // fire again since the playlist will be requested. In the case of vhs-json\r\n          // (where the manifest object is provided as the source), when the media\r\n          // playlist's `segments` list is already available, a media playlist won't be\r\n          // requested, and loadedplaylist won't fire again, so the playlist handler must be\r\n          // called on its own here.\r\n\r\n\r\n          var haveJsonSource = _this3.sourceType_ === 'vhs-json' && _this3.initialMedia_.segments;\r\n\r\n          if (!haveJsonSource) {\r\n            return;\r\n          }\r\n\r\n          updatedPlaylist = _this3.initialMedia_;\r\n        }\r\n\r\n        _this3.handleUpdatedMediaPlaylist(updatedPlaylist);\r\n      });\r\n      this.masterPlaylistLoader_.on('error', function () {\r\n        _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);\r\n      });\r\n      this.masterPlaylistLoader_.on('mediachanging', function () {\r\n        _this3.mainSegmentLoader_.abort();\r\n\r\n        _this3.mainSegmentLoader_.pause();\r\n      });\r\n      this.masterPlaylistLoader_.on('mediachange', function () {\r\n        var media = _this3.masterPlaylistLoader_.media();\r\n\r\n        var requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\r\n        // timeout the request.\r\n\r\n        if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {\r\n          _this3.requestOptions_.timeout = 0;\r\n        } else {\r\n          _this3.requestOptions_.timeout = requestTimeout;\r\n        } // TODO: Create a new event on the PlaylistLoader that signals\r\n        // that the segments have changed in some way and use that to\r\n        // update the SegmentLoader instead of doing it twice here and\r\n        // on `loadedplaylist`\r\n\r\n\r\n        _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);\r\n\r\n        _this3.mainSegmentLoader_.load();\r\n\r\n        _this3.tech_.trigger({\r\n          type: 'mediachange',\r\n          bubbles: true\r\n        });\r\n      });\r\n      this.masterPlaylistLoader_.on('playlistunchanged', function () {\r\n        var updatedPlaylist = _this3.masterPlaylistLoader_.media(); // ignore unchanged playlists that have already been\r\n        // excluded for not-changing. We likely just have a really slowly updating\r\n        // playlist.\r\n\r\n\r\n        if (updatedPlaylist.lastExcludeReason_ === 'playlist-unchanged') {\r\n          return;\r\n        }\r\n\r\n        var playlistOutdated = _this3.stuckAtPlaylistEnd_(updatedPlaylist);\r\n\r\n        if (playlistOutdated) {\r\n          // Playlist has stopped updating and we're stuck at its end. Try to\r\n          // blacklist it and switch to another playlist in the hope that that\r\n          // one is updating (and give the player a chance to re-adjust to the\r\n          // safe live point).\r\n          _this3.blacklistCurrentPlaylist({\r\n            message: 'Playlist no longer updating.',\r\n            reason: 'playlist-unchanged'\r\n          }); // useful for monitoring QoS\r\n\r\n\r\n          _this3.tech_.trigger('playliststuck');\r\n        }\r\n      });\r\n      this.masterPlaylistLoader_.on('renditiondisabled', function () {\r\n        _this3.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-rendition-disabled'\r\n        });\r\n\r\n        _this3.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-rendition-disabled'\r\n        });\r\n      });\r\n      this.masterPlaylistLoader_.on('renditionenabled', function () {\r\n        _this3.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-rendition-enabled'\r\n        });\r\n\r\n        _this3.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-rendition-enabled'\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Given an updated media playlist (whether it was loaded for the first time, or\r\n     * refreshed for live playlists), update any relevant properties and state to reflect\r\n     * changes in the media that should be accounted for (e.g., cues and duration).\r\n     *\r\n     * @param {Object} updatedPlaylist the updated media playlist object\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {\r\n      if (this.useCueTags_) {\r\n        this.updateAdCues_(updatedPlaylist);\r\n      } // TODO: Create a new event on the PlaylistLoader that signals\r\n      // that the segments have changed in some way and use that to\r\n      // update the SegmentLoader instead of doing it twice here and\r\n      // on `mediachange`\r\n\r\n\r\n      this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);\r\n      this.updateDuration(!updatedPlaylist.endList); // If the player isn't paused, ensure that the segment loader is running,\r\n      // as it is possible that it was temporarily stopped while waiting for\r\n      // a playlist (e.g., in case the playlist errored and we re-requested it).\r\n\r\n      if (!this.tech_.paused()) {\r\n        this.mainSegmentLoader_.load();\r\n\r\n        if (this.audioSegmentLoader_) {\r\n          this.audioSegmentLoader_.load();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * A helper function for triggerring presence usage events once per source\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {\r\n      var mediaGroups = master.mediaGroups || {};\r\n      var defaultDemuxed = true;\r\n      var audioGroupKeys = Object.keys(mediaGroups.AUDIO);\r\n\r\n      for (var mediaGroup in mediaGroups.AUDIO) {\r\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\r\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\r\n\r\n          if (!properties.uri) {\r\n            defaultDemuxed = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (defaultDemuxed) {\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-demuxed'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-demuxed'\r\n        });\r\n      }\r\n\r\n      if (Object.keys(mediaGroups.SUBTITLES).length) {\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-webvtt'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-webvtt'\r\n        });\r\n      }\r\n\r\n      if (Vhs$1.Playlist.isAes(media)) {\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-aes'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-aes'\r\n        });\r\n      }\r\n\r\n      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-alternate-audio'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-alternate-audio'\r\n        });\r\n      }\r\n\r\n      if (this.useCueTags_) {\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-playlist-cue-tags'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-playlist-cue-tags'\r\n        });\r\n      }\r\n    };\r\n\r\n    _proto.shouldSwitchToMedia_ = function shouldSwitchToMedia_(nextPlaylist) {\r\n      var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_;\r\n      var currentTime = this.tech_.currentTime();\r\n      var bufferLowWaterLine = this.bufferLowWaterLine();\r\n      var bufferHighWaterLine = this.bufferHighWaterLine();\r\n      var buffered = this.tech_.buffered();\r\n      return shouldSwitchToMedia({\r\n        buffered: buffered,\r\n        currentTime: currentTime,\r\n        currentPlaylist: currentPlaylist,\r\n        nextPlaylist: nextPlaylist,\r\n        bufferLowWaterLine: bufferLowWaterLine,\r\n        bufferHighWaterLine: bufferHighWaterLine,\r\n        duration: this.duration(),\r\n        experimentalBufferBasedABR: this.experimentalBufferBasedABR,\r\n        log: this.logger_\r\n      });\r\n    }\r\n    /**\r\n     * Register event handlers on the segment loaders. A helper function\r\n     * for construction time.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {\r\n      var _this4 = this;\r\n\r\n      if (!this.experimentalBufferBasedABR) {\r\n        this.mainSegmentLoader_.on('bandwidthupdate', function () {\r\n          var nextPlaylist = _this4.selectPlaylist();\r\n\r\n          if (_this4.shouldSwitchToMedia_(nextPlaylist)) {\r\n            _this4.switchMedia_(nextPlaylist, 'bandwidthupdate');\r\n          }\r\n\r\n          _this4.tech_.trigger('bandwidthupdate');\r\n        });\r\n        this.mainSegmentLoader_.on('progress', function () {\r\n          _this4.trigger('progress');\r\n        });\r\n      }\r\n\r\n      this.mainSegmentLoader_.on('error', function () {\r\n        _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());\r\n      });\r\n      this.mainSegmentLoader_.on('appenderror', function () {\r\n        _this4.error = _this4.mainSegmentLoader_.error_;\r\n\r\n        _this4.trigger('error');\r\n      });\r\n      this.mainSegmentLoader_.on('syncinfoupdate', function () {\r\n        _this4.onSyncInfoUpdate_();\r\n      });\r\n      this.mainSegmentLoader_.on('timestampoffset', function () {\r\n        _this4.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-timestamp-offset'\r\n        });\r\n\r\n        _this4.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-timestamp-offset'\r\n        });\r\n      });\r\n      this.audioSegmentLoader_.on('syncinfoupdate', function () {\r\n        _this4.onSyncInfoUpdate_();\r\n      });\r\n      this.audioSegmentLoader_.on('appenderror', function () {\r\n        _this4.error = _this4.audioSegmentLoader_.error_;\r\n\r\n        _this4.trigger('error');\r\n      });\r\n      this.mainSegmentLoader_.on('ended', function () {\r\n        _this4.logger_('main segment loader ended');\r\n\r\n        _this4.onEndOfStream();\r\n      });\r\n      this.mainSegmentLoader_.on('earlyabort', function (event) {\r\n        // never try to early abort with the new ABR algorithm\r\n        if (_this4.experimentalBufferBasedABR) {\r\n          return;\r\n        }\r\n\r\n        _this4.delegateLoaders_('all', ['abort']);\r\n\r\n        _this4.blacklistCurrentPlaylist({\r\n          message: 'Aborted early because there isn\\'t enough bandwidth to complete the ' + 'request without rebuffering.'\r\n        }, ABORT_EARLY_BLACKLIST_SECONDS);\r\n      });\r\n\r\n      var updateCodecs = function updateCodecs() {\r\n        if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) {\r\n          return _this4.tryToCreateSourceBuffers_();\r\n        }\r\n\r\n        var codecs = _this4.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\r\n\r\n\r\n        if (!codecs) {\r\n          return;\r\n        }\r\n\r\n        _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);\r\n      };\r\n\r\n      this.mainSegmentLoader_.on('trackinfo', updateCodecs);\r\n      this.audioSegmentLoader_.on('trackinfo', updateCodecs);\r\n      this.mainSegmentLoader_.on('fmp4', function () {\r\n        if (!_this4.triggeredFmp4Usage) {\r\n          _this4.tech_.trigger({\r\n            type: 'usage',\r\n            name: 'vhs-fmp4'\r\n          });\r\n\r\n          _this4.tech_.trigger({\r\n            type: 'usage',\r\n            name: 'hls-fmp4'\r\n          });\r\n\r\n          _this4.triggeredFmp4Usage = true;\r\n        }\r\n      });\r\n      this.audioSegmentLoader_.on('fmp4', function () {\r\n        if (!_this4.triggeredFmp4Usage) {\r\n          _this4.tech_.trigger({\r\n            type: 'usage',\r\n            name: 'vhs-fmp4'\r\n          });\r\n\r\n          _this4.tech_.trigger({\r\n            type: 'usage',\r\n            name: 'hls-fmp4'\r\n          });\r\n\r\n          _this4.triggeredFmp4Usage = true;\r\n        }\r\n      });\r\n      this.audioSegmentLoader_.on('ended', function () {\r\n        _this4.logger_('audioSegmentLoader ended');\r\n\r\n        _this4.onEndOfStream();\r\n      });\r\n    };\r\n\r\n    _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {\r\n      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\r\n    }\r\n    /**\r\n     * Call load on our SegmentLoaders\r\n     */\r\n    ;\r\n\r\n    _proto.load = function load() {\r\n      this.mainSegmentLoader_.load();\r\n\r\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\r\n        this.audioSegmentLoader_.load();\r\n      }\r\n\r\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\r\n        this.subtitleSegmentLoader_.load();\r\n      }\r\n    }\r\n    /**\r\n     * Re-tune playback quality level for the current player\r\n     * conditions without performing destructive actions, like\r\n     * removing already buffered content\r\n     *\r\n     * @private\r\n     * @deprecated\r\n     */\r\n    ;\r\n\r\n    _proto.smoothQualityChange_ = function smoothQualityChange_(media) {\r\n      if (media === void 0) {\r\n        media = this.selectPlaylist();\r\n      }\r\n\r\n      this.fastQualityChange_(media);\r\n    }\r\n    /**\r\n     * Re-tune playback quality level for the current player\r\n     * conditions. This method will perform destructive actions like removing\r\n     * already buffered content in order to readjust the currently active\r\n     * playlist quickly. This is good for manual quality changes\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.fastQualityChange_ = function fastQualityChange_(media) {\r\n      var _this5 = this;\r\n\r\n      if (media === void 0) {\r\n        media = this.selectPlaylist();\r\n      }\r\n\r\n      if (media === this.masterPlaylistLoader_.media()) {\r\n        this.logger_('skipping fastQualityChange because new media is same as old');\r\n        return;\r\n      }\r\n\r\n      this.switchMedia_(media, 'fast-quality'); // Delete all buffered data to allow an immediate quality switch, then seek to give\r\n      // the browser a kick to remove any cached frames from the previous rendtion (.04 seconds\r\n      // ahead is roughly the minimum that will accomplish this across a variety of content\r\n      // in IE and Edge, but seeking in place is sufficient on all other browsers)\r\n      // Edge/IE bug: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14600375/\r\n      // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=651904\r\n\r\n      this.mainSegmentLoader_.resetEverything(function () {\r\n        // Since this is not a typical seek, we avoid the seekTo method which can cause segments\r\n        // from the previously enabled rendition to load before the new playlist has finished loading\r\n        if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {\r\n          _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04);\r\n        } else {\r\n          _this5.tech_.setCurrentTime(_this5.tech_.currentTime());\r\n        }\r\n      }); // don't need to reset audio as it is reset when media changes\r\n    }\r\n    /**\r\n     * Begin playback.\r\n     */\r\n    ;\r\n\r\n    _proto.play = function play() {\r\n      if (this.setupFirstPlay()) {\r\n        return;\r\n      }\r\n\r\n      if (this.tech_.ended()) {\r\n        this.tech_.setCurrentTime(0);\r\n      }\r\n\r\n      if (this.hasPlayed_) {\r\n        this.load();\r\n      }\r\n\r\n      var seekable = this.tech_.seekable(); // if the viewer has paused and we fell out of the live window,\r\n      // seek forward to the live point\r\n\r\n      if (this.tech_.duration() === Infinity) {\r\n        if (this.tech_.currentTime() < seekable.start(0)) {\r\n          return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Seek to the latest media position if this is a live video and the\r\n     * player and video are loaded and initialized.\r\n     */\r\n    ;\r\n\r\n    _proto.setupFirstPlay = function setupFirstPlay() {\r\n      var _this6 = this;\r\n\r\n      var media = this.masterPlaylistLoader_.media(); // Check that everything is ready to begin buffering for the first call to play\r\n      //  If 1) there is no active media\r\n      //     2) the player is paused\r\n      //     3) the first play has already been setup\r\n      // then exit early\r\n\r\n      if (!media || this.tech_.paused() || this.hasPlayed_) {\r\n        return false;\r\n      } // when the video is a live stream\r\n\r\n\r\n      if (!media.endList) {\r\n        var seekable = this.seekable();\r\n\r\n        if (!seekable.length) {\r\n          // without a seekable range, the player cannot seek to begin buffering at the live\r\n          // point\r\n          return false;\r\n        }\r\n\r\n        if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {\r\n          // IE11 throws an InvalidStateError if you try to set currentTime while the\r\n          // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\r\n          this.tech_.one('loadedmetadata', function () {\r\n            _this6.trigger('firstplay');\r\n\r\n            _this6.tech_.setCurrentTime(seekable.end(0));\r\n\r\n            _this6.hasPlayed_ = true;\r\n          });\r\n          return false;\r\n        } // trigger firstplay to inform the source handler to ignore the next seek event\r\n\r\n\r\n        this.trigger('firstplay'); // seek to the live point\r\n\r\n        this.tech_.setCurrentTime(seekable.end(0));\r\n      }\r\n\r\n      this.hasPlayed_ = true; // we can begin loading now that everything is ready\r\n\r\n      this.load();\r\n      return true;\r\n    }\r\n    /**\r\n     * handle the sourceopen event on the MediaSource\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleSourceOpen_ = function handleSourceOpen_() {\r\n      // Only attempt to create the source buffer if none already exist.\r\n      // handleSourceOpen is also called when we are \"re-opening\" a source buffer\r\n      // after `endOfStream` has been called (in response to a seek for instance)\r\n      this.tryToCreateSourceBuffers_(); // if autoplay is enabled, begin playback. This is duplicative of\r\n      // code in video.js but is required because play() must be invoked\r\n      // *after* the media source has opened.\r\n\r\n      if (this.tech_.autoplay()) {\r\n        var playPromise = this.tech_.play(); // Catch/silence error when a pause interrupts a play request\r\n        // on browsers which return a promise\r\n\r\n        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\r\n          playPromise.then(null, function (e) {});\r\n        }\r\n      }\r\n\r\n      this.trigger('sourceopen');\r\n    }\r\n    /**\r\n     * handle the sourceended event on the MediaSource\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleSourceEnded_ = function handleSourceEnded_() {\r\n      if (!this.inbandTextTracks_.metadataTrack_) {\r\n        return;\r\n      }\r\n\r\n      var cues = this.inbandTextTracks_.metadataTrack_.cues;\r\n\r\n      if (!cues || !cues.length) {\r\n        return;\r\n      }\r\n\r\n      var duration = this.duration();\r\n      cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === Infinity ? Number.MAX_VALUE : duration;\r\n    }\r\n    /**\r\n     * handle the durationchange event on the MediaSource\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.handleDurationChange_ = function handleDurationChange_() {\r\n      this.tech_.trigger('durationchange');\r\n    }\r\n    /**\r\n     * Calls endOfStream on the media source when all active stream types have called\r\n     * endOfStream\r\n     *\r\n     * @param {string} streamType\r\n     *        Stream type of the segment loader that called endOfStream\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.onEndOfStream = function onEndOfStream() {\r\n      var isEndOfStream = this.mainSegmentLoader_.ended_;\r\n\r\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\r\n        var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_(); // if the audio playlist loader exists, then alternate audio is active\r\n\r\n        if (!mainMediaInfo || mainMediaInfo.hasVideo) {\r\n          // if we do not know if the main segment loader contains video yet or if we\r\n          // definitively know the main segment loader contains video, then we need to wait\r\n          // for both main and audio segment loaders to call endOfStream\r\n          isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\r\n        } else {\r\n          // otherwise just rely on the audio loader\r\n          isEndOfStream = this.audioSegmentLoader_.ended_;\r\n        }\r\n      }\r\n\r\n      if (!isEndOfStream) {\r\n        return;\r\n      }\r\n\r\n      this.stopABRTimer_();\r\n      this.sourceUpdater_.endOfStream();\r\n    }\r\n    /**\r\n     * Check if a playlist has stopped being updated\r\n     *\r\n     * @param {Object} playlist the media playlist object\r\n     * @return {boolean} whether the playlist has stopped being updated or not\r\n     */\r\n    ;\r\n\r\n    _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {\r\n      var seekable = this.seekable();\r\n\r\n      if (!seekable.length) {\r\n        // playlist doesn't have enough information to determine whether we are stuck\r\n        return false;\r\n      }\r\n\r\n      var expired = this.syncController_.getExpiredTime(playlist, this.duration());\r\n\r\n      if (expired === null) {\r\n        return false;\r\n      } // does not use the safe live end to calculate playlist end, since we\r\n      // don't want to say we are stuck while there is still content\r\n\r\n\r\n      var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);\r\n      var currentTime = this.tech_.currentTime();\r\n      var buffered = this.tech_.buffered();\r\n\r\n      if (!buffered.length) {\r\n        // return true if the playhead reached the absolute end of the playlist\r\n        return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;\r\n      }\r\n\r\n      var bufferedEnd = buffered.end(buffered.length - 1); // return true if there is too little buffer left and buffer has reached absolute\r\n      // end of playlist\r\n\r\n      return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;\r\n    }\r\n    /**\r\n     * Blacklists a playlist when an error occurs for a set amount of time\r\n     * making it unavailable for selection by the rendition selection algorithm\r\n     * and then forces a new playlist (rendition) selection.\r\n     *\r\n     * @param {Object=} error an optional error that may include the playlist\r\n     * to blacklist\r\n     * @param {number=} blacklistDuration an optional number of seconds to blacklist the\r\n     * playlist\r\n     */\r\n    ;\r\n\r\n    _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {\r\n      if (error === void 0) {\r\n        error = {};\r\n      } // If the `error` was generated by the playlist loader, it will contain\r\n      // the playlist we were trying to load (but failed) and that should be\r\n      // blacklisted instead of the currently selected playlist which is likely\r\n      // out-of-date in this scenario\r\n\r\n\r\n      var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\r\n      blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration; // If there is no current playlist, then an error occurred while we were\r\n      // trying to load the master OR while we were disposing of the tech\r\n\r\n      if (!currentPlaylist) {\r\n        this.error = error;\r\n\r\n        if (this.mediaSource.readyState !== 'open') {\r\n          this.trigger('error');\r\n        } else {\r\n          this.sourceUpdater_.endOfStream('network');\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      currentPlaylist.playlistErrors_++;\r\n      var playlists = this.masterPlaylistLoader_.master.playlists;\r\n      var enabledPlaylists = playlists.filter(isEnabled);\r\n      var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist; // Don't blacklist the only playlist unless it was blacklisted\r\n      // forever\r\n\r\n      if (playlists.length === 1 && blacklistDuration !== Infinity) {\r\n        videojs.log.warn(\"Problem encountered with playlist \" + currentPlaylist.id + \". \" + 'Trying again since it is the only playlist.');\r\n        this.tech_.trigger('retryplaylist'); // if this is a final rendition, we should delay\r\n\r\n        return this.masterPlaylistLoader_.load(isFinalRendition);\r\n      }\r\n\r\n      if (isFinalRendition) {\r\n        // Since we're on the final non-blacklisted playlist, and we're about to blacklist\r\n        // it, instead of erring the player or retrying this playlist, clear out the current\r\n        // blacklist. This allows other playlists to be attempted in case any have been\r\n        // fixed.\r\n        var reincluded = false;\r\n        playlists.forEach(function (playlist) {\r\n          // skip current playlist which is about to be blacklisted\r\n          if (playlist === currentPlaylist) {\r\n            return;\r\n          }\r\n\r\n          var excludeUntil = playlist.excludeUntil; // a playlist cannot be reincluded if it wasn't excluded to begin with.\r\n\r\n          if (typeof excludeUntil !== 'undefined' && excludeUntil !== Infinity) {\r\n            reincluded = true;\r\n            delete playlist.excludeUntil;\r\n          }\r\n        });\r\n\r\n        if (reincluded) {\r\n          videojs.log.warn('Removing other playlists from the exclusion list because the last ' + 'rendition is about to be excluded.'); // Technically we are retrying a playlist, in that we are simply retrying a previous\r\n          // playlist. This is needed for users relying on the retryplaylist event to catch a\r\n          // case where the player might be stuck and looping through \"dead\" playlists.\r\n\r\n          this.tech_.trigger('retryplaylist');\r\n        }\r\n      } // Blacklist this playlist\r\n\r\n\r\n      var excludeUntil;\r\n\r\n      if (currentPlaylist.playlistErrors_ > this.maxPlaylistRetries) {\r\n        excludeUntil = Infinity;\r\n      } else {\r\n        excludeUntil = Date.now() + blacklistDuration * 1000;\r\n      }\r\n\r\n      currentPlaylist.excludeUntil = excludeUntil;\r\n\r\n      if (error.reason) {\r\n        currentPlaylist.lastExcludeReason_ = error.reason;\r\n      }\r\n\r\n      this.tech_.trigger('blacklistplaylist');\r\n      this.tech_.trigger({\r\n        type: 'usage',\r\n        name: 'vhs-rendition-blacklisted'\r\n      });\r\n      this.tech_.trigger({\r\n        type: 'usage',\r\n        name: 'hls-rendition-blacklisted'\r\n      }); // TODO: should we select a new playlist if this blacklist wasn't for the currentPlaylist?\r\n      // Would be something like media().id !=== currentPlaylist.id and we  would need something\r\n      // like `pendingMedia` in playlist loaders to check against that too. This will prevent us\r\n      // from loading a new playlist on any blacklist.\r\n      // Select a new playlist\r\n\r\n      var nextPlaylist = this.selectPlaylist();\r\n\r\n      if (!nextPlaylist) {\r\n        this.error = 'Playback cannot continue. No available working or supported playlists.';\r\n        this.trigger('error');\r\n        return;\r\n      }\r\n\r\n      var logFn = error.internal ? this.logger_ : videojs.log.warn;\r\n      var errorMessage = error.message ? ' ' + error.message : '';\r\n      logFn((error.internal ? 'Internal problem' : 'Problem') + \" encountered with playlist \" + currentPlaylist.id + \".\" + (errorMessage + \" Switching to playlist \" + nextPlaylist.id + \".\")); // if audio group changed reset audio loaders\r\n\r\n      if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {\r\n        this.delegateLoaders_('audio', ['abort', 'pause']);\r\n      } // if subtitle group changed reset subtitle loaders\r\n\r\n\r\n      if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {\r\n        this.delegateLoaders_('subtitle', ['abort', 'pause']);\r\n      }\r\n\r\n      this.delegateLoaders_('main', ['abort', 'pause']);\r\n      var delayDuration = nextPlaylist.targetDuration / 2 * 1000 || 5 * 1000;\r\n      var shouldDelay = typeof nextPlaylist.lastRequest === 'number' && Date.now() - nextPlaylist.lastRequest <= delayDuration; // delay if it's a final rendition or if the last refresh is sooner than half targetDuration\r\n\r\n      return this.switchMedia_(nextPlaylist, 'exclude', isFinalRendition || shouldDelay);\r\n    }\r\n    /**\r\n     * Pause all segment/playlist loaders\r\n     */\r\n    ;\r\n\r\n    _proto.pauseLoading = function pauseLoading() {\r\n      this.delegateLoaders_('all', ['abort', 'pause']);\r\n      this.stopABRTimer_();\r\n    }\r\n    /**\r\n     * Call a set of functions in order on playlist loaders, segment loaders,\r\n     * or both types of loaders.\r\n     *\r\n     * @param {string} filter\r\n     *        Filter loaders that should call fnNames using a string. Can be:\r\n     *        * all - run on all loaders\r\n     *        * audio - run on all audio loaders\r\n     *        * subtitle - run on all subtitle loaders\r\n     *        * main - run on the main/master loaders\r\n     *\r\n     * @param {Array|string} fnNames\r\n     *        A string or array of function names to call.\r\n     */\r\n    ;\r\n\r\n    _proto.delegateLoaders_ = function delegateLoaders_(filter, fnNames) {\r\n      var _this7 = this;\r\n\r\n      var loaders = [];\r\n      var dontFilterPlaylist = filter === 'all';\r\n\r\n      if (dontFilterPlaylist || filter === 'main') {\r\n        loaders.push(this.masterPlaylistLoader_);\r\n      }\r\n\r\n      var mediaTypes = [];\r\n\r\n      if (dontFilterPlaylist || filter === 'audio') {\r\n        mediaTypes.push('AUDIO');\r\n      }\r\n\r\n      if (dontFilterPlaylist || filter === 'subtitle') {\r\n        mediaTypes.push('CLOSED-CAPTIONS');\r\n        mediaTypes.push('SUBTITLES');\r\n      }\r\n\r\n      mediaTypes.forEach(function (mediaType) {\r\n        var loader = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;\r\n\r\n        if (loader) {\r\n          loaders.push(loader);\r\n        }\r\n      });\r\n      ['main', 'audio', 'subtitle'].forEach(function (name) {\r\n        var loader = _this7[name + \"SegmentLoader_\"];\r\n\r\n        if (loader && (filter === name || filter === 'all')) {\r\n          loaders.push(loader);\r\n        }\r\n      });\r\n      loaders.forEach(function (loader) {\r\n        return fnNames.forEach(function (fnName) {\r\n          if (typeof loader[fnName] === 'function') {\r\n            loader[fnName]();\r\n          }\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * set the current time on all segment loaders\r\n     *\r\n     * @param {TimeRange} currentTime the current time to set\r\n     * @return {TimeRange} the current time\r\n     */\r\n    ;\r\n\r\n    _proto.setCurrentTime = function setCurrentTime(currentTime) {\r\n      var buffered = findRange(this.tech_.buffered(), currentTime);\r\n\r\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\r\n        // return immediately if the metadata is not ready yet\r\n        return 0;\r\n      } // it's clearly an edge-case but don't thrown an error if asked to\r\n      // seek within an empty playlist\r\n\r\n\r\n      if (!this.masterPlaylistLoader_.media().segments) {\r\n        return 0;\r\n      } // if the seek location is already buffered, continue buffering as usual\r\n\r\n\r\n      if (buffered && buffered.length) {\r\n        return currentTime;\r\n      } // cancel outstanding requests so we begin buffering at the new\r\n      // location\r\n\r\n\r\n      this.mainSegmentLoader_.resetEverything();\r\n      this.mainSegmentLoader_.abort();\r\n\r\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\r\n        this.audioSegmentLoader_.resetEverything();\r\n        this.audioSegmentLoader_.abort();\r\n      }\r\n\r\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\r\n        this.subtitleSegmentLoader_.resetEverything();\r\n        this.subtitleSegmentLoader_.abort();\r\n      } // start segment loader loading in case they are paused\r\n\r\n\r\n      this.load();\r\n    }\r\n    /**\r\n     * get the current duration\r\n     *\r\n     * @return {TimeRange} the duration\r\n     */\r\n    ;\r\n\r\n    _proto.duration = function duration() {\r\n      if (!this.masterPlaylistLoader_) {\r\n        return 0;\r\n      }\r\n\r\n      var media = this.masterPlaylistLoader_.media();\r\n\r\n      if (!media) {\r\n        // no playlists loaded yet, so can't determine a duration\r\n        return 0;\r\n      } // Don't rely on the media source for duration in the case of a live playlist since\r\n      // setting the native MediaSource's duration to infinity ends up with consequences to\r\n      // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\r\n      //\r\n      // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\r\n      // however, few browsers have support for setLiveSeekableRange()\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\r\n      //\r\n      // Until a time when the duration of the media source can be set to infinity, and a\r\n      // seekable range specified across browsers, just return Infinity.\r\n\r\n\r\n      if (!media.endList) {\r\n        return Infinity;\r\n      } // Since this is a VOD video, it is safe to rely on the media source's duration (if\r\n      // available). If it's not available, fall back to a playlist-calculated estimate.\r\n\r\n\r\n      if (this.mediaSource) {\r\n        return this.mediaSource.duration;\r\n      }\r\n\r\n      return Vhs$1.Playlist.duration(media);\r\n    }\r\n    /**\r\n     * check the seekable range\r\n     *\r\n     * @return {TimeRange} the seekable range\r\n     */\r\n    ;\r\n\r\n    _proto.seekable = function seekable() {\r\n      return this.seekable_;\r\n    };\r\n\r\n    _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {\r\n      var audioSeekable; // TODO check for creation of both source buffers before updating seekable\r\n      //\r\n      // A fix was made to this function where a check for\r\n      // this.sourceUpdater_.hasCreatedSourceBuffers\r\n      // was added to ensure that both source buffers were created before seekable was\r\n      // updated. However, it originally had a bug where it was checking for a true and\r\n      // returning early instead of checking for false. Setting it to check for false to\r\n      // return early though created other issues. A call to play() would check for seekable\r\n      // end without verifying that a seekable range was present. In addition, even checking\r\n      // for that didn't solve some issues, as handleFirstPlay is sometimes worked around\r\n      // due to a media update calling load on the segment loaders, skipping a seek to live,\r\n      // thereby starting live streams at the beginning of the stream rather than at the end.\r\n      //\r\n      // This conditional should be fixed to wait for the creation of two source buffers at\r\n      // the same time as the other sections of code are fixed to properly seek to live and\r\n      // not throw an error due to checking for a seekable end when no seekable range exists.\r\n      //\r\n      // For now, fall back to the older behavior, with the understanding that the seekable\r\n      // range may not be completely correct, leading to a suboptimal initial live point.\r\n\r\n      if (!this.masterPlaylistLoader_) {\r\n        return;\r\n      }\r\n\r\n      var media = this.masterPlaylistLoader_.media();\r\n\r\n      if (!media) {\r\n        return;\r\n      }\r\n\r\n      var expired = this.syncController_.getExpiredTime(media, this.duration());\r\n\r\n      if (expired === null) {\r\n        // not enough information to update seekable\r\n        return;\r\n      }\r\n\r\n      var master = this.masterPlaylistLoader_.master;\r\n      var mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));\r\n\r\n      if (mainSeekable.length === 0) {\r\n        return;\r\n      }\r\n\r\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\r\n        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\r\n        expired = this.syncController_.getExpiredTime(media, this.duration());\r\n\r\n        if (expired === null) {\r\n          return;\r\n        }\r\n\r\n        audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));\r\n\r\n        if (audioSeekable.length === 0) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      var oldEnd;\r\n      var oldStart;\r\n\r\n      if (this.seekable_ && this.seekable_.length) {\r\n        oldEnd = this.seekable_.end(0);\r\n        oldStart = this.seekable_.start(0);\r\n      }\r\n\r\n      if (!audioSeekable) {\r\n        // seekable has been calculated based on buffering video data so it\r\n        // can be returned directly\r\n        this.seekable_ = mainSeekable;\r\n      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\r\n        // seekables are pretty far off, rely on main\r\n        this.seekable_ = mainSeekable;\r\n      } else {\r\n        this.seekable_ = videojs.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\r\n      } // seekable is the same as last time\r\n\r\n\r\n      if (this.seekable_ && this.seekable_.length) {\r\n        if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      this.logger_(\"seekable updated [\" + printableRange(this.seekable_) + \"]\");\r\n      this.tech_.trigger('seekablechanged');\r\n    }\r\n    /**\r\n     * Update the player duration\r\n     */\r\n    ;\r\n\r\n    _proto.updateDuration = function updateDuration(isLive) {\r\n      if (this.updateDuration_) {\r\n        this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\r\n        this.updateDuration_ = null;\r\n      }\r\n\r\n      if (this.mediaSource.readyState !== 'open') {\r\n        this.updateDuration_ = this.updateDuration.bind(this, isLive);\r\n        this.mediaSource.addEventListener('sourceopen', this.updateDuration_);\r\n        return;\r\n      }\r\n\r\n      if (isLive) {\r\n        var seekable = this.seekable();\r\n\r\n        if (!seekable.length) {\r\n          return;\r\n        } // Even in the case of a live playlist, the native MediaSource's duration should not\r\n        // be set to Infinity (even though this would be expected for a live playlist), since\r\n        // setting the native MediaSource's duration to infinity ends up with consequences to\r\n        // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\r\n        //\r\n        // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\r\n        // however, few browsers have support for setLiveSeekableRange()\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\r\n        //\r\n        // Until a time when the duration of the media source can be set to infinity, and a\r\n        // seekable range specified across browsers, the duration should be greater than or\r\n        // equal to the last possible seekable value.\r\n        // MediaSource duration starts as NaN\r\n        // It is possible (and probable) that this case will never be reached for many\r\n        // sources, since the MediaSource reports duration as the highest value without\r\n        // accounting for timestamp offset. For example, if the timestamp offset is -100 and\r\n        // we buffered times 0 to 100 with real times of 100 to 200, even though current\r\n        // time will be between 0 and 100, the native media source may report the duration\r\n        // as 200. However, since we report duration separate from the media source (as\r\n        // Infinity), and as long as the native media source duration value is greater than\r\n        // our reported seekable range, seeks will work as expected. The large number as\r\n        // duration for live is actually a strategy used by some players to work around the\r\n        // issue of live seekable ranges cited above.\r\n\r\n\r\n        if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) {\r\n          this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      var buffered = this.tech_.buffered();\r\n      var duration = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());\r\n\r\n      if (buffered.length > 0) {\r\n        duration = Math.max(duration, buffered.end(buffered.length - 1));\r\n      }\r\n\r\n      if (this.mediaSource.duration !== duration) {\r\n        this.sourceUpdater_.setDuration(duration);\r\n      }\r\n    }\r\n    /**\r\n     * dispose of the MasterPlaylistController and everything\r\n     * that it controls\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      var _this8 = this;\r\n\r\n      this.trigger('dispose');\r\n      this.decrypter_.terminate();\r\n      this.masterPlaylistLoader_.dispose();\r\n      this.mainSegmentLoader_.dispose();\r\n\r\n      if (this.loadOnPlay_) {\r\n        this.tech_.off('play', this.loadOnPlay_);\r\n      }\r\n\r\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\r\n        var groups = _this8.mediaTypes_[type].groups;\r\n\r\n        for (var id in groups) {\r\n          groups[id].forEach(function (group) {\r\n            if (group.playlistLoader) {\r\n              group.playlistLoader.dispose();\r\n            }\r\n          });\r\n        }\r\n      });\r\n      this.audioSegmentLoader_.dispose();\r\n      this.subtitleSegmentLoader_.dispose();\r\n      this.sourceUpdater_.dispose();\r\n      this.timelineChangeController_.dispose();\r\n      this.stopABRTimer_();\r\n\r\n      if (this.updateDuration_) {\r\n        this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\r\n      }\r\n\r\n      this.mediaSource.removeEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\r\n\r\n      this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen_);\r\n      this.mediaSource.removeEventListener('sourceended', this.handleSourceEnded_);\r\n      this.off();\r\n    }\r\n    /**\r\n     * return the master playlist object if we have one\r\n     *\r\n     * @return {Object} the master playlist object that we parsed\r\n     */\r\n    ;\r\n\r\n    _proto.master = function master() {\r\n      return this.masterPlaylistLoader_.master;\r\n    }\r\n    /**\r\n     * return the currently selected playlist\r\n     *\r\n     * @return {Object} the currently selected playlist object that we parsed\r\n     */\r\n    ;\r\n\r\n    _proto.media = function media() {\r\n      // playlist loader will not return media if it has not been fully loaded\r\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\r\n    };\r\n\r\n    _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {\r\n      var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\r\n      var hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_(); // if we are not using an audio loader, then we have audio media info\r\n      // otherwise check on the segment loader.\r\n\r\n      var hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_(); // one or both loaders has not loaded sufficently to get codecs\r\n\r\n      if (!hasMainMediaInfo || !hasAudioMediaInfo) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    };\r\n\r\n    _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {\r\n      var _this9 = this;\r\n\r\n      var media = {\r\n        main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},\r\n        audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}\r\n      }; // set \"main\" media equal to video\r\n\r\n      media.video = media.main;\r\n      var playlistCodecs = codecsForPlaylist(this.master(), this.media());\r\n      var codecs = {};\r\n      var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\r\n\r\n      if (media.main.hasVideo) {\r\n        codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;\r\n      }\r\n\r\n      if (media.main.isMuxed) {\r\n        codecs.video += \",\" + (playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC);\r\n      }\r\n\r\n      if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {\r\n        codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC; // set audio isFmp4 so we use the correct \"supports\" function below\r\n\r\n        media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;\r\n      } // no codecs, no playback.\r\n\r\n\r\n      if (!codecs.audio && !codecs.video) {\r\n        this.blacklistCurrentPlaylist({\r\n          playlist: this.media(),\r\n          message: 'Could not determine codecs for playlist.',\r\n          blacklistDuration: Infinity\r\n        });\r\n        return;\r\n      } // fmp4 relies on browser support, while ts relies on muxer support\r\n\r\n\r\n      var supportFunction = function supportFunction(isFmp4, codec) {\r\n        return isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);\r\n      };\r\n\r\n      var unsupportedCodecs = {};\r\n      var unsupportedAudio;\r\n      ['video', 'audio'].forEach(function (type) {\r\n        if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {\r\n          var supporter = media[type].isFmp4 ? 'browser' : 'muxer';\r\n          unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];\r\n          unsupportedCodecs[supporter].push(codecs[type]);\r\n\r\n          if (type === 'audio') {\r\n            unsupportedAudio = supporter;\r\n          }\r\n        }\r\n      });\r\n\r\n      if (usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {\r\n        var audioGroup = this.media().attributes.AUDIO;\r\n        this.master().playlists.forEach(function (variant) {\r\n          var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;\r\n\r\n          if (variantAudioGroup === audioGroup && variant !== _this9.media()) {\r\n            variant.excludeUntil = Infinity;\r\n          }\r\n        });\r\n        this.logger_(\"excluding audio group \" + audioGroup + \" as \" + unsupportedAudio + \" does not support codec(s): \\\"\" + codecs.audio + \"\\\"\");\r\n      } // if we have any unsupported codecs blacklist this playlist.\r\n\r\n\r\n      if (Object.keys(unsupportedCodecs).length) {\r\n        var message = Object.keys(unsupportedCodecs).reduce(function (acc, supporter) {\r\n          if (acc) {\r\n            acc += ', ';\r\n          }\r\n\r\n          acc += supporter + \" does not support codec(s): \\\"\" + unsupportedCodecs[supporter].join(',') + \"\\\"\";\r\n          return acc;\r\n        }, '') + '.';\r\n        this.blacklistCurrentPlaylist({\r\n          playlist: this.media(),\r\n          internal: true,\r\n          message: message,\r\n          blacklistDuration: Infinity\r\n        });\r\n        return;\r\n      } // check if codec switching is happening\r\n\r\n\r\n      if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {\r\n        var switchMessages = [];\r\n        ['video', 'audio'].forEach(function (type) {\r\n          var newCodec = (parseCodecs(_this9.sourceUpdater_.codecs[type] || '')[0] || {}).type;\r\n          var oldCodec = (parseCodecs(codecs[type] || '')[0] || {}).type;\r\n\r\n          if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {\r\n            switchMessages.push(\"\\\"\" + _this9.sourceUpdater_.codecs[type] + \"\\\" -> \\\"\" + codecs[type] + \"\\\"\");\r\n          }\r\n        });\r\n\r\n        if (switchMessages.length) {\r\n          this.blacklistCurrentPlaylist({\r\n            playlist: this.media(),\r\n            message: \"Codec switching not supported: \" + switchMessages.join(', ') + \".\",\r\n            blacklistDuration: Infinity,\r\n            internal: true\r\n          });\r\n          return;\r\n        }\r\n      } // TODO: when using the muxer shouldn't we just return\r\n      // the codecs that the muxer outputs?\r\n\r\n\r\n      return codecs;\r\n    }\r\n    /**\r\n     * Create source buffers and exlude any incompatible renditions.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {\r\n      // media source is not ready yet or sourceBuffers are already\r\n      // created.\r\n      if (this.mediaSource.readyState !== 'open' || this.sourceUpdater_.hasCreatedSourceBuffers()) {\r\n        return;\r\n      }\r\n\r\n      if (!this.areMediaTypesKnown_()) {\r\n        return;\r\n      }\r\n\r\n      var codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\r\n\r\n      if (!codecs) {\r\n        return;\r\n      }\r\n\r\n      this.sourceUpdater_.createSourceBuffers(codecs);\r\n      var codecString = [codecs.video, codecs.audio].filter(Boolean).join(',');\r\n      this.excludeIncompatibleVariants_(codecString);\r\n    }\r\n    /**\r\n     * Excludes playlists with codecs that are unsupported by the muxer and browser.\r\n     */\r\n    ;\r\n\r\n    _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {\r\n      var _this10 = this;\r\n\r\n      var playlists = this.master().playlists;\r\n      var ids = []; // TODO: why don't we have a property to loop through all\r\n      // playlist? Why did we ever mix indexes and keys?\r\n\r\n      Object.keys(playlists).forEach(function (key) {\r\n        var variant = playlists[key]; // check if we already processed this playlist.\r\n\r\n        if (ids.indexOf(variant.id) !== -1) {\r\n          return;\r\n        }\r\n\r\n        ids.push(variant.id);\r\n        var codecs = codecsForPlaylist(_this10.master, variant);\r\n        var unsupported = [];\r\n\r\n        if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {\r\n          unsupported.push(\"audio codec \" + codecs.audio);\r\n        }\r\n\r\n        if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {\r\n          unsupported.push(\"video codec \" + codecs.video);\r\n        }\r\n\r\n        if (codecs.text && codecs.text === 'stpp.ttml.im1t') {\r\n          unsupported.push(\"text codec \" + codecs.text);\r\n        }\r\n\r\n        if (unsupported.length) {\r\n          variant.excludeUntil = Infinity;\r\n\r\n          _this10.logger_(\"excluding \" + variant.id + \" for unsupported: \" + unsupported.join(', '));\r\n        }\r\n      });\r\n    }\r\n    /**\r\n     * Blacklist playlists that are known to be codec or\r\n     * stream-incompatible with the SourceBuffer configuration. For\r\n     * instance, Media Source Extensions would cause the video element to\r\n     * stall waiting for video data if you switched from a variant with\r\n     * video and audio to an audio-only one.\r\n     *\r\n     * @param {Object} media a media playlist compatible with the current\r\n     * set of SourceBuffers. Variants in the current master playlist that\r\n     * do not appear to have compatible codec or stream configurations\r\n     * will be excluded from the default playlist selection algorithm\r\n     * indefinitely.\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {\r\n      var _this11 = this;\r\n\r\n      var ids = [];\r\n      var playlists = this.master().playlists;\r\n      var codecs = unwrapCodecList(parseCodecs(codecString));\r\n      var codecCount_ = codecCount(codecs);\r\n      var videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;\r\n      var audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;\r\n      Object.keys(playlists).forEach(function (key) {\r\n        var variant = playlists[key]; // check if we already processed this playlist.\r\n        // or it if it is already excluded forever.\r\n\r\n        if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {\r\n          return;\r\n        }\r\n\r\n        ids.push(variant.id);\r\n        var blacklistReasons = []; // get codecs from the playlist for this variant\r\n\r\n        var variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant);\r\n        var variantCodecCount = codecCount(variantCodecs); // if no codecs are listed, we cannot determine that this\r\n        // variant is incompatible. Wait for mux.js to probe\r\n\r\n        if (!variantCodecs.audio && !variantCodecs.video) {\r\n          return;\r\n        } // TODO: we can support this by removing the\r\n        // old media source and creating a new one, but it will take some work.\r\n        // The number of streams cannot change\r\n\r\n\r\n        if (variantCodecCount !== codecCount_) {\r\n          blacklistReasons.push(\"codec count \\\"\" + variantCodecCount + \"\\\" !== \\\"\" + codecCount_ + \"\\\"\");\r\n        } // only exclude playlists by codec change, if codecs cannot switch\r\n        // during playback.\r\n\r\n\r\n        if (!_this11.sourceUpdater_.canChangeType()) {\r\n          var variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;\r\n          var variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null; // the video codec cannot change\r\n\r\n          if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {\r\n            blacklistReasons.push(\"video codec \\\"\" + variantVideoDetails.type + \"\\\" !== \\\"\" + videoDetails.type + \"\\\"\");\r\n          } // the audio codec cannot change\r\n\r\n\r\n          if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {\r\n            blacklistReasons.push(\"audio codec \\\"\" + variantAudioDetails.type + \"\\\" !== \\\"\" + audioDetails.type + \"\\\"\");\r\n          }\r\n        }\r\n\r\n        if (blacklistReasons.length) {\r\n          variant.excludeUntil = Infinity;\r\n\r\n          _this11.logger_(\"blacklisting \" + variant.id + \": \" + blacklistReasons.join(' && '));\r\n        }\r\n      });\r\n    };\r\n\r\n    _proto.updateAdCues_ = function updateAdCues_(media) {\r\n      var offset = 0;\r\n      var seekable = this.seekable();\r\n\r\n      if (seekable.length) {\r\n        offset = seekable.start(0);\r\n      }\r\n\r\n      updateAdCues(media, this.cueTagsTrack_, offset);\r\n    }\r\n    /**\r\n     * Calculates the desired forward buffer length based on current time\r\n     *\r\n     * @return {number} Desired forward buffer length in seconds\r\n     */\r\n    ;\r\n\r\n    _proto.goalBufferLength = function goalBufferLength() {\r\n      var currentTime = this.tech_.currentTime();\r\n      var initial = Config.GOAL_BUFFER_LENGTH;\r\n      var rate = Config.GOAL_BUFFER_LENGTH_RATE;\r\n      var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);\r\n      return Math.min(initial + currentTime * rate, max);\r\n    }\r\n    /**\r\n     * Calculates the desired buffer low water line based on current time\r\n     *\r\n     * @return {number} Desired buffer low water line in seconds\r\n     */\r\n    ;\r\n\r\n    _proto.bufferLowWaterLine = function bufferLowWaterLine() {\r\n      var currentTime = this.tech_.currentTime();\r\n      var initial = Config.BUFFER_LOW_WATER_LINE;\r\n      var rate = Config.BUFFER_LOW_WATER_LINE_RATE;\r\n      var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);\r\n      var newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);\r\n      return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max);\r\n    };\r\n\r\n    _proto.bufferHighWaterLine = function bufferHighWaterLine() {\r\n      return Config.BUFFER_HIGH_WATER_LINE;\r\n    };\r\n\r\n    return MasterPlaylistController;\r\n  }(videojs.EventTarget);\r\n  /**\r\n   * Returns a function that acts as the Enable/disable playlist function.\r\n   *\r\n   * @param {PlaylistLoader} loader - The master playlist loader\r\n   * @param {string} playlistID - id of the playlist\r\n   * @param {Function} changePlaylistFn - A function to be called after a\r\n   * playlist's enabled-state has been changed. Will NOT be called if a\r\n   * playlist's enabled-state is unchanged\r\n   * @param {boolean=} enable - Value to set the playlist enabled-state to\r\n   * or if undefined returns the current enabled-state for the playlist\r\n   * @return {Function} Function for setting/getting enabled\r\n   */\r\n\r\n\r\n  var enableFunction = function enableFunction(loader, playlistID, changePlaylistFn) {\r\n    return function (enable) {\r\n      var playlist = loader.master.playlists[playlistID];\r\n      var incompatible = isIncompatible(playlist);\r\n      var currentlyEnabled = isEnabled(playlist);\r\n\r\n      if (typeof enable === 'undefined') {\r\n        return currentlyEnabled;\r\n      }\r\n\r\n      if (enable) {\r\n        delete playlist.disabled;\r\n      } else {\r\n        playlist.disabled = true;\r\n      }\r\n\r\n      if (enable !== currentlyEnabled && !incompatible) {\r\n        // Ensure the outside world knows about our changes\r\n        changePlaylistFn();\r\n\r\n        if (enable) {\r\n          loader.trigger('renditionenabled');\r\n        } else {\r\n          loader.trigger('renditiondisabled');\r\n        }\r\n      }\r\n\r\n      return enable;\r\n    };\r\n  };\r\n  /**\r\n   * The representation object encapsulates the publicly visible information\r\n   * in a media playlist along with a setter/getter-type function (enabled)\r\n   * for changing the enabled-state of a particular playlist entry\r\n   *\r\n   * @class Representation\r\n   */\r\n\r\n\r\n  var Representation = function Representation(vhsHandler, playlist, id) {\r\n    var mpc = vhsHandler.masterPlaylistController_,\r\n        smoothQualityChange = vhsHandler.options_.smoothQualityChange; // Get a reference to a bound version of the quality change function\r\n\r\n    var changeType = smoothQualityChange ? 'smooth' : 'fast';\r\n    var qualityChangeFunction = mpc[changeType + \"QualityChange_\"].bind(mpc); // some playlist attributes are optional\r\n\r\n    if (playlist.attributes) {\r\n      var resolution = playlist.attributes.RESOLUTION;\r\n      this.width = resolution && resolution.width;\r\n      this.height = resolution && resolution.height;\r\n      this.bandwidth = playlist.attributes.BANDWIDTH;\r\n    }\r\n\r\n    this.codecs = codecsForPlaylist(mpc.master(), playlist);\r\n    this.playlist = playlist; // The id is simply the ordinality of the media playlist\r\n    // within the master playlist\r\n\r\n    this.id = id; // Partially-apply the enableFunction to create a playlist-\r\n    // specific variant\r\n\r\n    this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);\r\n  };\r\n  /**\r\n   * A mixin function that adds the `representations` api to an instance\r\n   * of the VhsHandler class\r\n   *\r\n   * @param {VhsHandler} vhsHandler - An instance of VhsHandler to add the\r\n   * representation API into\r\n   */\r\n\r\n\r\n  var renditionSelectionMixin = function renditionSelectionMixin(vhsHandler) {\r\n    // Add a single API-specific function to the VhsHandler instance\r\n    vhsHandler.representations = function () {\r\n      var master = vhsHandler.masterPlaylistController_.master();\r\n      var playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;\r\n\r\n      if (!playlists) {\r\n        return [];\r\n      }\r\n\r\n      return playlists.filter(function (media) {\r\n        return !isIncompatible(media);\r\n      }).map(function (e, i) {\r\n        return new Representation(vhsHandler, e, e.id);\r\n      });\r\n    };\r\n  };\r\n  /**\r\n   * @file playback-watcher.js\r\n   *\r\n   * Playback starts, and now my watch begins. It shall not end until my death. I shall\r\n   * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\r\n   * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\r\n   * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\r\n   * my life and honor to the Playback Watch, for this Player and all the Players to come.\r\n   */\r\n\r\n\r\n  var timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\r\n  /**\r\n   * @class PlaybackWatcher\r\n   */\r\n\r\n  var PlaybackWatcher = /*#__PURE__*/function () {\r\n    /**\r\n     * Represents an PlaybackWatcher object.\r\n     *\r\n     * @class\r\n     * @param {Object} options an object that includes the tech and settings\r\n     */\r\n    function PlaybackWatcher(options) {\r\n      var _this = this;\r\n\r\n      this.masterPlaylistController_ = options.masterPlaylistController;\r\n      this.tech_ = options.tech;\r\n      this.seekable = options.seekable;\r\n      this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;\r\n      this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;\r\n      this.media = options.media;\r\n      this.consecutiveUpdates = 0;\r\n      this.lastRecordedTime = null;\r\n      this.timer_ = null;\r\n      this.checkCurrentTimeTimeout_ = null;\r\n      this.logger_ = logger('PlaybackWatcher');\r\n      this.logger_('initialize');\r\n\r\n      var playHandler = function playHandler() {\r\n        return _this.monitorCurrentTime_();\r\n      };\r\n\r\n      var canPlayHandler = function canPlayHandler() {\r\n        return _this.monitorCurrentTime_();\r\n      };\r\n\r\n      var waitingHandler = function waitingHandler() {\r\n        return _this.techWaiting_();\r\n      };\r\n\r\n      var cancelTimerHandler = function cancelTimerHandler() {\r\n        return _this.cancelTimer_();\r\n      };\r\n\r\n      var mpc = this.masterPlaylistController_;\r\n      var loaderTypes = ['main', 'subtitle', 'audio'];\r\n      var loaderChecks = {};\r\n      loaderTypes.forEach(function (type) {\r\n        loaderChecks[type] = {\r\n          reset: function reset() {\r\n            return _this.resetSegmentDownloads_(type);\r\n          },\r\n          updateend: function updateend() {\r\n            return _this.checkSegmentDownloads_(type);\r\n          }\r\n        };\r\n        mpc[type + \"SegmentLoader_\"].on('appendsdone', loaderChecks[type].updateend); // If a rendition switch happens during a playback stall where the buffer\r\n        // isn't changing we want to reset. We cannot assume that the new rendition\r\n        // will also be stalled, until after new appends.\r\n\r\n        mpc[type + \"SegmentLoader_\"].on('playlistupdate', loaderChecks[type].reset); // Playback stalls should not be detected right after seeking.\r\n        // This prevents one segment playlists (single vtt or single segment content)\r\n        // from being detected as stalling. As the buffer will not change in those cases, since\r\n        // the buffer is the entire video duration.\r\n\r\n        _this.tech_.on(['seeked', 'seeking'], loaderChecks[type].reset);\r\n      });\r\n      /**\r\n       * We check if a seek was into a gap through the following steps:\r\n       * 1. We get a seeking event and we do not get a seeked event. This means that\r\n       *    a seek was attempted but not completed.\r\n       * 2. We run `fixesBadSeeks_` on segment loader appends. This means that we already\r\n       *    removed everything from our buffer and appended a segment, and should be ready\r\n       *    to check for gaps.\r\n       */\r\n\r\n      var setSeekingHandlers = function setSeekingHandlers(fn) {\r\n        ['main', 'audio'].forEach(function (type) {\r\n          mpc[type + \"SegmentLoader_\"][fn]('appended', _this.seekingAppendCheck_);\r\n        });\r\n      };\r\n\r\n      this.seekingAppendCheck_ = function () {\r\n        if (_this.fixesBadSeeks_()) {\r\n          _this.consecutiveUpdates = 0;\r\n          _this.lastRecordedTime = _this.tech_.currentTime();\r\n          setSeekingHandlers('off');\r\n        }\r\n      };\r\n\r\n      this.clearSeekingAppendCheck_ = function () {\r\n        return setSeekingHandlers('off');\r\n      };\r\n\r\n      this.watchForBadSeeking_ = function () {\r\n        _this.clearSeekingAppendCheck_();\r\n\r\n        setSeekingHandlers('on');\r\n      };\r\n\r\n      this.tech_.on('seeked', this.clearSeekingAppendCheck_);\r\n      this.tech_.on('seeking', this.watchForBadSeeking_);\r\n      this.tech_.on('waiting', waitingHandler);\r\n      this.tech_.on(timerCancelEvents, cancelTimerHandler);\r\n      this.tech_.on('canplay', canPlayHandler);\r\n      /*\r\n        An edge case exists that results in gaps not being skipped when they exist at the beginning of a stream. This case\r\n        is surfaced in one of two ways:\r\n         1)  The `waiting` event is fired before the player has buffered content, making it impossible\r\n            to find or skip the gap. The `waiting` event is followed by a `play` event. On first play\r\n            we can check if playback is stalled due to a gap, and skip the gap if necessary.\r\n        2)  A source with a gap at the beginning of the stream is loaded programatically while the player\r\n            is in a playing state. To catch this case, it's important that our one-time play listener is setup\r\n            even if the player is in a playing state\r\n      */\r\n\r\n      this.tech_.one('play', playHandler); // Define the dispose function to clean up our events\r\n\r\n      this.dispose = function () {\r\n        _this.clearSeekingAppendCheck_();\r\n\r\n        _this.logger_('dispose');\r\n\r\n        _this.tech_.off('waiting', waitingHandler);\r\n\r\n        _this.tech_.off(timerCancelEvents, cancelTimerHandler);\r\n\r\n        _this.tech_.off('canplay', canPlayHandler);\r\n\r\n        _this.tech_.off('play', playHandler);\r\n\r\n        _this.tech_.off('seeking', _this.watchForBadSeeking_);\r\n\r\n        _this.tech_.off('seeked', _this.clearSeekingAppendCheck_);\r\n\r\n        loaderTypes.forEach(function (type) {\r\n          mpc[type + \"SegmentLoader_\"].off('appendsdone', loaderChecks[type].updateend);\r\n          mpc[type + \"SegmentLoader_\"].off('playlistupdate', loaderChecks[type].reset);\r\n\r\n          _this.tech_.off(['seeked', 'seeking'], loaderChecks[type].reset);\r\n        });\r\n\r\n        if (_this.checkCurrentTimeTimeout_) {\r\n          window.clearTimeout(_this.checkCurrentTimeTimeout_);\r\n        }\r\n\r\n        _this.cancelTimer_();\r\n      };\r\n    }\r\n    /**\r\n     * Periodically check current time to see if playback stopped\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var _proto = PlaybackWatcher.prototype;\r\n\r\n    _proto.monitorCurrentTime_ = function monitorCurrentTime_() {\r\n      this.checkCurrentTime_();\r\n\r\n      if (this.checkCurrentTimeTimeout_) {\r\n        window.clearTimeout(this.checkCurrentTimeTimeout_);\r\n      } // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\r\n\r\n\r\n      this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250);\r\n    }\r\n    /**\r\n     * Reset stalled download stats for a specific type of loader\r\n     *\r\n     * @param {string} type\r\n     *        The segment loader type to check.\r\n     *\r\n     * @listens SegmentLoader#playlistupdate\r\n     * @listens Tech#seeking\r\n     * @listens Tech#seeked\r\n     */\r\n    ;\r\n\r\n    _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type) {\r\n      var loader = this.masterPlaylistController_[type + \"SegmentLoader_\"];\r\n\r\n      if (this[type + \"StalledDownloads_\"] > 0) {\r\n        this.logger_(\"resetting possible stalled download count for \" + type + \" loader\");\r\n      }\r\n\r\n      this[type + \"StalledDownloads_\"] = 0;\r\n      this[type + \"Buffered_\"] = loader.buffered_();\r\n    }\r\n    /**\r\n     * Checks on every segment `appendsdone` to see\r\n     * if segment appends are making progress. If they are not\r\n     * and we are still downloading bytes. We blacklist the playlist.\r\n     *\r\n     * @param {string} type\r\n     *        The segment loader type to check.\r\n     *\r\n     * @listens SegmentLoader#appendsdone\r\n     */\r\n    ;\r\n\r\n    _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type) {\r\n      var mpc = this.masterPlaylistController_;\r\n      var loader = mpc[type + \"SegmentLoader_\"];\r\n      var buffered = loader.buffered_();\r\n      var isBufferedDifferent = isRangeDifferent(this[type + \"Buffered_\"], buffered);\r\n      this[type + \"Buffered_\"] = buffered; // if another watcher is going to fix the issue or\r\n      // the buffered value for this loader changed\r\n      // appends are working\r\n\r\n      if (isBufferedDifferent) {\r\n        this.resetSegmentDownloads_(type);\r\n        return;\r\n      }\r\n\r\n      this[type + \"StalledDownloads_\"]++;\r\n      this.logger_(\"found #\" + this[type + \"StalledDownloads_\"] + \" \" + type + \" appends that did not increase buffer (possible stalled download)\", {\r\n        playlistId: loader.playlist_ && loader.playlist_.id,\r\n        buffered: timeRangesToArray(buffered)\r\n      }); // after 10 possibly stalled appends with no reset, exclude\r\n\r\n      if (this[type + \"StalledDownloads_\"] < 10) {\r\n        return;\r\n      }\r\n\r\n      this.logger_(type + \" loader stalled download exclusion\");\r\n      this.resetSegmentDownloads_(type);\r\n      this.tech_.trigger({\r\n        type: 'usage',\r\n        name: \"vhs-\" + type + \"-download-exclusion\"\r\n      });\r\n\r\n      if (type === 'subtitle') {\r\n        return;\r\n      } // TODO: should we exclude audio tracks rather than main tracks\r\n      // when type is audio?\r\n\r\n\r\n      mpc.blacklistCurrentPlaylist({\r\n        message: \"Excessive \" + type + \" segment downloading detected.\"\r\n      }, Infinity);\r\n    }\r\n    /**\r\n     * The purpose of this function is to emulate the \"waiting\" event on\r\n     * browsers that do not emit it when they are waiting for more\r\n     * data to continue playback\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.checkCurrentTime_ = function checkCurrentTime_() {\r\n      if (this.tech_.paused() || this.tech_.seeking()) {\r\n        return;\r\n      }\r\n\r\n      var currentTime = this.tech_.currentTime();\r\n      var buffered = this.tech_.buffered();\r\n\r\n      if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\r\n        // If current time is at the end of the final buffered region, then any playback\r\n        // stall is most likely caused by buffering in a low bandwidth environment. The tech\r\n        // should fire a `waiting` event in this scenario, but due to browser and tech\r\n        // inconsistencies. Calling `techWaiting_` here allows us to simulate\r\n        // responding to a native `waiting` event when the tech fails to emit one.\r\n        return this.techWaiting_();\r\n      }\r\n\r\n      if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\r\n        this.consecutiveUpdates++;\r\n        this.waiting_();\r\n      } else if (currentTime === this.lastRecordedTime) {\r\n        this.consecutiveUpdates++;\r\n      } else {\r\n        this.consecutiveUpdates = 0;\r\n        this.lastRecordedTime = currentTime;\r\n      }\r\n    }\r\n    /**\r\n     * Cancels any pending timers and resets the 'timeupdate' mechanism\r\n     * designed to detect that we are stalled\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.cancelTimer_ = function cancelTimer_() {\r\n      this.consecutiveUpdates = 0;\r\n\r\n      if (this.timer_) {\r\n        this.logger_('cancelTimer_');\r\n        clearTimeout(this.timer_);\r\n      }\r\n\r\n      this.timer_ = null;\r\n    }\r\n    /**\r\n     * Fixes situations where there's a bad seek\r\n     *\r\n     * @return {boolean} whether an action was taken to fix the seek\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.fixesBadSeeks_ = function fixesBadSeeks_() {\r\n      var seeking = this.tech_.seeking();\r\n\r\n      if (!seeking) {\r\n        return false;\r\n      } // TODO: It's possible that these seekable checks should be moved out of this function\r\n      // and into a function that runs on seekablechange. It's also possible that we only need\r\n      // afterSeekableWindow as the buffered check at the bottom is good enough to handle before\r\n      // seekable range.\r\n\r\n\r\n      var seekable = this.seekable();\r\n      var currentTime = this.tech_.currentTime();\r\n      var isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);\r\n      var seekTo;\r\n\r\n      if (isAfterSeekableRange) {\r\n        var seekableEnd = seekable.end(seekable.length - 1); // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\r\n\r\n        seekTo = seekableEnd;\r\n      }\r\n\r\n      if (this.beforeSeekableWindow_(seekable, currentTime)) {\r\n        var seekableStart = seekable.start(0); // sync to the beginning of the live window\r\n        // provide a buffer of .1 seconds to handle rounding/imprecise numbers\r\n\r\n        seekTo = seekableStart + ( // if the playlist is too short and the seekable range is an exact time (can\r\n        // happen in live with a 3 segment playlist), then don't use a time delta\r\n        seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);\r\n      }\r\n\r\n      if (typeof seekTo !== 'undefined') {\r\n        this.logger_(\"Trying to seek outside of seekable at time \" + currentTime + \" with \" + (\"seekable range \" + printableRange(seekable) + \". Seeking to \") + (seekTo + \".\"));\r\n        this.tech_.setCurrentTime(seekTo);\r\n        return true;\r\n      }\r\n\r\n      var sourceUpdater = this.masterPlaylistController_.sourceUpdater_;\r\n      var buffered = this.tech_.buffered();\r\n      var audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;\r\n      var videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;\r\n      var media = this.media(); // verify that at least two segment durations or one part duration have been\r\n      // appended before checking for a gap.\r\n\r\n      var minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2; // verify that at least two segment durations have been\r\n      // appended before checking for a gap.\r\n\r\n      var bufferedToCheck = [audioBuffered, videoBuffered];\r\n\r\n      for (var i = 0; i < bufferedToCheck.length; i++) {\r\n        // skip null buffered\r\n        if (!bufferedToCheck[i]) {\r\n          continue;\r\n        }\r\n\r\n        var timeAhead = timeAheadOf(bufferedToCheck[i], currentTime); // if we are less than two video/audio segment durations or one part\r\n        // duration behind we haven't appended enough to call this a bad seek.\r\n\r\n        if (timeAhead < minAppendedDuration) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      var nextRange = findNextRange(buffered, currentTime); // we have appended enough content, but we don't have anything buffered\r\n      // to seek over the gap\r\n\r\n      if (nextRange.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      seekTo = nextRange.start(0) + SAFE_TIME_DELTA;\r\n      this.logger_(\"Buffered region starts (\" + nextRange.start(0) + \") \" + (\" just beyond seek point (\" + currentTime + \"). Seeking to \" + seekTo + \".\"));\r\n      this.tech_.setCurrentTime(seekTo);\r\n      return true;\r\n    }\r\n    /**\r\n     * Handler for situations when we determine the player is waiting.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.waiting_ = function waiting_() {\r\n      if (this.techWaiting_()) {\r\n        return;\r\n      } // All tech waiting checks failed. Use last resort correction\r\n\r\n\r\n      var currentTime = this.tech_.currentTime();\r\n      var buffered = this.tech_.buffered();\r\n      var currentRange = findRange(buffered, currentTime); // Sometimes the player can stall for unknown reasons within a contiguous buffered\r\n      // region with no indication that anything is amiss (seen in Firefox). Seeking to\r\n      // currentTime is usually enough to kickstart the player. This checks that the player\r\n      // is currently within a buffered region before attempting a corrective seek.\r\n      // Chrome does not appear to continue `timeupdate` events after a `waiting` event\r\n      // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\r\n      // make sure there is ~3 seconds of forward buffer before taking any corrective action\r\n      // to avoid triggering an `unknownwaiting` event when the network is slow.\r\n\r\n      if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\r\n        this.cancelTimer_();\r\n        this.tech_.setCurrentTime(currentTime);\r\n        this.logger_(\"Stopped at \" + currentTime + \" while inside a buffered region \" + (\"[\" + currentRange.start(0) + \" -> \" + currentRange.end(0) + \"]. Attempting to resume \") + 'playback by seeking to the current time.'); // unknown waiting corrections may be useful for monitoring QoS\r\n\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-unknown-waiting'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-unknown-waiting'\r\n        });\r\n        return;\r\n      }\r\n    }\r\n    /**\r\n     * Handler for situations when the tech fires a `waiting` event\r\n     *\r\n     * @return {boolean}\r\n     *         True if an action (or none) was needed to correct the waiting. False if no\r\n     *         checks passed\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.techWaiting_ = function techWaiting_() {\r\n      var seekable = this.seekable();\r\n      var currentTime = this.tech_.currentTime();\r\n\r\n      if (this.tech_.seeking() || this.timer_ !== null) {\r\n        // Tech is seeking or already waiting on another action, no action needed\r\n        return true;\r\n      }\r\n\r\n      if (this.beforeSeekableWindow_(seekable, currentTime)) {\r\n        var livePoint = seekable.end(seekable.length - 1);\r\n        this.logger_(\"Fell out of live window at time \" + currentTime + \". Seeking to \" + (\"live point (seekable end) \" + livePoint));\r\n        this.cancelTimer_();\r\n        this.tech_.setCurrentTime(livePoint); // live window resyncs may be useful for monitoring QoS\r\n\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-live-resync'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-live-resync'\r\n        });\r\n        return true;\r\n      }\r\n\r\n      var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;\r\n      var buffered = this.tech_.buffered();\r\n      var videoUnderflow = this.videoUnderflow_({\r\n        audioBuffered: sourceUpdater.audioBuffered(),\r\n        videoBuffered: sourceUpdater.videoBuffered(),\r\n        currentTime: currentTime\r\n      });\r\n\r\n      if (videoUnderflow) {\r\n        // Even though the video underflowed and was stuck in a gap, the audio overplayed\r\n        // the gap, leading currentTime into a buffered range. Seeking to currentTime\r\n        // allows the video to catch up to the audio position without losing any audio\r\n        // (only suffering ~3 seconds of frozen video and a pause in audio playback).\r\n        this.cancelTimer_();\r\n        this.tech_.setCurrentTime(currentTime); // video underflow may be useful for monitoring QoS\r\n\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-video-underflow'\r\n        });\r\n        this.tech_.trigger({\r\n          type: 'usage',\r\n          name: 'hls-video-underflow'\r\n        });\r\n        return true;\r\n      }\r\n\r\n      var nextRange = findNextRange(buffered, currentTime); // check for gap\r\n\r\n      if (nextRange.length > 0) {\r\n        var difference = nextRange.start(0) - currentTime;\r\n        this.logger_(\"Stopped at \" + currentTime + \", setting timer for \" + difference + \", seeking \" + (\"to \" + nextRange.start(0)));\r\n        this.cancelTimer_();\r\n        this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);\r\n        return true;\r\n      } // All checks failed. Returning false to indicate failure to correct waiting\r\n\r\n\r\n      return false;\r\n    };\r\n\r\n    _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {\r\n      if (allowSeeksWithinUnsafeLiveWindow === void 0) {\r\n        allowSeeksWithinUnsafeLiveWindow = false;\r\n      }\r\n\r\n      if (!seekable.length) {\r\n        // we can't make a solid case if there's no seekable, default to false\r\n        return false;\r\n      }\r\n\r\n      var allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;\r\n      var isLive = !playlist.endList;\r\n\r\n      if (isLive && allowSeeksWithinUnsafeLiveWindow) {\r\n        allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;\r\n      }\r\n\r\n      if (currentTime > allowedEnd) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable, currentTime) {\r\n      if (seekable.length && // can't fall before 0 and 0 seekable start identifies VOD stream\r\n      seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    _proto.videoUnderflow_ = function videoUnderflow_(_ref) {\r\n      var videoBuffered = _ref.videoBuffered,\r\n          audioBuffered = _ref.audioBuffered,\r\n          currentTime = _ref.currentTime; // audio only content will not have video underflow :)\r\n\r\n      if (!videoBuffered) {\r\n        return;\r\n      }\r\n\r\n      var gap; // find a gap in demuxed content.\r\n\r\n      if (videoBuffered.length && audioBuffered.length) {\r\n        // in Chrome audio will continue to play for ~3s when we run out of video\r\n        // so we have to check that the video buffer did have some buffer in the\r\n        // past.\r\n        var lastVideoRange = findRange(videoBuffered, currentTime - 3);\r\n        var videoRange = findRange(videoBuffered, currentTime);\r\n        var audioRange = findRange(audioBuffered, currentTime);\r\n\r\n        if (audioRange.length && !videoRange.length && lastVideoRange.length) {\r\n          gap = {\r\n            start: lastVideoRange.end(0),\r\n            end: audioRange.end(0)\r\n          };\r\n        } // find a gap in muxed content.\r\n\r\n      } else {\r\n        var nextRange = findNextRange(videoBuffered, currentTime); // Even if there is no available next range, there is still a possibility we are\r\n        // stuck in a gap due to video underflow.\r\n\r\n        if (!nextRange.length) {\r\n          gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);\r\n        }\r\n      }\r\n\r\n      if (gap) {\r\n        this.logger_(\"Encountered a gap in video from \" + gap.start + \" to \" + gap.end + \". \" + (\"Seeking to current time \" + currentTime));\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n    /**\r\n     * Timer callback. If playback still has not proceeded, then we seek\r\n     * to the start of the next buffered region.\r\n     *\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {\r\n      var buffered = this.tech_.buffered();\r\n      var currentTime = this.tech_.currentTime();\r\n      var nextRange = findNextRange(buffered, currentTime);\r\n      this.cancelTimer_();\r\n\r\n      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\r\n        return;\r\n      }\r\n\r\n      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0)); // only seek if we still have not played\r\n\r\n      this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);\r\n      this.tech_.trigger({\r\n        type: 'usage',\r\n        name: 'vhs-gap-skip'\r\n      });\r\n      this.tech_.trigger({\r\n        type: 'usage',\r\n        name: 'hls-gap-skip'\r\n      });\r\n    };\r\n\r\n    _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {\r\n      // At least in Chrome, if there is a gap in the video buffer, the audio will continue\r\n      // playing for ~3 seconds after the video gap starts. This is done to account for\r\n      // video buffer underflow/underrun (note that this is not done when there is audio\r\n      // buffer underflow/underrun -- in that case the video will stop as soon as it\r\n      // encounters the gap, as audio stalls are more noticeable/jarring to a user than\r\n      // video stalls). The player's time will reflect the playthrough of audio, so the\r\n      // time will appear as if we are in a buffered region, even if we are stuck in a\r\n      // \"gap.\"\r\n      //\r\n      // Example:\r\n      // video buffer:   0 => 10.1, 10.2 => 20\r\n      // audio buffer:   0 => 20\r\n      // overall buffer: 0 => 10.1, 10.2 => 20\r\n      // current time: 13\r\n      //\r\n      // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\r\n      // however, the audio continued playing until it reached ~3 seconds past the gap\r\n      // (13 seconds), at which point it stops as well. Since current time is past the\r\n      // gap, findNextRange will return no ranges.\r\n      //\r\n      // To check for this issue, we see if there is a gap that starts somewhere within\r\n      // a 3 second range (3 seconds +/- 1 second) back from our current time.\r\n      var gaps = findGaps(buffered);\r\n\r\n      for (var i = 0; i < gaps.length; i++) {\r\n        var start = gaps.start(i);\r\n        var end = gaps.end(i); // gap is starts no more than 4 seconds back\r\n\r\n        if (currentTime - start < 4 && currentTime - start > 2) {\r\n          return {\r\n            start: start,\r\n            end: end\r\n          };\r\n        }\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    return PlaybackWatcher;\r\n  }();\r\n\r\n  var defaultOptions = {\r\n    errorInterval: 30,\r\n    getSource: function getSource(next) {\r\n      var tech = this.tech({\r\n        IWillNotUseThisInPlugins: true\r\n      });\r\n      var sourceObj = tech.currentSource_ || this.currentSource();\r\n      return next(sourceObj);\r\n    }\r\n  };\r\n  /**\r\n   * Main entry point for the plugin\r\n   *\r\n   * @param {Player} player a reference to a videojs Player instance\r\n   * @param {Object} [options] an object with plugin options\r\n   * @private\r\n   */\r\n\r\n  var initPlugin = function initPlugin(player, options) {\r\n    var lastCalled = 0;\r\n    var seekTo = 0;\r\n    var localOptions = videojs.mergeOptions(defaultOptions, options);\r\n    player.ready(function () {\r\n      player.trigger({\r\n        type: 'usage',\r\n        name: 'vhs-error-reload-initialized'\r\n      });\r\n      player.trigger({\r\n        type: 'usage',\r\n        name: 'hls-error-reload-initialized'\r\n      });\r\n    });\r\n    /**\r\n     * Player modifications to perform that must wait until `loadedmetadata`\r\n     * has been triggered\r\n     *\r\n     * @private\r\n     */\r\n\r\n    var loadedMetadataHandler = function loadedMetadataHandler() {\r\n      if (seekTo) {\r\n        player.currentTime(seekTo);\r\n      }\r\n    };\r\n    /**\r\n     * Set the source on the player element, play, and seek if necessary\r\n     *\r\n     * @param {Object} sourceObj An object specifying the source url and mime-type to play\r\n     * @private\r\n     */\r\n\r\n\r\n    var setSource = function setSource(sourceObj) {\r\n      if (sourceObj === null || sourceObj === undefined) {\r\n        return;\r\n      }\r\n\r\n      seekTo = player.duration() !== Infinity && player.currentTime() || 0;\r\n      player.one('loadedmetadata', loadedMetadataHandler);\r\n      player.src(sourceObj);\r\n      player.trigger({\r\n        type: 'usage',\r\n        name: 'vhs-error-reload'\r\n      });\r\n      player.trigger({\r\n        type: 'usage',\r\n        name: 'hls-error-reload'\r\n      });\r\n      player.play();\r\n    };\r\n    /**\r\n     * Attempt to get a source from either the built-in getSource function\r\n     * or a custom function provided via the options\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var errorHandler = function errorHandler() {\r\n      // Do not attempt to reload the source if a source-reload occurred before\r\n      // 'errorInterval' time has elapsed since the last source-reload\r\n      if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\r\n        player.trigger({\r\n          type: 'usage',\r\n          name: 'vhs-error-reload-canceled'\r\n        });\r\n        player.trigger({\r\n          type: 'usage',\r\n          name: 'hls-error-reload-canceled'\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\r\n        videojs.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\r\n        return;\r\n      }\r\n\r\n      lastCalled = Date.now();\r\n      return localOptions.getSource.call(player, setSource);\r\n    };\r\n    /**\r\n     * Unbind any event handlers that were bound by the plugin\r\n     *\r\n     * @private\r\n     */\r\n\r\n\r\n    var cleanupEvents = function cleanupEvents() {\r\n      player.off('loadedmetadata', loadedMetadataHandler);\r\n      player.off('error', errorHandler);\r\n      player.off('dispose', cleanupEvents);\r\n    };\r\n    /**\r\n     * Cleanup before re-initializing the plugin\r\n     *\r\n     * @param {Object} [newOptions] an object with plugin options\r\n     * @private\r\n     */\r\n\r\n\r\n    var reinitPlugin = function reinitPlugin(newOptions) {\r\n      cleanupEvents();\r\n      initPlugin(player, newOptions);\r\n    };\r\n\r\n    player.on('error', errorHandler);\r\n    player.on('dispose', cleanupEvents); // Overwrite the plugin function so that we can correctly cleanup before\r\n    // initializing the plugin\r\n\r\n    player.reloadSourceOnError = reinitPlugin;\r\n  };\r\n  /**\r\n   * Reload the source when an error is detected as long as there\r\n   * wasn't an error previously within the last 30 seconds\r\n   *\r\n   * @param {Object} [options] an object with plugin options\r\n   */\r\n\r\n\r\n  var reloadSourceOnError = function reloadSourceOnError(options) {\r\n    initPlugin(this, options);\r\n  };\r\n\r\n  var version$4 = \"2.14.3\";\r\n  var version$3 = \"6.0.1\";\r\n  var version$2 = \"0.21.1\";\r\n  var version$1 = \"4.7.1\";\r\n  var version = \"3.1.3\";\r\n  var Vhs = {\r\n    PlaylistLoader: PlaylistLoader,\r\n    Playlist: Playlist,\r\n    utils: utils,\r\n    STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,\r\n    INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,\r\n    lastBandwidthSelector: lastBandwidthSelector,\r\n    movingAverageBandwidthSelector: movingAverageBandwidthSelector,\r\n    comparePlaylistBandwidth: comparePlaylistBandwidth,\r\n    comparePlaylistResolution: comparePlaylistResolution,\r\n    xhr: xhrFactory()\r\n  }; // Define getter/setters for config properties\r\n\r\n  Object.keys(Config).forEach(function (prop) {\r\n    Object.defineProperty(Vhs, prop, {\r\n      get: function get() {\r\n        videojs.log.warn(\"using Vhs.\" + prop + \" is UNSAFE be sure you know what you are doing\");\r\n        return Config[prop];\r\n      },\r\n      set: function set(value) {\r\n        videojs.log.warn(\"using Vhs.\" + prop + \" is UNSAFE be sure you know what you are doing\");\r\n\r\n        if (typeof value !== 'number' || value < 0) {\r\n          videojs.log.warn(\"value of Vhs.\" + prop + \" must be greater than or equal to 0\");\r\n          return;\r\n        }\r\n\r\n        Config[prop] = value;\r\n      }\r\n    });\r\n  });\r\n  var LOCAL_STORAGE_KEY = 'videojs-vhs';\r\n  /**\r\n   * Updates the selectedIndex of the QualityLevelList when a mediachange happens in vhs.\r\n   *\r\n   * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\r\n   * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\r\n   * @function handleVhsMediaChange\r\n   */\r\n\r\n  var handleVhsMediaChange = function handleVhsMediaChange(qualityLevels, playlistLoader) {\r\n    var newPlaylist = playlistLoader.media();\r\n    var selectedIndex = -1;\r\n\r\n    for (var i = 0; i < qualityLevels.length; i++) {\r\n      if (qualityLevels[i].id === newPlaylist.id) {\r\n        selectedIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    qualityLevels.selectedIndex_ = selectedIndex;\r\n    qualityLevels.trigger({\r\n      selectedIndex: selectedIndex,\r\n      type: 'change'\r\n    });\r\n  };\r\n  /**\r\n   * Adds quality levels to list once playlist metadata is available\r\n   *\r\n   * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\r\n   * @param {Object} vhs Vhs object to listen to for media events.\r\n   * @function handleVhsLoadedMetadata\r\n   */\r\n\r\n\r\n  var handleVhsLoadedMetadata = function handleVhsLoadedMetadata(qualityLevels, vhs) {\r\n    vhs.representations().forEach(function (rep) {\r\n      qualityLevels.addQualityLevel(rep);\r\n    });\r\n    handleVhsMediaChange(qualityLevels, vhs.playlists);\r\n  }; // HLS is a source handler, not a tech. Make sure attempts to use it\r\n  // as one do not cause exceptions.\r\n\r\n\r\n  Vhs.canPlaySource = function () {\r\n    return videojs.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\r\n  };\r\n\r\n  var emeKeySystems = function emeKeySystems(keySystemOptions, mainPlaylist, audioPlaylist) {\r\n    if (!keySystemOptions) {\r\n      return keySystemOptions;\r\n    }\r\n\r\n    var codecs = {};\r\n\r\n    if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {\r\n      codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));\r\n    }\r\n\r\n    if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {\r\n      codecs.audio = audioPlaylist.attributes.CODECS;\r\n    }\r\n\r\n    var videoContentType = getMimeForCodec(codecs.video);\r\n    var audioContentType = getMimeForCodec(codecs.audio); // upsert the content types based on the selected playlist\r\n\r\n    var keySystemContentTypes = {};\r\n\r\n    for (var keySystem in keySystemOptions) {\r\n      keySystemContentTypes[keySystem] = {};\r\n\r\n      if (audioContentType) {\r\n        keySystemContentTypes[keySystem].audioContentType = audioContentType;\r\n      }\r\n\r\n      if (videoContentType) {\r\n        keySystemContentTypes[keySystem].videoContentType = videoContentType;\r\n      } // Default to using the video playlist's PSSH even though they may be different, as\r\n      // videojs-contrib-eme will only accept one in the options.\r\n      //\r\n      // This shouldn't be an issue for most cases as early intialization will handle all\r\n      // unique PSSH values, and if they aren't, then encrypted events should have the\r\n      // specific information needed for the unique license.\r\n\r\n\r\n      if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {\r\n        keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;\r\n      } // videojs-contrib-eme accepts the option of specifying: 'com.some.cdm': 'url'\r\n      // so we need to prevent overwriting the URL entirely\r\n\r\n\r\n      if (typeof keySystemOptions[keySystem] === 'string') {\r\n        keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];\r\n      }\r\n    }\r\n\r\n    return videojs.mergeOptions(keySystemOptions, keySystemContentTypes);\r\n  };\r\n  /**\r\n   * @typedef {Object} KeySystems\r\n   *\r\n   * keySystems configuration for https://github.com/videojs/videojs-contrib-eme\r\n   * Note: not all options are listed here.\r\n   *\r\n   * @property {Uint8Array} [pssh]\r\n   *           Protection System Specific Header\r\n   */\r\n\r\n  /**\r\n   * Goes through all the playlists and collects an array of KeySystems options objects\r\n   * containing each playlist's keySystems and their pssh values, if available.\r\n   *\r\n   * @param {Object[]} playlists\r\n   *        The playlists to look through\r\n   * @param {string[]} keySystems\r\n   *        The keySystems to collect pssh values for\r\n   *\r\n   * @return {KeySystems[]}\r\n   *         An array of KeySystems objects containing available key systems and their\r\n   *         pssh values\r\n   */\r\n\r\n\r\n  var getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions(playlists, keySystems) {\r\n    return playlists.reduce(function (keySystemsArr, playlist) {\r\n      if (!playlist.contentProtection) {\r\n        return keySystemsArr;\r\n      }\r\n\r\n      var keySystemsOptions = keySystems.reduce(function (keySystemsObj, keySystem) {\r\n        var keySystemOptions = playlist.contentProtection[keySystem];\r\n\r\n        if (keySystemOptions && keySystemOptions.pssh) {\r\n          keySystemsObj[keySystem] = {\r\n            pssh: keySystemOptions.pssh\r\n          };\r\n        }\r\n\r\n        return keySystemsObj;\r\n      }, {});\r\n\r\n      if (Object.keys(keySystemsOptions).length) {\r\n        keySystemsArr.push(keySystemsOptions);\r\n      }\r\n\r\n      return keySystemsArr;\r\n    }, []);\r\n  };\r\n  /**\r\n   * Returns a promise that waits for the\r\n   * [eme plugin](https://github.com/videojs/videojs-contrib-eme) to create a key session.\r\n   *\r\n   * Works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449 in non-IE11\r\n   * browsers.\r\n   *\r\n   * As per the above ticket, this is particularly important for Chrome, where, if\r\n   * unencrypted content is appended before encrypted content and the key session has not\r\n   * been created, a MEDIA_ERR_DECODE will be thrown once the encrypted content is reached\r\n   * during playback.\r\n   *\r\n   * @param {Object} player\r\n   *        The player instance\r\n   * @param {Object[]} sourceKeySystems\r\n   *        The key systems options from the player source\r\n   * @param {Object} [audioMedia]\r\n   *        The active audio media playlist (optional)\r\n   * @param {Object[]} mainPlaylists\r\n   *        The playlists found on the master playlist object\r\n   *\r\n   * @return {Object}\r\n   *         Promise that resolves when the key session has been created\r\n   */\r\n\r\n\r\n  var waitForKeySessionCreation = function waitForKeySessionCreation(_ref) {\r\n    var player = _ref.player,\r\n        sourceKeySystems = _ref.sourceKeySystems,\r\n        audioMedia = _ref.audioMedia,\r\n        mainPlaylists = _ref.mainPlaylists;\r\n\r\n    if (!player.eme.initializeMediaKeys) {\r\n      return Promise.resolve();\r\n    } // TODO should all audio PSSH values be initialized for DRM?\r\n    //\r\n    // All unique video rendition pssh values are initialized for DRM, but here only\r\n    // the initial audio playlist license is initialized. In theory, an encrypted\r\n    // event should be fired if the user switches to an alternative audio playlist\r\n    // where a license is required, but this case hasn't yet been tested. In addition, there\r\n    // may be many alternate audio playlists unlikely to be used (e.g., multiple different\r\n    // languages).\r\n\r\n\r\n    var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;\r\n    var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));\r\n    var initializationFinishedPromises = [];\r\n    var keySessionCreatedPromises = []; // Since PSSH values are interpreted as initData, EME will dedupe any duplicates. The\r\n    // only place where it should not be deduped is for ms-prefixed APIs, but the early\r\n    // return for IE11 above, and the existence of modern EME APIs in addition to\r\n    // ms-prefixed APIs on Edge should prevent this from being a concern.\r\n    // initializeMediaKeys also won't use the webkit-prefixed APIs.\r\n\r\n    keySystemsOptionsArr.forEach(function (keySystemsOptions) {\r\n      keySessionCreatedPromises.push(new Promise(function (resolve, reject) {\r\n        player.tech_.one('keysessioncreated', resolve);\r\n      }));\r\n      initializationFinishedPromises.push(new Promise(function (resolve, reject) {\r\n        player.eme.initializeMediaKeys({\r\n          keySystems: keySystemsOptions\r\n        }, function (err) {\r\n          if (err) {\r\n            reject(err);\r\n            return;\r\n          }\r\n\r\n          resolve();\r\n        });\r\n      }));\r\n    }); // The reasons Promise.race is chosen over Promise.any:\r\n    //\r\n    // * Promise.any is only available in Safari 14+.\r\n    // * None of these promises are expected to reject. If they do reject, it might be\r\n    //   better here for the race to surface the rejection, rather than mask it by using\r\n    //   Promise.any.\r\n\r\n    return Promise.race([// If a session was previously created, these will all finish resolving without\r\n    // creating a new session, otherwise it will take until the end of all license\r\n    // requests, which is why the key session check is used (to make setup much faster).\r\n    Promise.all(initializationFinishedPromises), // Once a single session is created, the browser knows DRM will be used.\r\n    Promise.race(keySessionCreatedPromises)]);\r\n  };\r\n  /**\r\n   * If the [eme](https://github.com/videojs/videojs-contrib-eme) plugin is available, and\r\n   * there are keySystems on the source, sets up source options to prepare the source for\r\n   * eme.\r\n   *\r\n   * @param {Object} player\r\n   *        The player instance\r\n   * @param {Object[]} sourceKeySystems\r\n   *        The key systems options from the player source\r\n   * @param {Object} media\r\n   *        The active media playlist\r\n   * @param {Object} [audioMedia]\r\n   *        The active audio media playlist (optional)\r\n   *\r\n   * @return {boolean}\r\n   *         Whether or not options were configured and EME is available\r\n   */\r\n\r\n\r\n  var setupEmeOptions = function setupEmeOptions(_ref2) {\r\n    var player = _ref2.player,\r\n        sourceKeySystems = _ref2.sourceKeySystems,\r\n        media = _ref2.media,\r\n        audioMedia = _ref2.audioMedia;\r\n    var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);\r\n\r\n    if (!sourceOptions) {\r\n      return false;\r\n    }\r\n\r\n    player.currentSource().keySystems = sourceOptions; // eme handles the rest of the setup, so if it is missing\r\n    // do nothing.\r\n\r\n    if (sourceOptions && !player.eme) {\r\n      videojs.log.warn('DRM encrypted source cannot be decrypted without a DRM plugin');\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  var getVhsLocalStorage = function getVhsLocalStorage() {\r\n    if (!window.localStorage) {\r\n      return null;\r\n    }\r\n\r\n    var storedObject = window.localStorage.getItem(LOCAL_STORAGE_KEY);\r\n\r\n    if (!storedObject) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(storedObject);\r\n    } catch (e) {\r\n      // someone may have tampered with the value\r\n      return null;\r\n    }\r\n  };\r\n\r\n  var updateVhsLocalStorage = function updateVhsLocalStorage(options) {\r\n    if (!window.localStorage) {\r\n      return false;\r\n    }\r\n\r\n    var objectToStore = getVhsLocalStorage();\r\n    objectToStore = objectToStore ? videojs.mergeOptions(objectToStore, options) : options;\r\n\r\n    try {\r\n      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));\r\n    } catch (e) {\r\n      // Throws if storage is full (e.g., always on iOS 5+ Safari private mode, where\r\n      // storage is set to 0).\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem#Exceptions\r\n      // No need to perform any operation.\r\n      return false;\r\n    }\r\n\r\n    return objectToStore;\r\n  };\r\n  /**\r\n   * Parses VHS-supported media types from data URIs. See\r\n   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\r\n   * for information on data URIs.\r\n   *\r\n   * @param {string} dataUri\r\n   *        The data URI\r\n   *\r\n   * @return {string|Object}\r\n   *         The parsed object/string, or the original string if no supported media type\r\n   *         was found\r\n   */\r\n\r\n\r\n  var expandDataUri = function expandDataUri(dataUri) {\r\n    if (dataUri.toLowerCase().indexOf('data:application/vnd.videojs.vhs+json,') === 0) {\r\n      return JSON.parse(dataUri.substring(dataUri.indexOf(',') + 1));\r\n    } // no known case for this data URI, return the string as-is\r\n\r\n\r\n    return dataUri;\r\n  };\r\n  /**\r\n   * Whether the browser has built-in HLS support.\r\n   */\r\n\r\n\r\n  Vhs.supportsNativeHls = function () {\r\n    if (!document || !document.createElement) {\r\n      return false;\r\n    }\r\n\r\n    var video = document.createElement('video'); // native HLS is definitely not supported if HTML5 video isn't\r\n\r\n    if (!videojs.getTech('Html5').isSupported()) {\r\n      return false;\r\n    } // HLS manifests can go by many mime-types\r\n\r\n\r\n    var canPlay = [// Apple santioned\r\n    'application/vnd.apple.mpegurl', // Apple sanctioned for backwards compatibility\r\n    'audio/mpegurl', // Very common\r\n    'audio/x-mpegurl', // Very common\r\n    'application/x-mpegurl', // Included for completeness\r\n    'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\r\n    return canPlay.some(function (canItPlay) {\r\n      return /maybe|probably/i.test(video.canPlayType(canItPlay));\r\n    });\r\n  }();\r\n\r\n  Vhs.supportsNativeDash = function () {\r\n    if (!document || !document.createElement || !videojs.getTech('Html5').isSupported()) {\r\n      return false;\r\n    }\r\n\r\n    return /maybe|probably/i.test(document.createElement('video').canPlayType('application/dash+xml'));\r\n  }();\r\n\r\n  Vhs.supportsTypeNatively = function (type) {\r\n    if (type === 'hls') {\r\n      return Vhs.supportsNativeHls;\r\n    }\r\n\r\n    if (type === 'dash') {\r\n      return Vhs.supportsNativeDash;\r\n    }\r\n\r\n    return false;\r\n  };\r\n  /**\r\n   * HLS is a source handler, not a tech. Make sure attempts to use it\r\n   * as one do not cause exceptions.\r\n   */\r\n\r\n\r\n  Vhs.isSupported = function () {\r\n    return videojs.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\r\n  };\r\n\r\n  var Component = videojs.getComponent('Component');\r\n  /**\r\n   * The Vhs Handler object, where we orchestrate all of the parts\r\n   * of HLS to interact with video.js\r\n   *\r\n   * @class VhsHandler\r\n   * @extends videojs.Component\r\n   * @param {Object} source the soruce object\r\n   * @param {Tech} tech the parent tech object\r\n   * @param {Object} options optional and required options\r\n   */\r\n\r\n  var VhsHandler = /*#__PURE__*/function (_Component) {\r\n    inheritsLoose(VhsHandler, _Component);\r\n\r\n    function VhsHandler(source, tech, options) {\r\n      var _this;\r\n\r\n      _this = _Component.call(this, tech, videojs.mergeOptions(options.hls, options.vhs)) || this;\r\n\r\n      if (options.hls && Object.keys(options.hls).length) {\r\n        videojs.log.warn('Using hls options is deprecated. Please rename `hls` to `vhs` in your options object.');\r\n      } // if a tech level `initialBandwidth` option was passed\r\n      // use that over the VHS level `bandwidth` option\r\n\r\n\r\n      if (typeof options.initialBandwidth === 'number') {\r\n        _this.options_.bandwidth = options.initialBandwidth;\r\n      }\r\n\r\n      _this.logger_ = logger('VhsHandler'); // tech.player() is deprecated but setup a reference to HLS for\r\n      // backwards-compatibility\r\n\r\n      if (tech.options_ && tech.options_.playerId) {\r\n        var _player = videojs(tech.options_.playerId);\r\n\r\n        if (!_player.hasOwnProperty('hls')) {\r\n          Object.defineProperty(_player, 'hls', {\r\n            get: function get() {\r\n              videojs.log.warn('player.hls is deprecated. Use player.tech().vhs instead.');\r\n              tech.trigger({\r\n                type: 'usage',\r\n                name: 'hls-player-access'\r\n              });\r\n              return assertThisInitialized(_this);\r\n            },\r\n            configurable: true\r\n          });\r\n        }\r\n\r\n        if (!_player.hasOwnProperty('vhs')) {\r\n          Object.defineProperty(_player, 'vhs', {\r\n            get: function get() {\r\n              videojs.log.warn('player.vhs is deprecated. Use player.tech().vhs instead.');\r\n              tech.trigger({\r\n                type: 'usage',\r\n                name: 'vhs-player-access'\r\n              });\r\n              return assertThisInitialized(_this);\r\n            },\r\n            configurable: true\r\n          });\r\n        }\r\n\r\n        if (!_player.hasOwnProperty('dash')) {\r\n          Object.defineProperty(_player, 'dash', {\r\n            get: function get() {\r\n              videojs.log.warn('player.dash is deprecated. Use player.tech().vhs instead.');\r\n              return assertThisInitialized(_this);\r\n            },\r\n            configurable: true\r\n          });\r\n        }\r\n\r\n        _this.player_ = _player;\r\n      }\r\n\r\n      _this.tech_ = tech;\r\n      _this.source_ = source;\r\n      _this.stats = {};\r\n      _this.ignoreNextSeekingEvent_ = false;\r\n\r\n      _this.setOptions_();\r\n\r\n      if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {\r\n        tech.overrideNativeAudioTracks(true);\r\n        tech.overrideNativeVideoTracks(true);\r\n      } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\r\n        // overriding native HLS only works if audio tracks have been emulated\r\n        // error early if we're misconfigured\r\n        throw new Error('Overriding native HLS requires emulated tracks. ' + 'See https://git.io/vMpjB');\r\n      } // listen for fullscreenchange events for this player so that we\r\n      // can adjust our quality selection quickly\r\n\r\n\r\n      _this.on(document, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {\r\n        var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\r\n\r\n        if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {\r\n          _this.masterPlaylistController_.fastQualityChange_();\r\n        } else {\r\n          // When leaving fullscreen, since the in page pixel dimensions should be smaller\r\n          // than full screen, see if there should be a rendition switch down to preserve\r\n          // bandwidth.\r\n          _this.masterPlaylistController_.checkABR_();\r\n        }\r\n      });\r\n\r\n      _this.on(_this.tech_, 'seeking', function () {\r\n        if (this.ignoreNextSeekingEvent_) {\r\n          this.ignoreNextSeekingEvent_ = false;\r\n          return;\r\n        }\r\n\r\n        this.setCurrentTime(this.tech_.currentTime());\r\n      });\r\n\r\n      _this.on(_this.tech_, 'error', function () {\r\n        // verify that the error was real and we are loaded\r\n        // enough to have mpc loaded.\r\n        if (this.tech_.error() && this.masterPlaylistController_) {\r\n          this.masterPlaylistController_.pauseLoading();\r\n        }\r\n      });\r\n\r\n      _this.on(_this.tech_, 'play', _this.play);\r\n\r\n      return _this;\r\n    }\r\n\r\n    var _proto = VhsHandler.prototype;\r\n\r\n    _proto.setOptions_ = function setOptions_() {\r\n      var _this2 = this; // defaults\r\n\r\n\r\n      this.options_.withCredentials = this.options_.withCredentials || false;\r\n      this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;\r\n      this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;\r\n      this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;\r\n      this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;\r\n      this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== 'undefined' ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;\r\n      this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;\r\n      this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;\r\n      this.options_.customTagParsers = this.options_.customTagParsers || [];\r\n      this.options_.customTagMappers = this.options_.customTagMappers || [];\r\n      this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;\r\n\r\n      if (typeof this.options_.blacklistDuration !== 'number') {\r\n        this.options_.blacklistDuration = 5 * 60;\r\n      }\r\n\r\n      if (typeof this.options_.bandwidth !== 'number') {\r\n        if (this.options_.useBandwidthFromLocalStorage) {\r\n          var storedObject = getVhsLocalStorage();\r\n\r\n          if (storedObject && storedObject.bandwidth) {\r\n            this.options_.bandwidth = storedObject.bandwidth;\r\n            this.tech_.trigger({\r\n              type: 'usage',\r\n              name: 'vhs-bandwidth-from-local-storage'\r\n            });\r\n            this.tech_.trigger({\r\n              type: 'usage',\r\n              name: 'hls-bandwidth-from-local-storage'\r\n            });\r\n          }\r\n\r\n          if (storedObject && storedObject.throughput) {\r\n            this.options_.throughput = storedObject.throughput;\r\n            this.tech_.trigger({\r\n              type: 'usage',\r\n              name: 'vhs-throughput-from-local-storage'\r\n            });\r\n            this.tech_.trigger({\r\n              type: 'usage',\r\n              name: 'hls-throughput-from-local-storage'\r\n            });\r\n          }\r\n        }\r\n      } // if bandwidth was not set by options or pulled from local storage, start playlist\r\n      // selection at a reasonable bandwidth\r\n\r\n\r\n      if (typeof this.options_.bandwidth !== 'number') {\r\n        this.options_.bandwidth = Config.INITIAL_BANDWIDTH;\r\n      } // If the bandwidth number is unchanged from the initial setting\r\n      // then this takes precedence over the enableLowInitialPlaylist option\r\n\r\n\r\n      this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH; // grab options passed to player.src\r\n\r\n      ['withCredentials', 'useDevicePixelRatio', 'limitRenditionByPlayerDimensions', 'bandwidth', 'smoothQualityChange', 'customTagParsers', 'customTagMappers', 'handleManifestRedirects', 'cacheEncryptionKeys', 'playlistSelector', 'initialPlaylistSelector', 'experimentalBufferBasedABR', 'liveRangeSafeTimeDelta', 'experimentalLLHLS', 'useNetworkInformationApi', 'useDtsForTimestampOffset', 'experimentalExactManifestTimings', 'experimentalLeastPixelDiffSelector'].forEach(function (option) {\r\n        if (typeof _this2.source_[option] !== 'undefined') {\r\n          _this2.options_[option] = _this2.source_[option];\r\n        }\r\n      });\r\n      this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;\r\n      this.useDevicePixelRatio = this.options_.useDevicePixelRatio;\r\n    }\r\n    /**\r\n     * called when player.src gets called, handle a new source\r\n     *\r\n     * @param {Object} src the source object to handle\r\n     */\r\n    ;\r\n\r\n    _proto.src = function src(_src, type) {\r\n      var _this3 = this; // do nothing if the src is falsey\r\n\r\n\r\n      if (!_src) {\r\n        return;\r\n      }\r\n\r\n      this.setOptions_(); // add master playlist controller options\r\n\r\n      this.options_.src = expandDataUri(this.source_.src);\r\n      this.options_.tech = this.tech_;\r\n      this.options_.externVhs = Vhs;\r\n      this.options_.sourceType = simpleTypeFromSourceType(type); // Whenever we seek internally, we should update the tech\r\n\r\n      this.options_.seekTo = function (time) {\r\n        _this3.tech_.setCurrentTime(time);\r\n      };\r\n\r\n      if (this.options_.smoothQualityChange) {\r\n        videojs.log.warn('smoothQualityChange is deprecated and will be removed in the next major version');\r\n      }\r\n\r\n      this.masterPlaylistController_ = new MasterPlaylistController(this.options_);\r\n      var playbackWatcherOptions = videojs.mergeOptions({\r\n        liveRangeSafeTimeDelta: SAFE_TIME_DELTA\r\n      }, this.options_, {\r\n        seekable: function seekable() {\r\n          return _this3.seekable();\r\n        },\r\n        media: function media() {\r\n          return _this3.masterPlaylistController_.media();\r\n        },\r\n        masterPlaylistController: this.masterPlaylistController_\r\n      });\r\n      this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);\r\n      this.masterPlaylistController_.on('error', function () {\r\n        var player = videojs.players[_this3.tech_.options_.playerId];\r\n        var error = _this3.masterPlaylistController_.error;\r\n\r\n        if (typeof error === 'object' && !error.code) {\r\n          error.code = 3;\r\n        } else if (typeof error === 'string') {\r\n          error = {\r\n            message: error,\r\n            code: 3\r\n          };\r\n        }\r\n\r\n        player.error(error);\r\n      });\r\n      var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR; // `this` in selectPlaylist should be the VhsHandler for backwards\r\n      // compatibility with < v2\r\n\r\n      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);\r\n      this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this); // re-expose some internal objects for backwards compatibility with < v2\r\n\r\n      this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;\r\n      this.mediaSource = this.masterPlaylistController_.mediaSource; // Proxy assignment of some properties to the master playlist\r\n      // controller. Using a custom property for backwards compatibility\r\n      // with < v2\r\n\r\n      Object.defineProperties(this, {\r\n        selectPlaylist: {\r\n          get: function get() {\r\n            return this.masterPlaylistController_.selectPlaylist;\r\n          },\r\n          set: function set(selectPlaylist) {\r\n            this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);\r\n          }\r\n        },\r\n        throughput: {\r\n          get: function get() {\r\n            return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;\r\n          },\r\n          set: function set(throughput) {\r\n            this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput; // By setting `count` to 1 the throughput value becomes the starting value\r\n            // for the cumulative average\r\n\r\n            this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;\r\n          }\r\n        },\r\n        bandwidth: {\r\n          get: function get() {\r\n            var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\r\n            var networkInformation = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\r\n            var tenMbpsAsBitsPerSecond = 10e6;\r\n\r\n            if (this.options_.useNetworkInformationApi && networkInformation) {\r\n              // downlink returns Mbps\r\n              // https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/downlink\r\n              var networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1000 * 1000; // downlink maxes out at 10 Mbps. In the event that both networkInformationApi and the player\r\n              // estimate a bandwidth greater than 10 Mbps, use the larger of the two estimates to ensure that\r\n              // high quality streams are not filtered out.\r\n\r\n              if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {\r\n                playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);\r\n              } else {\r\n                playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;\r\n              }\r\n            }\r\n\r\n            return playerBandwidthEst;\r\n          },\r\n          set: function set(bandwidth) {\r\n            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth; // setting the bandwidth manually resets the throughput counter\r\n            // `count` is set to zero that current value of `rate` isn't included\r\n            // in the cumulative average\r\n\r\n            this.masterPlaylistController_.mainSegmentLoader_.throughput = {\r\n              rate: 0,\r\n              count: 0\r\n            };\r\n          }\r\n        },\r\n\r\n        /**\r\n         * `systemBandwidth` is a combination of two serial processes bit-rates. The first\r\n         * is the network bitrate provided by `bandwidth` and the second is the bitrate of\r\n         * the entire process after that - decryption, transmuxing, and appending - provided\r\n         * by `throughput`.\r\n         *\r\n         * Since the two process are serial, the overall system bandwidth is given by:\r\n         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\r\n         */\r\n        systemBandwidth: {\r\n          get: function get() {\r\n            var invBandwidth = 1 / (this.bandwidth || 1);\r\n            var invThroughput;\r\n\r\n            if (this.throughput > 0) {\r\n              invThroughput = 1 / this.throughput;\r\n            } else {\r\n              invThroughput = 0;\r\n            }\r\n\r\n            var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\r\n            return systemBitrate;\r\n          },\r\n          set: function set() {\r\n            videojs.log.error('The \"systemBandwidth\" property is read-only');\r\n          }\r\n        }\r\n      });\r\n\r\n      if (this.options_.bandwidth) {\r\n        this.bandwidth = this.options_.bandwidth;\r\n      }\r\n\r\n      if (this.options_.throughput) {\r\n        this.throughput = this.options_.throughput;\r\n      }\r\n\r\n      Object.defineProperties(this.stats, {\r\n        bandwidth: {\r\n          get: function get() {\r\n            return _this3.bandwidth || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaRequests: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaRequests_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaRequestsAborted: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaRequestsTimedout: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaRequestsErrored: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaTransferDuration: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaBytesTransferred: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaSecondsLoaded: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mediaAppends: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mediaAppends_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        mainAppendsToLoadedData: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        audioAppendsToLoadedData: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        appendsToLoadedData: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        timeToLoadedData: {\r\n          get: function get() {\r\n            return _this3.masterPlaylistController_.timeToLoadedData_() || 0;\r\n          },\r\n          enumerable: true\r\n        },\r\n        buffered: {\r\n          get: function get() {\r\n            return timeRangesToArray(_this3.tech_.buffered());\r\n          },\r\n          enumerable: true\r\n        },\r\n        currentTime: {\r\n          get: function get() {\r\n            return _this3.tech_.currentTime();\r\n          },\r\n          enumerable: true\r\n        },\r\n        currentSource: {\r\n          get: function get() {\r\n            return _this3.tech_.currentSource_;\r\n          },\r\n          enumerable: true\r\n        },\r\n        currentTech: {\r\n          get: function get() {\r\n            return _this3.tech_.name_;\r\n          },\r\n          enumerable: true\r\n        },\r\n        duration: {\r\n          get: function get() {\r\n            return _this3.tech_.duration();\r\n          },\r\n          enumerable: true\r\n        },\r\n        master: {\r\n          get: function get() {\r\n            return _this3.playlists.master;\r\n          },\r\n          enumerable: true\r\n        },\r\n        playerDimensions: {\r\n          get: function get() {\r\n            return _this3.tech_.currentDimensions();\r\n          },\r\n          enumerable: true\r\n        },\r\n        seekable: {\r\n          get: function get() {\r\n            return timeRangesToArray(_this3.tech_.seekable());\r\n          },\r\n          enumerable: true\r\n        },\r\n        timestamp: {\r\n          get: function get() {\r\n            return Date.now();\r\n          },\r\n          enumerable: true\r\n        },\r\n        videoPlaybackQuality: {\r\n          get: function get() {\r\n            return _this3.tech_.getVideoPlaybackQuality();\r\n          },\r\n          enumerable: true\r\n        }\r\n      });\r\n      this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));\r\n      this.tech_.on('bandwidthupdate', function () {\r\n        if (_this3.options_.useBandwidthFromLocalStorage) {\r\n          updateVhsLocalStorage({\r\n            bandwidth: _this3.bandwidth,\r\n            throughput: Math.round(_this3.throughput)\r\n          });\r\n        }\r\n      });\r\n      this.masterPlaylistController_.on('selectedinitialmedia', function () {\r\n        // Add the manual rendition mix-in to VhsHandler\r\n        renditionSelectionMixin(_this3);\r\n      });\r\n      this.masterPlaylistController_.sourceUpdater_.on('createdsourcebuffers', function () {\r\n        _this3.setupEme_();\r\n      }); // the bandwidth of the primary segment loader is our best\r\n      // estimate of overall bandwidth\r\n\r\n      this.on(this.masterPlaylistController_, 'progress', function () {\r\n        this.tech_.trigger('progress');\r\n      }); // In the live case, we need to ignore the very first `seeking` event since\r\n      // that will be the result of the seek-to-live behavior\r\n\r\n      this.on(this.masterPlaylistController_, 'firstplay', function () {\r\n        this.ignoreNextSeekingEvent_ = true;\r\n      });\r\n      this.setupQualityLevels_(); // do nothing if the tech has been disposed already\r\n      // this can occur if someone sets the src in player.ready(), for instance\r\n\r\n      if (!this.tech_.el()) {\r\n        return;\r\n      }\r\n\r\n      this.mediaSourceUrl_ = window.URL.createObjectURL(this.masterPlaylistController_.mediaSource);\r\n      this.tech_.src(this.mediaSourceUrl_);\r\n    };\r\n\r\n    _proto.createKeySessions_ = function createKeySessions_() {\r\n      var _this4 = this;\r\n\r\n      var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;\r\n      this.logger_('waiting for EME key session creation');\r\n      waitForKeySessionCreation({\r\n        player: this.player_,\r\n        sourceKeySystems: this.source_.keySystems,\r\n        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),\r\n        mainPlaylists: this.playlists.master.playlists\r\n      }).then(function () {\r\n        _this4.logger_('created EME key session');\r\n\r\n        _this4.masterPlaylistController_.sourceUpdater_.initializedEme();\r\n      })[\"catch\"](function (err) {\r\n        _this4.logger_('error while creating EME key session', err);\r\n\r\n        _this4.player_.error({\r\n          message: 'Failed to initialize media keys for EME',\r\n          code: 3\r\n        });\r\n      });\r\n    };\r\n\r\n    _proto.handleWaitingForKey_ = function handleWaitingForKey_() {\r\n      // If waitingforkey is fired, it's possible that the data that's necessary to retrieve\r\n      // the key is in the manifest. While this should've happened on initial source load, it\r\n      // may happen again in live streams where the keys change, and the manifest info\r\n      // reflects the update.\r\n      //\r\n      // Because videojs-contrib-eme compares the PSSH data we send to that of PSSH data it's\r\n      // already requested keys for, we don't have to worry about this generating extraneous\r\n      // requests.\r\n      this.logger_('waitingforkey fired, attempting to create any new key sessions');\r\n      this.createKeySessions_();\r\n    }\r\n    /**\r\n     * If necessary and EME is available, sets up EME options and waits for key session\r\n     * creation.\r\n     *\r\n     * This function also updates the source updater so taht it can be used, as for some\r\n     * browsers, EME must be configured before content is appended (if appending unencrypted\r\n     * content before encrypted content).\r\n     */\r\n    ;\r\n\r\n    _proto.setupEme_ = function setupEme_() {\r\n      var _this5 = this;\r\n\r\n      var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;\r\n      var didSetupEmeOptions = setupEmeOptions({\r\n        player: this.player_,\r\n        sourceKeySystems: this.source_.keySystems,\r\n        media: this.playlists.media(),\r\n        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()\r\n      });\r\n      this.player_.tech_.on('keystatuschange', function (e) {\r\n        if (e.status !== 'output-restricted') {\r\n          return;\r\n        }\r\n\r\n        var masterPlaylist = _this5.masterPlaylistController_.master();\r\n\r\n        if (!masterPlaylist || !masterPlaylist.playlists) {\r\n          return;\r\n        }\r\n\r\n        var excludedHDPlaylists = []; // Assume all HD streams are unplayable and exclude them from ABR selection\r\n\r\n        masterPlaylist.playlists.forEach(function (playlist) {\r\n          if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {\r\n            if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {\r\n              playlist.excludeUntil = Infinity;\r\n              excludedHDPlaylists.push(playlist);\r\n            }\r\n          }\r\n        });\r\n\r\n        if (excludedHDPlaylists.length) {\r\n          var _videojs$log;\r\n\r\n          (_videojs$log = videojs.log).warn.apply(_videojs$log, ['DRM keystatus changed to \"output-restricted.\" Removing the following HD playlists ' + 'that will most likely fail to play and clearing the buffer. ' + 'This may be due to HDCP restrictions on the stream and the capabilities of the current device.'].concat(excludedHDPlaylists)); // Clear the buffer before switching playlists, since it may already contain unplayable segments\r\n\r\n\r\n          _this5.masterPlaylistController_.fastQualityChange_();\r\n        }\r\n      });\r\n      this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);\r\n      this.player_.tech_.on('waitingforkey', this.handleWaitingForKey_); // In IE11 this is too early to initialize media keys, and IE11 does not support\r\n      // promises.\r\n\r\n      if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {\r\n        // If EME options were not set up, we've done all we could to initialize EME.\r\n        this.masterPlaylistController_.sourceUpdater_.initializedEme();\r\n        return;\r\n      }\r\n\r\n      this.createKeySessions_();\r\n    }\r\n    /**\r\n     * Initializes the quality levels and sets listeners to update them.\r\n     *\r\n     * @method setupQualityLevels_\r\n     * @private\r\n     */\r\n    ;\r\n\r\n    _proto.setupQualityLevels_ = function setupQualityLevels_() {\r\n      var _this6 = this;\r\n\r\n      var player = videojs.players[this.tech_.options_.playerId]; // if there isn't a player or there isn't a qualityLevels plugin\r\n      // or qualityLevels_ listeners have already been setup, do nothing.\r\n\r\n      if (!player || !player.qualityLevels || this.qualityLevels_) {\r\n        return;\r\n      }\r\n\r\n      this.qualityLevels_ = player.qualityLevels();\r\n      this.masterPlaylistController_.on('selectedinitialmedia', function () {\r\n        handleVhsLoadedMetadata(_this6.qualityLevels_, _this6);\r\n      });\r\n      this.playlists.on('mediachange', function () {\r\n        handleVhsMediaChange(_this6.qualityLevels_, _this6.playlists);\r\n      });\r\n    }\r\n    /**\r\n     * return the version\r\n     */\r\n    ;\r\n\r\n    VhsHandler.version = function version$5() {\r\n      return {\r\n        '@videojs/http-streaming': version$4,\r\n        'mux.js': version$3,\r\n        'mpd-parser': version$2,\r\n        'm3u8-parser': version$1,\r\n        'aes-decrypter': version\r\n      };\r\n    }\r\n    /**\r\n     * return the version\r\n     */\r\n    ;\r\n\r\n    _proto.version = function version() {\r\n      return this.constructor.version();\r\n    };\r\n\r\n    _proto.canChangeType = function canChangeType() {\r\n      return SourceUpdater.canChangeType();\r\n    }\r\n    /**\r\n     * Begin playing the video.\r\n     */\r\n    ;\r\n\r\n    _proto.play = function play() {\r\n      this.masterPlaylistController_.play();\r\n    }\r\n    /**\r\n     * a wrapper around the function in MasterPlaylistController\r\n     */\r\n    ;\r\n\r\n    _proto.setCurrentTime = function setCurrentTime(currentTime) {\r\n      this.masterPlaylistController_.setCurrentTime(currentTime);\r\n    }\r\n    /**\r\n     * a wrapper around the function in MasterPlaylistController\r\n     */\r\n    ;\r\n\r\n    _proto.duration = function duration() {\r\n      return this.masterPlaylistController_.duration();\r\n    }\r\n    /**\r\n     * a wrapper around the function in MasterPlaylistController\r\n     */\r\n    ;\r\n\r\n    _proto.seekable = function seekable() {\r\n      return this.masterPlaylistController_.seekable();\r\n    }\r\n    /**\r\n     * Abort all outstanding work and cleanup.\r\n     */\r\n    ;\r\n\r\n    _proto.dispose = function dispose() {\r\n      if (this.playbackWatcher_) {\r\n        this.playbackWatcher_.dispose();\r\n      }\r\n\r\n      if (this.masterPlaylistController_) {\r\n        this.masterPlaylistController_.dispose();\r\n      }\r\n\r\n      if (this.qualityLevels_) {\r\n        this.qualityLevels_.dispose();\r\n      }\r\n\r\n      if (this.player_) {\r\n        delete this.player_.vhs;\r\n        delete this.player_.dash;\r\n        delete this.player_.hls;\r\n      }\r\n\r\n      if (this.tech_ && this.tech_.vhs) {\r\n        delete this.tech_.vhs;\r\n      } // don't check this.tech_.hls as it will log a deprecated warning\r\n\r\n\r\n      if (this.tech_) {\r\n        delete this.tech_.hls;\r\n      }\r\n\r\n      if (this.mediaSourceUrl_ && window.URL.revokeObjectURL) {\r\n        window.URL.revokeObjectURL(this.mediaSourceUrl_);\r\n        this.mediaSourceUrl_ = null;\r\n      }\r\n\r\n      if (this.tech_) {\r\n        this.tech_.off('waitingforkey', this.handleWaitingForKey_);\r\n      }\r\n\r\n      _Component.prototype.dispose.call(this);\r\n    };\r\n\r\n    _proto.convertToProgramTime = function convertToProgramTime(time, callback) {\r\n      return getProgramTime({\r\n        playlist: this.masterPlaylistController_.media(),\r\n        time: time,\r\n        callback: callback\r\n      });\r\n    } // the player must be playing before calling this\r\n    ;\r\n\r\n    _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback, pauseAfterSeek, retryCount) {\r\n      if (pauseAfterSeek === void 0) {\r\n        pauseAfterSeek = true;\r\n      }\r\n\r\n      if (retryCount === void 0) {\r\n        retryCount = 2;\r\n      }\r\n\r\n      return seekToProgramTime({\r\n        programTime: programTime,\r\n        playlist: this.masterPlaylistController_.media(),\r\n        retryCount: retryCount,\r\n        pauseAfterSeek: pauseAfterSeek,\r\n        seekTo: this.options_.seekTo,\r\n        tech: this.options_.tech,\r\n        callback: callback\r\n      });\r\n    };\r\n\r\n    return VhsHandler;\r\n  }(Component);\r\n  /**\r\n   * The Source Handler object, which informs video.js what additional\r\n   * MIME types are supported and sets up playback. It is registered\r\n   * automatically to the appropriate tech based on the capabilities of\r\n   * the browser it is running in. It is not necessary to use or modify\r\n   * this object in normal usage.\r\n   */\r\n\r\n\r\n  var VhsSourceHandler = {\r\n    name: 'videojs-http-streaming',\r\n    VERSION: version$4,\r\n    canHandleSource: function canHandleSource(srcObj, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var localOptions = videojs.mergeOptions(videojs.options, options);\r\n      return VhsSourceHandler.canPlayType(srcObj.type, localOptions);\r\n    },\r\n    handleSource: function handleSource(source, tech, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var localOptions = videojs.mergeOptions(videojs.options, options);\r\n      tech.vhs = new VhsHandler(source, tech, localOptions);\r\n\r\n      if (!videojs.hasOwnProperty('hls')) {\r\n        Object.defineProperty(tech, 'hls', {\r\n          get: function get() {\r\n            videojs.log.warn('player.tech().hls is deprecated. Use player.tech().vhs instead.');\r\n            return tech.vhs;\r\n          },\r\n          configurable: true\r\n        });\r\n      }\r\n\r\n      tech.vhs.xhr = xhrFactory();\r\n      tech.vhs.src(source.src, source.type);\r\n      return tech.vhs;\r\n    },\r\n    canPlayType: function canPlayType(type, options) {\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      var _videojs$mergeOptions = videojs.mergeOptions(videojs.options, options),\r\n          _videojs$mergeOptions2 = _videojs$mergeOptions.vhs;\r\n\r\n      _videojs$mergeOptions2 = _videojs$mergeOptions2 === void 0 ? {} : _videojs$mergeOptions2;\r\n      var _videojs$mergeOptions3 = _videojs$mergeOptions2.overrideNative,\r\n          overrideNative = _videojs$mergeOptions3 === void 0 ? !videojs.browser.IS_ANY_SAFARI : _videojs$mergeOptions3,\r\n          _videojs$mergeOptions4 = _videojs$mergeOptions.hls;\r\n      _videojs$mergeOptions4 = _videojs$mergeOptions4 === void 0 ? {} : _videojs$mergeOptions4;\r\n      var _videojs$mergeOptions5 = _videojs$mergeOptions4.overrideNative,\r\n          legacyOverrideNative = _videojs$mergeOptions5 === void 0 ? false : _videojs$mergeOptions5;\r\n      var supportedType = simpleTypeFromSourceType(type);\r\n      var canUseMsePlayback = supportedType && (!Vhs.supportsTypeNatively(supportedType) || legacyOverrideNative || overrideNative);\r\n      return canUseMsePlayback ? 'maybe' : '';\r\n    }\r\n  };\r\n  /**\r\n   * Check to see if the native MediaSource object exists and supports\r\n   * an MP4 container with both H.264 video and AAC-LC audio.\r\n   *\r\n   * @return {boolean} if  native media sources are supported\r\n   */\r\n\r\n  var supportsNativeMediaSources = function supportsNativeMediaSources() {\r\n    return browserSupportsCodec('avc1.4d400d,mp4a.40.2');\r\n  }; // register source handlers with the appropriate techs\r\n\r\n\r\n  if (supportsNativeMediaSources()) {\r\n    videojs.getTech('Html5').registerSourceHandler(VhsSourceHandler, 0);\r\n  }\r\n\r\n  videojs.VhsHandler = VhsHandler;\r\n  Object.defineProperty(videojs, 'HlsHandler', {\r\n    get: function get() {\r\n      videojs.log.warn('videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.');\r\n      return VhsHandler;\r\n    },\r\n    configurable: true\r\n  });\r\n  videojs.VhsSourceHandler = VhsSourceHandler;\r\n  Object.defineProperty(videojs, 'HlsSourceHandler', {\r\n    get: function get() {\r\n      videojs.log.warn('videojs.HlsSourceHandler is deprecated. ' + 'Use videojs.VhsSourceHandler instead.');\r\n      return VhsSourceHandler;\r\n    },\r\n    configurable: true\r\n  });\r\n  videojs.Vhs = Vhs;\r\n  Object.defineProperty(videojs, 'Hls', {\r\n    get: function get() {\r\n      videojs.log.warn('videojs.Hls is deprecated. Use videojs.Vhs instead.');\r\n      return Vhs;\r\n    },\r\n    configurable: true\r\n  });\r\n\r\n  if (!videojs.use) {\r\n    videojs.registerComponent('Hls', Vhs);\r\n    videojs.registerComponent('Vhs', Vhs);\r\n  }\r\n\r\n  videojs.options.vhs = videojs.options.vhs || {};\r\n  videojs.options.hls = videojs.options.hls || {};\r\n\r\n  if (!videojs.getPlugin || !videojs.getPlugin('reloadSourceOnError')) {\r\n    var registerPlugin = videojs.registerPlugin || videojs.plugin;\r\n    registerPlugin('reloadSourceOnError', reloadSourceOnError);\r\n  }\r\n\r\n  return videojs;\r\n\r\n})));\r\n"],"names":["global","factory","exports","module","define","amd","globalThis","self","videojs","this","browserApi","hooks_","hooks","type","fn","concat","removeHook","index","indexOf","slice","splice","FullscreenApi","prefixed","apiMap","specApi","i","length","document","_i","history","log$1","createLogger$1","name","logByType","level","log","_len","arguments","args","Array","_key","lvl","levels","lvlRegExp","RegExp","unshift","toUpperCase","push","window","console","info","test","isArray","LogByTypeFactory","createLogger","subname","all","off","debug","warn","error","DEFAULT","hasOwnProperty","Error","filter","fname","historyItem","clear","disable","enable","_len2","_key2","_len3","_key3","_len4","_key4","commonjsGlobal","createCommonjsModule","_extends_1","_extends","Object","assign","target","source","key","prototype","call","apply","toString$1","toString","keys","object","isObject$1","each","forEach","sources","value","isPlain","constructor","computedStyle","el","prop","getComputedStyle","computedStyleValue","e","getPropertyValue","match","USER_AGENT","navigator","userAgent","webkitVersionMap","exec","appleWebkitVersion","parseFloat","pop","IS_IPOD","IOS_VERSION","IS_ANDROID","ANDROID_VERSION","major","minor","IS_NATIVE_ANDROID","IS_FIREFOX","IS_EDGE","IS_CHROME","CHROME_VERSION","IE_VERSION","result","version","IS_SAFARI","IS_WINDOWS","TOUCH_ENABLED","Boolean","isReal","maxTouchPoints","DocumentTouch","IS_IPAD","IS_IPHONE","IS_IOS","IS_ANY_SAFARI","browser","freeze","__proto__","isNonBlankString","str","trim","throwIfWhitespace","isEl","nodeType","isInFrame","parent","x","createQuerier","method","selector","context","querySelector","ctx","createEl","tagName","properties","attributes","content","createElement","getOwnPropertyNames","propName","val","setAttribute","textContent","attrName","appendContent","text","innerText","prependTo","child","firstChild","insertBefore","appendChild","hasClass","element","classToCheck","classList","contains","className","addClass","classToAdd","add","removeClass","classToRemove","remove","split","c","join","toggleClass","classToToggle","predicate","has","setAttributes","attrValue","removeAttribute","getAttributes","tag","obj","knownBooleans","attrs","attrVal","getAttribute","attribute","blockTextSelection","body","focus","onselectstart","unblockTextSelection","getBoundingClientRect","parentNode","rect","k","undefined","height","width","findPosition","offsetParent","left","top","offsetWidth","offsetHeight","fullscreenElement","offsetLeft","offsetTop","getPointerPosition","event","translated","y","item","nodeName","toLowerCase","transform","values","map","Number","_values","position","boxTarget","box","boxW","boxH","offsetY","offsetX","changedTouches","pageX","pageY","Math","max","min","isTextNode","emptyEl","removeChild","normalizeContent","createTextNode","node","insertContent","isSingleLeftClick","button","buttons","videojs$1","$","$$","Dom","_windowLoaded","autoSetup","options","vids","getElementsByTagName","audios","divs","mediaEls","mediaEl","autoSetupTimeout","player","wait","vjs","setTimeout","setWindowLoaded","removeEventListener","readyState","addEventListener","FakeWeakMap","createStyleElement","style","setTextContent","styleSheet","cssText","_guid","newGUID","WeakMap","vdata","floor","performance","now","Date","data","_proto","set","access","get","_supportsPassive","DomData","_cleanUpEvents","elem","handlers","dispatcher","detachEvent","disabled","_handleMultipleEvents","types","callback","fixEvent","fixed_","returnTrue","returnFalse","isPropagationStopped","isImmediatePropagationStopped","old","preventDefault","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","clientX","doc","documentElement","scrollLeft","clientLeft","clientY","scrollTop","clientTop","which","charCode","keyCode","passiveEvents","on","guid","hash","handlersCopy","m","n","opts","defineProperty","supportsPassive","passive","attachEvent","removeType","t","trigger","elemData","ownerDocument","bubbles","targetData","one","func","any","EVENT_MAP","Events","bind","uid","bound","throttle","last","EventTarget$2","allowedEvents_","ael","dispatchEvent","queueTrigger","_this","Map","oldTimeout","clearTimeout","timeout","size","objName","name_","isEvented","eventBusEl_","every","isValidEventType","validateTarget","fnName","validateEventType","validateListener","listener","normalizeListenArgs","isTargetingSelf","shift","listen","EventedMixin","_normalizeListenArgs","removeListenerOnDispose","removeRemoverOnTargetDispose","_this2","_normalizeListenArgs2","wrapper","largs","_this3","_normalizeListenArgs3","_len5","_key5","targetOrType","typeOrListener","evented","eventBusKey","eventedCallbacks","el_","StatefulMixin","state","setState","stateUpdates","changes","from","to","stateful","defaultState","handleStateChanged","string","replace","w","toTitleCase$1","mergeOptions$3","MapSham","map_","thisArg","Map$1","SetSham","set_","Set$1","Set","keycode","searchInput","hasKeyCode","names","foundNamedKey","search","String","codes","aliases","charCodeAt","isEventKey","nameOrCode","code","fromCharCode","title","alias","Component$1","Component","ready","play","player_","isDisposed_","parentComponent_","options_","id_","id","handleLanguagechange","children_","childIndex_","childNameIndex_","setTimeoutIds_","setIntervalIds_","rafIds_","namedRafs_","clearingTimersOnDispose_","initChildren","reportTouchActivity","enableTouchActivity","dispose","readyQueue_","restoreEl","replaceChild","isDisposed","localize","tokens","defaultValue","language","languages","primaryCode","primaryLang","localizedString","ret","contentEl","contentEl_","children","getChildById","getChild","getDescendant","reduce","acc","currentChild","addChild","component","componentName","componentClassName","componentClass","ComponentClass","getComponent","refNode","childFound","compEl","workingChildren","parentOptions","Tech","some","wchild","isTech","playerOptions","newChild","buildCSSClass","sync","isReady_","triggerReady","readyQueue","show","hide","lockShowing","unlockShowing","num","skipListeners","dimension","dimensions","widthOrHeight","pxIndex","parseInt","currentDimension","computedWidthOrHeight","isNaN","rule","currentDimensions","currentWidth","currentHeight","blur","handleKeyDown","handleKeyPress","emitTapEvents","couldBeTap","touchStart","firstTouch","touches","xdiff","ydiff","sqrt","noTap","reportUserActivity","touchHolding","report","clearInterval","setInterval","touchEnd","timeoutId","clearTimersOnDispose_","interval","intervalId","requestAnimationFrame","_this4","supportsRaf_","requestNamedAnimationFrame","_this5","cancelNamedAnimationFrame","cancelAnimationFrame","_this6","_ref","idName","cancelName","registerComponent","ComponentToRegister","reason","isComp","isPrototypeOf","components_","Player","players","playerNames","pname","assertThisInitialized","ReferenceError","inheritsLoose","subClass","superClass","create","getRange","valueIndex","ranges","rangeIndex","maxIndex","rangeCheck","createTimeRangesObj","timeRangesObj","start","end","Symbol","iterator","createTimeRanges","bufferedPercent","buffered","duration","bufferedDuration","MediaError","message","defaultMessages","status","errorTypes","errNum","tuple","reviver","json","JSON","parse","err","isPromise","then","silencePromise","trackToJson_","track","cues","cue","startTime","endTime","textTrackConverter","tech","trackEls","trackObjs","trackEl","src","textTracks","addedTrack","addRemoteTextTrack","addCue","ModalDialog","_Component","handleKeyDown_","close_","close","opened_","hasBeenOpened_","hasBeenFilled_","closeable","uncloseable","MODAL_CLASS_NAME","role","descEl_","description","tabIndex","label","previouslyActiveEl_","desc","open","fillAlways","fill","wasPlaying_","paused","pauseOnOpen","pause","hadControls_","controls","conditionalFocus_","opened","conditionalBlur_","temporary","closeable_","temp","controlText","fillWith","parentEl","nextSiblingEl","nextSibling","empty","closeButton","content_","activeEl","activeElement","playerEl","focusIndex","focusableEls","focusableEls_","shiftKey","allChildren","querySelectorAll","HTMLAnchorElement","HTMLAreaElement","hasAttribute","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","HTMLButtonElement","HTMLIFrameElement","HTMLObjectElement","HTMLEmbedElement","TrackList","_EventTarget","tracks","tracks_","addTrack","labelchange_","removeTrack","rtrack","l","getTrackById","change","addtrack","removetrack","labelchange","disableOthers$1","list","enabled","AudioTrackList","_TrackList","changing_","enabledChange_","disableOthers","selected","VideoTrackList","selectedChange_","TextTrackList","queueChange_","triggerSelectedlanguagechange","triggerSelectedlanguagechange_","kind","selectedlanguagechange_","HtmlTrackElementList","trackElements","trackElements_","addTrackElement_","trackElement","getTrackElementByTrack_","trackElement_","removeTrackElement_","TextTrackCueList","setCues_","length_","oldLength","cues_","defineProp","getCueById","VideoTrackKind","alternative","captions","main","sign","subtitles","commentary","AudioTrackKind","TextTrackKind","descriptions","chapters","metadata","TextTrackMode","hidden","showing","Track","trackProps","_loop","newLabel","parseUrl","url","props","a","href","details","protocol","host","location","getAbsoluteURL","getFileExtension","path","pathParts","isCrossOrigin","winLoc","urlInfo","Url","window_1","isFunction_1","alert","confirm","prompt","httpHandler","decodeResponseBody","response","responseBody","statusCode","cause","TextDecoder","charset","contentTypeHeader","contentType","_contentType$split","getCharset","headers","decode","Uint8Array","createXHR","lib","default_1","initParams","uri","params","_createXHR","called","getBody","xhr","responseText","responseType","responseXML","firefoxBugTakenEffect","getXml","isJson","errorFunc","evt","timeoutTimer","failureResponse","loadFunc","aborted","useXDR","rawRequest","getAllResponseHeaders","row","parseHeaders","cors","XDomainRequest","XMLHttpRequest","stringify","onreadystatechange","onload","onerror","onprogress","onabort","ontimeout","username","password","withCredentials","abort","setRequestHeader","isEmpty","beforeSend","send","array","forEachArray","parseCues","srcContent","parser","WebVTT","Parser","vttjs","StringDecoder","errors","oncue","onparsingerror","onflush","groupCollapsed","groupEnd","flush","loadTrack","crossOrigin","tech_","loaded_","TextTrack","_Track","settings","srclang","mode","default_","activeCues_","preload_","preloadTextTracks","activeCues","changed","timeupdateHandler","rvf_","requestVideoFrameCallback","stopTracking","startTracking","defineProperties","newMode","ct","currentTime","active","cancelVideoFrameCallback","originalCue","VTTCue","originalCue_","removeCue","_removeCue","cuechange","AudioTrack","newEnabled","VideoTrack","newSelected","HTMLTrackElement","load","NONE","LOADING","LOADED","ERROR","NORMAL","audio","ListClass","TrackClass","capitalName","video","getterName","privateName","REMOTE","remoteText","remoteTextEl","ALL","doccy","topLevel","document_1","_objCreate","F","o","ParsingError","errorData","parseTimeStamp","input","computeSeconds","h","s","f","Settings","parseOptions","keyValueDelim","groupDelim","groups","kv","parseCue","regionList","oInput","consumeTimeStamp","ts","Errors","BadTimeStamp","skipWhitespace","substr","v","region","alt","vals","vals0","integer","percent","vertical","line","lineAlign","snapToLines","align","center","middle","right","positionAlign","consumeCueSettings","BadSignature","dflt","defaultKey","TEXTAREA_ELEMENT","TAG_NAME","b","u","ruby","rt","lang","DEFAULT_COLOR_CLASS","white","lime","cyan","red","yellow","magenta","blue","black","TAG_ANNOTATION","NEEDS_PARENT","parseContent","nextToken","shouldAdd","current","localName","annotation","rootDiv","tagStack","innerHTML","createProcessingInstruction","classes","cl","bgColor","colorName","propValue","strongRTLRanges","isStrongRTLChar","currentRange","determineBidi","cueDiv","nodeStack","childNodes","pushNodes","nextTextNode","StyleBox","CueStyleBox","styleOptions","styles","color","backgroundColor","bottom","display","writingMode","unicodeBidi","applyStyles","div","direction","textAlign","font","whiteSpace","textPos","formatStyle","move","BoxPosition","lh","rects","getClientRects","lineHeight","moveBoxToLinePosition","styleBox","containerBox","boxPositions","boxPosition","linePos","textTrackList","mediaElement","trackList","count","computeLinePos","axis","step","round","maxPosition","initialAxis","abs","ceil","reverse","calculatedPercentage","bestPosition","specifiedPosition","percentage","overlapsOppositeAxis","within","overlapsAny","p","intersectPercentage","findBestPosition","toCSSCompatValues","WebVTT$1","unit","toMove","overlaps","b2","boxes","container","reference","getSimpleBoxPosition","decodeURIComponent","encodeURIComponent","convertCueToDOMTree","cuetext","processCues","overlay","paddedOverlay","margin","hasBeenReset","displayState","shouldCompute","fontSize","decoder","buffer","reportOrThrowError","collectNextLine","pos","parseHeader","ontimestampmap","parseTimestampMap","xy","anchor","VTTRegion","lines","regionAnchorX","regionAnchorY","viewportAnchorX","viewportAnchorY","scroll","onregion","parseRegion","stream","alreadyCollectedLine","hasSubstring","vtt","directionSetting","alignSetting","findAlignSetting","_id","_pauseOnExit","_startTime","_endTime","_text","_region","_vertical","_snapToLines","_line","_lineAlign","_position","_positionAlign","_size","_align","enumerable","TypeError","setting","findDirectionSetting","SyntaxError","getCueAsHTML","vttcue","scrollSetting","isValidPercentValue","vttregion","_width","_lines","_regionAnchorX","_regionAnchorY","_viewportAnchorX","_viewportAnchorY","_scroll","findScrollSetting","browserIndex","cueShim","regionShim","nativeVTTCue","nativeVTTRegion","shim","restore","onDurationChange_","onDurationChange","trackProgress_","trackProgress","trackCurrentTime_","trackCurrentTime","stopTrackingCurrentTime_","stopTrackingCurrentTime","disposeSourceHandler_","disposeSourceHandler","queuedHanders_","hasStarted_","featuresProgressEvents","manualProgressOn","featuresTimeupdateEvents","manualTimeUpdatesOn","nativeCaptions","nativeTextTracks","featuresNativeTextTracks","emulateTextTracks","autoRemoteTextTracks_","initTrackListeners","nativeControlsForTouch","triggerSourceset","manualProgress","manualProgressOff","stopTrackingProgress","progressInterval","numBufferedPercent","bufferedPercent_","duration_","manualTimeUpdates","manualTimeUpdatesOff","currentTimeInterval","manuallyTriggered","clearTracks","removeRemoteTextTrack","cleanupAutoTextTracks","reset","setCrossOrigin","error_","played","setScrubbing","scrubbing","setCurrentTime","trackListChanges","addWebVttScript_","script","remoteTracks","remoteTextTracks","handleAddTrack","handleRemoveTrack","updateDisplay","textTracksChanges","addTextTrack","createTrackHelper","createRemoteTextTrack","manualCleanup","_this7","htmlTrackElement","remoteTextTrackEls","getVideoPlaybackQuality","requestPictureInPicture","PromiseClass","Promise","reject","disablePictureInPicture","setDisablePictureInPicture","cb","_this8","setPoster","playsinline","setPlaysinline","overrideNativeAudioTracks","overrideNativeVideoTracks","canPlayType","canPlaySource","srcObj","registerTech","techs_","defaultTechOrder_","getTech","featuresVolumeControl","featuresMuteControl","featuresFullscreenResize","featuresPlaybackRate","featuresSourceset","featuresVideoFrameCallback","withSourceHandlers","_Tech","registerSourceHandler","handler","sourceHandlers","can","selectSourceHandler","canHandleSource","sh","originalFn","sourceHandler_","setSource","nativeSourceHandler","currentSource_","handleSource","middlewares","middlewareInstances","TERMINATOR","next","setSourceHelper","mediate","middleware","arg","callMethod","middlewareValue","middlewareIterator","terminated","mws","mw","executeRight","allowedGetters","muted","seekable","volume","ended","allowedSetters","setMuted","setVolume","allowedMediators","lastRun","_middleware","mwFactory","mwrest","_mws$i","mwf","mwi","getOrCreateFactory","_src","MimetypesKind","opus","ogv","mp4","mov","m4v","mkv","m4a","mp3","aac","caf","flac","oga","wav","m3u8","mpd","jpg","jpeg","gif","png","svg","webp","getMimetype","ext","filterSource","newsrc","srcobj","fixSource","mimetype","MediaLoader","j","techOrder","techName","isSupported","loadTech_","ClickableComponent","handleMouseOver_","handleMouseOver","handleMouseOut_","handleMouseOut","handleClick_","handleClick","tabIndex_","createControlTextEl","controlTextEl_","controlText_","localizedText","nonIconControl","noUITitleAttributes","enabled_","clickHandler","PosterImage","_ClickableComponent","update","update_","poster","setSrc","backgroundImage","sourceIsEncrypted","usingPlugin","eme","sessions","fontMap","monospace","sansSerif","serif","monospaceSansSerif","monospaceSerif","proportionalSansSerif","proportionalSerif","casual","smallcaps","constructColor","opacity","hex","tryUpdateStyle","TextTrackDisplay","updateDisplayHandler","toggleDisplay","preselectTrack","firstDesc","firstCaptions","preferredTrack","modes","userPref","cache_","selectedLanguage","clearDisplay","allowMultipleShowingTracks","showingTracks","updateForTrack","descriptionsTrack","captionsSubtitlesTrack","_track","updateDisplayState","overrides","textTrackSettings","getValues","textOpacity","backgroundOpacity","windowColor","windowOpacity","edgeStyle","textShadow","fontPercent","fontFamily","fontVariant","_i2","_track2","_j","cueEl","LoadingSpinner","isAudio","playerType","dir","Button","BigPlayButton","_Button","mouseused_","handleMouseDown","playPromise","playToggle","playFocus","CloseButton","PlayToggle","replay","handlePlay","handlePause","handleEnded","handleSeeked","defaultImplementation","seconds","guide","gm","gh","Infinity","implementation","formatTime","TimeDisplay","updateContent","updateTextNode_","span","labelText_","textNode_","time","formattedTime_","oldNode","CurrentTimeDisplay","_TimeDisplay","getCache","DurationDisplay","TimeDivider","RemainingTimeDisplay","displayNegative","remainingTimeDisplay","remainingTime","LiveDisplay","updateShowing","SeekToLive","updateLiveEdgeStatus","liveTracker","updateLiveEdgeStatusHandler_","textEl_","atLiveEdge","seekToLiveEdge","clamp","number","Slider","handleMouseDown_","handleMouseUp_","handleMouseUp","handleMouseMove_","handleMouseMove","bar","barName","playerEvent","progress","getProgress","progress_","sizeKey","toFixed","getPercent","calculateDistance","stepBack","stepForward","bool","vertical_","percentify","LoadProgressBar","partEls_","loadedText","separator","percentageEl_","isLive","seekableEnd","bufferedEnd","percent_","part","dataset","TimeTooltip","seekBarRect","seekBarPoint","tooltipRect","playerRect","seekBarPointPx","spaceLeftOfPoint","spaceRightOfPoint","pullTooltipBy","write","updateTime","liveWindow","secondsBehind","PlayProgressBar","timeTooltip","MouseTimeDisplay","SeekBar","_Slider","setEventHandlers_","updateInterval","enableIntervalHandler_","enableInterval_","disableIntervalHandler_","disableInterval_","toggleVisibility_","visibilityState","getCurrentTime_","liveCurrentTime","currentTime_","userSeek_","nextSeekedFromUser","seekableStart","videoWasPlaying","mouseDown","newTime","distance","mouseTimeDisplay","handleAction","gotoFraction","STEP_SECONDS","ProgressControl","throttledHandleMouseSeek","handleMouseSeek","handleMouseUpHandler_","handleMouseDownHandler_","seekBar","playProgressBar","seekBarEl","removeListenersAddedOnMousedownAndTouchstart","PictureInPictureToggle","handlePictureInPictureChange","handlePictureInPictureEnabledChange","currentType","substring","audioPosterMode","audioOnlyMode","isInPictureInPicture","exitPictureInPicture","pictureInPictureEnabled","FullscreenToggle","handleFullscreenChange","fsApi_","fullscreenEnabled","isFullscreen","exitFullscreen","requestFullscreen","VolumeLevel","VolumeLevelTooltip","rangeBarRect","rangeBarPoint","volumeBarPointPx","updateVolume","MouseVolumeLevelDisplay","VolumeBar","updateLastVolume_","updateARIAAttributes","mouseVolumeLevelDisplay","volumeBarEl","volumeBarRect","volumeBarPoint","checkMuted","ariaValue","volumeAsPercentage_","volumeBeforeDrag","lastVolume_","VolumeControl","volumeBar","checkVolumeSupport","throttledHandleMouseMove","orientationClass","MuteToggle","checkMuteSupport","vol","lastVolume","volumeToSet","updateIcon_","updateControlText_","VolumePanel","inline","volumeControl","handleKeyPressHandler_","volumePanelState_","muteToggle","handleVolumeControlKeyUp","sliderActive_","sliderInactive_","Menu","menuButton_","menuButton","focusedChild_","boundHandleBlur_","handleBlur","boundHandleTapClick_","handleTapClick","addEventListenerForItem","removeEventListenerForItem","addItem","childComponent","contentElType","append","btn","buttonPressed_","unpressButton","childComponents","foundComponent","stepChild","MenuButton","buttonClass","handleMenuKeyUp_","handleMenuKeyUp","menu","handleMouseLeave","handleSubmenuKeyDown","createMenu","items","hideThreshold_","titleEl","titleComponent","createItems","buildWrapperCSSClass","menuButtonClass","pressButton","handleSubmenuKeyPress","TrackButton","_MenuButton","updateHandler","MenuKeys","MenuItem","selectable","isSelected_","multiSelectable","_selected","TextTrackMenuItem","_MenuItem","kinds","changeHandler","handleTracksChange","selectedLanguageChangeHandler","handleSelectedLanguageChange","onchange","Event","createEvent","initEvent","referenceTrack","shouldBeSelected","OffTextTrackMenuItem","_TextTrackMenuItem","allHidden","TextTrackButton","_TrackButton","TrackMenuItem","label_","kinds_","kind_","ChaptersTrackMenuItem","ChaptersButton","_TextTrackButton","selectCurrentItem_","track_","findChaptersTrack","setTrack","updateHandler_","remoteTextTrackEl","_remoteTextTrackEl","getMenuCaption","mi","DescriptionsButton","SubtitlesButton","CaptionSettingsMenuItem","CaptionsButton","SubsCapsMenuItem","parentSpan","SubsCapsButton","language_","AudioTrackMenuItem","audioTracks","featuresNativeAudioTracks","AudioTrackButton","PlaybackRateMenuItem","rate","playbackRate","PlaybackRateMenuButton","labelElId_","updateVisibility","updateLabel","handlePlaybackRateschange","labelEl_","rates","playbackRates","currentRate","newIndex","playbackRateSupported","Spacer","CustomControlSpacer","_Spacer","ControlBar","ErrorDisplay","_ModalDialog","COLOR_BLACK","COLOR_BLUE","COLOR_CYAN","COLOR_GREEN","COLOR_MAGENTA","COLOR_RED","COLOR_WHITE","COLOR_YELLOW","OPACITY_OPAQUE","OPACITY_SEMI","OPACITY_TRANS","selectConfigs","parseOptionValue","TextTrackSettings","endDialog","setDefaults","persistTextTrackSettings","saveSettings","config","restoreSettings","createElSelect_","legendId","selectLabelledbyIds","optionId","createElFgColor_","createElBgColor_","createElWinColor_","createElColors_","createElFont_","createElControls_","defaultsDescription","initial","accum","selectedIndex","setValues","setSelectedOption","localStorage","getItem","setItem","removeItem","ttDisplay","controlBar","subsCapsBtn","subsCapsButton","ccBtn","captionsButton","ResizeManager","RESIZE_OBSERVER_AVAILABLE","ResizeObserver","loadListener_","resizeObserver_","debouncedHandler_","immediate","debounced","_later","cancel","debounce","resizeHandler","observe","contentWindow","unloadListener_","unobserve","disconnect","resizeObserver","defaults","trackingThreshold","liveTolerance","LiveTracker","handleVisibilityChange_","handleVisibilityChange","trackLiveHandler_","trackLive_","handlePlay_","handleFirstTimeupdate_","handleFirstTimeupdate","handleSeeked_","seekToLiveEdge_","reset_","handleDurationchange","toggleTracking","deltaTime","lastTime_","pastSeekEnd_","pastSeekEnd","isBehind","seekedBehindLive_","timeupdateSeen_","behindLiveEdge_","liveui","isTracking","hasStarted","trackingInterval_","timeDiff","nextSeekedFromUser_","lastSeekEnd_","seekableEnds","sort","seekableStarts","behindLiveEdge","sourcesetLoad","srcUrls","innerHTMLDescriptorPolyfill","cloneNode","dummy","docFrag","createDocumentFragment","Element","getDescriptor","priority","descriptor","getOwnPropertyDescriptor","configurable","firstSourceWatch","resetSourceWatch_","innerDescriptor","HTMLMediaElement","getInnerHTMLDescriptor","appendWrapper","appendFn","retval","srcDescriptorPolyfill","setupSourceset","resetSourceset_","srcDescriptor","getSrcDescriptor","oldSetAttribute","oldLoad","currentSrc","defineLazyProperty","getValue","setter","writable","Html5","crossoriginTracks","initNetworkState_","handleLateInit_","enableSourceset","setupSourcesetHandling_","isScrubbing_","hasChildNodes","nodes","nodesLength","removeNodes","proxyNativeTracks_","restoreMetadataTracksInIOSNativePlayer_","setControls","proxyWebkitFullscreen_","disposeMediaElement","metadataTracksPreFullscreenState","takeMetadataTrackSnapshot","storedMode","restoreTrackMode","storedTrack","overrideNative_","override","lowerCaseType","eventName","proxyNativeTracksForType_","elTracks","techTracks","listeners","currentTarget","removeOldTracks","removeTracks","found","playerElIngest","movingMediaElementInDOM","clone","techId","playerId","preload","settingsAttrs","attr","networkState","loadstartFired","setLoadstartFired","triggerLoadstart","eventsToTrigger","isScrubbing","fastSeek","checkProgress","NaN","endFn","beginFn","webkitPresentationMode","nativeIOSFullscreen","supportsFullScreen","webkitEnterFullScreen","enterFullScreen","HAVE_METADATA","exitFullScreen","webkitDisplayingFullscreen","webkitExitFullScreen","webkitKeys","resetMediaElement","videoPlaybackQuality","webkitDroppedFrameCount","webkitDecodedFrameCount","droppedVideoFrames","totalVideoFrames","creationTime","timing","navigationStart","TEST_VID","canControlVolume","canControl","canMuteVolume","canControlPlaybackRate","canOverrideAttributes","noop","supportsNativeTextTracks","supportsNativeVideoTracks","videoTracks","supportsNativeAudioTracks","patchCanPlayType","unpatchCanPlayType","r","TECH_EVENTS_RETRIGGER","TECH_EVENTS_QUEUE","canplay","canplaythrough","playing","seeked","BREAKPOINT_ORDER","BREAKPOINT_CLASSES","charAt","DEFAULT_BREAKPOINTS","tiny","xsmall","small","medium","large","xlarge","huge","getTagSettings","closest","boundDocumentFullscreenChange_","documentFullscreenChange_","boundFullWindowOnEscKey_","fullWindowOnEscKey","boundUpdateStyleEl_","updateStyleEl_","boundApplyInitTime_","applyInitTime_","boundUpdateCurrentBreakpoint_","updateCurrentBreakpoint_","boundHandleTechClick_","handleTechClick_","boundHandleTechDoubleClick_","handleTechDoubleClick_","boundHandleTechTouchStart_","handleTechTouchStart_","boundHandleTechTouchMove_","handleTechTouchMove_","boundHandleTechTouchEnd_","handleTechTouchEnd_","boundHandleTechTap_","handleTechTap_","isFullscreen_","isPosterFromTech_","queuedCallbacks_","userActive_","debugEnabled_","audioOnlyMode_","audioPosterMode_","audioOnlyCache_","playerHeight","hiddenChildren","tagAttributes","languagesToLower","languages_","resetCache_","poster_","controls_","changingSrc_","playCallbacks_","playTerminatedQueue_","autoplay","plugins","scrubbing_","fullscreenchange","fluid_","playerOptionsCopy","middleware_","flexNotSupported_","majorVersion","userActive","listenForUserActivity_","handleStageClick_","breakpoints","responsive","styleEl_","playerElIngest_","divEmbed","tabindex","VIDEOJS_NO_DYNAMIC_STYLE","defaultsStyleEl","head","fill_","fluid","aspectRatio","crossorigin","links","linkEl","techGet_","techCall_","_dimension","privDimension","parsedVal","ratio","aspectRatio_","idClass","ratioParts","videoWidth","videoHeight","ratioMultiplier","width_","height_","_height","techEl","unloadTech_","titleTechName","camelTechName","techName_","normalizeAutoplay","techOptions","loop","techCanOverridePoster","TechClass","handleTechReady_","textTracksJson_","eventObj","seeking","handleTechLoadStart_","handleTechSourceset_","handleTechWaiting_","handleTechEnded_","handleTechSeeking_","handleTechPlay_","handleTechFirstPlay_","handleTechPause_","handleTechDurationChange_","handleTechFullscreenChange_","handleTechFullscreenError_","handleTechEnterPictureInPicture_","handleTechLeavePictureInPicture_","handleTechError_","handleTechPosterChange_","handleTechTextData_","handleTechRateChange_","usingNativeControls","addTechControlsListeners_","safety","removeTechControlsListeners_","manualAutoplay_","promise","resolveMuted","previouslyMuted","restoreMuted","mutedPromise","updateSourceCaches_","matchingSources","findMimetype","sourceElSources","sourceEls","matchingSourceEls","sourceObj","updateSourceCaches","playerSrc","currentSource","eventSrc","lastSource_","techSrc","techGet","request","lastPlaybackRate","queued","timeWhenWaiting","timeUpdateListener","handleTechCanPlay_","handleTechCanPlayThrough_","handleTechPlaying_","handleTechSeeked_","starttime","userActions","click","doubleClick","userWasActive","cancelable","toggleFullscreenClass_","targetPlayer","isFs","matches","fullscreen","msMatchesSelector","_this9","togglePictureInPictureClass_","initTime","inactivityTimeout","defaultPlaybackRate","media","reduceRight","_this10","resolve","play_","_this11","isSrcReady","waitToPlay_","runPlayTerminatedQueue_","runPlayCallbacks_","queue","q","callbacks","percentAsDecimal","_muted","defaultMuted","_defaultMuted","isFS","oldValue","fullscreenOptions","offHandler","errorHandler","requestFullscreenHelper_","fsOptions","_this12","preferFullWindow","enterFullWindow","exitFullscreenHelper_","_this13","exitFullWindow","isFullWindow","docOrigOverflow","overflow","isPiP","isInPictureInPicture_","hotkeys","isContentEditable","excludeElement","handleHotkeys","_hotkeys$fullscreenKe","fullscreenKey","keydownEvent","_hotkeys$muteKey","muteKey","_hotkeys$playPauseKey","playPauseKey","FSToggle","selectSource","_this14","techs","findFirstPassingTechSourcePair","outerArray","innerArray","tester","outerChoice","innerChoice","finder","_ref2","sourceOrder","handleSrc_","isRetry","_this15","resetRetryOnError_","middlewareSource","src_","notSupportedMessage","setTech","retryOnError","retry","stopListeningForErrors","str1","str2","_this16","sourceTech","_this17","doReset_","resetControlBarUI_","resetProgressBar_","resetPlaybackRate_","resetVolumeBar_","_ref3","durationDisplay","currentSources","techAutoplay","newPoster","usingNativeControls_","_this18","hookFunction","newErr","suppressNotSupportedError","triggerSuppressedError","errorDisplay","userActivity_","mouseInProgress","lastMoveX","lastMoveY","handleActivity","handleMouseUpAndMouseLeave","screenX","screenY","isAudio_","enableAudioOnlyUI_","_this19","playerChildren","controlBarHeight","disableAudioOnlyUI_","_this20","exitPromises","enablePosterModeUI_","disablePosterModeUI_","_this21","toJSON","createModal","_this22","modal","currentBreakpoint","candidateBreakpoint","breakpoints_","breakpoint_","removeCurrentBreakpoint_","currentBreakpointClass","_breakpoints","responsive_","loadMedia","_this23","_this$cache_$media","artwork","tt","getMedia","baseOptions","tagOptions","dataSetup","_safeParseTuple","childName","previousLogLevel_","newRates","html5","userLanguage","navigationUI","setPrototypeOf","_setPrototypeOf","isNativeReflectConstruct","Reflect","construct","sham","Proxy","_construct","Parent","Class","instance","Function","pluginStorage","pluginExists","getPlugin","markPluginAsActive","triggerSetupEvent","before","createPluginFactory","PluginSubClass","plugin","getEventHash","Plugin","VERSION","isBasic","registerPlugin","basicPluginWrapper","createBasicPlugin","deregisterPlugin","getPlugins","getPluginVersion","BASE_PLUGIN_NAME","hasPlugin","inherits","normalizeId","getPlayer","defaultView","PlayerComponent","hook","hookOnce","original","getPlayers","nId","_tag","_player","getAllPlayers","comp","use","writeable","extend","subClassMethods","methods","super_","mergeOptions","addLanguage","_mergeOptions","createTimeRange","setFormatTime","customImplementation","resetFormatTime","EventTarget","dom","urlToolkit","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","alwaysNormalize","basePartsForNormalise","parseURL","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","builtParts","query","fragment","baseURLPath","newPath","lastIndexOf","parts","Stream","_length","pipe","destination","decodeB64ToUint8Array$1","b64Text","decodedString","atob","Buffer","LineStream","_Stream","nextNewline","TAB","parseByterange","byterangeString","offset","parseAttributes$1","ParseStream","customParsers","tagMappers","mapper","mappedLine","newLine","tagType","playlistType","allowed","URI","BYTERANGE","byterange","RESOLUTION","resolution","BANDWIDTH","dateTimeString","dateTimeObject","IV","Uint32Array","PRECISE","subkey","addParser","expression","customType","dataParser","segment","addTagMapper","camelCaseKeys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","hb","phb","minTargetDuration","minPartDuration","lineStream","parseStream","currentMap","uris","currentUri","hasParts","defaultMediaGroups","currentTimeline","allowCache","discontinuityStarts","segments","lastByterangeEnd","lastPartByterangeEnd","preloadHints","timeline","preloadSegment","entry","mediaGroup","rendition","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","KEYID","schemeIdUri","keyId","pssh","iv","isFinite","playlist","playlists","mediaGroups","TYPE","NAME","mediaGroupType","autoselect","AUTOSELECT","LANGUAGE","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","targetduration","timeOffset","precise","cueOut","cueOutCont","cueIn","skip","warnOnMissingAttributes_","segmentIndex","partIndex","renditionReports","canBlockReload","canSkipDateranges","hint","isPart","otherHint","required","partInf","partTarget","comment","custom","identifier","missing","chunk","regexs","webm","ogg","muxerVideo","muxerAudio","muxerText","mediaTypes","upperMediaTypes","translateLegacyCodec","codec","orig","profile","avcLevel","parseCodecs","codecString","codecs","codecType","mediaType","isAudioCodec","getMimeForCodec","browserSupportsCodec","MediaSource","isTypeSupported","muxerSupportsCodec","MPEGURL_REGEX","DASH_REGEX","simpleTypeFromSourceType","isArrayBufferView","ArrayBuffer","isView","toUint8","bytes","byteOffset","byteLength","BigInt","BYTE_TABLE","bytesToNumber","_temp","_ref$signed","signed","_ref$le","le","total","_byte","exponent","numberToBytes","_temp2","_ref2$le","byteCount","countBits","byteIndex","stringToBytes","stringIsBytes","unescape","view","bytesMatch","_temp3","_ref3$offset","_ref3$mask","mask","bByte","resolveUrl$1","baseUrl","relativeUrl","nativeURL","URL","protocolLess","removeLocation","newUrl","decodeB64ToUint8Array","oc","MIME_TYPE","HTML","isHTML","XML_APPLICATION","XML_TEXT","XML_XHTML_APPLICATION","XML_SVG_IMAGE","NAMESPACE$3","SVG","XML","XMLNS","conventions","NAMESPACE","NAMESPACE$2","notEmptyString","orderedSetReducer","toOrderedSet","splitOnASCIIWhitespace","copy","dest","Super","pt","NodeType","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","ExceptionCode","ExceptionMessage","INDEX_SIZE_ERR","DOMSTRING_SIZE_ERR","HIERARCHY_REQUEST_ERR","WRONG_DOCUMENT_ERR","INVALID_CHARACTER_ERR","NO_DATA_ALLOWED_ERR","NO_MODIFICATION_ALLOWED_ERR","NOT_FOUND_ERR","NOT_SUPPORTED_ERR","INUSE_ATTRIBUTE_ERR","DOMException","captureStackTrace","NodeList","LiveNodeList","refresh","_node","_refresh","_updateLiveList","inc","_inc","ls","__set__","NamedNodeMap","_findNodeIndex","_addNamedNode","newAttr","oldAttr","ownerElement","_onRemoveAttribute","namespaceURI","_nsMap","prefix","_onAddAttribute","_removeNamedNode","lastIndex","DOMImplementation$1","Node","_xmlEncoder","_visitNode","Document","_onUpdateChild","cs","_removeChild","previous","previousSibling","lastChild","_insertBefore","nextChild","cp","newFirst","newLast","pre","Attr","CharacterData","Text","Comment","CDATASection","DocumentType","Notation","Entity","EntityReference","DocumentFragment","ProcessingInstruction","XMLSerializer$1","nodeSerializeToString","isHtml","nodeFilter","buf","lookupPrefix","visibleNamespaces","namespace","serializeToString","needNamespaceDefine","ns","addSerializedAttribute","qualifiedName","len","prefixedNodeName","defaultNS","ai","nsi","pubid","publicId","sysid","systemId","sub","internalSubset","_importNode","deep","node2","_cloneNode","attrs2","_ownerElement","setAttributeNode","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","NAMESPACE_ERR","INVALID_ACCESS_ERR","getNamedItem","setNamedItem","setNamedItemNS","getNamedItemNS","removeNamedItem","removeNamedItemNS","hasFeature","feature","createDocument","doctype","root","createElementNS","createDocumentType","nodeValue","refChild","oldChild","normalize","appendData","hasAttributes","lookupNamespaceURI","isDefaultNamespace","importNode","importedNode","getElementById","rtv","getElementsByClassName","classNames","classNamesSet","base","nodeClassNames","nodeClassNamesSet","createComment","createCDATASection","createAttribute","specified","createEntityReference","pl","createAttributeNS","getAttributeNode","removeAttributeNode","_appendSingleChild","setAttributeNodeNS","removeAttributeNS","getAttributeNodeNS","hasAttributeNS","getAttributeNS","setAttributeNS","getElementsByTagNameNS","substringData","insertData","replaceData","deleteData","splitText","newText","newNode","getTextContent","$$length","DOMImplementation","XMLSerializer","entities","XML_ENTITIES","amp","apos","gt","lt","quot","HTML_ENTITIES","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","forall","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","there4","sim","cong","asymp","ne","equiv","ge","sup","nsub","sube","supe","oplus","otimes","perp","sdot","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","euro","trade","larr","uarr","rarr","darr","harr","crarr","lceil","rceil","lfloor","rfloor","loz","spades","clubs","hearts","diams","entityMap","NAMESPACE$1","nameStartChar","nameChar","tagNamePattern","ParseError$1","locator","XMLReader$1","copyLocator","lineNumber","columnNumber","parseElementStartPart","currentNSMap","entityReplacer","addAttribute","qname","startIndex","attributeNames","fatalError","addValue","warning","setTagName","closed","appendElement$1","domBuilder","localNSMap","qName","nsp","nsPrefix","_copy","startPrefixMapping","startElement","endElement","endPrefixMapping","parseHtmlSpecialContent","elStartEnd","elEndStart","characters","fixSelfClosed","closeMap","parseDCC","startCDATA","endCDATA","matchs","lastMatch","startDTD","endDTD","parseInstruction","processingInstruction","ElementAttributes","defaultNSMap","startDocument","defaultNSMapCopy","fixedFromCharCode","surrogate1","surrogate2","appendText","xt","lineEnd","linePattern","lineStart","parseStack","tagStart","currentElement","endMatch","locator2","_parse","endDocument","getLocalName","getLocator","getQName","getURI","sax","XMLReader","ParseError","DOMParser$1","DOMHandler","cdata","_locator","_toString","chars","java","appendElement","hander","parseFromString","mimeType","xmlns","setDocumentLocator","errorImpl","isCallback","build","msg","buildErrorHandler","xml","documentURI","ins","ignorableWhitespace","ch","charNode","skippedEntity","comm","impl","dt","_error","DOMParser","__DOMHandler","isObject","merge","objects","flatten","lists","findIndex","matchingFunction","urlTypeToSegment","_ref$baseUrl","_ref$source","_ref$range","range","_ref$indexRange","indexRange","resolvedUri","startRange","endRange","MAX_SAFE_INTEGER","parseEndNumber","endNumber","segmentRange","_attributes$timescale","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","_attributes$timescale2","_attributes$periodSta","periodStart","_attributes$minimumUp","minimumUpdatePeriod","_attributes$timeShift","timeShiftBufferDepth","periodStartWC","segmentCount","availableStart","availableEnd","parseByDuration","_attributes$timescale4","_segmentRange$type","_attributes$timescale3","_attributes$startNumb","startNumber","toSegments","sectionDuration","segmentsFromBase","_attributes$initializ","initialization","_attributes$indexRang","presentationTime","_attributes$number","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","sidx","sidxByteRange","sidxEnd","mediaReferences","references","referenceType","firstOffset","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","getUniqueTimelineStarts","timelineStarts","keyFunction","getMediaGroupPlaylists","master","mediaGroupPlaylists","group","groupKey","labelKey","mediaProperties","updateMediaSequenceForPlaylist","positionManifestOnTimeline","_ref5","oldManifest","newManifest","oldPlaylists","newPlaylists","_ref4","oldPlaylist","findPlaylistWithName","firstNewSegment","oldMatchingSegmentIndex","oldSegment","updateSequenceNumbers","generateSidxKey","mergeDiscontiguousPlaylists","_acc$name$segments","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatVideoPlaylist","_attributes2","AUDIO","SUBTITLES","CODECS","bandwidth","videoOnly","audioOnly","vttOnly","_ref6","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref8","_mediaGroups","dashPlaylists","locations","_ref8$sidxMapping","previousManifest","_dashPlaylists$0$attr","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captionServices","VIDEO","isAudioOnly","organizedAudioGroup","mainPlaylist","formattedPlaylists","roleLabel","formatted","_attributes","formatAudioPlaylist","organizeAudioPlaylists","organizedVttGroup","_m3u8Attributes","m3u8Attributes","formatVttPlaylist","organizeVttPlaylists","playlistTimelineStarts","_ref9","_ref7","subs","cc","svcObj","svc","service","channel","easyReader","getLiveRValue","parseByTimeline","segmentTimeline","_attributes$minimumUp2","_attributes$media","sIndex","S","d","repeat","segmentTime","nextS","identifierPattern","constructTemplateUrl","format","identifierReplacement","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","parseTemplateInfo","Time","presentationTimeOffset","segmentsFromList","_attributes$segmentUr","segmentUrls","segmentUrlMap","segmentUrlObject","segmentUrl","mediaRange","SegmentURLToSegmentObject","generateSegments","segmentAttributes","segmentsFn","segmentInfo","template","segmentsInfo","_segmentAttributes","_segmentAttributes$ti","findChildren","getContent","parseDuration","_match$slice","year","month","day","hour","minute","second","parsers","mediaPresentationDuration","parsedValue","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","adaptationSetAttributes","adaptationSetBaseUrls","roleAttributes","accessibility","_value$split","flags","_value$split2","_value$split2$","opt","_opt$split","labelVal","keySystem","psshNode","representations","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","inheritBaseUrls","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","adaptationSets","stringToMpdXml","manifestString","parsedManifestInfo","_options","_options$manifestUri","manifestUri","_options$NOW","_options$clientOffset","periodNodes","periods","priorPeriod","priorPeriodAttributes","mpdType","getPeriodStart","representationInfo","inheritAttributes","parseUTCTiming","UTCTimingNode","parseUTCTimingScheme","MAX_UINT32","pow","getUint64","uint8","dv","DataView","getBigUint64","getUint32","parseSidx_1","subarray","referenceId","earliestPresentationTime","referenceCount","getUint16","startsWithSap","sapType","sapDeltaTime","ID3","getId3Offset","returnSize","getId3Size","normalizePath$1","findBox","paths","complete","normalizePaths$1","results","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getvint","removeLength","getLength","valueBytes","getInfinityDataSize","innerid","dataHeader","findEbml","normalizePaths","dataStart","dataEnd","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","positions","newLength","newData","sourceIndex","findNal","dataType","nalLimit","nalStart","nalsFound","nalOffset","nalType","CONSTANTS","_isLikely","docType","matroska","fmp4","moof","moov","ac3","avi","riff","findH264Nal","findH265Nal","isLikelyTypes","isLikelyFn","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","isLikely","detectContainerForBytes","sampleRate","timestamp","clock_1","resolveUrl","resolveManifestRedirect","handleManifestRedirect","req","responseURL","logger","filterRanges","timeRanges","findRange","TIME_FUDGE_FACTOR","findNextRange","printableRange","strArr","timeRangesToArray","timeRangesList","lastBufferedEnd","timeAheadOf","segmentDurationWithParts","getPartsAndSegments","si","getLastParts","lastSegment","getKnownPartCount","partCount","liveEdgeDelay","partHoldBack","holdBack","intervalDuration","endSequence","expired","backward","backwardDuration","forward","forwardDuration","totalDuration","sumDurations","defaultDuration","durationList","durations","playlistEnd","useSafeLiveEnd","liveEdgePadding","lastSegmentEndTime","isBlacklisted","excludeUntil","isIncompatible","isEnabled","blacklisted","isLowestEnabledRendition","currentBandwidth","MAX_VALUE","playlistMatch","someAudioVariant","groupName","variant","_ret","Playlist","getMediaInfoForTime","startingSegmentIndex","startingPartIndex","experimentalExactManifestTimings","partsAndSegments","partAndSegment","_partAndSegment","_i3","_i4","_partAndSegment2","isDisabled","isAes","estimateSegmentRequestTime","bytesReceived","createPlaylistID","forEachMediaGroup","setupMediaPlaylist","playlistErrors_","addPropertiesToMaster","phonyUri","audioOnlyMaster","groupId","setupMediaPlaylists","resolveMediaGroupUris","mergeOptions$2","EventTarget$1","updateSegment","skipped","resolveSegmentUris","baseUri","getAllSegments","isPlaylistUnchanged","updateMaster$1","newMedia","unchangedCheck","oldMedia","mergedPlaylist","skippedSegments","oldSegments","newSegments","newSegment","updateSegments","refreshDelay","lastPart","lastDuration","PlaylistLoader","vhs","logger_","_options$withCredenti","_options$handleManife","handleManifestRedirects","vhs_","vhsOptions","customTagParsers","customTagMappers","experimentalLLHLS","handleMediaupdatetimeout_","parameters","nextMSN","nextPart","_HLS_part","_HLS_msn","canSkipUntil","_HLS_skip","parsedUri","searchParams","addLLHLSQueryDirectives","playlistRequestError","haveMetadata","playlistString","startingState","parseManifest_","onwarn","oninfo","_ref$customTagParsers","_ref$customTagMappers","customParser","parseManifest","playlistObject","lastRequest","pendingMedia_","media_","updateMediaUpdateTimeout_","stopRequest","mediaUpdateTimeout","finalRenditionTimeout","oldRequest","shouldDelay","delay","mediaChange","masterPlaylistRef","started","setupInitialPlaylist","srcUri","masterForMedia","videojsXHR","mergeOptions$1","callbackWrapper","reqResponse","responseTime","roundTripTime","requestTime","responseHeaders","timedout","xhrFactory","XhrFunction","beforeRequest","Vhs","newOptions","originalAbort","segmentXhrHeaders","Range","textRange","formatHexString","formatAsciiString","createTransferableMessage","transferable","initSegmentId","segmentKeyId","hexDump","utils","tagDump","textRanges","getProgramTime","_ref$time","matchedSegment","segmentEnd","videoTimingInfo","transmuxedPresentationEnd","estimatedStart","transmuxedPresentationStart","findSegmentForPlayerTime","seekTime","programTimeObject","mediaSeconds","programTime","playerTime","transmuxerPrependedSeconds","offsetFromSegmentStart","getTime","playerTimeToProgramTime","programDateTime","toISOString","seekToProgramTime","_ref2$retryCount","retryCount","seekTo","_ref2$pauseAfterSeek","pauseAfterSeek","verifyProgramDateTimeTags","lastSegmentStart","lastSegmentDuration","findSegmentForProgramTime","mediaOffset","comparisonTimeStamp","segmentDateTime","segmentTimeEpoch","getOffsetFromTimestamp","seekToTime","callbackOnCompleted","containerRequest","id3Offset","finished","endRequestAndCallback","_bytes","progressListener","newPart","buffers","totalLen","tempBuffer","concatTypedArrays","overrideMimeType","loaded","dashPlaylistUnchanged","aSegment","bSegment","aByterange","bByterange","compareSidxEntry","oldSidxMapping","newSidxMapping","currentSidxInfo","savedSidxInfo","sidxInfo","DashPlaylistLoader","srcUrlOrPlaylist","masterPlaylistLoader","masterPlaylistLoader_","isMaster_","refreshXml_","refreshMedia_","loadedPlaylists_","srcUrl","sidxMapping_","childPlaylist_","requestErrored_","addSidxSegments_","fin","internal","blacklistDuration","_playlist$sidx$bytera","mediaRequest_","minimumUpdatePeriodTimeout_","createMupOnMedia_","hasPendingRequest","sidxChanged","isFinalRendition","updateMinimumUpdatePeriodTimeout_","requestMaster_","masterChanged","haveMaster_","masterXml_","date","masterLoaded_","handleMaster_","syncClientServerClock_","done","utcTiming","clientOffset_","serverTime","masterXml","oldMaster","newMaster","noChanges","playlistUpdate","_playlistUpdate","updateMaster","mpl","mup","createMUPTimeout_","mediaGroupSidx","mediaID","mediaChanged","createMediaUpdateTimeout","Config","GOAL_BUFFER_LENGTH","MAX_GOAL_BUFFER_LENGTH","BACK_BUFFER_LENGTH","GOAL_BUFFER_LENGTH_RATE","INITIAL_BANDWIDTH","BANDWIDTH_VARIANCE","BUFFER_LOW_WATER_LINE","MAX_BUFFER_LOW_WATER_LINE","EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE","BUFFER_LOW_WATER_LINE_RATE","BUFFER_HIGH_WATER_LINE","browserWorkerPolyFill","workerObj","objectUrl","createObjectURL","Blob","blob","BlobBuilder","getBlob","worker","Worker","objURL","terminate","revokeObjectURL","getWorkerString","workerCode$1","init","flushSource","partialFlush","endTimeline","dinf","esds","ftyp","mfhd","minf","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun$1","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","videoSample","audioSample","audioTrun","videoTrun","trunHeader","MAX_UINT32$1","numbers","avc1","avcC","btrt","dref","mdat","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","trun","vmhd","payload","setUint32","audioobjecttype","samplingfrequencyindex","channelcount","samplerate","sequenceNumber","trackFragments","samples","dependsOn","isDependedOn","hasRedundancy","avc1Box","sps","pps","sequenceParameterSets","pictureParameterSets","profileIdc","profileCompatibility","levelIdc","sarRatio","hSpacing","vSpacing","samplesize","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","silence","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","mp4Generator","fileType","movie","sampleForFrame","frame","dataOffset","pts","dts","keyFrame","frameUtils","nalUnits","currentNal","currentFrame","frames","nalCount","nalUnitType","currentGop","gops","baseDataOffset","nalsByteLength","numberOfNals","highPrefix","lowPrefix","zeroFill","silence_1","coneOfSilence","metaTable","arr","timelineStartPts","keepOriginalTimestamps","clock","audioFrameUtils","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","frameDuration","silentFrame","firstFrame","audioGapDuration","audioFillFrameCount","audioFillDuration","adtsFrames","earliestAllowedDts","minSegmentDts","minSegmentPts","sumFrameByteLengths","ONE_SECOND_IN_TS$3","trackDecodeInfo","maxSegmentDts","maxSegmentPts","timelineStartInfo","captionPacketParser","payloadType","payloadSize","sei","userData","ccData","emulationPreventionBytesPositions","CaptionStream$1","CaptionStream","parse708captions_","parse708captions","captionPackets_","ccStreams_","Cea608Stream","cc708Stream_","Cea708Stream","newCaptionPackets","escapedRBSP","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","idx","presortIndex","packet","dispatchCea608Packet","dispatchCea708Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION_708","within708TextBlock","Cea708Window","windowNum","clearText","pendingNewLine","winAttr","penAttr","penLoc","penColor","visible","rowLock","columnLock","relativePositioning","anchorVertical","anchorHorizontal","anchorPoint","rowCount","virtualRowCount","columnCount","windowStyle","penStyle","getText","rows","rowIdx","beforeRowOverflow","addText","backspace","Cea708Service","serviceNum","encoding","currentWindow","windows","createTextDecoder","startPts","win","setCurrentWindow","textDecoder_","serviceProps","captionServiceEncodings","serviceName","serviceEncodings","current708Packet","services","new708Packet","add708Bytes","push708Packet","ptsVals","byte0","byte1","packet708","packetData","blockSize","seq","sizeCode","pushServiceBlock","initService","handleText","multiByteCharacter","extendedCommands","defineWindow","clearWindows","deleteWindows","displayWindows","hideWindows","toggleWindows","setWindowAttributes","setPenAttributes","setPenColor","setPenLocation","isExtended","getPts","flushDisplayed","_char","charCodeArray","newCode","isMultiByte","extended","currentByte","nextByte","firstByte","secondByte","fillOpacity","fillRed","fillGreen","fillBlue","borderType","borderRed","borderGreen","borderBlue","wordWrap","printDirection","scrollDirection","justify","effectSpeed","effectDirection","displayEffect","displayedText","winId","endPts","pushCaption","textTag","penSize","italics","underline","edgeType","fontStyle","fgOpacity","fgRed","fgGreen","fgBlue","bgOpacity","bgRed","bgGreen","bgBlue","edgeRed","edgeGreen","edgeBlue","column","CHARACTER_TRANSLATION","getCharFromCode","ROWS","createDisplayBuffer","BOTTOM_ROW","field","dataChannel","field_","dataChannel_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","formatting_","isColorPAC","isNormalChar","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","_char2","newBaseRow","popOn","baseRow","rollUp","paintOn","captionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","handleRollover$1","TimestampRolloverStream$1","TimestampRolloverStream","lastDTS","referenceDTS","type_","_MetadataStream","timestampRolloverStream","percentEncode$1","parseUtf8","parseSyncSafeInteger$1","tagParsers","TXXX","WXXX","PRIV","owner","privateData","tagSize","bufferSize","dispatchType","frameStart","frameSize","dataAlignmentIndicator","timeStamp","_TransportPacketStream","_TransportParseStream","_ElementaryStream","metadataStream","bytesInBuffer","everything","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","streamType","pid","processPes_","STREAM_TYPES","h264","adts","segmentHadPmt","timedMetadata","forceFlush","packetFlushable","trackId","pes","ptsDtsFlags","startPrefix","packetLength","flushStreams_","m2ts","PAT_PID","MP2T_PACKET_LENGTH","TransportPacketStream","TransportParseStream","ElementaryStream","MetadataStream","_AdtsStream","m2ts_1","ONE_SECOND_IN_TS$2","ADTS_SAMPLING_FREQUENCIES$1","handlePartialSegments","frameNum","skipWarn_","frameLength","protectionSkipBytes","oldBuffer","sampleCount","adtsFrameDuration","ExpGolomb","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","skipBits","skipBytes","readBits","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","_H264Stream","_NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","expGolomb","syncPoint","swapBuffer","currentPts","currentDts","readSequenceParameterSet","skipScalingList","nalByteStream","nalUnitTypeCode","expGolombDecoder","lastScale","nextScale","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","_AacStream","H264Stream","NalByteStream","ADTS_SAMPLING_FREQUENCIES","parseId3TagSize","parseSyncSafeInteger","isLikelyAacData","parseAdtsSize","lowThree","parseType","parseSampleRate","parseAacTimestamp","percentEncode","setTimestamp","bytesLeft","tempLength","_VideoSegmentStream","_AudioSegmentStream","_Transmuxer","_CoalesceStream","audioProperties","videoProperties","ONE_SECOND_IN_TS$1","retriggerForStream","addPipelineLogRetriggers","transmuxer","pipeline","arrayEquals","generateSegmentTimingInfo","startDts","endDts","prependedContentDuration","firstSequenceNumber","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","videoClockCyclesOfSilencePrefixed","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","dtsDistance","nearestGopObj","currentGopObj","nearestDistance","alignIndex","gopIndex","alignEndIndex","matchFound","trimIndex","alignGopsWith","newGopsToAlignWith","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","caption","id3","captionStreams","cueTime","setRemux","hasFlushed","transmuxPipeline_","setupAacPipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","getLogTrigger_","hasAudio","hasVideo","setupTsPipeline","packetStream","elementaryStream","h264Stream","videoSegmentStream","id3Frame","setBaseMediaDecodeTime","isAac","resetCaptions","getTracks","getTimescaleFromMediaHeader","Transmuxer","VideoSegmentStream","AudioSegmentStream","AUDIO_PROPERTIES","VIDEO_PROPERTIES","bin","parseType_1","toUnsigned$2","findBox_1","subresults","toUnsigned$1","getUint64$1","parseTfdt","parseSampleFlags_1","parseTrun","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","parseTfhd","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","mapToSample","approximateOffset","parseCaptionNals","videoTrackId","trafs","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","headerInfo","truns","allSamples","parseSamples","avcStream","seiNal","lastMatchedSample","avcView","logs","seiNals","matchingSample","findSeiNals","captionParser","segmentCache","parsedCaptions","parsingPartial","isInitialized","isPartial","isNewInit","videoTrackIds","timescales","parsedData","cachedSegment","trackNals","parseEmbeddedCaptions","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","toUnsigned","toHexString","lowestTime","baseTime","scale","traks","tkhdVersion","getUint8","sampleDescriptions","codecConfig","codecBox","probe$2","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","parseNalUnitType","probe$1","pusi","payloadOffset","parsePesType","parsePesTime","videoPacketContainsKeyFrame","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","handleRollover","probe","ONE_SECOND_IN_TS","parseAudioPes_","pesType","parsed","endLoop","table","parseVideoPes_","firstKeyFrame","inspectTs_","parsePsi_","tsInspector","baseTimestamp","audioCount","audioTimescale","inspectAac_","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","adjustTimestamp_","MessageHandlers","initArray","typedArray","postMessage","action","gopInfo","timingInfo","videoSegmentTimingInfo","presentation","audioSegmentTimingInfo","trackInfo","audioTimingInfo","wireTransmuxerEvents","pushMp4Captions","trackIds","probeMp4StartTime","probeMp4Tracks","probeTs","baseStartTime","tsStartTime","timeInfo","videoStart","audioStart","clearAllMp4Captions","clearParsedMp4Captions","setTimestampOffset","timestampOffset","appendStart","onmessage","messageHandlers","TransmuxWorker","processTransmux","audioAppendStart","onData","onTrackInfo","onAudioTimingInfo","onVideoTimingInfo","onVideoSegmentTimingInfo","onAudioSegmentTimingInfo","onId3","onCaptions","onDone","onEndedTimeline","onTransmuxerLog","isEndOfTimeline","transmuxedData","waitForEndedTimelineEvent","currentTransmux","_event$data$segment","videoFrameDtsTime","videoFramePtsTime","handleData_","handleGopInfo_","handleDone_","dequeue","transmuxQueue","processAction","enqueueAction","transmux","segmentTransmuxer","term","workerCallback","endAction","listenForEndEvent","isArrayBuffer","transfers","REQUEST_ERRORS","abortAll","activeXhrs","handleErrors","handleKeyResponse","finishProcessingFn","errorObj","parseInitSegment","_callback","handleSegmentResponse","newBytes","stringToArrayBuffer","lastReachedChar","stats","getRequestStats","encryptedBytes","transmuxAndNotify","trackInfoFn","timingInfoFn","videoSegmentTimingInfoFn","audioSegmentTimingInfoFn","id3Fn","captionsFn","endedTimelineFn","dataFn","doneFn","fmp4Tracks","isMuxed","audioStartFn","audioEndFn","videoStartFn","videoEndFn","probeResult","id3Frames","handleSegmentBytes","bytesAsUint8Array","isLikelyFmp4MediaSegment","isFmp4","audioCodec","videoCodec","finishLoading","decrypt","keyBytes","decryptionWorker","decryptionHandler","decrypted","encrypted","waitForCompletion","didError","segmentFinish","requestId","decryptedBytes","decryptSegment","endOfAllRequests","parseError","handleProgress","_ref11","progressFn","progressEvent","getProgressStats","firstBytesReceivedAt","mediaSegmentRequest","_ref12","xhrOptions","abortFn","keyXhr","mapKeyXhr","initSegmentOptions","initSegmentRequestCallback","handleInitSegmentResponse","initSegmentXhr","segmentRequestOptions","segmentXhr","loadendState","activeXhr","_ref10","calledAbortFn","handleLoadEnd","logFn$1","isMaat","mediaAttributes","unwrapCodecList","codecList","codecCount","codecObj","codecsForPlaylist","codecInfo","getCodecs","audioGroup","defaultCodecs","audioGroupId","audioType","codecsFromDefault","logFn","representationToString","safeGetComputedStyle","property","stableSort","sortFn","newArray","cmp","comparePlaylistBandwidth","leftBandwidth","rightBandwidth","simpleSelector","playerBandwidth","playerWidth","limitRenditionByPlayerDimensions","masterPlaylistController","getAudioTrackPlaylists_","sortedPlaylistReps","enabledPlaylistReps","rep","bandwidthPlaylistReps","highestRemainingBandwidthRep","bandwidthBestRep","_chosenRep","haveResolution","resolutionBestRepList","resolutionPlusOneList","resolutionPlusOneSmallest","resolutionPlusOneRep","leastPixelDiffRep","resolutionBestRep","experimentalLeastPixelDiffSelector","leastPixelDiffList","pixelDiff","chosenRep","_type","lastBandwidthSelector","pixelRatio","useDevicePixelRatio","devicePixelRatio","systemBandwidth","masterPlaylistController_","addMetadata","inbandTextTracks","metadataArray","videoDuration","Cue","WebKitDataCue","metadataTrack","metadataTrack_","deprecateOldCue","cuesArray","cuesGroupedByStartTime","timeSlot","sortedStartTimes","cueGroup","nextTime","removeCuesFromTrack","finite","segmentInfoString","startOfSegment","_segmentInfo$playlist","_segmentInfo$playlist2","mediaIndex","segmentLen","selection","isSyncRequest","independent","hasPartIndex","zeroBasedPartCount","timingInfoPropertyForMedia","shouldWaitForTimelineChange","timelineChangeController","loaderType","audioDisabled","lastMainTimelineChange","lastTimelineChange","pendingAudioTimelineChange","pendingTimelineChange","segmentTooLong","maxDuration","getTroublesomeSegmentDurationMessage","sourceType","timingInfos","typeTimingInfo","isSegmentWayTooLong","isSegmentSlightlyTooLong","segmentTooLongMessage","severity","SegmentLoader","_videojs$EventTarget","mediaSource","throughput","roundTrip","resetStats_","hasPlayed_","hasPlayed","seekable_","seeking_","mediaSource_","loaderType_","currentMediaInfo_","startingMediaInfo_","segmentMetadataTrack_","segmentMetadataTrack","goalBufferLength_","goalBufferLength","sourceType_","sourceUpdater_","sourceUpdater","inbandTextTracks_","state_","timelineChangeController_","shouldSaveSegmentTimingInfo_","useDtsForTimestampOffset_","useDtsForTimestampOffset","captionServices_","checkBufferTimeout_","currentTimeline_","pendingSegment_","xhrOptions_","pendingSegments_","audioDisabled_","isPendingTimestampOffset_","gopBuffer_","timeMapping_","safeAppend_","appendInitSegment_","playlistOfLastInitSegment_","callQueue_","loadQueue_","metadataQueue_","waitingOnRemove_","quotaExceededErrorRetryTimeout_","activeInitSegmentId_","initSegments_","cacheEncryptionKeys_","cacheEncryptionKeys","keyCache_","decrypter_","decrypter","syncController_","syncController","syncPoint_","transmuxer_","createTransmuxer_","triggerSyncInfoUpdate_","isEndOfStream_","ended_","fetchAtBuffer_","newState","hasEnoughInfoToAppend_","processCallQueue_","hasEnoughInfoToLoad_","processLoadQueue_","mediaBytesTransferred","mediaRequests","mediaRequestsAborted","mediaRequestsTimedout","mediaRequestsErrored","mediaTransferDuration","mediaSecondsLoaded","mediaAppends","abort_","setAudio","removeAudio","monitorBuffer_","abortRequests","clearPendingTimelineChange","checkForAbort_","endOfStream","buffered_","getMediaInfo_","videoBuffered","audioBuffered","initSegmentForMap","storedMap","segmentKey","storedKey","couldBeginLoading_","playlist_","init_","resetEverything","newPlaylist","syncInfo","setDateTimeMappingForStart","oldId","resyncLoader","resetLoader","mediaSequenceDiff","saveExpiredSegmentInfo","force","removesRemaining","removeFinished","mapping","updatedBuffer","removeGopBuffer","removeVideo","monitorBufferTick_","fillBuffer_","updating","chooseNextRequest_","loadSegment_","appendedLastSegment","appendedLastPart","bufferedTime","preloaded","haveEnoughBuffer","getSyncPoint","targetTime","timelineSegments","getSyncSegmentCandidate","_Playlist$getMediaInf","_partIndex","nextSegment","lastSegmentLastPart","generateSegmentInfo_","forceTimestampOffset","random","overrideCheck","timestampOffsetForSegment_","audioBufferedEnd","audioTimestampOffset","currentTimePts","gopsSafeToAlignWith","videoTimestampOffset","earlyAbortWhenNeeded_","measuredBandwidth","requestTimeRemaining","timeUntilRebuffer$1","timeUntilRebuffer","switchCandidate","compatiblePlaylists","enabledPlaylists","rebufferingEstimates","numRequests","rebufferingImpact","noRebufferingPlaylists","estimate","minRebufferMaxBandwidthSelector","timeSavedBySwitching","minimumTimeSaving","handleAbort_","handleProgress_","simpleSegment","handleTrackInfo_","checkForIllegalMediaSwitch","akeys","bkeys","shallowEqual","handleTimingInfo_","timeType","timingInfoProperty","handleCaptions_","captionData","hasAppendedData_","captionTracks","captionTrack","trackName","_captionTracks$trackN","def","captionService","createCaptionsTrackIfNotExists","captionArray","addCaptionData","handleId3_","inBandMetadataTrackDispatchType","createMetadataTrackIfNotExists","processMetadataQueue_","callQueue","fun","loadQueue","getCurrentMediaInfo_","setTimeMapping_","updateMediaSecondsLoaded_","firstVideoFrameTimeForData","useVideoTimingInfo","trueSegmentStart_","currentStart","currentVideoTimestampOffset","updateAppendInitSegmentStatus","updateSourceBufferTimestampOffset_","updateTimingInfoEnd_","saveSegmentTimingInfo","shouldSaveTimelineMapping","appendData_","changedTimestampOffset","getInitSegmentAndUpdateState_","handleQuotaExceededError_","audioBufferStart","audioBufferEnd","videoBufferStart","videoBufferEnd","appendToSourceBuffer_","timeToRemoveUntil","MIN_BACK_BUFFER","handleAppendError_","segmentObj","appendBuffer","handleSegmentTimingInfo_","segmentTimingInfo","transmuxedDecodeStart","transmuxedDecodeEnd","trimBackBuffer_","updateTransmuxerAndRequestSegment_","shouldUpdateTransmuxerTimestampOffset_","createSimplifiedSegmentObj_","isEndOfStream","isWalkingForward","isDiscontinuity","segmentRequestFinished_","removeToTime","trimTime","maxTrimTime","safeBackBufferTrimTime","previousSegment","saveTransferStats_","saveBandwidthRelatedStats_","handleTimeout_","updateGopBuffer","waitForAppendsToComplete_","timelineMapping","mappingForTimeline","waitForVideo","waitForAudio","waitingOnAppends","checkAppendsDone_","videoQueueCallback","audioQueueCallback","handleAppendsDone_","illegalMediaSwitchError","startingMedia","illegalMediaSwitch","didChange","getSegmentStartTimeForTimestampOffsetCalculation_","prioritizedTimingInfo","segmentDurationMessage","recordThroughput_","addSegmentMetadataCue_","badSegmentGuess","badPartGuess","segmentProcessingTime","segmentProcessingThroughput","Vhs$1","toTitleCase","bufferTypes","_updating","sourceBuffer","queuePending","shiftQueue","queueIndex","queueEntry","nextQueueIndexOfType","cleanupBuffer","titleType","inSourceBuffers","sourceBuffers","actions","onError","_duration","mime","addSourceBuffer","removeSourceBuffer","changeType","pushQueue","onUpdateend","SourceUpdater","sourceopenListener_","audioTimestampOffset_","videoTimestampOffset_","delayedAudioAppendQueue_","videoAppendQueued_","onVideoUpdateEnd_","onAudioUpdateEnd_","onVideoError_","videoError_","onAudioError_","audioError_","createdSourceBuffers_","initializedEme_","triggeredReady_","initializedEme","hasCreatedSourceBuffers","hasInitializedAnyEme","createSourceBuffers","addOrChangeSourceBuffers","canRemoveSourceBuffer","canChangeType","SourceBuffer","processedAppend_","videoBuffer","que","audioBuffer","bufferA","bufferB","arity","extents","bufferIntersection","setDuration","uint8ToUtf8","uintArray","escape","VTT_LINE_TERMINATORS","_char3","VTTSegmentLoader","_SegmentLoader","subtitlesTrack_","featuresNativeTextTracks_","combinedByteLength","combinedSegment","timestampOffsetForTimeline","skipEmptySegments_","stopForError","loadHandler","requested","parseVTTCues_","updateTimeMapping_","timelines","duplicates","occurrences","dupe","removeDuplicateCuesFromTrack","decodeBytesToString","timestampmap","MPEGTS","LOCAL","mapData","segmentData","mappingObj","diff","firstStart","lastStart","findAdCue","mediaTime","adStartTime","adEndTime","syncPointStrategies","run","timelineToDatetimeMappings","lastDistance","datetimeMapping","z","discontinuitySync","discontinuities","SyncController","syncPoints","runStrategies_","selectSyncPoint_","getExpiredTime","strategy","bestSyncPoint","bestDistance","bestStrategy","newDistance","lastRemovedSegment","firstSegment","playlistTimestamp","didCalculateSegmentTimeMapping","calculateSegmentTimeMapping_","saveDiscontinuitySyncInfo_","dateTime","accuracy","mediaIndexDiff","TimelineChangeController","pendingTimelineChanges_","lastTimelineChanges_","workerCode","basedir","require","commonjsRequire","createClass","_defineProperties","Constructor","protoProps","staticProps","__esModule","aesTables","AES","tmp","xInv","x2","x4","tEnc","tDec","tables","encTable","decTable","sbox","sboxInv","th","precompute","_tables","keyLen","rcon","encKey","decKey","encrypted0","encrypted1","encrypted2","encrypted3","out","a2","c2","nInnerRounds","kIndex","table0","table1","table2","table3","AsyncStream","jobs","timeout_","processJob_","job","ntoh","word","Decrypter","initVector","STEP","encrypted32","Int32Array","asyncStream_","decryptChunk_","padded","init0","init1","init2","init3","wordIx","decipher","decrypted32","audioTrackKind_","stopLoaders","segmentLoader","activePlaylistLoader","startLoaders","playlistLoader","segmentLoaders","blacklistCurrentPlaylist","activeTrack","activeGroup","defaultTrack","onTrackChanged","setupListeners","requestOptions","initialize","_settings$mediaTypes$","variantLabel","isMasterPlaylist","_settings$mediaTypes$2","_settings$mediaTypes$3","newProps","groupMatch","setupMediaGroups","_settings$segmentLoad3","audioSegmentLoader","mainSegmentLoader","variants","groupKeys","groupPropertyList","onGroupChanged","_settings$segmentLoad","getActiveGroup","previousActiveLoader","lastGroup","lastGroup_","lastTrack_","onGroupChanging","_settings$segmentLoad2","lastTrack","mpc","selectPlaylist","fastQualityChange_","activeTrack_","onAudioTrackChanged","loaderStats","sumLoaderStat","stat","audioSegmentLoader_","mainSegmentLoader_","MasterPlaylistController","externVhs","useCueTags","enableLowInitialPlaylist","experimentalBufferBasedABR","maxPlaylistRetries","useCueTags_","cueTagsTrack_","requestOptions_","pauseLoading","mediaTypes_","createMediaTypes","handleDurationChange_","handleSourceOpen_","handleSourceEnded_","segmentLoaderSettings","setupMasterPlaylistLoaderListeners_","subtitleSegmentLoader_","setupSegmentLoaderListeners_","startABRTimer_","stopABRTimer_","triggeredFmp4Usage","loadOnPlay_","timeToLoadedData__","mainAppendsToLoadedData__","audioAppendsToLoadedData__","timeToLoadedDataStart","mainAppendsToLoadedData_","audioAppendsToLoadedData_","appendsToLoadedData_","timeToLoadedData_","checkABR_","nextPlaylist","shouldSwitchToMedia_","switchMedia_","newId","abrTimer_","defaultPlaylists","defaultGroup","requestTimeout","triggerPresenceUsage_","setupFirstPlay","updatedPlaylist","selectedMedia","excludeUnsupportedVariants_","selectInitialPlaylist","initialMedia_","handleUpdatedMediaPlaylist","lastExcludeReason_","stuckAtPlaylistEnd_","updateAdCues_","updateDuration","defaultDemuxed","audioGroupKeys","currentPlaylist","bufferLowWaterLine","bufferHighWaterLine","sharedLogLine","isBuffered","forwardBuffer","maxBufferLowWaterLine","nextBandwidth","currBandwidth","logLine","_logLine","shouldSwitchToMedia","onSyncInfoUpdate_","onEndOfStream","delegateLoaders_","updateCodecs","tryToCreateSourceBuffers_","getCodecsOrExclude_","mediaSecondsLoaded_","smoothQualityChange_","mainMediaInfo","absolutePlaylistEnd","reincluded","errorMessage","delayDuration","fnNames","loaders","dontFilterPlaylist","loader","audioSeekable","mainSeekable","oldEnd","oldStart","updateDuration_","areMediaTypesKnown_","usingAudioLoader","hasMainMediaInfo","hasAudioMediaInfo","playlistCodecs","unsupportedAudio","unsupportedCodecs","supporter","switchMessages","newCodec","oldCodec","excludeIncompatibleVariants_","ids","unsupported","codecCount_","videoDetails","audioDetails","blacklistReasons","variantCodecs","variantCodecCount","variantVideoDetails","variantAudioDetails","_segment$cueOutCont$s","adOffset","adTotal","updateAdCues","newMax","Representation","vhsHandler","playlistID","changePlaylistFn","qualityChangeFunction","smoothQualityChange","incompatible","currentlyEnabled","timerCancelEvents","PlaybackWatcher","allowSeeksWithinUnsafeLiveWindow","liveRangeSafeTimeDelta","consecutiveUpdates","lastRecordedTime","timer_","checkCurrentTimeTimeout_","playHandler","monitorCurrentTime_","canPlayHandler","waitingHandler","techWaiting_","cancelTimerHandler","cancelTimer_","loaderTypes","loaderChecks","resetSegmentDownloads_","updateend","checkSegmentDownloads_","setSeekingHandlers","seekingAppendCheck_","fixesBadSeeks_","clearSeekingAppendCheck_","watchForBadSeeking_","checkCurrentTime_","isBufferedDifferent","isRangeDifferent","playlistId","waiting_","afterSeekableWindow_","beforeSeekableWindow_","minAppendedDuration","bufferedToCheck","nextRange","livePoint","videoUnderflow_","difference","skipTheGap_","allowedEnd","gap","lastVideoRange","videoRange","audioRange","gapFromVideoUnderflow_","scheduledCurrentTime","gaps","findGaps","defaultOptions","errorInterval","getSource","IWillNotUseThisInPlugins","initPlugin","lastCalled","localOptions","loadedMetadataHandler","cleanupEvents","reloadSourceOnError","STANDARD_PLAYLIST_SELECTOR","INITIAL_PLAYLIST_SELECTOR","movingAverageBandwidthSelector","decay","average","lastSystemBandwidth","comparePlaylistResolution","leftWidth","rightWidth","handleVhsMediaChange","qualityLevels","selectedIndex_","waitForKeySessionCreation","sourceKeySystems","audioMedia","mainPlaylists","initializeMediaKeys","keySystemsOptionsArr","keySystems","keySystemsArr","keySystemsOptions","keySystemsObj","keySystemOptions","getAllPsshKeySystemsOptions","initializationFinishedPromises","keySessionCreatedPromises","race","setupEmeOptions","sourceOptions","audioPlaylist","videoContentType","audioContentType","keySystemContentTypes","emeKeySystems","getVhsLocalStorage","storedObject","supportsNativeHls","canItPlay","supportsNativeDash","supportsTypeNatively","VhsHandler","hls","initialBandwidth","source_","ignoreNextSeekingEvent_","setOptions_","overrideNative","featuresNativeVideoTracks","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","useBandwidthFromLocalStorage","useNetworkInformationApi","option","dataUri","playbackWatcherOptions","playbackWatcher_","defaultSelector","playerBandwidthEst","networkInformation","connection","mozConnection","webkitConnection","networkInfoBandwidthEstBitsPerSec","downlink","invThroughput","invBandwidth","mediaRequests_","mediaRequestsAborted_","mediaRequestsTimedout_","mediaRequestsErrored_","mediaTransferDuration_","mediaBytesTransferred_","mediaAppends_","mainAppendsToLoadedData","audioAppendsToLoadedData","appendsToLoadedData","timeToLoadedData","currentTech","playerDimensions","objectToStore","updateVhsLocalStorage","setupEme_","setupQualityLevels_","mediaSourceUrl_","createKeySessions_","audioPlaylistLoader","handleWaitingForKey_","didSetupEmeOptions","masterPlaylist","_videojs$log","excludedHDPlaylists","qualityLevels_","addQualityLevel","dash","convertToProgramTime","VhsSourceHandler","_videojs$mergeOptions","_videojs$mergeOptions2","_videojs$mergeOptions3","_videojs$mergeOptions4","_videojs$mergeOptions5","legacyOverrideNative","supportedType"],"mappings":"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"}