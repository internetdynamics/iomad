{"version":3,"file":"message_drawer_view_conversation_patcher.min.js","sources":["../src/message_drawer_view_conversation_patcher.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * This module will take 2 view states from the message_drawer_view_conversation\r\n * module and generate a patch that can be given to the\r\n * message_drawer_view_conversation_renderer module to update the UI.\r\n *\r\n * This module should never modify either state. It's purely a read only\r\n * module.\r\n *\r\n * @module     core_message/message_drawer_view_conversation_patcher\r\n * @copyright  2018 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(\r\n[\r\n    'jquery',\r\n    'core/user_date',\r\n    'core_message/message_drawer_view_conversation_constants'\r\n],\r\nfunction(\r\n    $,\r\n    UserDate,\r\n    Constants\r\n) {\r\n    /**\r\n     * Sort messages by day.\r\n     *\r\n     * @param  {Array} messages The list of messages to sort.\r\n     * @param  {Number} midnight User's midnight timestamp.\r\n     * @return {Array} messages sorted by day.\r\n     */\r\n    var sortMessagesByDay = function(messages, midnight) {\r\n        var messagesByDay = messages.reduce(function(carry, message) {\r\n            var timeCreated = message.timeCreated ? message.timeCreated : midnight;\r\n            var dayTimestamp = UserDate.getUserMidnightForTimestamp(timeCreated, midnight);\r\n\r\n            if (carry.hasOwnProperty(dayTimestamp)) {\r\n                carry[dayTimestamp].push(message);\r\n            } else {\r\n                carry[dayTimestamp] = [message];\r\n            }\r\n\r\n            return carry;\r\n        }, {});\r\n\r\n        return Object.keys(messagesByDay).map(function(dayTimestamp) {\r\n            return {\r\n                timestamp: dayTimestamp,\r\n                messages: messagesByDay[dayTimestamp]\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Diff 2 arrays using a match function\r\n     *\r\n     * @param  {Array} a The first array.\r\n     * @param  {Array} b The second array.\r\n     * @param  {Function} matchFunction Function used for matching array items.\r\n     * @return {Object} Object containing array items missing from a, array items missing from b\r\n     * and matches\r\n     */\r\n    var diffArrays = function(a, b, matchFunction) {\r\n        // Make copy of it.\r\n        b = b.slice();\r\n        var missingFromA = [];\r\n        var missingFromB = [];\r\n        var matches = [];\r\n\r\n        a.forEach(function(current) {\r\n            var found = false;\r\n            var index = 0;\r\n\r\n            for (; index < b.length; index++) {\r\n                var next = b[index];\r\n\r\n                if (matchFunction(current, next)) {\r\n                    found = true;\r\n                    matches.push({\r\n                        a: current,\r\n                        b: next\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (found) {\r\n                // This day has been processed so removed it from the list.\r\n                b.splice(index, 1);\r\n            } else {\r\n                // If we couldn't find it in the next messages then it means\r\n                // it needs to be added.\r\n                missingFromB.push(current);\r\n            }\r\n        });\r\n\r\n        missingFromA = b;\r\n\r\n        return {\r\n            missingFromA: missingFromA,\r\n            missingFromB: missingFromB,\r\n            matches: matches\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Find an element in a array based on a matching function.\r\n     *\r\n     * @param  {array} array Array to search.\r\n     * @param  {Function} breakFunction Function to run on array item.\r\n     * @return {*} The array item.\r\n     */\r\n    var findPositionInArray = function(array, breakFunction) {\r\n        var before = null;\r\n\r\n        for (var i = 0; i < array.length; i++) {\r\n            var candidate = array[i];\r\n\r\n            if (breakFunction(candidate)) {\r\n                return candidate;\r\n            }\r\n        }\r\n\r\n        return before;\r\n    };\r\n\r\n    /**\r\n     * Check if 2 arrays are equal.\r\n     *\r\n     * @param  {Array} a The first array.\r\n     * @param  {Array} b The second array.\r\n     * @return {Boolean} Are arrays equal.\r\n     */\r\n    var isArrayEqual = function(a, b) {\r\n        // Make shallow copies so that we don't mess with the array sorting.\r\n        a = a.slice();\r\n        b = b.slice();\r\n        a.sort();\r\n        b.sort();\r\n        var aLength = a.length;\r\n        var bLength = b.length;\r\n\r\n        if (aLength < 1 && bLength < 1) {\r\n            return true;\r\n        }\r\n\r\n        if (aLength != bLength) {\r\n            return false;\r\n        }\r\n\r\n        return a.every(function(item, index) {\r\n            return item == b[index];\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Do a shallow check to see if two objects appear to be equal. This should\r\n     * only be used for pretty basic objects.\r\n     *\r\n     * @param {Object} a First object to compare.\r\n     * @param {Object} b Second object to compare\r\n     * @return {Bool}\r\n     */\r\n    var isObjectEqual = function(a, b) {\r\n        var aKeys = Object.keys(a);\r\n        var bKeys = Object.keys(b);\r\n\r\n        if (aKeys.length != bKeys.length) {\r\n            return false;\r\n        }\r\n\r\n        return aKeys.every(function(key) {\r\n            var aVal = a[key];\r\n            var bVal = b[key];\r\n            var aType = typeof aVal;\r\n            var bType = typeof bVal;\r\n            aType = (aVal === null) ? 'null' : aType;\r\n            bType = (aVal === null) ? 'null' : bType;\r\n            aType = (aType === 'object' && Array.isArray(aType)) ? 'array' : aType;\r\n            bType = (bType === 'object' && Array.isArray(bType)) ? 'array' : bType;\r\n\r\n            if (aType !== bType) {\r\n                return false;\r\n            }\r\n\r\n            switch (aType) {\r\n                case 'object':\r\n                    return isObjectEqual(aVal, bVal);\r\n                case 'array':\r\n                    return isArrayEqual(aVal, bVal);\r\n                default:\r\n                    return a[key] == b[key];\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Compare two messages to check if they are equal. This function only checks a subset\r\n     * of the message properties which we know will change rather than all properties.\r\n     *\r\n     * @param {Object} a The first message\r\n     * @param {Object} b The second message\r\n     * @return {Bool}\r\n     */\r\n    var isMessageEqual = function(a, b) {\r\n        return isObjectEqual(\r\n            {\r\n                id: a.id,\r\n                state: a.sendState,\r\n                text: a.text,\r\n                timeCreated: a.timeCreated\r\n            },\r\n            {\r\n                id: b.id,\r\n                state: b.sendState,\r\n                text: b.text,\r\n                timeCreated: b.timeCreated\r\n            }\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Build a patch based on days.\r\n     *\r\n     * @param  {Object} current Current list current items.\r\n     * @param  {Array} remove List of days to remove.\r\n     * @param  {Array} add List of days to add.\r\n     * @return {Object} Patch with elements to add and remove.\r\n     */\r\n    var buildDaysPatch = function(current, remove, add) {\r\n        return {\r\n            remove: remove,\r\n            add: add.map(function(day) {\r\n                // Any days left over in the \"next\" list weren't in the \"current\" list\r\n                // so they will need to be added.\r\n                var before = findPositionInArray(current, function(candidate) {\r\n                    return day.timestamp < candidate.timestamp;\r\n                });\r\n\r\n                return {\r\n                    before: before,\r\n                    value: day\r\n                };\r\n            })\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Build the messages patch for each day.\r\n     *\r\n     * @param {Array} matchingDays Array of old and new messages sorted by day.\r\n     * @return {Object} patch.\r\n     */\r\n    var buildMessagesPatch = function(matchingDays) {\r\n        var remove = [];\r\n        var add = [];\r\n        var update = [];\r\n\r\n        // Iterate over the list of days and determine which messages in those days\r\n        // have been changed.\r\n        matchingDays.forEach(function(days) {\r\n            var dayCurrent = days.a;\r\n            var dayNext = days.b;\r\n            // Find out which messages have changed in this day. This will return a list of messages\r\n            // from the current state that couldn't be found in the next state and a list of messages in\r\n            // the next state which couldn't be count in the current state.\r\n            var messagesDiff = diffArrays(dayCurrent.messages, dayNext.messages, isMessageEqual);\r\n            // Take the two arrays (list of messages changed from dayNext and list of messages changed\r\n            // from dayCurrent) any work out which messages have been added/removed from the list and\r\n            // which messages were just updated.\r\n            var patch = diffArrays(\r\n                // The messages from dayCurrent.message that weren't in dayNext.messages.\r\n                messagesDiff.missingFromB,\r\n                // The messages from dayNext.message that weren't in dayCurrent.messages.\r\n                messagesDiff.missingFromA,\r\n                function(a, b) {\r\n                    // This function is going to determine if the messages were\r\n                    // added/removed from either list or if they were simply an updated.\r\n                    //\r\n                    // If the IDs match or it was a state change (i.e. message with a temp\r\n                    // ID goes from pending to sent and receives an actual id) then they are\r\n                    // the same message which should be an update not an add/remove.\r\n                    return a.id == b.id || (a.sendState != b.sendState && a.timeAdded == b.timeAdded);\r\n                }\r\n            );\r\n\r\n            // Any messages from the current state for this day which aren't in the next state\r\n            // for this day (i.e. the user deleted the message) means we need to remove them from\r\n            // the UI.\r\n            remove = remove.concat(patch.missingFromB);\r\n\r\n            // Any messages not in the current state for this day which are in the next state\r\n            // for this day (i.e. it's a new message) means we need to add it to the UI so work\r\n            // out where in the list of messages it should appear (it could be a new message the\r\n            // user has sent or older messages loaded as part of the conversation scroll back).\r\n            patch.missingFromA.forEach(function(message) {\r\n                // By default a null value for before will render the message at the bottom of\r\n                // the message UI (i.e. it's the newest message).\r\n                var before = null;\r\n\r\n                if (message.timeCreated) {\r\n                    // If this message has a time created then find where it sits in the list of\r\n                    // message to insert it into the correct position.\r\n                    before = findPositionInArray(dayCurrent.messages, function(candidate) {\r\n                        if (message.timeCreated == candidate.timeCreated) {\r\n                            return message.id < candidate.id;\r\n                        } else {\r\n                            return message.timeCreated < candidate.timeCreated;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                add.push({\r\n                    before: before,\r\n                    value: message,\r\n                    day: dayCurrent\r\n                });\r\n            });\r\n\r\n            // Any message that appears in both the current state for this day and the next state\r\n            // for this day means something in the message was updated.\r\n            update = update.concat(patch.matches.map(function(message) {\r\n                return {\r\n                    before: message.a,\r\n                    after: message.b\r\n                };\r\n            }));\r\n        });\r\n\r\n        return {\r\n            add: add,\r\n            remove: remove,\r\n            update: update\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Build a patch for this conversation.\r\n     *\r\n     * @param  {Object} state The current state of this conversation.\r\n     * @param  {Object} newState The new state of this conversation.\r\n     * @returns {Object} Patch with days and messsages for each day.\r\n     */\r\n    var buildConversationPatch = function(state, newState) {\r\n        var diff = diffArrays(state.messages, newState.messages, isMessageEqual);\r\n\r\n        if (diff.missingFromA.length || diff.missingFromB.length) {\r\n            // Some messages have changed so let's work out which ones by sorting\r\n            // them into their respective days.\r\n            var current = sortMessagesByDay(state.messages, state.midnight);\r\n            var next = sortMessagesByDay(newState.messages, newState.midnight);\r\n            // This diffs the arrays to work out if there are any missing days that need\r\n            // to be added (i.e. we've got some new messages on a new day) or if there\r\n            // are any days that need to be deleted (i.e. the user has deleted some old messages).\r\n            var daysDiff = diffArrays(current, next, function(dayCurrent, dayNext) {\r\n                return dayCurrent.timestamp == dayNext.timestamp;\r\n            });\r\n\r\n            return {\r\n                // Handle adding or removing whole days.\r\n                days: buildDaysPatch(current, daysDiff.missingFromB, daysDiff.missingFromA),\r\n                // Handle updating messages that don't require adding/removing a whole day.\r\n                messages: buildMessagesPatch(daysDiff.matches)\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the header of this conversation. Check if this conversation\r\n     * is a group conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildHeaderPatchTypePrivate = function(state, newState) {\r\n        var requireAddContact = buildRequireAddContact(state, newState);\r\n        var confirmContactRequest = buildConfirmContactRequest(state, newState);\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var requiresAddContact = requireAddContact && requireAddContact.show && !requireAddContact.hasMessages;\r\n        var requiredAddContact = requireAddContact && !requireAddContact.show;\r\n        // Render the header once we've got a user.\r\n        var shouldRenderHeader = !oldOtherUser && newOtherUser;\r\n        // We should also re-render the header if the other user requires\r\n        // being added as a contact or if they did but no longer do.\r\n        shouldRenderHeader = shouldRenderHeader || requiresAddContact || requiredAddContact;\r\n        // Finally, we should re-render if the other user has sent this user\r\n        // a contact request that is waiting for approval or if it's been approved/declined.\r\n        shouldRenderHeader = shouldRenderHeader || confirmContactRequest !== null;\r\n\r\n        if (shouldRenderHeader) {\r\n            return {\r\n                type: Constants.CONVERSATION_TYPES.PRIVATE,\r\n                // We can show controls if the other user doesn't require add contact\r\n                // and we aren't waiting for this user to respond to a contact request.\r\n                showControls: !requiresAddContact && !confirmContactRequest,\r\n                context: {\r\n                    id: newState.id,\r\n                    name: newState.name,\r\n                    subname: newState.subname,\r\n                    totalmembercount: newState.totalMemberCount,\r\n                    imageurl: newState.imageUrl,\r\n                    isfavourite: newState.isFavourite,\r\n                    ismuted: newState.isMuted,\r\n                    // Don't show favouriting if we don't have a conversation.\r\n                    showfavourite: newState.id !== null,\r\n                    userid: newOtherUser.id,\r\n                    showonlinestatus: newOtherUser.showonlinestatus,\r\n                    isonline: newOtherUser.isonline,\r\n                    isblocked: newOtherUser.isblocked,\r\n                    iscontact: newOtherUser.iscontact\r\n                }\r\n            };\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the header of this conversation. Check if this conversation\r\n     * is a group conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildHeaderPatchTypeSelf = function(state, newState) {\r\n        var shouldRenderHeader = (state.name === null && newState.name !== null);\r\n\r\n        if (shouldRenderHeader) {\r\n            return {\r\n                type: Constants.CONVERSATION_TYPES.SELF,\r\n                // Don't display the controls for the self-conversations.\r\n                showControls: false,\r\n                context: {\r\n                    id: newState.id,\r\n                    name: newState.name,\r\n                    subname: newState.subname,\r\n                    imageurl: newState.imageUrl,\r\n                    isfavourite: newState.isFavourite,\r\n                    // Don't show favouriting if we don't have a conversation.\r\n                    showfavourite: newState.id !== null,\r\n                    showonlinestatus: true,\r\n                }\r\n            };\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the header of this conversation. Check if this conversation\r\n     * is a group conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildHeaderPatchTypePublic = function(state, newState) {\r\n        var oldMemberCount = state.totalMemberCount;\r\n        var newMemberCount = newState.totalMemberCount;\r\n\r\n        if (oldMemberCount != newMemberCount) {\r\n            return {\r\n                type: Constants.CONVERSATION_TYPES.PUBLIC,\r\n                showControls: true,\r\n                context: {\r\n                    id: newState.id,\r\n                    name: newState.name,\r\n                    subname: newState.subname,\r\n                    totalmembercount: newState.totalMemberCount,\r\n                    imageurl: newState.imageUrl,\r\n                    isfavourite: newState.isFavourite,\r\n                    ismuted: newState.isMuted,\r\n                    // Don't show favouriting if we don't have a conversation.\r\n                    showfavourite: newState.id !== null\r\n                }\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find the newest or oldest message.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Number} Oldest or newest message id.\r\n     */\r\n    var buildScrollToMessagePatch = function(state, newState) {\r\n        var oldMessages = state.messages;\r\n        var newMessages = newState.messages;\r\n\r\n        if (newMessages.length < 1) {\r\n            return null;\r\n        }\r\n\r\n        if (oldMessages.length < 1) {\r\n            return newMessages[newMessages.length - 1].id;\r\n        }\r\n\r\n        var previousNewest = oldMessages[state.messages.length - 1];\r\n        var currentNewest = newMessages[newMessages.length - 1];\r\n        var previousOldest = oldMessages[0];\r\n        var currentOldest = newMessages[0];\r\n\r\n        if (previousNewest.id != currentNewest.id) {\r\n            return currentNewest.id;\r\n        } else if (previousOldest.id != currentOldest.id) {\r\n            return previousOldest.id;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if members should be loaded.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingMembersPatch = function(state, newState) {\r\n        if (!state.loadingMembers && newState.loadingMembers) {\r\n            return true;\r\n        } else if (state.loadingMembers && !newState.loadingMembers) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if the messages are being loaded for the first time.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingFirstMessages = function(state, newState) {\r\n        if (state.hasTriedToLoadMessages === newState.hasTriedToLoadMessages) {\r\n            return null;\r\n        } else if (!newState.hasTriedToLoadMessages && newState.loadingMessages) {\r\n            return true;\r\n        } else if (newState.hasTriedToLoadMessages && !newState.loadingMessages) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if the messages are still being loaded\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingMessages = function(state, newState) {\r\n        if (!state.loadingMessages && newState.loadingMessages) {\r\n            return true;\r\n        } else if (state.loadingMessages && !newState.loadingMessages) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determine if we should show the emoji picker.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildShowEmojiPicker = function(state, newState) {\r\n        if (!state.showEmojiPicker && newState.showEmojiPicker) {\r\n            return true;\r\n        } else if (state.showEmojiPicker && !newState.showEmojiPicker) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determine if we should show the emoji auto complete.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildShowEmojiAutoComplete = function(state, newState) {\r\n        if (!state.showEmojiAutoComplete && newState.showEmojiAutoComplete) {\r\n            return true;\r\n        } else if (state.showEmojiAutoComplete && !newState.showEmojiAutoComplete) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be blocked if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmBlockUser = function(state, newState) {\r\n        if (newState.pendingBlockUserIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingBlockUserIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingBlockUserIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be unblocked if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmUnblockUser = function(state, newState) {\r\n        if (newState.pendingUnblockUserIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingUnblockUserIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingUnblockUserIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be added as contact if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmAddContact = function(state, newState) {\r\n        if (newState.pendingAddContactIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingAddContactIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingAddContactIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be removed as contact if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmRemoveContact = function(state, newState) {\r\n        if (newState.pendingRemoveContactIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingRemoveContactIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingRemoveContactIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if there are any messages to be deleted.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Null} The conversation type and if the user can delete  the messages for all users.\r\n     */\r\n    var buildConfirmDeleteSelectedMessages = function(state, newState) {\r\n        var oldPendingCount = state.pendingDeleteMessageIds.length;\r\n        var newPendingCount = newState.pendingDeleteMessageIds.length;\r\n\r\n        if (newPendingCount && !oldPendingCount) {\r\n            return {\r\n                show: true,\r\n                type: newState.type,\r\n                canDeleteMessagesForAllUsers: newState.canDeleteMessagesForAllUsers\r\n            };\r\n        } else if (oldPendingCount && !newPendingCount) {\r\n            return {\r\n                show: false\r\n            };\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if there is a conversation to be deleted.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {int|Null} The conversation type to be deleted.\r\n     */\r\n    var buildConfirmDeleteConversation = function(state, newState) {\r\n        if (!state.pendingDeleteConversation && newState.pendingDeleteConversation) {\r\n            return newState.type;\r\n        } else if (state.pendingDeleteConversation && !newState.pendingDeleteConversation) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if there is a pending contact request to accept or decline.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildConfirmContactRequest = function(state, newState) {\r\n        var loggedInUserId = state.loggedInUserId;\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var oldReceivedRequests = !oldOtherUser ? [] : oldOtherUser.contactrequests.filter(function(request) {\r\n            return request.requesteduserid == loggedInUserId && request.userid == oldOtherUser.id;\r\n        });\r\n        var newReceivedRequests = !newOtherUser ? [] : newOtherUser.contactrequests.filter(function(request) {\r\n            return request.requesteduserid == loggedInUserId && request.userid == newOtherUser.id;\r\n        });\r\n        var oldRequest = oldReceivedRequests.length ? oldReceivedRequests[0] : null;\r\n        var newRequest = newReceivedRequests.length ? newReceivedRequests[0] : null;\r\n\r\n        if (!oldRequest && newRequest) {\r\n            return newOtherUser;\r\n        } else if (oldRequest && !newRequest) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes in blocked users.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildIsBlocked = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.isblocked ? true : null;\r\n        } else if (!newOtherUser && oldOtherUser) {\r\n            return oldOtherUser.isblocked ? false : null;\r\n        } else if (oldOtherUser.isblocked && !newOtherUser.isblocked) {\r\n            return false;\r\n        } else if (!oldOtherUser.isblocked && newOtherUser.isblocked) {\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes the conversation favourite state.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildIsFavourite = function(state, newState) {\r\n        var oldIsFavourite = state.isFavourite;\r\n        var newIsFavourite = newState.isFavourite;\r\n\r\n        if (state.id === null && newState.id === null) {\r\n            // The conversation isn't yet created so don't change anything.\r\n            return null;\r\n        } else if (state.id === null && newState.id !== null) {\r\n            // The conversation was created so we can show the add favourite button.\r\n            return 'show-add';\r\n        } else if (state.id !== null && newState.id === null) {\r\n            // We're changing from a created conversation to a new conversation so hide\r\n            // the favouriting functionality for now.\r\n            return 'hide';\r\n        } else if (oldIsFavourite == newIsFavourite) {\r\n            // No change.\r\n            return null;\r\n        } else if (!oldIsFavourite && newIsFavourite) {\r\n            return 'show-remove';\r\n        } else if (oldIsFavourite && !newIsFavourite) {\r\n            return 'show-add';\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes the conversation muted state.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {string|null}\r\n     */\r\n    var buildIsMuted = function(state, newState) {\r\n        var oldIsMuted = state.isMuted;\r\n        var newIsMuted = newState.isMuted;\r\n\r\n        if (state.id === null && newState.id === null) {\r\n            // The conversation isn't yet created so don't change anything.\r\n            return null;\r\n        } else if (state.id === null && newState.id !== null) {\r\n            // The conversation was created so we can show the mute button.\r\n            return 'show-mute';\r\n        } else if (state.id !== null && newState.id === null) {\r\n            // We're changing from a created conversation to a new conversation so hide\r\n            // the muting functionality for now.\r\n            return 'hide';\r\n        } else if (oldIsMuted == newIsMuted) {\r\n            // No change.\r\n            return null;\r\n        } else if (!oldIsMuted && newIsMuted) {\r\n            return 'show-unmute';\r\n        } else if (oldIsMuted && !newIsMuted) {\r\n            return 'show-mute';\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes in the contact status of the current user\r\n     * and other user.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildIsContact = function(state, newState) {\r\n        var loggedInUserId = state.loggedInUserId;\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var oldContactRequests = !oldOtherUser ? [] : oldOtherUser.contactrequests.filter(function(request) {\r\n            return (request.userid == loggedInUserId && request.requesteduserid == oldOtherUser.id) ||\r\n                (request.userid == oldOtherUser.id && request.requesteduserid == loggedInUserId);\r\n        });\r\n        var newContactRequests = !newOtherUser ? [] : newOtherUser.contactrequests.filter(function(request) {\r\n            return (request.userid == loggedInUserId && request.requesteduserid == newOtherUser.id) ||\r\n                (request.userid == newOtherUser.id && request.requesteduserid == loggedInUserId);\r\n        });\r\n        var oldHasContactRequests = oldContactRequests.length > 0;\r\n        var newHasContactRequests = newContactRequests.length > 0;\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (oldHasContactRequests && newHasContactRequests) {\r\n            return null;\r\n        } else if (!oldHasContactRequests && newHasContactRequests && !newOtherUser.iscontact) {\r\n            return 'pending-contact';\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.iscontact ? 'contact' : null;\r\n        } else if (!newOtherUser && oldOtherUser) {\r\n            return oldOtherUser.iscontact ? 'non-contact' : null;\r\n        } else if (oldOtherUser.iscontact && !newOtherUser.iscontact) {\r\n            return newHasContactRequests ? 'pending-contact' : 'non-contact';\r\n        } else if (!oldOtherUser.iscontact && newOtherUser.iscontact) {\r\n            return 'contact';\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if a confirm action is active.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingConfirmationAction = function(state, newState) {\r\n        if (!state.loadingConfirmAction && newState.loadingConfirmAction) {\r\n            return true;\r\n        } else if (state.loadingConfirmAction && !newState.loadingConfirmAction) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if a edit mode is active.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildInEditMode = function(state, newState) {\r\n        var oldHasSelectedMessages = state.selectedMessageIds.length > 0;\r\n        var newHasSelectedMessages = newState.selectedMessageIds.length > 0;\r\n        var numberOfMessagesHasChanged = state.messages.length != newState.messages.length;\r\n\r\n        if (!oldHasSelectedMessages && newHasSelectedMessages) {\r\n            return true;\r\n        } else if (oldHasSelectedMessages && !newHasSelectedMessages) {\r\n            return false;\r\n        } else if (oldHasSelectedMessages && numberOfMessagesHasChanged) {\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the messages selected.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildSelectedMessages = function(state, newState) {\r\n        var oldSelectedMessages = state.selectedMessageIds;\r\n        var newSelectedMessages = newState.selectedMessageIds;\r\n\r\n        if (isArrayEqual(oldSelectedMessages, newSelectedMessages)) {\r\n            return null;\r\n        }\r\n\r\n        var diff = diffArrays(oldSelectedMessages, newSelectedMessages, function(a, b) {\r\n            return a == b;\r\n        });\r\n\r\n        return {\r\n            count: newSelectedMessages.length,\r\n            add: diff.missingFromA,\r\n            remove: diff.missingFromB\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Get a list of users from the state that are not the logged in user. Use to find group\r\n     * message members or the other user in a conversation.\r\n     *\r\n     * @param  {Object} state State\r\n     * @return {Array} List of users.\r\n     */\r\n    var getOtherUserFromState = function(state) {\r\n        return Object.keys(state.members).reduce(function(carry, userId) {\r\n            if (userId != state.loggedInUserId && !carry) {\r\n                carry = state.members[userId];\r\n            }\r\n\r\n            return carry;\r\n        }, null);\r\n    };\r\n\r\n    /**\r\n     * Check if the given user requires a contact request from the logged in user.\r\n     *\r\n     * @param  {Integer} loggedInUserId The logged in user id\r\n     * @param  {Object} user User record\r\n     * @return {Bool}\r\n     */\r\n    var requiresContactRequest = function(loggedInUserId, user) {\r\n        // If a user can message then no contact request is required.\r\n        if (user.canmessage) {\r\n            return false;\r\n        }\r\n\r\n        var contactRequests = user.contactrequests.filter(function(request) {\r\n            return request.userid == loggedInUserId || request.requesteduserid;\r\n        });\r\n        var hasSentContactRequest = contactRequests.length > 0;\r\n        return user.requirescontact && !user.iscontact && !hasSentContactRequest;\r\n    };\r\n\r\n    /**\r\n     * Check if other users are required to be added as contact.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} Object controlling the required to add contact dialog variables.\r\n     */\r\n    var buildRequireAddContact = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var hadMessages = state.messages.length > 0;\r\n        var hasMessages = newState.messages.length > 0;\r\n        var loggedInUserId = newState.loggedInUserId;\r\n        var prevRequiresContactRequest = oldOtherUser && requiresContactRequest(loggedInUserId, oldOtherUser);\r\n        var nextRequiresContactRequest = newOtherUser && requiresContactRequest(loggedInUserId, newOtherUser);\r\n        var confirmAddContact = buildConfirmAddContact(state, newState);\r\n        var finishedAddContact = confirmAddContact === false;\r\n\r\n        // Still doing first load.\r\n        if (!state.hasTriedToLoadMessages && !newState.hasTriedToLoadMessages) {\r\n            return null;\r\n        }\r\n\r\n        // No users yet.\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        }\r\n\r\n        // We've loaded a new user and they require a contact request.\r\n        if (!oldOtherUser && nextRequiresContactRequest) {\r\n            return {\r\n                show: true,\r\n                hasMessages: hasMessages,\r\n                user: newOtherUser\r\n            };\r\n        }\r\n\r\n        // The logged in user has completed the confirm contact request dialogue\r\n        // but the other user still requires a contact request which means the logged\r\n        // in user either declined the confirmation or it failed.\r\n        if (finishedAddContact && nextRequiresContactRequest) {\r\n            return {\r\n                show: true,\r\n                hasMessages: hasMessages,\r\n                user: newOtherUser\r\n            };\r\n        }\r\n\r\n        // Everything is loaded.\r\n        if (state.hasTriedToLoadMessages && newState.hasTriedToLoadMessages) {\r\n            if (!prevRequiresContactRequest && nextRequiresContactRequest) {\r\n                return {\r\n                    show: true,\r\n                    hasMessages: hasMessages,\r\n                    user: newOtherUser\r\n                };\r\n            }\r\n\r\n            if (prevRequiresContactRequest && !nextRequiresContactRequest) {\r\n                return {\r\n                    show: false,\r\n                    hasMessages: hasMessages\r\n                };\r\n            }\r\n        }\r\n\r\n        // First load just completed.\r\n        if (!state.hasTriedToLoadMessages && newState.hasTriedToLoadMessages) {\r\n            if (nextRequiresContactRequest) {\r\n                return {\r\n                    show: true,\r\n                    hasMessages: hasMessages,\r\n                    user: newOtherUser\r\n                };\r\n            }\r\n        }\r\n\r\n        // Being reset.\r\n        if (state.hasTriedToLoadMessages && !newState.hasTriedToLoadMessages) {\r\n            if (prevRequiresContactRequest) {\r\n                return {\r\n                    show: false,\r\n                    hasMessages: hadMessages\r\n                };\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if other users are required to be unblocked.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildRequireUnblock = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (oldOtherUser && !newOtherUser) {\r\n            return oldOtherUser.isblocked ? false : null;\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.isblocked ? true : null;\r\n        } else if (!oldOtherUser.isblocked && newOtherUser.isblocked) {\r\n            return true;\r\n        } else if (oldOtherUser.isblocked && !newOtherUser.isblocked) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if other users can be messaged.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildUnableToMessage = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n\r\n        if (newState.type == Constants.CONVERSATION_TYPES.SELF) {\r\n            // Users always can send message themselves on self-conversations.\r\n            return null;\r\n        }\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (oldOtherUser && !newOtherUser) {\r\n            return oldOtherUser.canmessage ? null : true;\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.canmessage ? null : true;\r\n        } else if (!oldOtherUser.canmessage && newOtherUser.canmessage) {\r\n            return false;\r\n        } else if (oldOtherUser.canmessage && !newOtherUser.canmessage) {\r\n            return true;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Build patch for footer information for a private conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} containing footer state type.\r\n     */\r\n    var buildFooterPatchTypePrivate = function(state, newState) {\r\n        var loadingFirstMessages = buildLoadingFirstMessages(state, newState);\r\n        var inEditMode = buildInEditMode(state, newState);\r\n        var requireAddContact = buildRequireAddContact(state, newState);\r\n        var requireUnblock = buildRequireUnblock(state, newState);\r\n        var unableToMessage = buildUnableToMessage(state, newState);\r\n        var showRequireAddContact = requireAddContact !== null ? requireAddContact.show && requireAddContact.hasMessages : null;\r\n        var otherUser = getOtherUserFromState(newState);\r\n        var generateReturnValue = function(checkValue, successReturn) {\r\n            if (checkValue) {\r\n                return successReturn;\r\n            } else if (checkValue !== null && !checkValue) {\r\n                if (!otherUser) {\r\n                    return {type: 'content'};\r\n                } else if (otherUser.isblocked) {\r\n                    return {type: 'unblock'};\r\n                } else if (newState.messages.length && requiresContactRequest(newState.loggedInUserId, otherUser)) {\r\n                    return {\r\n                        type: 'add-contact',\r\n                        user: otherUser\r\n                    };\r\n                } else if (!otherUser.canmessage && (otherUser.requirescontact && !otherUser.iscontact)) {\r\n                    return {type: 'unable-to-message'};\r\n                }\r\n            }\r\n\r\n            return null;\r\n        };\r\n\r\n        if (\r\n            loadingFirstMessages === null &&\r\n            inEditMode === null &&\r\n            requireAddContact === null &&\r\n            requireUnblock === null\r\n        ) {\r\n            return null;\r\n        }\r\n\r\n        var checks = [\r\n            [loadingFirstMessages, {type: 'placeholder'}],\r\n            [inEditMode, {type: 'edit-mode'}],\r\n            [unableToMessage, {type: 'unable-to-message'}],\r\n            [requireUnblock, {type: 'unblock'}],\r\n            [showRequireAddContact, {type: 'add-contact', user: otherUser}]\r\n        ];\r\n\r\n        for (var i = 0; i < checks.length; i++) {\r\n            var checkValue = checks[i][0];\r\n            var successReturn = checks[i][1];\r\n            var result = generateReturnValue(checkValue, successReturn);\r\n\r\n            if (result !== null) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return {\r\n            type: 'content'\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Build patch for footer information for a public conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} containing footer state type.\r\n     */\r\n    var buildFooterPatchTypePublic = function(state, newState) {\r\n        var loadingFirstMessages = buildLoadingFirstMessages(state, newState);\r\n        var inEditMode = buildInEditMode(state, newState);\r\n\r\n        if (loadingFirstMessages === null && inEditMode === null) {\r\n            return null;\r\n        }\r\n\r\n        if (loadingFirstMessages) {\r\n            return {type: 'placeholder'};\r\n        }\r\n\r\n        if (inEditMode) {\r\n            return {type: 'edit-mode'};\r\n        }\r\n\r\n        return {\r\n            type: 'content'\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Check if we're viewing a different conversation. If so then we need to\r\n     * reset the UI.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {bool|null} If a reset needs to occur\r\n     */\r\n    var buildReset = function(state, newState) {\r\n        var oldType = state.type;\r\n        var newType = newState.type;\r\n        var oldConversationId = state.id;\r\n        var newConversationId = newState.id;\r\n        var oldMemberIds = Object.keys(state.members);\r\n        var newMemberIds = Object.keys(newState.members);\r\n\r\n        oldMemberIds.sort();\r\n        newMemberIds.sort();\r\n\r\n        var membersUnchanged = oldMemberIds.every(function(id, index) {\r\n            return id == newMemberIds[index];\r\n        });\r\n\r\n        if (oldType != newType) {\r\n            // If we've changed conversation type then we need to reset.\r\n            return true;\r\n        } else if (oldConversationId && !newConversationId) {\r\n            // We previously had a conversation id but no longer do. This likely means\r\n            // the user is viewing the conversation with someone they've never spoken to\r\n            // before.\r\n            return true;\r\n        } else if (oldConversationId && newConversationId && oldConversationId != newConversationId) {\r\n            // If we had a conversation id and it's changed then we need to reset.\r\n            return true;\r\n        } else if (!oldConversationId && !newConversationId && !membersUnchanged) {\r\n            // If we never had a conversation id but the members of the conversation have\r\n            // changed then we need to reset. This can happen if the user goes from viewing\r\n            // a user they've never had a conversation with to viewing a different user that\r\n            // they've never had a conversation with.\r\n            return true;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * We should show this message always, for all the self-conversations.\r\n     *\r\n     * The message should be hidden when it's not a self-conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {bool}\r\n     */\r\n    var buildSelfConversationMessage = function(state, newState) {\r\n        if (state.type != newState.type) {\r\n            return (newState.type == Constants.CONVERSATION_TYPES.SELF);\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * We should show the contact request sent message if the user just sent\r\n     * a contact request to the other user\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {string|false|null}\r\n     */\r\n    var buildContactRequestSent = function(state, newState) {\r\n        var loggedInUserId = newState.loggedInUserId;\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var oldSentRequests = !oldOtherUser ? [] : oldOtherUser.contactrequests.filter(function(request) {\r\n            return request.userid == loggedInUserId;\r\n        });\r\n        var newSentRequests = !newOtherUser ? [] : newOtherUser.contactrequests.filter(function(request) {\r\n            return request.userid == loggedInUserId;\r\n        });\r\n        var oldRequest = oldSentRequests.length > 0;\r\n        var newRequest = newSentRequests.length > 0;\r\n\r\n        if (!oldRequest && newRequest && !newOtherUser.iscontact) {\r\n            return newOtherUser.fullname;\r\n        } else if (oldOtherUser && !oldOtherUser.iscontact && newRequest && newOtherUser.iscontact) {\r\n            // Contact request accepted.\r\n            return false;\r\n        } else if (oldRequest && !newRequest) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Build the full patch comparing the current state and the new state. This patch is used by\r\n     * the conversation renderer to render the UI on any update.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} Patch containing all information changed.\r\n     */\r\n    var buildPatch = function(state, newState) {\r\n        var config = {\r\n            all: {\r\n                reset: buildReset,\r\n                conversation: buildConversationPatch,\r\n                scrollToMessage: buildScrollToMessagePatch,\r\n                loadingMembers: buildLoadingMembersPatch,\r\n                loadingFirstMessages: buildLoadingFirstMessages,\r\n                loadingMessages: buildLoadingMessages,\r\n                confirmDeleteSelectedMessages: buildConfirmDeleteSelectedMessages,\r\n                inEditMode: buildInEditMode,\r\n                selectedMessages: buildSelectedMessages,\r\n                isFavourite: buildIsFavourite,\r\n                isMuted: buildIsMuted,\r\n                showEmojiPicker: buildShowEmojiPicker,\r\n                showEmojiAutoComplete: buildShowEmojiAutoComplete\r\n            }\r\n        };\r\n        // These build functions are only applicable to private conversations.\r\n        config[Constants.CONVERSATION_TYPES.PRIVATE] = {\r\n            header: buildHeaderPatchTypePrivate,\r\n            footer: buildFooterPatchTypePrivate,\r\n            confirmBlockUser: buildConfirmBlockUser,\r\n            confirmUnblockUser: buildConfirmUnblockUser,\r\n            confirmAddContact: buildConfirmAddContact,\r\n            confirmRemoveContact: buildConfirmRemoveContact,\r\n            confirmContactRequest: buildConfirmContactRequest,\r\n            confirmDeleteConversation: buildConfirmDeleteConversation,\r\n            isBlocked: buildIsBlocked,\r\n            isContact: buildIsContact,\r\n            loadingConfirmAction: buildLoadingConfirmationAction,\r\n            requireAddContact: buildRequireAddContact,\r\n            contactRequestSent: buildContactRequestSent\r\n        };\r\n        // These build functions are only applicable to public (group) conversations.\r\n        config[Constants.CONVERSATION_TYPES.PUBLIC] = {\r\n            header: buildHeaderPatchTypePublic,\r\n            footer: buildFooterPatchTypePublic,\r\n        };\r\n        // These build functions are only applicable to self-conversations.\r\n        config[Constants.CONVERSATION_TYPES.SELF] = {\r\n            header: buildHeaderPatchTypeSelf,\r\n            footer: buildFooterPatchTypePublic,\r\n            confirmDeleteConversation: buildConfirmDeleteConversation,\r\n            selfConversationMessage: buildSelfConversationMessage\r\n        };\r\n\r\n        var patchConfig = $.extend({}, config.all);\r\n        if (newState.type && newState.type in config) {\r\n            // Add the type specific builders to the patch config.\r\n            patchConfig = $.extend(patchConfig, config[newState.type]);\r\n        }\r\n\r\n        return Object.keys(patchConfig).reduce(function(patch, key) {\r\n            var buildFunc = patchConfig[key];\r\n            var value = buildFunc(state, newState);\r\n\r\n            if (value !== null) {\r\n                patch[key] = value;\r\n            }\r\n\r\n            return patch;\r\n        }, {});\r\n    };\r\n\r\n    return {\r\n        buildPatch: buildPatch\r\n    };\r\n});\r\n"],"names":["define","$","UserDate","Constants","sortMessagesByDay","messages","midnight","messagesByDay","reduce","carry","message","timeCreated","dayTimestamp","getUserMidnightForTimestamp","hasOwnProperty","push","Object","keys","map","timestamp","diffArrays","a","b","matchFunction","slice","missingFromB","matches","forEach","current","found","index","length","next","splice","missingFromA","findPositionInArray","array","breakFunction","i","candidate","isArrayEqual","sort","aLength","bLength","every","item","isObjectEqual","aKeys","bKeys","key","aVal","bVal","aType","bType","Array","isArray","isMessageEqual","id","state","sendState","text","buildDaysPatch","remove","add","day","before","value","buildConversationPatch","newState","matchingDays","update","diff","daysDiff","dayCurrent","dayNext","days","messagesDiff","patch","timeAdded","concat","after","buildHeaderPatchTypePrivate","requireAddContact","buildRequireAddContact","confirmContactRequest","buildConfirmContactRequest","oldOtherUser","getOtherUserFromState","newOtherUser","requiresAddContact","show","hasMessages","requiredAddContact","shouldRenderHeader","type","CONVERSATION_TYPES","PRIVATE","showControls","context","name","subname","totalmembercount","totalMemberCount","imageurl","imageUrl","isfavourite","isFavourite","ismuted","isMuted","showfavourite","userid","showonlinestatus","isonline","isblocked","iscontact","buildHeaderPatchTypeSelf","SELF","buildHeaderPatchTypePublic","PUBLIC","buildScrollToMessagePatch","oldMessages","newMessages","previousNewest","currentNewest","previousOldest","currentOldest","buildLoadingMembersPatch","loadingMembers","buildLoadingFirstMessages","hasTriedToLoadMessages","loadingMessages","buildLoadingMessages","buildShowEmojiPicker","showEmojiPicker","buildShowEmojiAutoComplete","showEmojiAutoComplete","buildConfirmBlockUser","pendingBlockUserIds","userId","members","buildConfirmUnblockUser","pendingUnblockUserIds","buildConfirmAddContact","pendingAddContactIds","buildConfirmRemoveContact","pendingRemoveContactIds","buildConfirmDeleteSelectedMessages","oldPendingCount","pendingDeleteMessageIds","newPendingCount","canDeleteMessagesForAllUsers","buildConfirmDeleteConversation","pendingDeleteConversation","loggedInUserId","oldReceivedRequests","contactrequests","filter","request","requesteduserid","newReceivedRequests","oldRequest","newRequest","buildIsBlocked","buildIsFavourite","oldIsFavourite","newIsFavourite","buildIsMuted","oldIsMuted","newIsMuted","buildIsContact","oldContactRequests","newContactRequests","oldHasContactRequests","newHasContactRequests","buildLoadingConfirmationAction","loadingConfirmAction","buildInEditMode","oldHasSelectedMessages","selectedMessageIds","newHasSelectedMessages","numberOfMessagesHasChanged","buildSelectedMessages","oldSelectedMessages","newSelectedMessages","count","requiresContactRequest","user","canmessage","hasSentContactRequest","requirescontact","hadMessages","prevRequiresContactRequest","nextRequiresContactRequest","finishedAddContact","buildFooterPatchTypePrivate","loadingFirstMessages","inEditMode","requireUnblock","buildRequireUnblock","unableToMessage","buildUnableToMessage","showRequireAddContact","otherUser","generateReturnValue","checkValue","successReturn","checks","result","buildFooterPatchTypePublic","buildReset","oldType","newType","oldConversationId","newConversationId","oldMemberIds","newMemberIds","membersUnchanged","buildSelfConversationMessage","buildContactRequestSent","oldSentRequests","newSentRequests","fullname","buildPatch","config","all","reset","conversation","scrollToMessage","confirmDeleteSelectedMessages","selectedMessages","header","footer","confirmBlockUser","confirmUnblockUser","confirmAddContact","confirmRemoveContact","confirmDeleteConversation","isBlocked","isContact","contactRequestSent","selfConversationMessage","patchConfig","extend","buildFunc"],"mappings":"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"}